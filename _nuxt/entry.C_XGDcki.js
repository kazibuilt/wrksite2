var kP = Object.defineProperty;
var IP = (n, e, t) => e in n ? kP(n, e, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: t
}) : n[e] = t;
var Fs = (n, e, t) => (IP(n, typeof e != "symbol" ? e + "" : e, t), t);
/**
 * @vue/shared v3.4.26
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function Vv(n, e) {
	const t = new Set(n.split(","));
	return i => t.has(i)
}
const rn = {},
	Tc = [],
	Br = () => {},
	OP = () => !1,
	fd = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97),
	Hv = n => n.startsWith("onUpdate:"),
	An = Object.assign,
	Gv = (n, e) => {
		const t = n.indexOf(e);
		t > -1 && n.splice(t, 1)
	},
	FP = Object.prototype.hasOwnProperty,
	At = (n, e) => FP.call(n, e),
	rt = Array.isArray,
	Mc = n => pd(n) === "[object Map]",
	IS = n => pd(n) === "[object Set]",
	NP = n => pd(n) === "[object RegExp]",
	ut = n => typeof n == "function",
	ln = n => typeof n == "string",
	Pl = n => typeof n == "symbol",
	Zt = n => n !== null && typeof n == "object",
	Wv = n => (Zt(n) || ut(n)) && ut(n.then) && ut(n.catch),
	OS = Object.prototype.toString,
	pd = n => OS.call(n),
	UP = n => pd(n).slice(8, -1),
	FS = n => pd(n) === "[object Object]",
	jv = n => ln(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n,
	Cc = Vv(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
	ym = n => {
		const e = Object.create(null);
		return t => e[t] || (e[t] = n(t))
	},
	BP = /-(\w)/g,
	As = ym(n => n.replace(BP, (e, t) => t ? t.toUpperCase() : "")),
	zP = /\B([A-Z])/g,
	mu = ym(n => n.replace(zP, "-$1").toLowerCase()),
	xm = ym(n => n.charAt(0).toUpperCase() + n.slice(1)),
	h0 = ym(n => n ? `on${xm(n)}` : ""),
	pa = (n, e) => !Object.is(n, e),
	sh = (n, e) => {
		for (let t = 0; t < n.length; t++) n[t](e)
	},
	NS = (n, e, t, i = !1) => {
		Object.defineProperty(n, e, {
			configurable: !0,
			enumerable: !1,
			writable: i,
			value: t
		})
	},
	VP = n => {
		const e = parseFloat(n);
		return isNaN(e) ? n : e
	},
	US = n => {
		const e = ln(n) ? Number(n) : NaN;
		return isNaN(e) ? n : e
	};
let Xb;
const BS = () => Xb || (Xb = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function md(n) {
	if (rt(n)) {
		const e = {};
		for (let t = 0; t < n.length; t++) {
			const i = n[t],
				r = ln(i) ? jP(i) : md(i);
			if (r)
				for (const s in r) e[s] = r[s]
		}
		return e
	} else if (ln(n) || Zt(n)) return n
}
const HP = /;(?![^(]*\))/g,
	GP = /:([^]+)/,
	WP = /\/\*[^]*?\*\//g;

function jP(n) {
	const e = {};
	return n.replace(WP, "").split(HP).forEach(t => {
		if (t) {
			const i = t.split(GP);
			i.length > 1 && (e[i[0].trim()] = i[1].trim())
		}
	}), e
}

function jt(n) {
	let e = "";
	if (ln(n)) e = n;
	else if (rt(n))
		for (let t = 0; t < n.length; t++) {
			const i = jt(n[t]);
			i && (e += i + " ")
		} else if (Zt(n))
			for (const t in n) n[t] && (e += t + " ");
	return e.trim()
}

function $P(n) {
	if (!n) return null;
	let {
		class: e,
		style: t
	} = n;
	return e && !ln(e) && (n.class = jt(e)), t && (n.style = md(t)), n
}
const qP = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
	XP = Vv(qP);

function zS(n) {
	return !!n || n === ""
}
const to = n => ln(n) ? n : n == null ? "" : rt(n) || Zt(n) && (n.toString === OS || !ut(n.toString)) ? JSON.stringify(n, VS, 2) : String(n),
	VS = (n, e) => e && e.__v_isRef ? VS(n, e.value) : Mc(e) ? {
		[`Map(${e.size})`]: [...e.entries()].reduce((t, [i, r], s) => (t[d0(i, s) + " =>"] = r, t), {})
	} : IS(e) ? {
		[`Set(${e.size})`]: [...e.values()].map(t => d0(t))
	} : Pl(e) ? d0(e) : Zt(e) && !rt(e) && !FS(e) ? String(e) : e,
	d0 = (n, e = "") => {
		var t;
		return Pl(n) ? `Symbol(${(t=n.description)!=null?t:e})` : n
	};
/**
 * @vue/reactivity v3.4.26
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let ur;
class HS {
	constructor(e = !1) {
		this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ur, !e && ur && (this.index = (ur.scopes || (ur.scopes = [])).push(this) - 1)
	}
	get active() {
		return this._active
	}
	run(e) {
		if (this._active) {
			const t = ur;
			try {
				return ur = this, e()
			} finally {
				ur = t
			}
		}
	}
	on() {
		ur = this
	}
	off() {
		ur = this.parent
	}
	stop(e) {
		if (this._active) {
			let t, i;
			for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop();
			for (t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]();
			if (this.scopes)
				for (t = 0, i = this.scopes.length; t < i; t++) this.scopes[t].stop(!0);
			if (!this.detached && this.parent && !e) {
				const r = this.parent.scopes.pop();
				r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index)
			}
			this.parent = void 0, this._active = !1
		}
	}
}

function $v(n) {
	return new HS(n)
}

function YP(n, e = ur) {
	e && e.active && e.effects.push(n)
}

function wm() {
	return ur
}

function qv(n) {
	ur && ur.cleanups.push(n)
}
let rl;
class Xv {
	constructor(e, t, i, r) {
		this.fn = e, this.trigger = t, this.scheduler = i, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, YP(this, r)
	}
	get dirty() {
		if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
			this._dirtyLevel = 1, wa();
			for (let e = 0; e < this._depsLength; e++) {
				const t = this.deps[e];
				if (t.computed && (KP(t.computed), this._dirtyLevel >= 4)) break
			}
			this._dirtyLevel === 1 && (this._dirtyLevel = 0), Ea()
		}
		return this._dirtyLevel >= 4
	}
	set dirty(e) {
		this._dirtyLevel = e ? 4 : 0
	}
	run() {
		if (this._dirtyLevel = 0, !this.active) return this.fn();
		let e = ta,
			t = rl;
		try {
			return ta = !0, rl = this, this._runnings++, Yb(this), this.fn()
		} finally {
			Kb(this), this._runnings--, rl = t, ta = e
		}
	}
	stop() {
		this.active && (Yb(this), Kb(this), this.onStop && this.onStop(), this.active = !1)
	}
}

function KP(n) {
	return n.value
}

function Yb(n) {
	n._trackId++, n._depsLength = 0
}

function Kb(n) {
	if (n.deps.length > n._depsLength) {
		for (let e = n._depsLength; e < n.deps.length; e++) GS(n.deps[e], n);
		n.deps.length = n._depsLength
	}
}

function GS(n, e) {
	const t = n.get(e);
	t !== void 0 && e._trackId !== t && (n.delete(e), n.size === 0 && n.cleanup())
}
let ta = !0,
	i_ = 0;
const WS = [];

function wa() {
	WS.push(ta), ta = !1
}

function Ea() {
	const n = WS.pop();
	ta = n === void 0 ? !0 : n
}

function Yv() {
	i_++
}

function Kv() {
	for (i_--; !i_ && r_.length;) r_.shift()()
}

function jS(n, e, t) {
	if (e.get(n) !== n._trackId) {
		e.set(n, n._trackId);
		const i = n.deps[n._depsLength];
		i !== e ? (i && GS(i, n), n.deps[n._depsLength++] = e) : n._depsLength++
	}
}
const r_ = [];

function $S(n, e, t) {
	Yv();
	for (const i of n.keys()) {
		let r;
		i._dirtyLevel < e && (r ?? (r = n.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = e), i._shouldSchedule && (r ?? (r = n.get(i) === i._trackId)) && (i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && r_.push(i.scheduler)))
	}
	Kv()
}
const qS = (n, e) => {
		const t = new Map;
		return t.cleanup = n, t.computed = e, t
	},
	yp = new WeakMap,
	sl = Symbol(""),
	s_ = Symbol("");

function qi(n, e, t) {
	if (ta && rl) {
		let i = yp.get(n);
		i || yp.set(n, i = new Map);
		let r = i.get(t);
		r || i.set(t, r = qS(() => i.delete(t))), jS(rl, r)
	}
}

function no(n, e, t, i, r, s) {
	const o = yp.get(n);
	if (!o) return;
	let a = [];
	if (e === "clear") a = [...o.values()];
	else if (t === "length" && rt(n)) {
		const l = Number(i);
		o.forEach((c, u) => {
			(u === "length" || !Pl(u) && u >= l) && a.push(c)
		})
	} else switch (t !== void 0 && a.push(o.get(t)), e) {
		case "add":
			rt(n) ? jv(t) && a.push(o.get("length")) : (a.push(o.get(sl)), Mc(n) && a.push(o.get(s_)));
			break;
		case "delete":
			rt(n) || (a.push(o.get(sl)), Mc(n) && a.push(o.get(s_)));
			break;
		case "set":
			Mc(n) && a.push(o.get(sl));
			break
	}
	Yv();
	for (const l of a) l && $S(l, 4);
	Kv()
}

function ZP(n, e) {
	const t = yp.get(n);
	return t && t.get(e)
}
const JP = Vv("__proto__,__v_isRef,__isVue"),
	XS = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(Pl)),
	Zb = QP();

function QP() {
	const n = {};
	return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
		n[e] = function (...t) {
			const i = Mt(this);
			for (let s = 0, o = this.length; s < o; s++) qi(i, "get", s + "");
			const r = i[e](...t);
			return r === -1 || r === !1 ? i[e](...t.map(Mt)) : r
		}
	}), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
		n[e] = function (...t) {
			wa(), Yv();
			const i = Mt(this)[e].apply(this, t);
			return Kv(), Ea(), i
		}
	}), n
}

function eR(n) {
	Pl(n) || (n = String(n));
	const e = Mt(this);
	return qi(e, "has", n), e.hasOwnProperty(n)
}
class YS {
	constructor(e = !1, t = !1) {
		this._isReadonly = e, this._isShallow = t
	}
	get(e, t, i) {
		const r = this._isReadonly,
			s = this._isShallow;
		if (t === "__v_isReactive") return !r;
		if (t === "__v_isReadonly") return r;
		if (t === "__v_isShallow") return s;
		if (t === "__v_raw") return i === (r ? s ? fR : QS : s ? JS : ZS).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
		const o = rt(e);
		if (!r) {
			if (o && At(Zb, t)) return Reflect.get(Zb, t, i);
			if (t === "hasOwnProperty") return eR
		}
		const a = Reflect.get(e, t, i);
		return (Pl(t) ? XS.has(t) : JP(t)) || (r || qi(e, "get", t), s) ? a : bn(a) ? o && jv(t) ? a : a.value : Zt(a) ? r ? eT(a) : Ii(a) : a
	}
}
class KS extends YS {
	constructor(e = !1) {
		super(!1, e)
	}
	set(e, t, i, r) {
		let s = e[t];
		if (!this._isShallow) {
			const l = Gc(s);
			if (!xp(i) && !Gc(i) && (s = Mt(s), i = Mt(i)), !rt(e) && bn(s) && !bn(i)) return l ? !1 : (s.value = i, !0)
		}
		const o = rt(e) && jv(t) ? Number(t) < e.length : At(e, t),
			a = Reflect.set(e, t, i, r);
		return e === Mt(r) && (o ? pa(i, s) && no(e, "set", t, i) : no(e, "add", t, i)), a
	}
	deleteProperty(e, t) {
		const i = At(e, t);
		e[t];
		const r = Reflect.deleteProperty(e, t);
		return r && i && no(e, "delete", t, void 0), r
	}
	has(e, t) {
		const i = Reflect.has(e, t);
		return (!Pl(t) || !XS.has(t)) && qi(e, "has", t), i
	}
	ownKeys(e) {
		return qi(e, "iterate", rt(e) ? "length" : sl), Reflect.ownKeys(e)
	}
}
class tR extends YS {
	constructor(e = !1) {
		super(!0, e)
	}
	set(e, t) {
		return !0
	}
	deleteProperty(e, t) {
		return !0
	}
}
const nR = new KS,
	iR = new tR,
	rR = new KS(!0);
const Zv = n => n,
	Em = n => Reflect.getPrototypeOf(n);

function Hd(n, e, t = !1, i = !1) {
	n = n.__v_raw;
	const r = Mt(n),
		s = Mt(e);
	t || (pa(e, s) && qi(r, "get", e), qi(r, "get", s));
	const {
		has: o
	} = Em(r), a = i ? Zv : t ? t1 : Fh;
	if (o.call(r, e)) return a(n.get(e));
	if (o.call(r, s)) return a(n.get(s));
	n !== r && n.get(e)
}

function Gd(n, e = !1) {
	const t = this.__v_raw,
		i = Mt(t),
		r = Mt(n);
	return e || (pa(n, r) && qi(i, "has", n), qi(i, "has", r)), n === r ? t.has(n) : t.has(n) || t.has(r)
}

function Wd(n, e = !1) {
	return n = n.__v_raw, !e && qi(Mt(n), "iterate", sl), Reflect.get(n, "size", n)
}

function Jb(n) {
	n = Mt(n);
	const e = Mt(this);
	return Em(e).has.call(e, n) || (e.add(n), no(e, "add", n, n)), this
}

function Qb(n, e) {
	e = Mt(e);
	const t = Mt(this),
		{
			has: i,
			get: r
		} = Em(t);
	let s = i.call(t, n);
	s || (n = Mt(n), s = i.call(t, n));
	const o = r.call(t, n);
	return t.set(n, e), s ? pa(e, o) && no(t, "set", n, e) : no(t, "add", n, e), this
}

function ey(n) {
	const e = Mt(this),
		{
			has: t,
			get: i
		} = Em(e);
	let r = t.call(e, n);
	r || (n = Mt(n), r = t.call(e, n)), i && i.call(e, n);
	const s = e.delete(n);
	return r && no(e, "delete", n, void 0), s
}

function ty() {
	const n = Mt(this),
		e = n.size !== 0,
		t = n.clear();
	return e && no(n, "clear", void 0, void 0), t
}

function jd(n, e) {
	return function (i, r) {
		const s = this,
			o = s.__v_raw,
			a = Mt(o),
			l = e ? Zv : n ? t1 : Fh;
		return !n && qi(a, "iterate", sl), o.forEach((c, u) => i.call(r, l(c), l(u), s))
	}
}

function $d(n, e, t) {
	return function (...i) {
		const r = this.__v_raw,
			s = Mt(r),
			o = Mc(s),
			a = n === "entries" || n === Symbol.iterator && o,
			l = n === "keys" && o,
			c = r[n](...i),
			u = t ? Zv : e ? t1 : Fh;
		return !e && qi(s, "iterate", l ? s_ : sl), {
			next() {
				const {
					value: h,
					done: d
				} = c.next();
				return d ? {
					value: h,
					done: d
				} : {
					value: a ? [u(h[0]), u(h[1])] : u(h),
					done: d
				}
			},
			[Symbol.iterator]() {
				return this
			}
		}
	}
}

function _o(n) {
	return function (...e) {
		return n === "delete" ? !1 : n === "clear" ? void 0 : this
	}
}

function sR() {
	const n = {
			get(s) {
				return Hd(this, s)
			},
			get size() {
				return Wd(this)
			},
			has: Gd,
			add: Jb,
			set: Qb,
			delete: ey,
			clear: ty,
			forEach: jd(!1, !1)
		},
		e = {
			get(s) {
				return Hd(this, s, !1, !0)
			},
			get size() {
				return Wd(this)
			},
			has: Gd,
			add: Jb,
			set: Qb,
			delete: ey,
			clear: ty,
			forEach: jd(!1, !0)
		},
		t = {
			get(s) {
				return Hd(this, s, !0)
			},
			get size() {
				return Wd(this, !0)
			},
			has(s) {
				return Gd.call(this, s, !0)
			},
			add: _o("add"),
			set: _o("set"),
			delete: _o("delete"),
			clear: _o("clear"),
			forEach: jd(!0, !1)
		},
		i = {
			get(s) {
				return Hd(this, s, !0, !0)
			},
			get size() {
				return Wd(this, !0)
			},
			has(s) {
				return Gd.call(this, s, !0)
			},
			add: _o("add"),
			set: _o("set"),
			delete: _o("delete"),
			clear: _o("clear"),
			forEach: jd(!0, !0)
		};
	return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
		n[s] = $d(s, !1, !1), t[s] = $d(s, !0, !1), e[s] = $d(s, !1, !0), i[s] = $d(s, !0, !0)
	}), [n, t, e, i]
}
const [oR, aR, lR, cR] = sR();

function Jv(n, e) {
	const t = e ? n ? cR : lR : n ? aR : oR;
	return (i, r, s) => r === "__v_isReactive" ? !n : r === "__v_isReadonly" ? n : r === "__v_raw" ? i : Reflect.get(At(t, r) && r in i ? t : i, r, s)
}
const uR = {
		get: Jv(!1, !1)
	},
	hR = {
		get: Jv(!1, !0)
	},
	dR = {
		get: Jv(!0, !1)
	};
const ZS = new WeakMap,
	JS = new WeakMap,
	QS = new WeakMap,
	fR = new WeakMap;

function pR(n) {
	switch (n) {
		case "Object":
		case "Array":
			return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet":
			return 2;
		default:
			return 0
	}
}

function mR(n) {
	return n.__v_skip || !Object.isExtensible(n) ? 0 : pR(UP(n))
}

function Ii(n) {
	return Gc(n) ? n : Qv(n, !1, nR, uR, ZS)
}

function gd(n) {
	return Qv(n, !1, rR, hR, JS)
}

function eT(n) {
	return Qv(n, !0, iR, dR, QS)
}

function Qv(n, e, t, i, r) {
	if (!Zt(n) || n.__v_raw && !(e && n.__v_isReactive)) return n;
	const s = r.get(n);
	if (s) return s;
	const o = mR(n);
	if (o === 0) return n;
	const a = new Proxy(n, o === 2 ? i : t);
	return r.set(n, a), a
}

function na(n) {
	return Gc(n) ? na(n.__v_raw) : !!(n && n.__v_isReactive)
}

function Gc(n) {
	return !!(n && n.__v_isReadonly)
}

function xp(n) {
	return !!(n && n.__v_isShallow)
}

function tT(n) {
	return n ? !!n.__v_raw : !1
}

function Mt(n) {
	const e = n && n.__v_raw;
	return e ? Mt(e) : n
}

function e1(n) {
	return Object.isExtensible(n) && NS(n, "__v_skip", !0), n
}
const Fh = n => Zt(n) ? Ii(n) : n,
	t1 = n => Zt(n) ? eT(n) : n;
class nT {
	constructor(e, t, i, r) {
		this.getter = e, this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Xv(() => e(this._value), () => oh(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = i
	}
	get value() {
		const e = Mt(this);
		return (!e._cacheable || e.effect.dirty) && pa(e._value, e._value = e.effect.run()) && oh(e, 4), n1(e), e.effect._dirtyLevel >= 2 && oh(e, 2), e._value
	}
	set value(e) {
		this._setter(e)
	}
	get _dirty() {
		return this.effect.dirty
	}
	set _dirty(e) {
		this.effect.dirty = e
	}
}

function gR(n, e, t = !1) {
	let i, r;
	const s = ut(n);
	return s ? (i = n, r = Br) : (i = n.get, r = n.set), new nT(i, r, s || !r, t)
}

function n1(n) {
	var e;
	ta && rl && (n = Mt(n), jS(rl, (e = n.dep) != null ? e : n.dep = qS(() => n.dep = void 0, n instanceof nT ? n : void 0)))
}

function oh(n, e = 4, t) {
	n = Mt(n);
	const i = n.dep;
	i && $S(i, e)
}

function bn(n) {
	return !!(n && n.__v_isRef === !0)
}

function tt(n) {
	return iT(n, !1)
}

function Wc(n) {
	return iT(n, !0)
}

function iT(n, e) {
	return bn(n) ? n : new _R(n, e)
}
class _R {
	constructor(e, t) {
		this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : Mt(e), this._value = t ? e : Fh(e)
	}
	get value() {
		return n1(this), this._value
	}
	set value(e) {
		const t = this.__v_isShallow || xp(e) || Gc(e);
		e = t ? e : Mt(e), pa(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : Fh(e), oh(this, 4))
	}
}

function fe(n) {
	return bn(n) ? n.value : n
}
const vR = {
	get: (n, e, t) => fe(Reflect.get(n, e, t)),
	set: (n, e, t, i) => {
		const r = n[e];
		return bn(r) && !bn(t) ? (r.value = t, !0) : Reflect.set(n, e, t, i)
	}
};

function rT(n) {
	return na(n) ? n : new Proxy(n, vR)
}
class bR {
	constructor(e) {
		this.dep = void 0, this.__v_isRef = !0;
		const {
			get: t,
			set: i
		} = e(() => n1(this), () => oh(this));
		this._get = t, this._set = i
	}
	get value() {
		return this._get()
	}
	set value(e) {
		this._set(e)
	}
}

function yR(n) {
	return new bR(n)
}

function xR(n) {
	const e = rt(n) ? new Array(n.length) : {};
	for (const t in n) e[t] = sT(n, t);
	return e
}
class wR {
	constructor(e, t, i) {
		this._object = e, this._key = t, this._defaultValue = i, this.__v_isRef = !0
	}
	get value() {
		const e = this._object[this._key];
		return e === void 0 ? this._defaultValue : e
	}
	set value(e) {
		this._object[this._key] = e
	}
	get dep() {
		return ZP(Mt(this._object), this._key)
	}
}
class ER {
	constructor(e) {
		this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0
	}
	get value() {
		return this._getter()
	}
}

function Sm(n, e, t) {
	return bn(n) ? n : ut(n) ? new ER(n) : Zt(n) && arguments.length > 1 ? sT(n, e, t) : tt(n)
}

function sT(n, e, t) {
	const i = n[e];
	return bn(i) ? i : new wR(n, e, t)
}
/**
 * @vue/runtime-core v3.4.26
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function ia(n, e, t, i) {
	try {
		return i ? n(...i) : n()
	} catch (r) {
		gu(r, e, t)
	}
}

function Wr(n, e, t, i) {
	if (ut(n)) {
		const r = ia(n, e, t, i);
		return r && Wv(r) && r.catch(s => {
			gu(s, e, t)
		}), r
	}
	if (rt(n)) {
		const r = [];
		for (let s = 0; s < n.length; s++) r.push(Wr(n[s], e, t, i));
		return r
	}
}

function gu(n, e, t, i = !0) {
	const r = e ? e.vnode : null;
	if (e) {
		let s = e.parent;
		const o = e.proxy,
			a = `https://vuejs.org/error-reference/#runtime-${t}`;
		for (; s;) {
			const c = s.ec;
			if (c) {
				for (let u = 0; u < c.length; u++)
					if (c[u](n, o, a) === !1) return
			}
			s = s.parent
		}
		const l = e.appContext.config.errorHandler;
		if (l) {
			wa(), ia(l, null, 10, [n, o, a]), Ea();
			return
		}
	}
	SR(n, t, r, i)
}

function SR(n, e, t, i = !0) {
	console.error(n)
}
let Nh = !1,
	o_ = !1;
const hi = [];
let ms = 0;
const Ac = [];
let No = null,
	Ka = 0;
const oT = Promise.resolve();
let i1 = null;

function Xi(n) {
	const e = i1 || oT;
	return n ? e.then(this ? n.bind(this) : n) : e
}

function TR(n) {
	let e = ms + 1,
		t = hi.length;
	for (; e < t;) {
		const i = e + t >>> 1,
			r = hi[i],
			s = Uh(r);
		s < n || s === n && r.pre ? e = i + 1 : t = i
	}
	return e
}

function Tm(n) {
	(!hi.length || !hi.includes(n, Nh && n.allowRecurse ? ms + 1 : ms)) && (n.id == null ? hi.push(n) : hi.splice(TR(n.id), 0, n), aT())
}

function aT() {
	!Nh && !o_ && (o_ = !0, i1 = oT.then(lT))
}

function MR(n) {
	const e = hi.indexOf(n);
	e > ms && hi.splice(e, 1)
}

function a_(n) {
	rt(n) ? Ac.push(...n) : (!No || !No.includes(n, n.allowRecurse ? Ka + 1 : Ka)) && Ac.push(n), aT()
}

function ny(n, e, t = Nh ? ms + 1 : 0) {
	for (; t < hi.length; t++) {
		const i = hi[t];
		if (i && i.pre) {
			if (n && i.id !== n.uid) continue;
			hi.splice(t, 1), t--, i()
		}
	}
}

function wp(n) {
	if (Ac.length) {
		const e = [...new Set(Ac)].sort((t, i) => Uh(t) - Uh(i));
		if (Ac.length = 0, No) {
			No.push(...e);
			return
		}
		for (No = e, Ka = 0; Ka < No.length; Ka++) No[Ka]();
		No = null, Ka = 0
	}
}
const Uh = n => n.id == null ? 1 / 0 : n.id,
	CR = (n, e) => {
		const t = Uh(n) - Uh(e);
		if (t === 0) {
			if (n.pre && !e.pre) return -1;
			if (e.pre && !n.pre) return 1
		}
		return t
	};

function lT(n) {
	o_ = !1, Nh = !0, hi.sort(CR);
	try {
		for (ms = 0; ms < hi.length; ms++) {
			const e = hi[ms];
			e && e.active !== !1 && ia(e, null, 14)
		}
	} finally {
		ms = 0, hi.length = 0, wp(), Nh = !1, i1 = null, (hi.length || Ac.length) && lT()
	}
}

function AR(n, e, ...t) {
	if (n.isUnmounted) return;
	const i = n.vnode.props || rn;
	let r = t;
	const s = e.startsWith("update:"),
		o = s && e.slice(7);
	if (o && o in i) {
		const u = `${o==="modelValue"?"model":o}Modifiers`,
			{
				number: h,
				trim: d
			} = i[u] || rn;
		d && (r = t.map(f => ln(f) ? f.trim() : f)), h && (r = t.map(VP))
	}
	let a, l = i[a = h0(e)] || i[a = h0(As(e))];
	!l && s && (l = i[a = h0(mu(e))]), l && Wr(l, n, 6, r);
	const c = i[a + "Once"];
	if (c) {
		if (!n.emitted) n.emitted = {};
		else if (n.emitted[a]) return;
		n.emitted[a] = !0, Wr(c, n, 6, r)
	}
}

function cT(n, e, t = !1) {
	const i = e.emitsCache,
		r = i.get(n);
	if (r !== void 0) return r;
	const s = n.emits;
	let o = {},
		a = !1;
	if (!ut(n)) {
		const l = c => {
			const u = cT(c, e, !0);
			u && (a = !0, An(o, u))
		};
		!t && e.mixins.length && e.mixins.forEach(l), n.extends && l(n.extends), n.mixins && n.mixins.forEach(l)
	}
	return !s && !a ? (Zt(n) && i.set(n, null), null) : (rt(s) ? s.forEach(l => o[l] = null) : An(o, s), Zt(n) && i.set(n, o), o)
}

function Mm(n, e) {
	return !n || !fd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), At(n, e[0].toLowerCase() + e.slice(1)) || At(n, mu(e)) || At(n, e))
}
let ii = null,
	uT = null;

function Ep(n) {
	const e = ii;
	return ii = n, uT = n && n.type.__scopeId || null, e
}

function En(n, e = ii, t) {
	if (!e || n._n) return n;
	const i = (...r) => {
		i._d && _y(-1);
		const s = Ep(e);
		let o;
		try {
			o = n(...r)
		} finally {
			Ep(s), i._d && _y(1)
		}
		return o
	};
	return i._n = !0, i._c = !0, i._d = !0, i
}

function f0(n) {
	const {
		type: e,
		vnode: t,
		proxy: i,
		withProxy: r,
		propsOptions: [s],
		slots: o,
		attrs: a,
		emit: l,
		render: c,
		renderCache: u,
		props: h,
		data: d,
		setupState: f,
		ctx: p,
		inheritAttrs: _
	} = n, g = Ep(n);
	let m, b;
	try {
		if (t.shapeFlag & 4) {
			const y = r || i,
				x = y;
			m = Ir(c.call(x, y, u, h, f, d, p)), b = a
		} else {
			const y = e;
			m = Ir(y.length > 1 ? y(h, {
				attrs: a,
				slots: o,
				emit: l
			}) : y(h, null)), b = e.props ? a : PR(a)
		}
	} catch (y) {
		uh.length = 0, gu(y, n, 1), m = Ge(fi)
	}
	let v = m;
	if (b && _ !== !1) {
		const y = Object.keys(b),
			{
				shapeFlag: x
			} = v;
		y.length && x & 7 && (s && y.some(Hv) && (b = RR(b, s)), v = oo(v, b, !1, !0))
	}
	return t.dirs && (v = oo(v, null, !1, !0), v.dirs = v.dirs ? v.dirs.concat(t.dirs) : t.dirs), t.transition && (v.transition = t.transition), m = v, Ep(g), m
}

function DR(n, e = !0) {
	let t;
	for (let i = 0; i < n.length; i++) {
		const r = n[i];
		if (qc(r)) {
			if (r.type !== fi || r.children === "v-if") {
				if (t) return;
				t = r
			}
		} else return
	}
	return t
}
const PR = n => {
		let e;
		for (const t in n)(t === "class" || t === "style" || fd(t)) && ((e || (e = {}))[t] = n[t]);
		return e
	},
	RR = (n, e) => {
		const t = {};
		for (const i in n)(!Hv(i) || !(i.slice(9) in e)) && (t[i] = n[i]);
		return t
	};

function LR(n, e, t) {
	const {
		props: i,
		children: r,
		component: s
	} = n, {
		props: o,
		children: a,
		patchFlag: l
	} = e, c = s.emitsOptions;
	if (e.dirs || e.transition) return !0;
	if (t && l >= 0) {
		if (l & 1024) return !0;
		if (l & 16) return i ? iy(i, o, c) : !!o;
		if (l & 8) {
			const u = e.dynamicProps;
			for (let h = 0; h < u.length; h++) {
				const d = u[h];
				if (o[d] !== i[d] && !Mm(c, d)) return !0
			}
		}
	} else return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? iy(i, o, c) : !0 : !!o;
	return !1
}

function iy(n, e, t) {
	const i = Object.keys(e);
	if (i.length !== Object.keys(n).length) return !0;
	for (let r = 0; r < i.length; r++) {
		const s = i[r];
		if (e[s] !== n[s] && !Mm(t, s)) return !0
	}
	return !1
}

function r1({
	vnode: n,
	parent: e
}, t) {
	for (; e;) {
		const i = e.subTree;
		if (i.suspense && i.suspense.activeBranch === n && (i.el = n.el), i === n)(n = e.vnode).el = t, e = e.parent;
		else break
	}
}
const hT = "components";

function kR(n, e) {
	return fT(hT, n, !0, e) || n
}
const dT = Symbol.for("v-ndc");

function _u(n) {
	return ln(n) ? fT(hT, n, !1) || n : n || dT
}

function fT(n, e, t = !0, i = !1) {
	const r = ii || Nn;
	if (r) {
		const s = r.type; {
			const a = v_(s, !1);
			if (a && (a === e || a === As(e) || a === xm(As(e)))) return s
		}
		const o = ry(r[n] || s[n], e) || ry(r.appContext[n], e);
		return !o && i ? s : o
	}
}

function ry(n, e) {
	return n && (n[e] || n[As(e)] || n[xm(As(e))])
}
const pT = n => n.__isSuspense;
let l_ = 0;
const IR = {
		name: "Suspense",
		__isSuspense: !0,
		process(n, e, t, i, r, s, o, a, l, c) {
			if (n == null) OR(e, t, i, r, s, o, a, l, c);
			else {
				if (s && s.deps > 0 && !n.suspense.isInFallback) {
					e.suspense = n.suspense, e.suspense.vnode = e, e.el = n.el;
					return
				}
				FR(n, e, t, i, r, o, a, l, c)
			}
		},
		hydrate: NR,
		create: s1,
		normalize: UR
	},
	mT = IR;

function Bh(n, e) {
	const t = n.props && n.props[e];
	ut(t) && t()
}

function OR(n, e, t, i, r, s, o, a, l) {
	const {
		p: c,
		o: {
			createElement: u
		}
	} = l, h = u("div"), d = n.suspense = s1(n, r, i, e, h, t, s, o, a, l);
	c(null, d.pendingBranch = n.ssContent, h, null, i, d, s, o), d.deps > 0 ? (Bh(n, "onPending"), Bh(n, "onFallback"), c(null, n.ssFallback, e, t, i, null, s, o), Dc(d, n.ssFallback)) : d.resolve(!1, !0)
}

function FR(n, e, t, i, r, s, o, a, {
	p: l,
	um: c,
	o: {
		createElement: u
	}
}) {
	const h = e.suspense = n.suspense;
	h.vnode = e, e.el = n.el;
	const d = e.ssContent,
		f = e.ssFallback,
		{
			activeBranch: p,
			pendingBranch: _,
			isInFallback: g,
			isHydrating: m
		} = h;
	if (_) h.pendingBranch = d, ts(d, _) ? (l(_, d, h.hiddenContainer, null, r, h, s, o, a), h.deps <= 0 ? h.resolve() : g && (m || (l(p, f, t, i, r, null, s, o, a), Dc(h, f)))) : (h.pendingId = l_++, m ? (h.isHydrating = !1, h.activeBranch = _) : c(_, r, h), h.deps = 0, h.effects.length = 0, h.hiddenContainer = u("div"), g ? (l(null, d, h.hiddenContainer, null, r, h, s, o, a), h.deps <= 0 ? h.resolve() : (l(p, f, t, i, r, null, s, o, a), Dc(h, f))) : p && ts(d, p) ? (l(p, d, t, i, r, h, s, o, a), h.resolve(!0)) : (l(null, d, h.hiddenContainer, null, r, h, s, o, a), h.deps <= 0 && h.resolve()));
	else if (p && ts(d, p)) l(p, d, t, i, r, h, s, o, a), Dc(h, d);
	else if (Bh(e, "onPending"), h.pendingBranch = d, d.shapeFlag & 512 ? h.pendingId = d.component.suspenseId : h.pendingId = l_++, l(null, d, h.hiddenContainer, null, r, h, s, o, a), h.deps <= 0) h.resolve();
	else {
		const {
			timeout: b,
			pendingId: v
		} = h;
		b > 0 ? setTimeout(() => {
			h.pendingId === v && h.fallback(f)
		}, b) : b === 0 && h.fallback(f)
	}
}

function s1(n, e, t, i, r, s, o, a, l, c, u = !1) {
	const {
		p: h,
		m: d,
		um: f,
		n: p,
		o: {
			parentNode: _,
			remove: g
		}
	} = c;
	let m;
	const b = BR(n);
	b && e && e.pendingBranch && (m = e.pendingId, e.deps++);
	const v = n.props ? US(n.props.timeout) : void 0,
		y = s,
		x = {
			vnode: n,
			parent: e,
			parentComponent: t,
			namespace: o,
			container: i,
			hiddenContainer: r,
			deps: 0,
			pendingId: l_++,
			timeout: typeof v == "number" ? v : -1,
			activeBranch: null,
			pendingBranch: null,
			isInFallback: !u,
			isHydrating: u,
			isUnmounted: !1,
			effects: [],
			resolve(S = !1, E = !1) {
				const {
					vnode: C,
					activeBranch: P,
					pendingBranch: w,
					pendingId: D,
					effects: U,
					parentComponent: j,
					container: z
				} = x;
				let H = !1;
				x.isHydrating ? x.isHydrating = !1 : S || (H = P && w.transition && w.transition.mode === "out-in", H && (P.transition.afterLeave = () => {
					D === x.pendingId && (d(w, z, s === y ? p(P) : s, 0), a_(U))
				}), P && (_(P.el) !== x.hiddenContainer && (s = p(P)), f(P, j, x, !0)), H || d(w, z, s, 0)), Dc(x, w), x.pendingBranch = null, x.isInFallback = !1;
				let F = x.parent,
					G = !1;
				for (; F;) {
					if (F.pendingBranch) {
						F.effects.push(...U), G = !0;
						break
					}
					F = F.parent
				}!G && !H && a_(U), x.effects = [], b && e && e.pendingBranch && m === e.pendingId && (e.deps--, e.deps === 0 && !E && e.resolve()), Bh(C, "onResolve")
			},
			fallback(S) {
				if (!x.pendingBranch) return;
				const {
					vnode: E,
					activeBranch: C,
					parentComponent: P,
					container: w,
					namespace: D
				} = x;
				Bh(E, "onFallback");
				const U = p(C),
					j = () => {
						x.isInFallback && (h(null, S, w, U, P, null, D, a, l), Dc(x, S))
					},
					z = S.transition && S.transition.mode === "out-in";
				z && (C.transition.afterLeave = j), x.isInFallback = !0, f(C, P, null, !0), z || j()
			},
			move(S, E, C) {
				x.activeBranch && d(x.activeBranch, S, E, C), x.container = S
			},
			next() {
				return x.activeBranch && p(x.activeBranch)
			},
			registerDep(S, E) {
				const C = !!x.pendingBranch;
				C && x.deps++;
				const P = S.vnode.el;
				S.asyncDep.catch(w => {
					gu(w, S, 0)
				}).then(w => {
					if (S.isUnmounted || x.isUnmounted || x.pendingId !== S.suspenseId) return;
					S.asyncResolved = !0;
					const {
						vnode: D
					} = S;
					__(S, w, !1), P && (D.el = P);
					const U = !P && S.subTree.el;
					E(S, D, _(P || S.subTree.el), P ? null : p(S.subTree), x, o, l), U && g(U), r1(S, D.el), C && --x.deps === 0 && x.resolve()
				})
			},
			unmount(S, E) {
				x.isUnmounted = !0, x.activeBranch && f(x.activeBranch, t, S, E), x.pendingBranch && f(x.pendingBranch, t, S, E)
			}
		};
	return x
}

function NR(n, e, t, i, r, s, o, a, l) {
	const c = e.suspense = s1(e, i, t, n.parentNode, document.createElement("div"), null, r, s, o, a, !0),
		u = l(n, c.pendingBranch = e.ssContent, t, c, s, o);
	return c.deps === 0 && c.resolve(!1, !0), u
}

function UR(n) {
	const {
		shapeFlag: e,
		children: t
	} = n, i = e & 32;
	n.ssContent = sy(i ? t.default : t), n.ssFallback = i ? sy(t.fallback) : Ge(fi)
}

function sy(n) {
	let e;
	if (ut(n)) {
		const t = $c && n._c;
		t && (n._d = !1, ke()), n = n(), t && (n._d = !0, e = zr, BT())
	}
	return rt(n) && (n = DR(n)), n = Ir(n), e && !n.dynamicChildren && (n.dynamicChildren = e.filter(t => t !== n)), n
}

function gT(n, e) {
	e && e.pendingBranch ? rt(n) ? e.effects.push(...n) : e.effects.push(n) : a_(n)
}

function Dc(n, e) {
	n.activeBranch = e;
	const {
		vnode: t,
		parentComponent: i
	} = n;
	let r = e.el;
	for (; !r && e.component;) e = e.component.subTree, r = e.el;
	t.el = r, i && i.subTree === t && (i.vnode.el = r, r1(i, r))
}

function BR(n) {
	const e = n.props && n.props.suspensible;
	return e != null && e !== !1
}
const zR = Symbol.for("v-scx"),
	VR = () => si(zR);

function HR(n, e) {
	return Cm(n, null, e)
}

function GR(n, e) {
	return Cm(n, null, {
		flush: "post"
	})
}
const qd = {};

function Vt(n, e, t) {
	return Cm(n, e, t)
}

function Cm(n, e, {
	immediate: t,
	deep: i,
	flush: r,
	once: s,
	onTrack: o,
	onTrigger: a
} = rn) {
	if (e && s) {
		const S = e;
		e = (...E) => {
			S(...E), x()
		}
	}
	const l = Nn,
		c = S => i === !0 ? S : _c(S, i === !1 ? 1 : void 0);
	let u, h = !1,
		d = !1;
	if (bn(n) ? (u = () => n.value, h = xp(n)) : na(n) ? (u = () => c(n), h = !0) : rt(n) ? (d = !0, h = n.some(S => na(S) || xp(S)), u = () => n.map(S => {
			if (bn(S)) return S.value;
			if (na(S)) return c(S);
			if (ut(S)) return ia(S, l, 2)
		})) : ut(n) ? e ? u = () => ia(n, l, 2) : u = () => (f && f(), Wr(n, l, 3, [p])) : u = Br, e && i) {
		const S = u;
		u = () => _c(S())
	}
	let f, p = S => {
			f = v.onStop = () => {
				ia(S, l, 4), f = v.onStop = void 0
			}
		},
		_;
	if (vd)
		if (p = Br, e ? t && Wr(e, l, 3, [u(), d ? [] : void 0, p]) : u(), r === "sync") {
			const S = VR();
			_ = S.__watcherHandles || (S.__watcherHandles = [])
		} else return Br;
	let g = d ? new Array(n.length).fill(qd) : qd;
	const m = () => {
		if (!(!v.active || !v.dirty))
			if (e) {
				const S = v.run();
				(i || h || (d ? S.some((E, C) => pa(E, g[C])) : pa(S, g))) && (f && f(), Wr(e, l, 3, [S, g === qd ? void 0 : d && g[0] === qd ? [] : g, p]), g = S)
			} else v.run()
	};
	m.allowRecurse = !!e;
	let b;
	r === "sync" ? b = m : r === "post" ? b = () => ei(m, l && l.suspense) : (m.pre = !0, l && (m.id = l.uid), b = () => Tm(m));
	const v = new Xv(u, Br, b),
		y = wm(),
		x = () => {
			v.stop(), y && Gv(y.effects, v)
		};
	return e ? t ? m() : g = v.run() : r === "post" ? ei(v.run.bind(v), l && l.suspense) : v.run(), _ && _.push(x), x
}

function WR(n, e, t) {
	const i = this.proxy,
		r = ln(n) ? n.includes(".") ? _T(i, n) : () => i[n] : n.bind(i, i);
	let s;
	ut(e) ? s = e : (s = e.handler, t = e);
	const o = yl(this),
		a = Cm(r, s.bind(i), t);
	return o(), a
}

function _T(n, e) {
	const t = e.split(".");
	return () => {
		let i = n;
		for (let r = 0; r < t.length && i; r++) i = i[t[r]];
		return i
	}
}

function _c(n, e = 1 / 0, t) {
	if (e <= 0 || !Zt(n) || n.__v_skip || (t = t || new Set, t.has(n))) return n;
	if (t.add(n), e--, bn(n)) _c(n.value, e, t);
	else if (rt(n))
		for (let i = 0; i < n.length; i++) _c(n[i], e, t);
	else if (IS(n) || Mc(n)) n.forEach(i => {
		_c(i, e, t)
	});
	else if (FS(n))
		for (const i in n) _c(n[i], e, t);
	return n
}

function us(n, e, t, i) {
	const r = n.dirs,
		s = e && e.dirs;
	for (let o = 0; o < r.length; o++) {
		const a = r[o];
		s && (a.oldValue = s[o].value);
		let l = a.dir[i];
		l && (wa(), Wr(l, t, 8, [n.el, a, n, e]), Ea())
	}
}
const Uo = Symbol("_leaveCb"),
	Xd = Symbol("_enterCb");

function jR() {
	const n = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map
	};
	return Vn(() => {
		n.isMounted = !0
	}), Sa(() => {
		n.isUnmounting = !0
	}), n
}
const Ar = [Function, Array],
	vT = {
		mode: String,
		appear: Boolean,
		persisted: Boolean,
		onBeforeEnter: Ar,
		onEnter: Ar,
		onAfterEnter: Ar,
		onEnterCancelled: Ar,
		onBeforeLeave: Ar,
		onLeave: Ar,
		onAfterLeave: Ar,
		onLeaveCancelled: Ar,
		onBeforeAppear: Ar,
		onAppear: Ar,
		onAfterAppear: Ar,
		onAppearCancelled: Ar
	},
	$R = {
		name: "BaseTransition",
		props: vT,
		setup(n, {
			slots: e
		}) {
			const t = vu(),
				i = jR();
			return () => {
				const r = e.default && yT(e.default(), !0);
				if (!r || !r.length) return;
				let s = r[0];
				if (r.length > 1) {
					for (const d of r)
						if (d.type !== fi) {
							s = d;
							break
						}
				}
				const o = Mt(n),
					{
						mode: a
					} = o;
				if (i.isLeaving) return p0(s);
				const l = oy(s);
				if (!l) return p0(s);
				const c = c_(l, o, i, t);
				Sp(l, c);
				const u = t.subTree,
					h = u && oy(u);
				if (h && h.type !== fi && !ts(l, h)) {
					const d = c_(h, o, i, t);
					if (Sp(h, d), a === "out-in" && l.type !== fi) return i.isLeaving = !0, d.afterLeave = () => {
						i.isLeaving = !1, t.update.active !== !1 && (t.effect.dirty = !0, t.update())
					}, p0(s);
					a === "in-out" && l.type !== fi && (d.delayLeave = (f, p, _) => {
						const g = bT(i, h);
						g[String(h.key)] = h, f[Uo] = () => {
							p(), f[Uo] = void 0, delete c.delayedLeave
						}, c.delayedLeave = _
					})
				}
				return s
			}
		}
	},
	qR = $R;

function bT(n, e) {
	const {
		leavingVNodes: t
	} = n;
	let i = t.get(e.type);
	return i || (i = Object.create(null), t.set(e.type, i)), i
}

function c_(n, e, t, i) {
	const {
		appear: r,
		mode: s,
		persisted: o = !1,
		onBeforeEnter: a,
		onEnter: l,
		onAfterEnter: c,
		onEnterCancelled: u,
		onBeforeLeave: h,
		onLeave: d,
		onAfterLeave: f,
		onLeaveCancelled: p,
		onBeforeAppear: _,
		onAppear: g,
		onAfterAppear: m,
		onAppearCancelled: b
	} = e, v = String(n.key), y = bT(t, n), x = (C, P) => {
		C && Wr(C, i, 9, P)
	}, S = (C, P) => {
		const w = P[1];
		x(C, P), rt(C) ? C.every(D => D.length <= 1) && w() : C.length <= 1 && w()
	}, E = {
		mode: s,
		persisted: o,
		beforeEnter(C) {
			let P = a;
			if (!t.isMounted)
				if (r) P = _ || a;
				else return;
			C[Uo] && C[Uo](!0);
			const w = y[v];
			w && ts(n, w) && w.el[Uo] && w.el[Uo](), x(P, [C])
		},
		enter(C) {
			let P = l,
				w = c,
				D = u;
			if (!t.isMounted)
				if (r) P = g || l, w = m || c, D = b || u;
				else return;
			let U = !1;
			const j = C[Xd] = z => {
				U || (U = !0, z ? x(D, [C]) : x(w, [C]), E.delayedLeave && E.delayedLeave(), C[Xd] = void 0)
			};
			P ? S(P, [C, j]) : j()
		},
		leave(C, P) {
			const w = String(n.key);
			if (C[Xd] && C[Xd](!0), t.isUnmounting) return P();
			x(h, [C]);
			let D = !1;
			const U = C[Uo] = j => {
				D || (D = !0, P(), j ? x(p, [C]) : x(f, [C]), C[Uo] = void 0, y[w] === n && delete y[w])
			};
			y[w] = n, d ? S(d, [C, U]) : U()
		},
		clone(C) {
			return c_(C, e, t, i)
		}
	};
	return E
}

function p0(n) {
	if (_d(n)) return n = oo(n), n.children = null, n
}

function oy(n) {
	if (!_d(n)) return n;
	const {
		shapeFlag: e,
		children: t
	} = n;
	if (t) {
		if (e & 16) return t[0];
		if (e & 32 && ut(t.default)) return t.default()
	}
}

function Sp(n, e) {
	n.shapeFlag & 6 && n.component ? Sp(n.component.subTree, e) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e
}

function yT(n, e = !1, t) {
	let i = [],
		r = 0;
	for (let s = 0; s < n.length; s++) {
		let o = n[s];
		const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : s);
		o.type === gn ? (o.patchFlag & 128 && r++, i = i.concat(yT(o.children, e, a))) : (e || o.type !== fi) && i.push(a != null ? oo(o, {
			key: a
		}) : o)
	}
	if (r > 1)
		for (let s = 0; s < i.length; s++) i[s].patchFlag = -2;
	return i
} /*! #__NO_SIDE_EFFECTS__ */
function Qi(n, e) {
	return ut(n) ? An({
		name: n.name
	}, e, {
		setup: n
	}) : n
}
const ol = n => !!n.type.__asyncLoader; /*! #__NO_SIDE_EFFECTS__ */
function xt(n) {
	ut(n) && (n = {
		loader: n
	});
	const {
		loader: e,
		loadingComponent: t,
		errorComponent: i,
		delay: r = 200,
		timeout: s,
		suspensible: o = !0,
		onError: a
	} = n;
	let l = null,
		c, u = 0;
	const h = () => (u++, l = null, d()),
		d = () => {
			let f;
			return l || (f = l = e().catch(p => {
				if (p = p instanceof Error ? p : new Error(String(p)), a) return new Promise((_, g) => {
					a(p, () => _(h()), () => g(p), u + 1)
				});
				throw p
			}).then(p => f !== l && l ? l : (p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), c = p, p)))
		};
	return Qi({
		name: "AsyncComponentWrapper",
		__asyncLoader: d,
		get __asyncResolved() {
			return c
		},
		setup() {
			const f = Nn;
			if (c) return () => m0(c, f);
			const p = b => {
				l = null, gu(b, f, 13, !i)
			};
			if (o && f.suspense || vd) return d().then(b => () => m0(b, f)).catch(b => (p(b), () => i ? Ge(i, {
				error: b
			}) : null));
			const _ = tt(!1),
				g = tt(),
				m = tt(!!r);
			return r && setTimeout(() => {
				m.value = !1
			}, r), s != null && setTimeout(() => {
				if (!_.value && !g.value) {
					const b = new Error(`Async component timed out after ${s}ms.`);
					p(b), g.value = b
				}
			}, s), d().then(() => {
				_.value = !0, f.parent && _d(f.parent.vnode) && (f.parent.effect.dirty = !0, Tm(f.parent.update))
			}).catch(b => {
				p(b), g.value = b
			}), () => {
				if (_.value && c) return m0(c, f);
				if (g.value && i) return Ge(i, {
					error: g.value
				});
				if (t && !m.value) return Ge(t)
			}
		}
	})
}

function m0(n, e) {
	const {
		ref: t,
		props: i,
		children: r,
		ce: s
	} = e.vnode, o = Ge(n, i, r);
	return o.ref = t, o.ce = s, delete e.vnode.ce, o
}
const _d = n => n.type.__isKeepAlive,
	XR = {
		name: "KeepAlive",
		__isKeepAlive: !0,
		props: {
			include: [String, RegExp, Array],
			exclude: [String, RegExp, Array],
			max: [String, Number]
		},
		setup(n, {
			slots: e
		}) {
			const t = vu(),
				i = t.ctx;
			if (!i.renderer) return () => {
				const b = e.default && e.default();
				return b && b.length === 1 ? b[0] : b
			};
			const r = new Map,
				s = new Set;
			let o = null;
			const a = t.suspense,
				{
					renderer: {
						p: l,
						m: c,
						um: u,
						o: {
							createElement: h
						}
					}
				} = i,
				d = h("div");
			i.activate = (b, v, y, x, S) => {
				const E = b.component;
				c(b, v, y, 0, a), l(E.vnode, b, v, y, E, a, x, b.slotScopeIds, S), ei(() => {
					E.isDeactivated = !1, E.a && sh(E.a);
					const C = b.props && b.props.onVnodeMounted;
					C && Ui(C, E.parent, b)
				}, a)
			}, i.deactivate = b => {
				const v = b.component;
				c(b, d, null, 1, a), ei(() => {
					v.da && sh(v.da);
					const y = b.props && b.props.onVnodeUnmounted;
					y && Ui(y, v.parent, b), v.isDeactivated = !0
				}, a)
			};

			function f(b) {
				g0(b), u(b, t, a, !0)
			}

			function p(b) {
				r.forEach((v, y) => {
					const x = v_(v.type);
					x && (!b || !b(x)) && _(y)
				})
			}

			function _(b) {
				const v = r.get(b);
				!o || !ts(v, o) ? f(v) : o && g0(o), r.delete(b), s.delete(b)
			}
			Vt(() => [n.include, n.exclude], ([b, v]) => {
				b && p(y => Xu(b, y)), v && p(y => !Xu(v, y))
			}, {
				flush: "post",
				deep: !0
			});
			let g = null;
			const m = () => {
				g != null && r.set(g, _0(t.subTree))
			};
			return Vn(m), wT(m), Sa(() => {
				r.forEach(b => {
					const {
						subTree: v,
						suspense: y
					} = t, x = _0(v);
					if (b.type === x.type && b.key === x.key) {
						g0(x);
						const S = x.component.da;
						S && ei(S, y);
						return
					}
					f(b)
				})
			}), () => {
				if (g = null, !e.default) return null;
				const b = e.default(),
					v = b[0];
				if (b.length > 1) return o = null, b;
				if (!qc(v) || !(v.shapeFlag & 4) && !(v.shapeFlag & 128)) return o = null, v;
				let y = _0(v);
				const x = y.type,
					S = v_(ol(y) ? y.type.__asyncResolved || {} : x),
					{
						include: E,
						exclude: C,
						max: P
					} = n;
				if (E && (!S || !Xu(E, S)) || C && S && Xu(C, S)) return o = y, v;
				const w = y.key == null ? x : y.key,
					D = r.get(w);
				return y.el && (y = oo(y), v.shapeFlag & 128 && (v.ssContent = y)), g = w, D ? (y.el = D.el, y.component = D.component, y.transition && Sp(y, y.transition), y.shapeFlag |= 512, s.delete(w), s.add(w)) : (s.add(w), P && s.size > parseInt(P, 10) && _(s.values().next().value)), y.shapeFlag |= 256, o = y, pT(v.type) ? v : y
			}
		}
	},
	YR = XR;

function Xu(n, e) {
	return rt(n) ? n.some(t => Xu(t, e)) : ln(n) ? n.split(",").includes(e) : NP(n) ? n.test(e) : !1
}

function o1(n, e) {
	xT(n, "a", e)
}

function a1(n, e) {
	xT(n, "da", e)
}

function xT(n, e, t = Nn) {
	const i = n.__wdc || (n.__wdc = () => {
		let r = t;
		for (; r;) {
			if (r.isDeactivated) return;
			r = r.parent
		}
		return n()
	});
	if (Am(e, i, t), t) {
		let r = t.parent;
		for (; r && r.parent;) _d(r.parent.vnode) && KR(i, e, t, r), r = r.parent
	}
}

function KR(n, e, t, i) {
	const r = Am(e, n, i, !0);
	Yi(() => {
		Gv(i[e], r)
	}, t)
}

function g0(n) {
	n.shapeFlag &= -257, n.shapeFlag &= -513
}

function _0(n) {
	return n.shapeFlag & 128 ? n.ssContent : n
}

function Am(n, e, t = Nn, i = !1) {
	if (t) {
		const r = t[n] || (t[n] = []),
			s = e.__weh || (e.__weh = (...o) => {
				if (t.isUnmounted) return;
				wa();
				const a = yl(t),
					l = Wr(e, t, n, o);
				return a(), Ea(), l
			});
		return i ? r.unshift(s) : r.push(s), s
	}
}
const po = n => (e, t = Nn) => (!vd || n === "sp") && Am(n, (...i) => e(...i), t),
	l1 = po("bm"),
	Vn = po("m"),
	ZR = po("bu"),
	wT = po("u"),
	Sa = po("bum"),
	Yi = po("um"),
	JR = po("sp"),
	QR = po("rtg"),
	e4 = po("rtc");

function ET(n, e = Nn) {
	Am("ec", n, e)
}

function Dm(n, e, t, i) {
	let r;
	const s = t;
	if (rt(n) || ln(n)) {
		r = new Array(n.length);
		for (let o = 0, a = n.length; o < a; o++) r[o] = e(n[o], o, void 0, s)
	} else if (typeof n == "number") {
		r = new Array(n);
		for (let o = 0; o < n; o++) r[o] = e(o + 1, o, void 0, s)
	} else if (Zt(n))
		if (n[Symbol.iterator]) r = Array.from(n, (o, a) => e(o, a, void 0, s));
		else {
			const o = Object.keys(n);
			r = new Array(o.length);
			for (let a = 0, l = o.length; a < l; a++) {
				const c = o[a];
				r[a] = e(n[c], c, a, s)
			}
		}
	else r = [];
	return r
}

function zh(n, e, t = {}, i, r) {
	if (ii.isCE || ii.parent && ol(ii.parent) && ii.parent.isCE) return e !== "default" && (t.name = e), Ge("slot", t, i);
	let s = n[e];
	s && s._c && (s._d = !1), ke();
	const o = s && ST(s(t)),
		a = It(gn, {
			key: t.key || o && o.key || `_${e}`
		}, o || [], o && n._ === 1 ? 64 : -2);
	return a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}

function ST(n) {
	return n.some(e => qc(e) ? !(e.type === fi || e.type === gn && !ST(e.children)) : !0) ? n : null
}
const u_ = n => n ? jT(n) ? p1(n) || n.proxy : u_(n.parent) : null,
	ah = An(Object.create(null), {
		$: n => n,
		$el: n => n.vnode.el,
		$data: n => n.data,
		$props: n => n.props,
		$attrs: n => n.attrs,
		$slots: n => n.slots,
		$refs: n => n.refs,
		$parent: n => u_(n.parent),
		$root: n => u_(n.root),
		$emit: n => n.emit,
		$options: n => c1(n),
		$forceUpdate: n => n.f || (n.f = () => {
			n.effect.dirty = !0, Tm(n.update)
		}),
		$nextTick: n => n.n || (n.n = Xi.bind(n.proxy)),
		$watch: n => WR.bind(n)
	}),
	v0 = (n, e) => n !== rn && !n.__isScriptSetup && At(n, e),
	t4 = {
		get({
			_: n
		}, e) {
			if (e === "__v_skip") return !0;
			const {
				ctx: t,
				setupState: i,
				data: r,
				props: s,
				accessCache: o,
				type: a,
				appContext: l
			} = n;
			let c;
			if (e[0] !== "$") {
				const f = o[e];
				if (f !== void 0) switch (f) {
					case 1:
						return i[e];
					case 2:
						return r[e];
					case 4:
						return t[e];
					case 3:
						return s[e]
				} else {
					if (v0(i, e)) return o[e] = 1, i[e];
					if (r !== rn && At(r, e)) return o[e] = 2, r[e];
					if ((c = n.propsOptions[0]) && At(c, e)) return o[e] = 3, s[e];
					if (t !== rn && At(t, e)) return o[e] = 4, t[e];
					h_ && (o[e] = 0)
				}
			}
			const u = ah[e];
			let h, d;
			if (u) return e === "$attrs" && qi(n.attrs, "get", ""), u(n);
			if ((h = a.__cssModules) && (h = h[e])) return h;
			if (t !== rn && At(t, e)) return o[e] = 4, t[e];
			if (d = l.config.globalProperties, At(d, e)) return d[e]
		},
		set({
			_: n
		}, e, t) {
			const {
				data: i,
				setupState: r,
				ctx: s
			} = n;
			return v0(r, e) ? (r[e] = t, !0) : i !== rn && At(i, e) ? (i[e] = t, !0) : At(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (s[e] = t, !0)
		},
		has({
			_: {
				data: n,
				setupState: e,
				accessCache: t,
				ctx: i,
				appContext: r,
				propsOptions: s
			}
		}, o) {
			let a;
			return !!t[o] || n !== rn && At(n, o) || v0(e, o) || (a = s[0]) && At(a, o) || At(i, o) || At(ah, o) || At(r.config.globalProperties, o)
		},
		defineProperty(n, e, t) {
			return t.get != null ? n._.accessCache[e] = 0 : At(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t)
		}
	};

function ay(n) {
	return rt(n) ? n.reduce((e, t) => (e[t] = null, e), {}) : n
}

function cte(n) {
	const e = vu();
	let t = n();
	return g_(), Wv(t) && (t = t.catch(i => {
		throw yl(e), i
	})), [t, () => yl(e)]
}
let h_ = !0;

function n4(n) {
	const e = c1(n),
		t = n.proxy,
		i = n.ctx;
	h_ = !1, e.beforeCreate && ly(e.beforeCreate, n, "bc");
	const {
		data: r,
		computed: s,
		methods: o,
		watch: a,
		provide: l,
		inject: c,
		created: u,
		beforeMount: h,
		mounted: d,
		beforeUpdate: f,
		updated: p,
		activated: _,
		deactivated: g,
		beforeDestroy: m,
		beforeUnmount: b,
		destroyed: v,
		unmounted: y,
		render: x,
		renderTracked: S,
		renderTriggered: E,
		errorCaptured: C,
		serverPrefetch: P,
		expose: w,
		inheritAttrs: D,
		components: U,
		directives: j,
		filters: z
	} = e;
	if (c && i4(c, i, null), o)
		for (const G in o) {
			const R = o[G];
			ut(R) && (i[G] = R.bind(t))
		}
	if (r) {
		const G = r.call(t, t);
		Zt(G) && (n.data = Ii(G))
	}
	if (h_ = !0, s)
		for (const G in s) {
			const R = s[G],
				Q = ut(R) ? R.bind(t, t) : ut(R.get) ? R.get.bind(t, t) : Br,
				B = !ut(R) && ut(R.set) ? R.set.bind(t) : Br,
				ge = Be({
					get: Q,
					set: B
				});
			Object.defineProperty(i, G, {
				enumerable: !0,
				configurable: !0,
				get: () => ge.value,
				set: Ae => ge.value = Ae
			})
		}
	if (a)
		for (const G in a) TT(a[G], i, t, G);
	if (l) {
		const G = ut(l) ? l.call(t) : l;
		Reflect.ownKeys(G).forEach(R => {
			al(R, G[R])
		})
	}
	u && ly(u, n, "c");

	function F(G, R) {
		rt(R) ? R.forEach(Q => G(Q.bind(t))) : R && G(R.bind(t))
	}
	if (F(l1, h), F(Vn, d), F(ZR, f), F(wT, p), F(o1, _), F(a1, g), F(ET, C), F(e4, S), F(QR, E), F(Sa, b), F(Yi, y), F(JR, P), rt(w))
		if (w.length) {
			const G = n.exposed || (n.exposed = {});
			w.forEach(R => {
				Object.defineProperty(G, R, {
					get: () => t[R],
					set: Q => t[R] = Q
				})
			})
		} else n.exposed || (n.exposed = {});
	x && n.render === Br && (n.render = x), D != null && (n.inheritAttrs = D), U && (n.components = U), j && (n.directives = j)
}

function i4(n, e, t = Br) {
	rt(n) && (n = d_(n));
	for (const i in n) {
		const r = n[i];
		let s;
		Zt(r) ? "default" in r ? s = si(r.from || i, r.default, !0) : s = si(r.from || i) : s = si(r), bn(s) ? Object.defineProperty(e, i, {
			enumerable: !0,
			configurable: !0,
			get: () => s.value,
			set: o => s.value = o
		}) : e[i] = s
	}
}

function ly(n, e, t) {
	Wr(rt(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}

function TT(n, e, t, i) {
	const r = i.includes(".") ? _T(t, i) : () => t[i];
	if (ln(n)) {
		const s = e[n];
		ut(s) && Vt(r, s)
	} else if (ut(n)) Vt(r, n.bind(t));
	else if (Zt(n))
		if (rt(n)) n.forEach(s => TT(s, e, t, i));
		else {
			const s = ut(n.handler) ? n.handler.bind(t) : e[n.handler];
			ut(s) && Vt(r, s, n)
		}
}

function c1(n) {
	const e = n.type,
		{
			mixins: t,
			extends: i
		} = e,
		{
			mixins: r,
			optionsCache: s,
			config: {
				optionMergeStrategies: o
			}
		} = n.appContext,
		a = s.get(e);
	let l;
	return a ? l = a : !r.length && !t && !i ? l = e : (l = {}, r.length && r.forEach(c => Tp(l, c, o, !0)), Tp(l, e, o)), Zt(e) && s.set(e, l), l
}

function Tp(n, e, t, i = !1) {
	const {
		mixins: r,
		extends: s
	} = e;
	s && Tp(n, s, t, !0), r && r.forEach(o => Tp(n, o, t, !0));
	for (const o in e)
		if (!(i && o === "expose")) {
			const a = r4[o] || t && t[o];
			n[o] = a ? a(n[o], e[o]) : e[o]
		} return n
}
const r4 = {
	data: cy,
	props: uy,
	emits: uy,
	methods: Yu,
	computed: Yu,
	beforeCreate: wi,
	created: wi,
	beforeMount: wi,
	mounted: wi,
	beforeUpdate: wi,
	updated: wi,
	beforeDestroy: wi,
	beforeUnmount: wi,
	destroyed: wi,
	unmounted: wi,
	activated: wi,
	deactivated: wi,
	errorCaptured: wi,
	serverPrefetch: wi,
	components: Yu,
	directives: Yu,
	watch: o4,
	provide: cy,
	inject: s4
};

function cy(n, e) {
	return e ? n ? function () {
		return An(ut(n) ? n.call(this, this) : n, ut(e) ? e.call(this, this) : e)
	} : e : n
}

function s4(n, e) {
	return Yu(d_(n), d_(e))
}

function d_(n) {
	if (rt(n)) {
		const e = {};
		for (let t = 0; t < n.length; t++) e[n[t]] = n[t];
		return e
	}
	return n
}

function wi(n, e) {
	return n ? [...new Set([].concat(n, e))] : e
}

function Yu(n, e) {
	return n ? An(Object.create(null), n, e) : e
}

function uy(n, e) {
	return n ? rt(n) && rt(e) ? [...new Set([...n, ...e])] : An(Object.create(null), ay(n), ay(e ?? {})) : e
}

function o4(n, e) {
	if (!n) return e;
	if (!e) return n;
	const t = An(Object.create(null), n);
	for (const i in e) t[i] = wi(n[i], e[i]);
	return t
}

function MT() {
	return {
		app: null,
		config: {
			isNativeTag: OP,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap,
		propsCache: new WeakMap,
		emitsCache: new WeakMap
	}
}
let a4 = 0;

function l4(n, e) {
	return function (i, r = null) {
		ut(i) || (i = An({}, i)), r != null && !Zt(r) && (r = null);
		const s = MT(),
			o = new WeakSet;
		let a = !1;
		const l = s.app = {
			_uid: a4++,
			_component: i,
			_props: r,
			_container: null,
			_context: s,
			_instance: null,
			version: qT,
			get config() {
				return s.config
			},
			set config(c) {},
			use(c, ...u) {
				return o.has(c) || (c && ut(c.install) ? (o.add(c), c.install(l, ...u)) : ut(c) && (o.add(c), c(l, ...u))), l
			},
			mixin(c) {
				return s.mixins.includes(c) || s.mixins.push(c), l
			},
			component(c, u) {
				return u ? (s.components[c] = u, l) : s.components[c]
			},
			directive(c, u) {
				return u ? (s.directives[c] = u, l) : s.directives[c]
			},
			mount(c, u, h) {
				if (!a) {
					const d = Ge(i, r);
					return d.appContext = s, h === !0 ? h = "svg" : h === !1 && (h = void 0), u && e ? e(d, c) : n(d, c, h), a = !0, l._container = c, c.__vue_app__ = l, p1(d.component) || d.component.proxy
				}
			},
			unmount() {
				a && (n(null, l._container), delete l._container.__vue_app__)
			},
			provide(c, u) {
				return s.provides[c] = u, l
			},
			runWithContext(c) {
				const u = Pc;
				Pc = l;
				try {
					return c()
				} finally {
					Pc = u
				}
			}
		};
		return l
	}
}
let Pc = null;

function al(n, e) {
	if (Nn) {
		let t = Nn.provides;
		const i = Nn.parent && Nn.parent.provides;
		i === t && (t = Nn.provides = Object.create(i)), t[n] = e
	}
}

function si(n, e, t = !1) {
	const i = Nn || ii;
	if (i || Pc) {
		const r = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Pc._context.provides;
		if (r && n in r) return r[n];
		if (arguments.length > 1) return t && ut(e) ? e.call(i && i.proxy) : e
	}
}

function u1() {
	return !!(Nn || ii || Pc)
}
const CT = {},
	AT = () => Object.create(CT),
	DT = n => Object.getPrototypeOf(n) === CT;

function c4(n, e, t, i = !1) {
	const r = {},
		s = AT();
	n.propsDefaults = Object.create(null), PT(n, e, r, s);
	for (const o in n.propsOptions[0]) o in r || (r[o] = void 0);
	t ? n.props = i ? r : gd(r) : n.type.props ? n.props = r : n.props = s, n.attrs = s
}

function u4(n, e, t, i) {
	const {
		props: r,
		attrs: s,
		vnode: {
			patchFlag: o
		}
	} = n, a = Mt(r), [l] = n.propsOptions;
	let c = !1;
	if ((i || o > 0) && !(o & 16)) {
		if (o & 8) {
			const u = n.vnode.dynamicProps;
			for (let h = 0; h < u.length; h++) {
				let d = u[h];
				if (Mm(n.emitsOptions, d)) continue;
				const f = e[d];
				if (l)
					if (At(s, d)) f !== s[d] && (s[d] = f, c = !0);
					else {
						const p = As(d);
						r[p] = f_(l, a, p, f, n, !1)
					}
				else f !== s[d] && (s[d] = f, c = !0)
			}
		}
	} else {
		PT(n, e, r, s) && (c = !0);
		let u;
		for (const h in a)(!e || !At(e, h) && ((u = mu(h)) === h || !At(e, u))) && (l ? t && (t[h] !== void 0 || t[u] !== void 0) && (r[h] = f_(l, a, h, void 0, n, !0)) : delete r[h]);
		if (s !== a)
			for (const h in s)(!e || !At(e, h)) && (delete s[h], c = !0)
	}
	c && no(n.attrs, "set", "")
}

function PT(n, e, t, i) {
	const [r, s] = n.propsOptions;
	let o = !1,
		a;
	if (e)
		for (let l in e) {
			if (Cc(l)) continue;
			const c = e[l];
			let u;
			r && At(r, u = As(l)) ? !s || !s.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : Mm(n.emitsOptions, l) || (!(l in i) || c !== i[l]) && (i[l] = c, o = !0)
		}
	if (s) {
		const l = Mt(t),
			c = a || rn;
		for (let u = 0; u < s.length; u++) {
			const h = s[u];
			t[h] = f_(r, l, h, c[h], n, !At(c, h))
		}
	}
	return o
}

function f_(n, e, t, i, r, s) {
	const o = n[t];
	if (o != null) {
		const a = At(o, "default");
		if (a && i === void 0) {
			const l = o.default;
			if (o.type !== Function && !o.skipFactory && ut(l)) {
				const {
					propsDefaults: c
				} = r;
				if (t in c) i = c[t];
				else {
					const u = yl(r);
					i = c[t] = l.call(null, e), u()
				}
			} else i = l
		}
		o[0] && (s && !a ? i = !1 : o[1] && (i === "" || i === mu(t)) && (i = !0))
	}
	return i
}

function RT(n, e, t = !1) {
	const i = e.propsCache,
		r = i.get(n);
	if (r) return r;
	const s = n.props,
		o = {},
		a = [];
	let l = !1;
	if (!ut(n)) {
		const u = h => {
			l = !0;
			const [d, f] = RT(h, e, !0);
			An(o, d), f && a.push(...f)
		};
		!t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u)
	}
	if (!s && !l) return Zt(n) && i.set(n, Tc), Tc;
	if (rt(s))
		for (let u = 0; u < s.length; u++) {
			const h = As(s[u]);
			hy(h) && (o[h] = rn)
		} else if (s)
			for (const u in s) {
				const h = As(u);
				if (hy(h)) {
					const d = s[u],
						f = o[h] = rt(d) || ut(d) ? {
							type: d
						} : An({}, d);
					if (f) {
						const p = py(Boolean, f.type),
							_ = py(String, f.type);
						f[0] = p > -1, f[1] = _ < 0 || p < _, (p > -1 || At(f, "default")) && a.push(h)
					}
				}
			}
	const c = [o, a];
	return Zt(n) && i.set(n, c), c
}

function hy(n) {
	return n[0] !== "$" && !Cc(n)
}

function dy(n) {
	return n === null ? "null" : typeof n == "function" ? n.name || "" : typeof n == "object" && n.constructor && n.constructor.name || ""
}

function fy(n, e) {
	return dy(n) === dy(e)
}

function py(n, e) {
	return rt(e) ? e.findIndex(t => fy(t, n)) : ut(e) && fy(e, n) ? 0 : -1
}
const LT = n => n[0] === "_" || n === "$stable",
	h1 = n => rt(n) ? n.map(Ir) : [Ir(n)],
	h4 = (n, e, t) => {
		if (e._n) return e;
		const i = En((...r) => h1(e(...r)), t);
		return i._c = !1, i
	},
	kT = (n, e, t) => {
		const i = n._ctx;
		for (const r in n) {
			if (LT(r)) continue;
			const s = n[r];
			if (ut(s)) e[r] = h4(r, s, i);
			else if (s != null) {
				const o = h1(s);
				e[r] = () => o
			}
		}
	},
	IT = (n, e) => {
		const t = h1(e);
		n.slots.default = () => t
	},
	d4 = (n, e) => {
		const t = n.slots = AT();
		if (n.vnode.shapeFlag & 32) {
			const i = e._;
			i ? (An(t, e), NS(t, "_", i, !0)) : kT(e, t)
		} else e && IT(n, e)
	},
	f4 = (n, e, t) => {
		const {
			vnode: i,
			slots: r
		} = n;
		let s = !0,
			o = rn;
		if (i.shapeFlag & 32) {
			const a = e._;
			a ? t && a === 1 ? s = !1 : (An(r, e), !t && a === 1 && delete r._) : (s = !e.$stable, kT(e, r)), o = e
		} else e && (IT(n, e), o = {
			default: 1
		});
		if (s)
			for (const a in r) !LT(a) && o[a] == null && delete r[a]
	};

function Mp(n, e, t, i, r = !1) {
	if (rt(n)) {
		n.forEach((d, f) => Mp(d, e && (rt(e) ? e[f] : e), t, i, r));
		return
	}
	if (ol(i) && !r) return;
	const s = i.shapeFlag & 4 ? p1(i.component) || i.component.proxy : i.el,
		o = r ? null : s,
		{
			i: a,
			r: l
		} = n,
		c = e && e.r,
		u = a.refs === rn ? a.refs = {} : a.refs,
		h = a.setupState;
	if (c != null && c !== l && (ln(c) ? (u[c] = null, At(h, c) && (h[c] = null)) : bn(c) && (c.value = null)), ut(l)) ia(l, a, 12, [o, u]);
	else {
		const d = ln(l),
			f = bn(l);
		if (d || f) {
			const p = () => {
				if (n.f) {
					const _ = d ? At(h, l) ? h[l] : u[l] : l.value;
					r ? rt(_) && Gv(_, s) : rt(_) ? _.includes(s) || _.push(s) : d ? (u[l] = [s], At(h, l) && (h[l] = u[l])) : (l.value = [s], n.k && (u[n.k] = l.value))
				} else d ? (u[l] = o, At(h, l) && (h[l] = o)) : f && (l.value = o, n.k && (u[n.k] = o))
			};
			o ? (p.id = -1, ei(p, t)) : p()
		}
	}
}
let vo = !1;
const p4 = n => n.namespaceURI.includes("svg") && n.tagName !== "foreignObject",
	m4 = n => n.namespaceURI.includes("MathML"),
	Yd = n => {
		if (p4(n)) return "svg";
		if (m4(n)) return "mathml"
	},
	Kd = n => n.nodeType === 8;

function g4(n) {
	const {
		mt: e,
		p: t,
		o: {
			patchProp: i,
			createText: r,
			nextSibling: s,
			parentNode: o,
			remove: a,
			insert: l,
			createComment: c
		}
	} = n, u = (v, y) => {
		if (!y.hasChildNodes()) {
			t(null, v, y), wp(), y._vnode = v;
			return
		}
		vo = !1, h(y.firstChild, v, null, null, null), wp(), y._vnode = v, vo && console.error("Hydration completed but contains mismatches.")
	}, h = (v, y, x, S, E, C = !1) => {
		C = C || !!y.dynamicChildren;
		const P = Kd(v) && v.data === "[",
			w = () => _(v, y, x, S, E, P),
			{
				type: D,
				ref: U,
				shapeFlag: j,
				patchFlag: z
			} = y;
		let H = v.nodeType;
		y.el = v, z === -2 && (C = !1, y.dynamicChildren = null);
		let F = null;
		switch (D) {
			case jc:
				H !== 3 ? y.children === "" ? (l(y.el = r(""), o(v), v), F = v) : F = w() : (v.data !== y.children && (vo = !0, v.data = y.children), F = s(v));
				break;
			case fi:
				b(v) ? (F = s(v), m(y.el = v.content.firstChild, v, x)) : H !== 8 || P ? F = w() : F = s(v);
				break;
			case ch:
				if (P && (v = s(v), H = v.nodeType), H === 1 || H === 3) {
					F = v;
					const G = !y.children.length;
					for (let R = 0; R < y.staticCount; R++) G && (y.children += F.nodeType === 1 ? F.outerHTML : F.data), R === y.staticCount - 1 && (y.anchor = F), F = s(F);
					return P ? s(F) : F
				} else w();
				break;
			case gn:
				P ? F = p(v, y, x, S, E, C) : F = w();
				break;
			default:
				if (j & 1)(H !== 1 || y.type.toLowerCase() !== v.tagName.toLowerCase()) && !b(v) ? F = w() : F = d(v, y, x, S, E, C);
				else if (j & 6) {
					y.slotScopeIds = E;
					const G = o(v);
					if (P ? F = g(v) : Kd(v) && v.data === "teleport start" ? F = g(v, v.data, "teleport end") : F = s(v), e(y, G, null, x, S, Yd(G), C), ol(y)) {
						let R;
						P ? (R = Ge(gn), R.anchor = F ? F.previousSibling : G.lastChild) : R = v.nodeType === 3 ? Cp("") : Ge("div"), R.el = v, y.component.subTree = R
					}
				} else j & 64 ? H !== 8 ? F = w() : F = y.type.hydrate(v, y, x, S, E, C, n, f) : j & 128 && (F = y.type.hydrate(v, y, x, S, Yd(o(v)), E, C, n, h))
		}
		return U != null && Mp(U, null, S, y), F
	}, d = (v, y, x, S, E, C) => {
		C = C || !!y.dynamicChildren;
		const {
			type: P,
			props: w,
			patchFlag: D,
			shapeFlag: U,
			dirs: j,
			transition: z
		} = y, H = P === "input" || P === "option";
		if (H || D !== -1) {
			j && us(y, null, x, "created");
			let F = !1;
			if (b(v)) {
				F = FT(S, z) && x && x.vnode.props && x.vnode.props.appear;
				const R = v.content.firstChild;
				F && z.beforeEnter(R), m(R, v, x), y.el = v = R
			}
			if (U & 16 && !(w && (w.innerHTML || w.textContent))) {
				let R = f(v.firstChild, y, v, x, S, E, C);
				for (; R;) {
					vo = !0;
					const Q = R;
					R = R.nextSibling, a(Q)
				}
			} else U & 8 && v.textContent !== y.children && (vo = !0, v.textContent = y.children);
			if (w)
				if (H || !C || D & 48)
					for (const R in w)(H && (R.endsWith("value") || R === "indeterminate") || fd(R) && !Cc(R) || R[0] === ".") && i(v, R, null, w[R], void 0, void 0, x);
				else w.onClick && i(v, "onClick", null, w.onClick, void 0, void 0, x);
			let G;
			(G = w && w.onVnodeBeforeMount) && Ui(G, x, y), j && us(y, null, x, "beforeMount"), ((G = w && w.onVnodeMounted) || j || F) && gT(() => {
				G && Ui(G, x, y), F && z.enter(v), j && us(y, null, x, "mounted")
			}, S)
		}
		return v.nextSibling
	}, f = (v, y, x, S, E, C, P) => {
		P = P || !!y.dynamicChildren;
		const w = y.children,
			D = w.length;
		for (let U = 0; U < D; U++) {
			const j = P ? w[U] : w[U] = Ir(w[U]);
			if (v) v = h(v, j, S, E, C, P);
			else {
				if (j.type === jc && !j.children) continue;
				vo = !0, t(null, j, x, null, S, E, Yd(x), C)
			}
		}
		return v
	}, p = (v, y, x, S, E, C) => {
		const {
			slotScopeIds: P
		} = y;
		P && (E = E ? E.concat(P) : P);
		const w = o(v),
			D = f(s(v), y, w, x, S, E, C);
		return D && Kd(D) && D.data === "]" ? s(y.anchor = D) : (vo = !0, l(y.anchor = c("]"), w, D), D)
	}, _ = (v, y, x, S, E, C) => {
		if (vo = !0, y.el = null, C) {
			const D = g(v);
			for (;;) {
				const U = s(v);
				if (U && U !== D) a(U);
				else break
			}
		}
		const P = s(v),
			w = o(v);
		return a(v), t(null, y, w, P, x, S, Yd(w), E), P
	}, g = (v, y = "[", x = "]") => {
		let S = 0;
		for (; v;)
			if (v = s(v), v && Kd(v) && (v.data === y && S++, v.data === x)) {
				if (S === 0) return s(v);
				S--
			} return v
	}, m = (v, y, x) => {
		const S = y.parentNode;
		S && S.replaceChild(v, y);
		let E = x;
		for (; E;) E.vnode.el === y && (E.vnode.el = E.subTree.el = v), E = E.parent
	}, b = v => v.nodeType === 1 && v.tagName.toLowerCase() === "template";
	return [u, h]
}
const ei = gT;

function _4(n) {
	return OT(n)
}

function v4(n) {
	return OT(n, g4)
}

function OT(n, e) {
	const t = BS();
	t.__VUE__ = !0;
	const {
		insert: i,
		remove: r,
		patchProp: s,
		createElement: o,
		createText: a,
		createComment: l,
		setText: c,
		setElementText: u,
		parentNode: h,
		nextSibling: d,
		setScopeId: f = Br,
		insertStaticContent: p
	} = n, _ = (k, O, q, ie = null, N = null, me = null, ve = void 0, xe = null, A = !!O.dynamicChildren) => {
		if (k === O) return;
		k && !ts(k, O) && (ie = Z(k), Ae(k, N, me, !0), k = null), O.patchFlag === -2 && (A = !1, O.dynamicChildren = null);
		const {
			type: T,
			ref: $,
			shapeFlag: re
		} = O;
		switch (T) {
			case jc:
				g(k, O, q, ie);
				break;
			case fi:
				m(k, O, q, ie);
				break;
			case ch:
				k == null && b(O, q, ie, ve);
				break;
			case gn:
				U(k, O, q, ie, N, me, ve, xe, A);
				break;
			default:
				re & 1 ? x(k, O, q, ie, N, me, ve, xe, A) : re & 6 ? j(k, O, q, ie, N, me, ve, xe, A) : (re & 64 || re & 128) && T.process(k, O, q, ie, N, me, ve, xe, A, Ce)
		}
		$ != null && N && Mp($, k && k.ref, me, O || k, !O)
	}, g = (k, O, q, ie) => {
		if (k == null) i(O.el = a(O.children), q, ie);
		else {
			const N = O.el = k.el;
			O.children !== k.children && c(N, O.children)
		}
	}, m = (k, O, q, ie) => {
		k == null ? i(O.el = l(O.children || ""), q, ie) : O.el = k.el
	}, b = (k, O, q, ie) => {
		[k.el, k.anchor] = p(k.children, O, q, ie, k.el, k.anchor)
	}, v = ({
		el: k,
		anchor: O
	}, q, ie) => {
		let N;
		for (; k && k !== O;) N = d(k), i(k, q, ie), k = N;
		i(O, q, ie)
	}, y = ({
		el: k,
		anchor: O
	}) => {
		let q;
		for (; k && k !== O;) q = d(k), r(k), k = q;
		r(O)
	}, x = (k, O, q, ie, N, me, ve, xe, A) => {
		O.type === "svg" ? ve = "svg" : O.type === "math" && (ve = "mathml"), k == null ? S(O, q, ie, N, me, ve, xe, A) : P(k, O, N, me, ve, xe, A)
	}, S = (k, O, q, ie, N, me, ve, xe) => {
		let A, T;
		const {
			props: $,
			shapeFlag: re,
			transition: se,
			dirs: ue
		} = k;
		if (A = k.el = o(k.type, me, $ && $.is, $), re & 8 ? u(A, k.children) : re & 16 && C(k.children, A, null, ie, N, b0(k, me), ve, xe), ue && us(k, null, ie, "created"), E(A, k, k.scopeId, ve, ie), $) {
			for (const Le in $) Le !== "value" && !Cc(Le) && s(A, Le, null, $[Le], me, k.children, ie, N, Se);
			"value" in $ && s(A, "value", null, $.value, me), (T = $.onVnodeBeforeMount) && Ui(T, ie, k)
		}
		ue && us(k, null, ie, "beforeMount");
		const Me = FT(N, se);
		Me && se.beforeEnter(A), i(A, O, q), ((T = $ && $.onVnodeMounted) || Me || ue) && ei(() => {
			T && Ui(T, ie, k), Me && se.enter(A), ue && us(k, null, ie, "mounted")
		}, N)
	}, E = (k, O, q, ie, N) => {
		if (q && f(k, q), ie)
			for (let me = 0; me < ie.length; me++) f(k, ie[me]);
		if (N) {
			let me = N.subTree;
			if (O === me) {
				const ve = N.vnode;
				E(k, ve, ve.scopeId, ve.slotScopeIds, N.parent)
			}
		}
	}, C = (k, O, q, ie, N, me, ve, xe, A = 0) => {
		for (let T = A; T < k.length; T++) {
			const $ = k[T] = xe ? Bo(k[T]) : Ir(k[T]);
			_(null, $, O, q, ie, N, me, ve, xe)
		}
	}, P = (k, O, q, ie, N, me, ve) => {
		const xe = O.el = k.el;
		let {
			patchFlag: A,
			dynamicChildren: T,
			dirs: $
		} = O;
		A |= k.patchFlag & 16;
		const re = k.props || rn,
			se = O.props || rn;
		let ue;
		if (q && La(q, !1), (ue = se.onVnodeBeforeUpdate) && Ui(ue, q, O, k), $ && us(O, k, q, "beforeUpdate"), q && La(q, !0), T ? w(k.dynamicChildren, T, xe, q, ie, b0(O, N), me) : ve || R(k, O, xe, null, q, ie, b0(O, N), me, !1), A > 0) {
			if (A & 16) D(xe, O, re, se, q, ie, N);
			else if (A & 2 && re.class !== se.class && s(xe, "class", null, se.class, N), A & 4 && s(xe, "style", re.style, se.style, N), A & 8) {
				const Me = O.dynamicProps;
				for (let Le = 0; Le < Me.length; Le++) {
					const we = Me[Le],
						Te = re[we],
						je = se[we];
					(je !== Te || we === "value") && s(xe, we, Te, je, N, k.children, q, ie, Se)
				}
			}
			A & 1 && k.children !== O.children && u(xe, O.children)
		} else !ve && T == null && D(xe, O, re, se, q, ie, N);
		((ue = se.onVnodeUpdated) || $) && ei(() => {
			ue && Ui(ue, q, O, k), $ && us(O, k, q, "updated")
		}, ie)
	}, w = (k, O, q, ie, N, me, ve) => {
		for (let xe = 0; xe < O.length; xe++) {
			const A = k[xe],
				T = O[xe],
				$ = A.el && (A.type === gn || !ts(A, T) || A.shapeFlag & 70) ? h(A.el) : q;
			_(A, T, $, null, ie, N, me, ve, !0)
		}
	}, D = (k, O, q, ie, N, me, ve) => {
		if (q !== ie) {
			if (q !== rn)
				for (const xe in q) !Cc(xe) && !(xe in ie) && s(k, xe, q[xe], null, ve, O.children, N, me, Se);
			for (const xe in ie) {
				if (Cc(xe)) continue;
				const A = ie[xe],
					T = q[xe];
				A !== T && xe !== "value" && s(k, xe, T, A, ve, O.children, N, me, Se)
			}
			"value" in ie && s(k, "value", q.value, ie.value, ve)
		}
	}, U = (k, O, q, ie, N, me, ve, xe, A) => {
		const T = O.el = k ? k.el : a(""),
			$ = O.anchor = k ? k.anchor : a("");
		let {
			patchFlag: re,
			dynamicChildren: se,
			slotScopeIds: ue
		} = O;
		ue && (xe = xe ? xe.concat(ue) : ue), k == null ? (i(T, q, ie), i($, q, ie), C(O.children || [], q, $, N, me, ve, xe, A)) : re > 0 && re & 64 && se && k.dynamicChildren ? (w(k.dynamicChildren, se, q, N, me, ve, xe), (O.key != null || N && O === N.subTree) && d1(k, O, !0)) : R(k, O, q, $, N, me, ve, xe, A)
	}, j = (k, O, q, ie, N, me, ve, xe, A) => {
		O.slotScopeIds = xe, k == null ? O.shapeFlag & 512 ? N.ctx.activate(O, q, ie, ve, A) : z(O, q, ie, N, me, ve, A) : H(k, O, A)
	}, z = (k, O, q, ie, N, me, ve) => {
		const xe = k.component = M4(k, ie, N);
		if (_d(k) && (xe.ctx.renderer = Ce), C4(xe), xe.asyncDep) {
			if (N && N.registerDep(xe, F), !k.el) {
				const A = xe.subTree = Ge(fi);
				m(null, A, O, q)
			}
		} else F(xe, k, O, q, N, me, ve)
	}, H = (k, O, q) => {
		const ie = O.component = k.component;
		if (LR(k, O, q))
			if (ie.asyncDep && !ie.asyncResolved) {
				G(ie, O, q);
				return
			} else ie.next = O, MR(ie.update), ie.effect.dirty = !0, ie.update();
		else O.el = k.el, ie.vnode = O
	}, F = (k, O, q, ie, N, me, ve) => {
		const xe = () => {
				if (k.isMounted) {
					let {
						next: $,
						bu: re,
						u: se,
						parent: ue,
						vnode: Me
					} = k; {
						const M = NT(k);
						if (M) {
							$ && ($.el = Me.el, G(k, $, ve)), M.asyncDep.then(() => {
								k.isUnmounted || xe()
							});
							return
						}
					}
					let Le = $,
						we;
					La(k, !1), $ ? ($.el = Me.el, G(k, $, ve)) : $ = Me, re && sh(re), (we = $.props && $.props.onVnodeBeforeUpdate) && Ui(we, ue, $, Me), La(k, !0);
					const Te = f0(k),
						je = k.subTree;
					k.subTree = Te, _(je, Te, h(je.el), Z(je), k, N, me), $.el = Te.el, Le === null && r1(k, Te.el), se && ei(se, N), (we = $.props && $.props.onVnodeUpdated) && ei(() => Ui(we, ue, $, Me), N)
				} else {
					let $;
					const {
						el: re,
						props: se
					} = O, {
						bm: ue,
						m: Me,
						parent: Le
					} = k, we = ol(O);
					if (La(k, !1), ue && sh(ue), !we && ($ = se && se.onVnodeBeforeMount) && Ui($, Le, O), La(k, !0), re && Y) {
						const Te = () => {
							k.subTree = f0(k), Y(re, k.subTree, k, N, null)
						};
						we ? O.type.__asyncLoader().then(() => !k.isUnmounted && Te()) : Te()
					} else {
						const Te = k.subTree = f0(k);
						_(null, Te, q, ie, k, N, me), O.el = Te.el
					}
					if (Me && ei(Me, N), !we && ($ = se && se.onVnodeMounted)) {
						const Te = O;
						ei(() => Ui($, Le, Te), N)
					}(O.shapeFlag & 256 || Le && ol(Le.vnode) && Le.vnode.shapeFlag & 256) && k.a && ei(k.a, N), k.isMounted = !0, O = q = ie = null
				}
			},
			A = k.effect = new Xv(xe, Br, () => Tm(T), k.scope),
			T = k.update = () => {
				A.dirty && A.run()
			};
		T.id = k.uid, La(k, !0), T()
	}, G = (k, O, q) => {
		O.component = k;
		const ie = k.vnode.props;
		k.vnode = O, k.next = null, u4(k, O.props, ie, q), f4(k, O.children, q), wa(), ny(k), Ea()
	}, R = (k, O, q, ie, N, me, ve, xe, A = !1) => {
		const T = k && k.children,
			$ = k ? k.shapeFlag : 0,
			re = O.children,
			{
				patchFlag: se,
				shapeFlag: ue
			} = O;
		if (se > 0) {
			if (se & 128) {
				B(T, re, q, ie, N, me, ve, xe, A);
				return
			} else if (se & 256) {
				Q(T, re, q, ie, N, me, ve, xe, A);
				return
			}
		}
		ue & 8 ? ($ & 16 && Se(T, N, me), re !== T && u(q, re)) : $ & 16 ? ue & 16 ? B(T, re, q, ie, N, me, ve, xe, A) : Se(T, N, me, !0) : ($ & 8 && u(q, ""), ue & 16 && C(re, q, ie, N, me, ve, xe, A))
	}, Q = (k, O, q, ie, N, me, ve, xe, A) => {
		k = k || Tc, O = O || Tc;
		const T = k.length,
			$ = O.length,
			re = Math.min(T, $);
		let se;
		for (se = 0; se < re; se++) {
			const ue = O[se] = A ? Bo(O[se]) : Ir(O[se]);
			_(k[se], ue, q, null, N, me, ve, xe, A)
		}
		T > $ ? Se(k, N, me, !0, !1, re) : C(O, q, ie, N, me, ve, xe, A, re)
	}, B = (k, O, q, ie, N, me, ve, xe, A) => {
		let T = 0;
		const $ = O.length;
		let re = k.length - 1,
			se = $ - 1;
		for (; T <= re && T <= se;) {
			const ue = k[T],
				Me = O[T] = A ? Bo(O[T]) : Ir(O[T]);
			if (ts(ue, Me)) _(ue, Me, q, null, N, me, ve, xe, A);
			else break;
			T++
		}
		for (; T <= re && T <= se;) {
			const ue = k[re],
				Me = O[se] = A ? Bo(O[se]) : Ir(O[se]);
			if (ts(ue, Me)) _(ue, Me, q, null, N, me, ve, xe, A);
			else break;
			re--, se--
		}
		if (T > re) {
			if (T <= se) {
				const ue = se + 1,
					Me = ue < $ ? O[ue].el : ie;
				for (; T <= se;) _(null, O[T] = A ? Bo(O[T]) : Ir(O[T]), q, Me, N, me, ve, xe, A), T++
			}
		} else if (T > se)
			for (; T <= re;) Ae(k[T], N, me, !0), T++;
		else {
			const ue = T,
				Me = T,
				Le = new Map;
			for (T = Me; T <= se; T++) {
				const oe = O[T] = A ? Bo(O[T]) : Ir(O[T]);
				oe.key != null && Le.set(oe.key, T)
			}
			let we, Te = 0;
			const je = se - Me + 1;
			let M = !1,
				W = 0;
			const le = new Array(je);
			for (T = 0; T < je; T++) le[T] = 0;
			for (T = ue; T <= re; T++) {
				const oe = k[T];
				if (Te >= je) {
					Ae(oe, N, me, !0);
					continue
				}
				let _e;
				if (oe.key != null) _e = Le.get(oe.key);
				else
					for (we = Me; we <= se; we++)
						if (le[we - Me] === 0 && ts(oe, O[we])) {
							_e = we;
							break
						} _e === void 0 ? Ae(oe, N, me, !0) : (le[_e - Me] = T + 1, _e >= W ? W = _e : M = !0, _(oe, O[_e], q, null, N, me, ve, xe, A), Te++)
			}
			const J = M ? b4(le) : Tc;
			for (we = J.length - 1, T = je - 1; T >= 0; T--) {
				const oe = Me + T,
					_e = O[oe],
					I = oe + 1 < $ ? O[oe + 1].el : ie;
				le[T] === 0 ? _(null, _e, q, I, N, me, ve, xe, A) : M && (we < 0 || T !== J[we] ? ge(_e, q, I, 2) : we--)
			}
		}
	}, ge = (k, O, q, ie, N = null) => {
		const {
			el: me,
			type: ve,
			transition: xe,
			children: A,
			shapeFlag: T
		} = k;
		if (T & 6) {
			ge(k.component.subTree, O, q, ie);
			return
		}
		if (T & 128) {
			k.suspense.move(O, q, ie);
			return
		}
		if (T & 64) {
			ve.move(k, O, q, Ce);
			return
		}
		if (ve === gn) {
			i(me, O, q);
			for (let re = 0; re < A.length; re++) ge(A[re], O, q, ie);
			i(k.anchor, O, q);
			return
		}
		if (ve === ch) {
			v(k, O, q);
			return
		}
		if (ie !== 2 && T & 1 && xe)
			if (ie === 0) xe.beforeEnter(me), i(me, O, q), ei(() => xe.enter(me), N);
			else {
				const {
					leave: re,
					delayLeave: se,
					afterLeave: ue
				} = xe, Me = () => i(me, O, q), Le = () => {
					re(me, () => {
						Me(), ue && ue()
					})
				};
				se ? se(me, Me, Le) : Le()
			}
		else i(me, O, q)
	}, Ae = (k, O, q, ie = !1, N = !1) => {
		const {
			type: me,
			props: ve,
			ref: xe,
			children: A,
			dynamicChildren: T,
			shapeFlag: $,
			patchFlag: re,
			dirs: se
		} = k;
		if (xe != null && Mp(xe, null, q, k, !0), $ & 256) {
			O.ctx.deactivate(k);
			return
		}
		const ue = $ & 1 && se,
			Me = !ol(k);
		let Le;
		if (Me && (Le = ve && ve.onVnodeBeforeUnmount) && Ui(Le, O, k), $ & 6) ye(k.component, q, ie);
		else {
			if ($ & 128) {
				k.suspense.unmount(q, ie);
				return
			}
			ue && us(k, null, O, "beforeUnmount"), $ & 64 ? k.type.remove(k, O, q, N, Ce, ie) : T && (me !== gn || re > 0 && re & 64) ? Se(T, O, q, !1, !0) : (me === gn && re & 384 || !N && $ & 16) && Se(A, O, q), ie && ze(k)
		}(Me && (Le = ve && ve.onVnodeUnmounted) || ue) && ei(() => {
			Le && Ui(Le, O, k), ue && us(k, null, O, "unmounted")
		}, q)
	}, ze = k => {
		const {
			type: O,
			el: q,
			anchor: ie,
			transition: N
		} = k;
		if (O === gn) {
			K(q, ie);
			return
		}
		if (O === ch) {
			y(k);
			return
		}
		const me = () => {
			r(q), N && !N.persisted && N.afterLeave && N.afterLeave()
		};
		if (k.shapeFlag & 1 && N && !N.persisted) {
			const {
				leave: ve,
				delayLeave: xe
			} = N, A = () => ve(q, me);
			xe ? xe(k.el, me, A) : A()
		} else me()
	}, K = (k, O) => {
		let q;
		for (; k !== O;) q = d(k), r(k), k = q;
		r(O)
	}, ye = (k, O, q) => {
		const {
			bum: ie,
			scope: N,
			update: me,
			subTree: ve,
			um: xe
		} = k;
		ie && sh(ie), N.stop(), me && (me.active = !1, Ae(ve, k, O, q)), xe && ei(xe, O), ei(() => {
			k.isUnmounted = !0
		}, O), O && O.pendingBranch && !O.isUnmounted && k.asyncDep && !k.asyncResolved && k.suspenseId === O.pendingId && (O.deps--, O.deps === 0 && O.resolve())
	}, Se = (k, O, q, ie = !1, N = !1, me = 0) => {
		for (let ve = me; ve < k.length; ve++) Ae(k[ve], O, q, ie, N)
	}, Z = k => k.shapeFlag & 6 ? Z(k.component.subTree) : k.shapeFlag & 128 ? k.suspense.next() : d(k.anchor || k.el);
	let pe = !1;
	const ce = (k, O, q) => {
			k == null ? O._vnode && Ae(O._vnode, null, null, !0) : _(O._vnode || null, k, O, null, null, null, q), pe || (pe = !0, ny(), wp(), pe = !1), O._vnode = k
		},
		Ce = {
			p: _,
			um: Ae,
			m: ge,
			r: ze,
			mt: z,
			mc: C,
			pc: R,
			pbc: w,
			n: Z,
			o: n
		};
	let Re, Y;
	return e && ([Re, Y] = e(Ce)), {
		render: ce,
		hydrate: Re,
		createApp: l4(ce, Re)
	}
}

function b0({
	type: n,
	props: e
}, t) {
	return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}

function La({
	effect: n,
	update: e
}, t) {
	n.allowRecurse = e.allowRecurse = t
}

function FT(n, e) {
	return (!n || n && !n.pendingBranch) && e && !e.persisted
}

function d1(n, e, t = !1) {
	const i = n.children,
		r = e.children;
	if (rt(i) && rt(r))
		for (let s = 0; s < i.length; s++) {
			const o = i[s];
			let a = r[s];
			a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = Bo(r[s]), a.el = o.el), t || d1(o, a)), a.type === jc && (a.el = o.el)
		}
}

function b4(n) {
	const e = n.slice(),
		t = [0];
	let i, r, s, o, a;
	const l = n.length;
	for (i = 0; i < l; i++) {
		const c = n[i];
		if (c !== 0) {
			if (r = t[t.length - 1], n[r] < c) {
				e[i] = r, t.push(i);
				continue
			}
			for (s = 0, o = t.length - 1; s < o;) a = s + o >> 1, n[t[a]] < c ? s = a + 1 : o = a;
			c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]), t[s] = i)
		}
	}
	for (s = t.length, o = t[s - 1]; s-- > 0;) t[s] = o, o = e[o];
	return t
}

function NT(n) {
	const e = n.subTree.component;
	if (e) return e.asyncDep && !e.asyncResolved ? e : NT(e)
}
const y4 = n => n.__isTeleport,
	lh = n => n && (n.disabled || n.disabled === ""),
	my = n => typeof SVGElement < "u" && n instanceof SVGElement,
	gy = n => typeof MathMLElement == "function" && n instanceof MathMLElement,
	p_ = (n, e) => {
		const t = n && n.to;
		return ln(t) ? e ? e(t) : null : t
	},
	x4 = {
		name: "Teleport",
		__isTeleport: !0,
		process(n, e, t, i, r, s, o, a, l, c) {
			const {
				mc: u,
				pc: h,
				pbc: d,
				o: {
					insert: f,
					querySelector: p,
					createText: _,
					createComment: g
				}
			} = c, m = lh(e.props);
			let {
				shapeFlag: b,
				children: v,
				dynamicChildren: y
			} = e;
			if (n == null) {
				const x = e.el = _(""),
					S = e.anchor = _("");
				f(x, t, i), f(S, t, i);
				const E = e.target = p_(e.props, p),
					C = e.targetAnchor = _("");
				E && (f(C, E), o === "svg" || my(E) ? o = "svg" : (o === "mathml" || gy(E)) && (o = "mathml"));
				const P = (w, D) => {
					b & 16 && u(v, w, D, r, s, o, a, l)
				};
				m ? P(t, S) : E && P(E, C)
			} else {
				e.el = n.el;
				const x = e.anchor = n.anchor,
					S = e.target = n.target,
					E = e.targetAnchor = n.targetAnchor,
					C = lh(n.props),
					P = C ? t : S,
					w = C ? x : E;
				if (o === "svg" || my(S) ? o = "svg" : (o === "mathml" || gy(S)) && (o = "mathml"), y ? (d(n.dynamicChildren, y, P, r, s, o, a), d1(n, e, !0)) : l || h(n, e, P, w, r, s, o, a, !1), m) C ? e.props && n.props && e.props.to !== n.props.to && (e.props.to = n.props.to) : Zd(e, t, x, c, 1);
				else if ((e.props && e.props.to) !== (n.props && n.props.to)) {
					const D = e.target = p_(e.props, p);
					D && Zd(e, D, null, c, 0)
				} else C && Zd(e, S, E, c, 1)
			}
			UT(e)
		},
		remove(n, e, t, i, {
			um: r,
			o: {
				remove: s
			}
		}, o) {
			const {
				shapeFlag: a,
				children: l,
				anchor: c,
				targetAnchor: u,
				target: h,
				props: d
			} = n;
			if (h && s(u), o && s(c), a & 16) {
				const f = o || !lh(d);
				for (let p = 0; p < l.length; p++) {
					const _ = l[p];
					r(_, e, t, f, !!_.dynamicChildren)
				}
			}
		},
		move: Zd,
		hydrate: w4
	};

function Zd(n, e, t, {
	o: {
		insert: i
	},
	m: r
}, s = 2) {
	s === 0 && i(n.targetAnchor, e, t);
	const {
		el: o,
		anchor: a,
		shapeFlag: l,
		children: c,
		props: u
	} = n, h = s === 2;
	if (h && i(o, e, t), (!h || lh(u)) && l & 16)
		for (let d = 0; d < c.length; d++) r(c[d], e, t, 2);
	h && i(a, e, t)
}

function w4(n, e, t, i, r, s, {
	o: {
		nextSibling: o,
		parentNode: a,
		querySelector: l
	}
}, c) {
	const u = e.target = p_(e.props, l);
	if (u) {
		const h = u._lpa || u.firstChild;
		if (e.shapeFlag & 16)
			if (lh(e.props)) e.anchor = c(o(n), e, a(n), t, i, r, s), e.targetAnchor = h;
			else {
				e.anchor = o(n);
				let d = h;
				for (; d;)
					if (d = o(d), d && d.nodeType === 8 && d.data === "teleport anchor") {
						e.targetAnchor = d, u._lpa = e.targetAnchor && o(e.targetAnchor);
						break
					} c(h, e, u, t, i, r, s)
			} UT(e)
	}
	return e.anchor && o(e.anchor)
}
const ute = x4;

function UT(n) {
	const e = n.ctx;
	if (e && e.ut) {
		let t = n.children[0].el;
		for (; t && t !== n.targetAnchor;) t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
		e.ut()
	}
}
const gn = Symbol.for("v-fgt"),
	jc = Symbol.for("v-txt"),
	fi = Symbol.for("v-cmt"),
	ch = Symbol.for("v-stc"),
	uh = [];
let zr = null;

function ke(n = !1) {
	uh.push(zr = n ? null : [])
}

function BT() {
	uh.pop(), zr = uh[uh.length - 1] || null
}
let $c = 1;

function _y(n) {
	$c += n
}

function zT(n) {
	return n.dynamicChildren = $c > 0 ? zr || Tc : null, BT(), $c > 0 && zr && zr.push(n), n
}

function Ye(n, e, t, i, r, s) {
	return zT(Fe(n, e, t, i, r, s, !0))
}

function It(n, e, t, i, r) {
	return zT(Ge(n, e, t, i, r, !0))
}

function qc(n) {
	return n ? n.__v_isVNode === !0 : !1
}

function ts(n, e) {
	return n.type === e.type && n.key === e.key
}
const VT = ({
		key: n
	}) => n ?? null,
	np = ({
		ref: n,
		ref_key: e,
		ref_for: t
	}) => (typeof n == "number" && (n = "" + n), n != null ? ln(n) || bn(n) || ut(n) ? {
		i: ii,
		r: n,
		k: e,
		f: !!t
	} : n : null);

function Fe(n, e = null, t = null, i = 0, r = null, s = n === gn ? 0 : 1, o = !1, a = !1) {
	const l = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: n,
		props: e,
		key: e && VT(e),
		ref: e && np(e),
		scopeId: uT,
		slotScopeIds: null,
		children: t,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: s,
		patchFlag: i,
		dynamicProps: r,
		dynamicChildren: null,
		appContext: null,
		ctx: ii
	};
	return a ? (f1(l, t), s & 128 && n.normalize(l)) : t && (l.shapeFlag |= ln(t) ? 8 : 16), $c > 0 && !o && zr && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && zr.push(l), l
}
const Ge = E4;

function E4(n, e = null, t = null, i = 0, r = null, s = !1) {
	if ((!n || n === dT) && (n = fi), qc(n)) {
		const a = oo(n, e, !0);
		return t && f1(a, t), $c > 0 && !s && zr && (a.shapeFlag & 6 ? zr[zr.indexOf(n)] = a : zr.push(a)), a.patchFlag |= -2, a
	}
	if (R4(n) && (n = n.__vccOpts), e) {
		e = HT(e);
		let {
			class: a,
			style: l
		} = e;
		a && !ln(a) && (e.class = jt(a)), Zt(l) && (tT(l) && !rt(l) && (l = An({}, l)), e.style = md(l))
	}
	const o = ln(n) ? 1 : pT(n) ? 128 : y4(n) ? 64 : Zt(n) ? 4 : ut(n) ? 2 : 0;
	return Fe(n, e, t, i, r, o, s, !0)
}

function HT(n) {
	return n ? tT(n) || DT(n) ? An({}, n) : n : null
}

function oo(n, e, t = !1, i = !1) {
	const {
		props: r,
		ref: s,
		patchFlag: o,
		children: a,
		transition: l
	} = n, c = e ? WT(r || {}, e) : r, u = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: n.type,
		props: c,
		key: c && VT(c),
		ref: e && e.ref ? t && s ? rt(s) ? s.concat(np(e)) : [s, np(e)] : np(e) : s,
		scopeId: n.scopeId,
		slotScopeIds: n.slotScopeIds,
		children: a,
		target: n.target,
		targetAnchor: n.targetAnchor,
		staticCount: n.staticCount,
		shapeFlag: n.shapeFlag,
		patchFlag: e && n.type !== gn ? o === -1 ? 16 : o | 16 : o,
		dynamicProps: n.dynamicProps,
		dynamicChildren: n.dynamicChildren,
		appContext: n.appContext,
		dirs: n.dirs,
		transition: l,
		component: n.component,
		suspense: n.suspense,
		ssContent: n.ssContent && oo(n.ssContent),
		ssFallback: n.ssFallback && oo(n.ssFallback),
		el: n.el,
		anchor: n.anchor,
		ctx: n.ctx,
		ce: n.ce
	};
	return l && i && (u.transition = l.clone(u)), u
}

function Cp(n = " ", e = 0) {
	return Ge(jc, null, n, e)
}

function GT(n, e) {
	const t = Ge(ch, null, n);
	return t.staticCount = e, t
}

function Fn(n = "", e = !1) {
	return e ? (ke(), It(fi, null, n)) : Ge(fi, null, n)
}

function Ir(n) {
	return n == null || typeof n == "boolean" ? Ge(fi) : rt(n) ? Ge(gn, null, n.slice()) : typeof n == "object" ? Bo(n) : Ge(jc, null, String(n))
}

function Bo(n) {
	return n.el === null && n.patchFlag !== -1 || n.memo ? n : oo(n)
}

function f1(n, e) {
	let t = 0;
	const {
		shapeFlag: i
	} = n;
	if (e == null) e = null;
	else if (rt(e)) t = 16;
	else if (typeof e == "object")
		if (i & 65) {
			const r = e.default;
			r && (r._c && (r._d = !1), f1(n, r()), r._c && (r._d = !0));
			return
		} else {
			t = 32;
			const r = e._;
			!r && !DT(e) ? e._ctx = ii : r === 3 && ii && (ii.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024))
		}
	else ut(e) ? (e = {
		default: e,
		_ctx: ii
	}, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [Cp(e)]) : t = 8);
	n.children = e, n.shapeFlag |= t
}

function WT(...n) {
	const e = {};
	for (let t = 0; t < n.length; t++) {
		const i = n[t];
		for (const r in i)
			if (r === "class") e.class !== i.class && (e.class = jt([e.class, i.class]));
			else if (r === "style") e.style = md([e.style, i.style]);
		else if (fd(r)) {
			const s = e[r],
				o = i[r];
			o && s !== o && !(rt(s) && s.includes(o)) && (e[r] = s ? [].concat(s, o) : o)
		} else r !== "" && (e[r] = i[r])
	}
	return e
}

function Ui(n, e, t, i = null) {
	Wr(n, e, 7, [t, i])
}
const S4 = MT();
let T4 = 0;

function M4(n, e, t) {
	const i = n.type,
		r = (e ? e.appContext : n.appContext) || S4,
		s = {
			uid: T4++,
			vnode: n,
			type: i,
			parent: e,
			appContext: r,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			scope: new HS(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: e ? e.provides : Object.create(r.provides),
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: RT(i, r),
			emitsOptions: cT(i, r),
			emit: null,
			emitted: null,
			propsDefaults: rn,
			inheritAttrs: i.inheritAttrs,
			ctx: rn,
			data: rn,
			props: rn,
			attrs: rn,
			slots: rn,
			refs: rn,
			setupState: rn,
			setupContext: null,
			attrsProxy: null,
			slotsProxy: null,
			suspense: t,
			suspenseId: t ? t.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null
		};
	return s.ctx = {
		_: s
	}, s.root = e ? e.root : s, s.emit = AR.bind(null, s), n.ce && n.ce(s), s
}
let Nn = null;
const vu = () => Nn || ii;
let Ap, m_; {
	const n = BS(),
		e = (t, i) => {
			let r;
			return (r = n[t]) || (r = n[t] = []), r.push(i), s => {
				r.length > 1 ? r.forEach(o => o(s)) : r[0](s)
			}
		};
	Ap = e("__VUE_INSTANCE_SETTERS__", t => Nn = t), m_ = e("__VUE_SSR_SETTERS__", t => vd = t)
}
const yl = n => {
		const e = Nn;
		return Ap(n), n.scope.on(), () => {
			n.scope.off(), Ap(e)
		}
	},
	g_ = () => {
		Nn && Nn.scope.off(), Ap(null)
	};

function jT(n) {
	return n.vnode.shapeFlag & 4
}
let vd = !1;

function C4(n, e = !1) {
	e && m_(e);
	const {
		props: t,
		children: i
	} = n.vnode, r = jT(n);
	c4(n, t, r, e), d4(n, i);
	const s = r ? A4(n, e) : void 0;
	return e && m_(!1), s
}

function A4(n, e) {
	const t = n.type;
	n.accessCache = Object.create(null), n.proxy = new Proxy(n.ctx, t4);
	const {
		setup: i
	} = t;
	if (i) {
		const r = n.setupContext = i.length > 1 ? P4(n) : null,
			s = yl(n);
		wa();
		const o = ia(i, n, 0, [n.props, r]);
		if (Ea(), s(), Wv(o)) {
			if (o.then(g_, g_), e) return o.then(a => {
				__(n, a, e)
			}).catch(a => {
				gu(a, n, 0)
			});
			n.asyncDep = o
		} else __(n, o, e)
	} else $T(n, e)
}

function __(n, e, t) {
	ut(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : Zt(e) && (n.setupState = rT(e)), $T(n, t)
}
let vy;

function $T(n, e, t) {
	const i = n.type;
	if (!n.render) {
		if (!e && vy && !i.render) {
			const r = i.template || c1(n).template;
			if (r) {
				const {
					isCustomElement: s,
					compilerOptions: o
				} = n.appContext.config, {
					delimiters: a,
					compilerOptions: l
				} = i, c = An(An({
					isCustomElement: s,
					delimiters: a
				}, o), l);
				i.render = vy(r, c)
			}
		}
		n.render = i.render || Br
	} {
		const r = yl(n);
		wa();
		try {
			n4(n)
		} finally {
			Ea(), r()
		}
	}
}
const D4 = {
	get(n, e) {
		return qi(n, "get", ""), n[e]
	}
};

function P4(n) {
	const e = t => {
		n.exposed = t || {}
	};
	return {
		attrs: new Proxy(n.attrs, D4),
		slots: n.slots,
		emit: n.emit,
		expose: e
	}
}

function p1(n) {
	if (n.exposed) return n.exposeProxy || (n.exposeProxy = new Proxy(rT(e1(n.exposed)), {
		get(e, t) {
			if (t in e) return e[t];
			if (t in ah) return ah[t](n)
		},
		has(e, t) {
			return t in e || t in ah
		}
	}))
}

function v_(n, e = !0) {
	return ut(n) ? n.displayName || n.name : n.name || e && n.__name
}

function R4(n) {
	return ut(n) && "__vccOpts" in n
}
const Be = (n, e) => gR(n, e, vd);

function on(n, e, t) {
	const i = arguments.length;
	return i === 2 ? Zt(e) && !rt(e) ? qc(e) ? Ge(n, null, [e]) : Ge(n, e) : Ge(n, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && qc(t) && (t = [t]), Ge(n, e, t))
}
const qT = "3.4.26";
/**
 * @vue/runtime-dom v3.4.26
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const L4 = "http://www.w3.org/2000/svg",
	k4 = "http://www.w3.org/1998/Math/MathML",
	zo = typeof document < "u" ? document : null,
	by = zo && zo.createElement("template"),
	I4 = {
		insert: (n, e, t) => {
			e.insertBefore(n, t || null)
		},
		remove: n => {
			const e = n.parentNode;
			e && e.removeChild(n)
		},
		createElement: (n, e, t, i) => {
			const r = e === "svg" ? zo.createElementNS(L4, n) : e === "mathml" ? zo.createElementNS(k4, n) : zo.createElement(n, t ? {
				is: t
			} : void 0);
			return n === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r
		},
		createText: n => zo.createTextNode(n),
		createComment: n => zo.createComment(n),
		setText: (n, e) => {
			n.nodeValue = e
		},
		setElementText: (n, e) => {
			n.textContent = e
		},
		parentNode: n => n.parentNode,
		nextSibling: n => n.nextSibling,
		querySelector: n => zo.querySelector(n),
		setScopeId(n, e) {
			n.setAttribute(e, "")
		},
		insertStaticContent(n, e, t, i, r, s) {
			const o = t ? t.previousSibling : e.lastChild;
			if (r && (r === s || r.nextSibling))
				for (; e.insertBefore(r.cloneNode(!0), t), !(r === s || !(r = r.nextSibling)););
			else {
				by.innerHTML = i === "svg" ? `<svg>${n}</svg>` : i === "mathml" ? `<math>${n}</math>` : n;
				const a = by.content;
				if (i === "svg" || i === "mathml") {
					const l = a.firstChild;
					for (; l.firstChild;) a.appendChild(l.firstChild);
					a.removeChild(l)
				}
				e.insertBefore(a, t)
			}
			return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
		}
	},
	bo = "transition",
	Pu = "animation",
	Vh = Symbol("_vtc"),
	ma = (n, {
		slots: e
	}) => on(qR, O4(n), e);
ma.displayName = "Transition";
const XT = {
	name: String,
	type: String,
	css: {
		type: Boolean,
		default: !0
	},
	duration: [String, Number, Object],
	enterFromClass: String,
	enterActiveClass: String,
	enterToClass: String,
	appearFromClass: String,
	appearActiveClass: String,
	appearToClass: String,
	leaveFromClass: String,
	leaveActiveClass: String,
	leaveToClass: String
};
ma.props = An({}, vT, XT);
const ka = (n, e = []) => {
		rt(n) ? n.forEach(t => t(...e)) : n && n(...e)
	},
	yy = n => n ? rt(n) ? n.some(e => e.length > 1) : n.length > 1 : !1;

function O4(n) {
	const e = {};
	for (const U in n) U in XT || (e[U] = n[U]);
	if (n.css === !1) return e;
	const {
		name: t = "v",
		type: i,
		duration: r,
		enterFromClass: s = `${t}-enter-from`,
		enterActiveClass: o = `${t}-enter-active`,
		enterToClass: a = `${t}-enter-to`,
		appearFromClass: l = s,
		appearActiveClass: c = o,
		appearToClass: u = a,
		leaveFromClass: h = `${t}-leave-from`,
		leaveActiveClass: d = `${t}-leave-active`,
		leaveToClass: f = `${t}-leave-to`
	} = n, p = F4(r), _ = p && p[0], g = p && p[1], {
		onBeforeEnter: m,
		onEnter: b,
		onEnterCancelled: v,
		onLeave: y,
		onLeaveCancelled: x,
		onBeforeAppear: S = m,
		onAppear: E = b,
		onAppearCancelled: C = v
	} = e, P = (U, j, z) => {
		Ia(U, j ? u : a), Ia(U, j ? c : o), z && z()
	}, w = (U, j) => {
		U._isLeaving = !1, Ia(U, h), Ia(U, f), Ia(U, d), j && j()
	}, D = U => (j, z) => {
		const H = U ? E : b,
			F = () => P(j, U, z);
		ka(H, [j, F]), xy(() => {
			Ia(j, U ? l : s), yo(j, U ? u : a), yy(H) || wy(j, i, _, F)
		})
	};
	return An(e, {
		onBeforeEnter(U) {
			ka(m, [U]), yo(U, s), yo(U, o)
		},
		onBeforeAppear(U) {
			ka(S, [U]), yo(U, l), yo(U, c)
		},
		onEnter: D(!1),
		onAppear: D(!0),
		onLeave(U, j) {
			U._isLeaving = !0;
			const z = () => w(U, j);
			yo(U, h), yo(U, d), B4(), xy(() => {
				U._isLeaving && (Ia(U, h), yo(U, f), yy(y) || wy(U, i, g, z))
			}), ka(y, [U, z])
		},
		onEnterCancelled(U) {
			P(U, !1), ka(v, [U])
		},
		onAppearCancelled(U) {
			P(U, !0), ka(C, [U])
		},
		onLeaveCancelled(U) {
			w(U), ka(x, [U])
		}
	})
}

function F4(n) {
	if (n == null) return null;
	if (Zt(n)) return [y0(n.enter), y0(n.leave)]; {
		const e = y0(n);
		return [e, e]
	}
}

function y0(n) {
	return US(n)
}

function yo(n, e) {
	e.split(/\s+/).forEach(t => t && n.classList.add(t)), (n[Vh] || (n[Vh] = new Set)).add(e)
}

function Ia(n, e) {
	e.split(/\s+/).forEach(i => i && n.classList.remove(i));
	const t = n[Vh];
	t && (t.delete(e), t.size || (n[Vh] = void 0))
}

function xy(n) {
	requestAnimationFrame(() => {
		requestAnimationFrame(n)
	})
}
let N4 = 0;

function wy(n, e, t, i) {
	const r = n._endId = ++N4,
		s = () => {
			r === n._endId && i()
		};
	if (t) return setTimeout(s, t);
	const {
		type: o,
		timeout: a,
		propCount: l
	} = U4(n, e);
	if (!o) return i();
	const c = o + "end";
	let u = 0;
	const h = () => {
			n.removeEventListener(c, d), s()
		},
		d = f => {
			f.target === n && ++u >= l && h()
		};
	setTimeout(() => {
		u < l && h()
	}, a + 1), n.addEventListener(c, d)
}

function U4(n, e) {
	const t = window.getComputedStyle(n),
		i = p => (t[p] || "").split(", "),
		r = i(`${bo}Delay`),
		s = i(`${bo}Duration`),
		o = Ey(r, s),
		a = i(`${Pu}Delay`),
		l = i(`${Pu}Duration`),
		c = Ey(a, l);
	let u = null,
		h = 0,
		d = 0;
	e === bo ? o > 0 && (u = bo, h = o, d = s.length) : e === Pu ? c > 0 && (u = Pu, h = c, d = l.length) : (h = Math.max(o, c), u = h > 0 ? o > c ? bo : Pu : null, d = u ? u === bo ? s.length : l.length : 0);
	const f = u === bo && /\b(transform|all)(,|$)/.test(i(`${bo}Property`).toString());
	return {
		type: u,
		timeout: h,
		propCount: d,
		hasTransform: f
	}
}

function Ey(n, e) {
	for (; n.length < e.length;) n = n.concat(n);
	return Math.max(...e.map((t, i) => Sy(t) + Sy(n[i])))
}

function Sy(n) {
	return n === "auto" ? 0 : Number(n.slice(0, -1).replace(",", ".")) * 1e3
}

function B4() {
	return document.body.offsetHeight
}

function z4(n, e, t) {
	const i = n[Vh];
	i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e
}
const Ty = Symbol("_vod"),
	V4 = Symbol("_vsh"),
	H4 = Symbol(""),
	G4 = /(^|;)\s*display\s*:/;

function W4(n, e, t) {
	const i = n.style,
		r = ln(t);
	let s = !1;
	if (t && !r) {
		if (e)
			if (ln(e))
				for (const o of e.split(";")) {
					const a = o.slice(0, o.indexOf(":")).trim();
					t[a] == null && ip(i, a, "")
				} else
					for (const o in e) t[o] == null && ip(i, o, "");
		for (const o in t) o === "display" && (s = !0), ip(i, o, t[o])
	} else if (r) {
		if (e !== t) {
			const o = i[H4];
			o && (t += ";" + o), i.cssText = t, s = G4.test(t)
		}
	} else e && n.removeAttribute("style");
	Ty in n && (n[Ty] = s ? i.display : "", n[V4] && (i.display = "none"))
}
const My = /\s*!important$/;

function ip(n, e, t) {
	if (rt(t)) t.forEach(i => ip(n, e, i));
	else if (t == null && (t = ""), e.startsWith("--")) n.setProperty(e, t);
	else {
		const i = j4(n, e);
		My.test(t) ? n.setProperty(mu(i), t.replace(My, ""), "important") : n[i] = t
	}
}
const Cy = ["Webkit", "Moz", "ms"],
	x0 = {};

function j4(n, e) {
	const t = x0[e];
	if (t) return t;
	let i = As(e);
	if (i !== "filter" && i in n) return x0[e] = i;
	i = xm(i);
	for (let r = 0; r < Cy.length; r++) {
		const s = Cy[r] + i;
		if (s in n) return x0[e] = s
	}
	return e
}
const Ay = "http://www.w3.org/1999/xlink";

function $4(n, e, t, i, r) {
	if (i && e.startsWith("xlink:")) t == null ? n.removeAttributeNS(Ay, e.slice(6, e.length)) : n.setAttributeNS(Ay, e, t);
	else {
		const s = XP(e);
		t == null || s && !zS(t) ? n.removeAttribute(e) : n.setAttribute(e, s ? "" : t)
	}
}

function q4(n, e, t, i, r, s, o) {
	if (e === "innerHTML" || e === "textContent") {
		i && o(i, r, s), n[e] = t ?? "";
		return
	}
	const a = n.tagName;
	if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
		const c = a === "OPTION" ? n.getAttribute("value") || "" : n.value,
			u = t ?? "";
		(c !== u || !("_value" in n)) && (n.value = u), t == null && n.removeAttribute(e), n._value = t;
		return
	}
	let l = !1;
	if (t === "" || t == null) {
		const c = typeof n[e];
		c === "boolean" ? t = zS(t) : t == null && c === "string" ? (t = "", l = !0) : c === "number" && (t = 0, l = !0)
	}
	try {
		n[e] = t
	} catch {}
	l && n.removeAttribute(e)
}

function X4(n, e, t, i) {
	n.addEventListener(e, t, i)
}

function Y4(n, e, t, i) {
	n.removeEventListener(e, t, i)
}
const Dy = Symbol("_vei");

function K4(n, e, t, i, r = null) {
	const s = n[Dy] || (n[Dy] = {}),
		o = s[e];
	if (i && o) o.value = i;
	else {
		const [a, l] = Z4(e);
		if (i) {
			const c = s[e] = eL(i, r);
			X4(n, a, c, l)
		} else o && (Y4(n, a, o, l), s[e] = void 0)
	}
}
const Py = /(?:Once|Passive|Capture)$/;

function Z4(n) {
	let e;
	if (Py.test(n)) {
		e = {};
		let i;
		for (; i = n.match(Py);) n = n.slice(0, n.length - i[0].length), e[i[0].toLowerCase()] = !0
	}
	return [n[2] === ":" ? n.slice(3) : mu(n.slice(2)), e]
}
let w0 = 0;
const J4 = Promise.resolve(),
	Q4 = () => w0 || (J4.then(() => w0 = 0), w0 = Date.now());

function eL(n, e) {
	const t = i => {
		if (!i._vts) i._vts = Date.now();
		else if (i._vts <= t.attached) return;
		Wr(tL(i, t.value), e, 5, [i])
	};
	return t.value = n, t.attached = Q4(), t
}

function tL(n, e) {
	if (rt(e)) {
		const t = n.stopImmediatePropagation;
		return n.stopImmediatePropagation = () => {
			t.call(n), n._stopped = !0
		}, e.map(i => r => !r._stopped && i && i(r))
	} else return e
}
const Ry = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123,
	nL = (n, e, t, i, r, s, o, a, l) => {
		const c = r === "svg";
		e === "class" ? z4(n, i, c) : e === "style" ? W4(n, t, i) : fd(e) ? Hv(e) || K4(n, e, t, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : iL(n, e, i, c)) ? q4(n, e, i, s, o, a, l) : (e === "true-value" ? n._trueValue = i : e === "false-value" && (n._falseValue = i), $4(n, e, i, c))
	};

function iL(n, e, t, i) {
	if (i) return !!(e === "innerHTML" || e === "textContent" || e in n && Ry(e) && ut(t));
	if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA") return !1;
	if (e === "width" || e === "height") {
		const r = n.tagName;
		if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1
	}
	return Ry(e) && ln(t) ? !1 : e in n
}
const YT = An({
	patchProp: nL
}, I4);
let hh, Ly = !1;

function rL() {
	return hh || (hh = _4(YT))
}

function sL() {
	return hh = Ly ? hh : v4(YT), Ly = !0, hh
}
const oL = (...n) => {
		const e = rL().createApp(...n),
			{
				mount: t
			} = e;
		return e.mount = i => {
			const r = ZT(i);
			if (!r) return;
			const s = e._component;
			!ut(s) && !s.render && !s.template && (s.template = r.innerHTML), r.innerHTML = "";
			const o = t(r, !1, KT(r));
			return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o
		}, e
	},
	aL = (...n) => {
		const e = sL().createApp(...n),
			{
				mount: t
			} = e;
		return e.mount = i => {
			const r = ZT(i);
			if (r) return t(r, !0, KT(r))
		}, e
	};

function KT(n) {
	if (n instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && n instanceof MathMLElement) return "mathml"
}

function ZT(n) {
	return ln(n) ? document.querySelector(n) : n
}
const lL = /#/g,
	cL = /&/g,
	uL = /\//g,
	hL = /=/g,
	m1 = /\+/g,
	dL = /%5e/gi,
	fL = /%60/gi,
	pL = /%7c/gi,
	mL = /%20/gi;

function gL(n) {
	return encodeURI("" + n).replace(pL, "|")
}

function b_(n) {
	return gL(typeof n == "string" ? n : JSON.stringify(n)).replace(m1, "%2B").replace(mL, "+").replace(lL, "%23").replace(cL, "%26").replace(fL, "`").replace(dL, "^").replace(uL, "%2F")
}

function E0(n) {
	return b_(n).replace(hL, "%3D")
}

function Dp(n = "") {
	try {
		return decodeURIComponent("" + n)
	} catch {
		return "" + n
	}
}

function _L(n) {
	return Dp(n.replace(m1, " "))
}

function vL(n) {
	return Dp(n.replace(m1, " "))
}

function Pp(n = "") {
	const e = {};
	n[0] === "?" && (n = n.slice(1));
	for (const t of n.split("&")) {
		const i = t.match(/([^=]+)=?(.*)/) || [];
		if (i.length < 2) continue;
		const r = _L(i[1]);
		if (r === "__proto__" || r === "constructor") continue;
		const s = vL(i[2] || "");
		e[r] === void 0 ? e[r] = s : Array.isArray(e[r]) ? e[r].push(s) : e[r] = [e[r], s]
	}
	return e
}

function bL(n, e) {
	return (typeof e == "number" || typeof e == "boolean") && (e = String(e)), e ? Array.isArray(e) ? e.map(t => `${E0(n)}=${b_(t)}`).join("&") : `${E0(n)}=${b_(e)}` : E0(n)
}

function JT(n) {
	return Object.keys(n).filter(e => n[e] !== void 0).map(e => bL(e, n[e])).filter(Boolean).join("&")
}
const yL = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
	xL = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
	wL = /^([/\\]\s*){2,}[^/\\]/,
	EL = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
	SL = /\/$|\/\?|\/#/,
	TL = /^\.?\//;

function ao(n, e = {}) {
	return typeof e == "boolean" && (e = {
		acceptRelative: e
	}), e.strict ? yL.test(n) : xL.test(n) || (e.acceptRelative ? wL.test(n) : !1)
}

function ML(n) {
	return !!n && EL.test(n)
}

function y_(n = "", e) {
	return e ? SL.test(n) : n.endsWith("/")
}

function Pm(n = "", e) {
	if (!e) return (y_(n) ? n.slice(0, -1) : n) || "/";
	if (!y_(n, !0)) return n || "/";
	let t = n,
		i = "";
	const r = n.indexOf("#");
	r >= 0 && (t = n.slice(0, r), i = n.slice(r));
	const [s, ...o] = t.split("?");
	return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (o.length > 0 ? `?${o.join("?")}` : "") + i
}

function Rp(n = "", e) {
	if (!e) return n.endsWith("/") ? n : n + "/";
	if (y_(n, !0)) return n || "/";
	let t = n,
		i = "";
	const r = n.indexOf("#");
	if (r >= 0 && (t = n.slice(0, r), i = n.slice(r), !t)) return i;
	const [s, ...o] = t.split("?");
	return s + "/" + (o.length > 0 ? `?${o.join("?")}` : "") + i
}

function CL(n = "") {
	return n.startsWith("/")
}

function x_(n = "") {
	return CL(n) ? n : "/" + n
}

function AL(n, e) {
	if (QT(e) || ao(n)) return n;
	const t = Pm(e);
	return n.startsWith(t) ? n : Ta(t, n)
}

function ky(n, e) {
	if (QT(e)) return n;
	const t = Pm(e);
	if (!n.startsWith(t)) return n;
	const i = n.slice(t.length);
	return i[0] === "/" ? i : "/" + i
}

function g1(n, e) {
	const t = bu(n),
		i = {
			...Pp(t.search),
			...e
		};
	return t.search = JT(i), RL(t)
}

function QT(n) {
	return !n || n === "/"
}

function DL(n) {
	return n && n !== "/"
}

function Ta(n, ...e) {
	let t = n || "";
	for (const i of e.filter(r => DL(r)))
		if (t) {
			const r = i.replace(TL, "");
			t = Rp(t) + r
		} else t = i;
	return t
}

function PL(n, e, t = {}) {
	return t.trailingSlash || (n = Rp(n), e = Rp(e)), t.leadingSlash || (n = x_(n), e = x_(e)), t.encoding || (n = Dp(n), e = Dp(e)), n === e
}
const e3 = Symbol.for("ufo:protocolRelative");

function bu(n = "", e) {
	const t = n.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
	if (t) {
		const [, h, d = ""] = t;
		return {
			protocol: h.toLowerCase(),
			pathname: d,
			href: h + d,
			auth: "",
			host: "",
			search: "",
			hash: ""
		}
	}
	if (!ao(n, {
			acceptRelative: !0
		})) return Iy(n);
	const [, i = "", r, s = ""] = n.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, o = "", a = ""] = s.match(/([^#/?]*)(.*)?/) || [], {
		pathname: l,
		search: c,
		hash: u
	} = Iy(a.replace(/\/(?=[A-Za-z]:)/, ""));
	return {
		protocol: i.toLowerCase(),
		auth: r ? r.slice(0, Math.max(0, r.length - 1)) : "",
		host: o,
		pathname: l,
		search: c,
		hash: u,
		[e3]: !i
	}
}

function Iy(n = "") {
	const [e = "", t = "", i = ""] = (n.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
	return {
		pathname: e,
		search: t,
		hash: i
	}
}

function RL(n) {
	const e = n.pathname || "",
		t = n.search ? (n.search.startsWith("?") ? "" : "?") + n.search : "",
		i = n.hash || "",
		r = n.auth ? n.auth + "@" : "",
		s = n.host || "";
	return (n.protocol || n[e3] ? (n.protocol || "") + "//" : "") + r + s + e + t + i
}
const LL = () => {
		var n;
		return ((n = window == null ? void 0 : window.__NUXT__) == null ? void 0 : n.config) || {}
	},
	Lp = LL().app,
	kL = () => Lp.baseURL,
	IL = () => Lp.buildAssetsDir,
	_1 = (...n) => Ta(t3(), IL(), ...n),
	t3 = (...n) => {
		const e = Lp.cdnURL || Lp.baseURL;
		return n.length ? Ta(e, ...n) : e
	};
globalThis.__buildAssetsURL = _1, globalThis.__publicAssetsURL = t3;
const OL = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
	FL = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
	NL = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function UL(n, e) {
	if (n === "__proto__" || n === "constructor" && e && typeof e == "object" && "prototype" in e) {
		BL(n);
		return
	}
	return e
}

function BL(n) {
	console.warn(`[destr] Dropping "${n}" key to prevent prototype pollution.`)
}

function Hh(n, e = {}) {
	if (typeof n != "string") return n;
	const t = n.trim();
	if (n[0] === '"' && n.endsWith('"') && !n.includes("\\")) return t.slice(1, -1);
	if (t.length <= 9) {
		const i = t.toLowerCase();
		if (i === "true") return !0;
		if (i === "false") return !1;
		if (i === "undefined") return;
		if (i === "null") return null;
		if (i === "nan") return Number.NaN;
		if (i === "infinity") return Number.POSITIVE_INFINITY;
		if (i === "-infinity") return Number.NEGATIVE_INFINITY
	}
	if (!NL.test(n)) {
		if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
		return n
	}
	try {
		if (OL.test(n) || FL.test(n)) {
			if (e.strict) throw new Error("[destr] Possible prototype pollution");
			return JSON.parse(n, UL)
		}
		return JSON.parse(n)
	} catch (i) {
		if (e.strict) throw i;
		return n
	}
}
class zL extends Error {
	constructor(e, t) {
		super(e, t), this.name = "FetchError", t != null && t.cause && !this.cause && (this.cause = t.cause)
	}
}

function VL(n) {
	var l, c, u, h, d;
	const e = ((l = n.error) == null ? void 0 : l.message) || ((c = n.error) == null ? void 0 : c.toString()) || "",
		t = ((u = n.request) == null ? void 0 : u.method) || ((h = n.options) == null ? void 0 : h.method) || "GET",
		i = ((d = n.request) == null ? void 0 : d.url) || String(n.request) || "/",
		r = `[${t}] ${JSON.stringify(i)}`,
		s = n.response ? `${n.response.status} ${n.response.statusText}` : "<no response>",
		o = `${r}: ${s}${e?` ${e}`:""}`,
		a = new zL(o, n.error ? {
			cause: n.error
		} : void 0);
	for (const f of ["request", "options", "response"]) Object.defineProperty(a, f, {
		get() {
			return n[f]
		}
	});
	for (const [f, p] of [
			["data", "_data"],
			["status", "status"],
			["statusCode", "status"],
			["statusText", "statusText"],
			["statusMessage", "statusText"]
		]) Object.defineProperty(a, f, {
		get() {
			return n.response && n.response[p]
		}
	});
	return a
}
const HL = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function Oy(n = "GET") {
	return HL.has(n.toUpperCase())
}

function GL(n) {
	if (n === void 0) return !1;
	const e = typeof n;
	return e === "string" || e === "number" || e === "boolean" || e === null ? !0 : e !== "object" ? !1 : Array.isArray(n) ? !0 : n.buffer ? !1 : n.constructor && n.constructor.name === "Object" || typeof n.toJSON == "function"
}
const WL = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
	jL = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function $L(n = "") {
	if (!n) return "json";
	const e = n.split(";").shift() || "";
	return jL.test(e) ? "json" : WL.has(e) || e.startsWith("text/") ? "text" : "blob"
}

function qL(n, e, t = globalThis.Headers) {
	const i = {
		...e,
		...n
	};
	if (e != null && e.params && (n != null && n.params) && (i.params = {
			...e == null ? void 0 : e.params,
			...n == null ? void 0 : n.params
		}), e != null && e.query && (n != null && n.query) && (i.query = {
			...e == null ? void 0 : e.query,
			...n == null ? void 0 : n.query
		}), e != null && e.headers && (n != null && n.headers)) {
		i.headers = new t((e == null ? void 0 : e.headers) || {});
		for (const [r, s] of new t((n == null ? void 0 : n.headers) || {})) i.headers.set(r, s)
	}
	return i
}
const XL = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
	YL = new Set([101, 204, 205, 304]);

function n3(n = {}) {
	const {
		fetch: e = globalThis.fetch,
		Headers: t = globalThis.Headers,
		AbortController: i = globalThis.AbortController
	} = n;
	async function r(a) {
		const l = a.error && a.error.name === "AbortError" && !a.options.timeout || !1;
		if (a.options.retry !== !1 && !l) {
			let u;
			typeof a.options.retry == "number" ? u = a.options.retry : u = Oy(a.options.method) ? 0 : 1;
			const h = a.response && a.response.status || 500;
			if (u > 0 && (Array.isArray(a.options.retryStatusCodes) ? a.options.retryStatusCodes.includes(h) : XL.has(h))) {
				const d = a.options.retryDelay || 0;
				return d > 0 && await new Promise(f => setTimeout(f, d)), s(a.request, {
					...a.options,
					retry: u - 1
				})
			}
		}
		const c = VL(a);
		throw Error.captureStackTrace && Error.captureStackTrace(c, s), c
	}
	const s = async function (l, c = {}) {
		var f;
		const u = {
			request: l,
			options: qL(c, n.defaults, t),
			response: void 0,
			error: void 0
		};
		u.options.method = (f = u.options.method) == null ? void 0 : f.toUpperCase(), u.options.onRequest && await u.options.onRequest(u), typeof u.request == "string" && (u.options.baseURL && (u.request = AL(u.request, u.options.baseURL)), (u.options.query || u.options.params) && (u.request = g1(u.request, {
			...u.options.params,
			...u.options.query
		}))), u.options.body && Oy(u.options.method) && (GL(u.options.body) ? (u.options.body = typeof u.options.body == "string" ? u.options.body : JSON.stringify(u.options.body), u.options.headers = new t(u.options.headers || {}), u.options.headers.has("content-type") || u.options.headers.set("content-type", "application/json"), u.options.headers.has("accept") || u.options.headers.set("accept", "application/json")) : ("pipeTo" in u.options.body && typeof u.options.body.pipeTo == "function" || typeof u.options.body.pipe == "function") && ("duplex" in u.options || (u.options.duplex = "half")));
		let h;
		if (!u.options.signal && u.options.timeout) {
			const p = new i;
			h = setTimeout(() => p.abort(), u.options.timeout), u.options.signal = p.signal
		}
		try {
			u.response = await e(u.request, u.options)
		} catch (p) {
			return u.error = p, u.options.onRequestError && await u.options.onRequestError(u), await r(u)
		} finally {
			h && clearTimeout(h)
		}
		if (u.response.body && !YL.has(u.response.status) && u.options.method !== "HEAD") {
			const p = (u.options.parseResponse ? "json" : u.options.responseType) || $L(u.response.headers.get("content-type") || "");
			switch (p) {
				case "json": {
					const _ = await u.response.text(),
						g = u.options.parseResponse || Hh;
					u.response._data = g(_);
					break
				}
				case "stream": {
					u.response._data = u.response.body;
					break
				}
				default:
					u.response._data = await u.response[p]()
			}
		}
		return u.options.onResponse && await u.options.onResponse(u), !u.options.ignoreResponseError && u.response.status >= 400 && u.response.status < 600 ? (u.options.onResponseError && await u.options.onResponseError(u), await r(u)) : u.response
	}, o = async function (l, c) {
		return (await s(l, c))._data
	};
	return o.raw = s, o.native = (...a) => e(...a), o.create = (a = {}) => n3({
		...n,
		defaults: {
			...n.defaults,
			...a
		}
	}), o
}
const v1 = function () {
		if (typeof globalThis < "u") return globalThis;
		if (typeof self < "u") return self;
		if (typeof window < "u") return window;
		if (typeof global < "u") return global;
		throw new Error("unable to locate global object")
	}(),
	KL = v1.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))),
	ZL = v1.Headers,
	JL = v1.AbortController,
	QL = n3({
		fetch: KL,
		Headers: ZL,
		AbortController: JL
	}),
	e5 = QL;
globalThis.$fetch || (globalThis.$fetch = e5.create({
	baseURL: kL()
}));

function w_(n, e = {}, t) {
	for (const i in n) {
		const r = n[i],
			s = t ? `${t}:${i}` : i;
		typeof r == "object" && r !== null ? w_(r, e, s) : typeof r == "function" && (e[s] = r)
	}
	return e
}
const t5 = {
		run: n => n()
	},
	n5 = () => t5,
	i3 = typeof console.createTask < "u" ? console.createTask : n5;

function i5(n, e) {
	const t = e.shift(),
		i = i3(t);
	return n.reduce((r, s) => r.then(() => i.run(() => s(...e))), Promise.resolve())
}

function r5(n, e) {
	const t = e.shift(),
		i = i3(t);
	return Promise.all(n.map(r => i.run(() => r(...e))))
}

function S0(n, e) {
	for (const t of [...n]) t(e)
}
class s5 {
	constructor() {
		this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this)
	}
	hook(e, t, i = {}) {
		if (!e || typeof t != "function") return () => {};
		const r = e;
		let s;
		for (; this._deprecatedHooks[e];) s = this._deprecatedHooks[e], e = s.to;
		if (s && !i.allowDeprecated) {
			let o = s.message;
			o || (o = `${r} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(o) || (console.warn(o), this._deprecatedMessages.add(o))
		}
		if (!t.name) try {
			Object.defineProperty(t, "name", {
				get: () => "_" + e.replace(/\W+/g, "_") + "_hook_cb",
				configurable: !0
			})
		} catch {}
		return this._hooks[e] = this._hooks[e] || [], this._hooks[e].push(t), () => {
			t && (this.removeHook(e, t), t = void 0)
		}
	}
	hookOnce(e, t) {
		let i, r = (...s) => (typeof i == "function" && i(), i = void 0, r = void 0, t(...s));
		return i = this.hook(e, r), i
	}
	removeHook(e, t) {
		if (this._hooks[e]) {
			const i = this._hooks[e].indexOf(t);
			i !== -1 && this._hooks[e].splice(i, 1), this._hooks[e].length === 0 && delete this._hooks[e]
		}
	}
	deprecateHook(e, t) {
		this._deprecatedHooks[e] = typeof t == "string" ? {
			to: t
		} : t;
		const i = this._hooks[e] || [];
		delete this._hooks[e];
		for (const r of i) this.hook(e, r)
	}
	deprecateHooks(e) {
		Object.assign(this._deprecatedHooks, e);
		for (const t in e) this.deprecateHook(t, e[t])
	}
	addHooks(e) {
		const t = w_(e),
			i = Object.keys(t).map(r => this.hook(r, t[r]));
		return () => {
			for (const r of i.splice(0, i.length)) r()
		}
	}
	removeHooks(e) {
		const t = w_(e);
		for (const i in t) this.removeHook(i, t[i])
	}
	removeAllHooks() {
		for (const e in this._hooks) delete this._hooks[e]
	}
	callHook(e, ...t) {
		return t.unshift(e), this.callHookWith(i5, e, ...t)
	}
	callHookParallel(e, ...t) {
		return t.unshift(e), this.callHookWith(r5, e, ...t)
	}
	callHookWith(e, t, ...i) {
		const r = this._before || this._after ? {
			name: t,
			args: i,
			context: {}
		} : void 0;
		this._before && S0(this._before, r);
		const s = e(t in this._hooks ? [...this._hooks[t]] : [], i);
		return s instanceof Promise ? s.finally(() => {
			this._after && r && S0(this._after, r)
		}) : (this._after && r && S0(this._after, r), s)
	}
	beforeEach(e) {
		return this._before = this._before || [], this._before.push(e), () => {
			if (this._before !== void 0) {
				const t = this._before.indexOf(e);
				t !== -1 && this._before.splice(t, 1)
			}
		}
	}
	afterEach(e) {
		return this._after = this._after || [], this._after.push(e), () => {
			if (this._after !== void 0) {
				const t = this._after.indexOf(e);
				t !== -1 && this._after.splice(t, 1)
			}
		}
	}
}

function r3() {
	return new s5
}

function o5(n = {}) {
	let e, t = !1;
	const i = o => {
		if (e && e !== o) throw new Error("Context conflict")
	};
	let r;
	if (n.asyncContext) {
		const o = n.AsyncLocalStorage || globalThis.AsyncLocalStorage;
		o ? r = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
	}
	const s = () => {
		if (r && e === void 0) {
			const o = r.getStore();
			if (o !== void 0) return o
		}
		return e
	};
	return {
		use: () => {
			const o = s();
			if (o === void 0) throw new Error("Context is not available");
			return o
		},
		tryUse: () => s(),
		set: (o, a) => {
			a || i(o), e = o, t = !0
		},
		unset: () => {
			e = void 0, t = !1
		},
		call: (o, a) => {
			i(o), e = o;
			try {
				return r ? r.run(o, a) : a()
			} finally {
				t || (e = void 0)
			}
		},
		async callAsync(o, a) {
			e = o;
			const l = () => {
					e = o
				},
				c = () => e === o ? l : void 0;
			E_.add(c);
			try {
				const u = r ? r.run(o, a) : a();
				return t || (e = void 0), await u
			} finally {
				E_.delete(c)
			}
		}
	}
}

function a5(n = {}) {
	const e = {};
	return {
		get(t, i = {}) {
			return e[t] || (e[t] = o5({
				...n,
				...i
			})), e[t], e[t]
		}
	}
}
const kp = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {},
	Fy = "__unctx__",
	l5 = kp[Fy] || (kp[Fy] = a5()),
	c5 = (n, e = {}) => l5.get(n, e),
	Ny = "__unctx_async_handlers__",
	E_ = kp[Ny] || (kp[Ny] = new Set);

function Xc(n) {
	const e = [];
	for (const r of E_) {
		const s = r();
		s && e.push(s)
	}
	const t = () => {
		for (const r of e) r()
	};
	let i = n();
	return i && typeof i == "object" && "catch" in i && (i = i.catch(r => {
		throw t(), r
	})), [i, t]
}
const s3 = c5("nuxt-app", {
		asyncContext: !1
	}),
	u5 = "__nuxt_plugin";

function h5(n) {
	let e = 0;
	const t = {
		_scope: $v(),
		provide: void 0,
		globalName: "nuxt",
		versions: {
			get nuxt() {
				return "3.10.2"
			},
			get vue() {
				return t.vueApp.version
			}
		},
		payload: Ii({
			data: {},
			state: {},
			once: new Set,
			_errors: {},
			...window.__NUXT__ ?? {}
		}),
		static: {
			data: {}
		},
		runWithContext: r => t._scope.run(() => p5(t, r)),
		isHydrating: !0,
		deferHydration() {
			if (!t.isHydrating) return () => {};
			e++;
			let r = !1;
			return () => {
				if (!r && (r = !0, e--, e === 0)) return t.isHydrating = !1, t.callHook("app:suspense:resolve")
			}
		},
		_asyncDataPromises: {},
		_asyncData: {},
		_payloadRevivers: {},
		...n
	};
	t.hooks = r3(), t.hook = t.hooks.hook, t.callHook = t.hooks.callHook, t.provide = (r, s) => {
		const o = "$" + r;
		Jd(t, o, s), Jd(t.vueApp.config.globalProperties, o, s)
	}, Jd(t.vueApp, "$nuxt", t), Jd(t.vueApp.config.globalProperties, "$nuxt", t); {
		window.addEventListener("nuxt.preloadError", s => {
			t.callHook("app:chunkError", {
				error: s.payload
			})
		}), window.useNuxtApp = window.useNuxtApp || Ke;
		const r = t.hook("app:error", (...s) => {
			console.error("[nuxt] error caught during app initialization", ...s)
		});
		t.hook("app:mounted", r)
	}
	const i = Ii(t.payload.config);
	return t.provide("config", i), t
}
async function d5(n, e) {
	if (e.hooks && n.hooks.addHooks(e.hooks), typeof e == "function") {
		const {
			provide: t
		} = await n.runWithContext(() => e(n)) || {};
		if (t && typeof t == "object")
			for (const i in t) n.provide(i, t[i])
	}
}
async function f5(n, e) {
	const t = [],
		i = [],
		r = [],
		s = [];
	let o = 0;
	async function a(l) {
		var u;
		const c = ((u = l.dependsOn) == null ? void 0 : u.filter(h => e.some(d => d._name === h) && !t.includes(h))) ?? [];
		if (c.length > 0) i.push([new Set(c), l]);
		else {
			const h = d5(n, l).then(async () => {
				l._name && (t.push(l._name), await Promise.all(i.map(async ([d, f]) => {
					d.has(l._name) && (d.delete(l._name), d.size === 0 && (o++, await a(f)))
				})))
			});
			l.parallel ? r.push(h.catch(d => s.push(d))) : await h
		}
	}
	for (const l of e) await a(l);
	if (await Promise.all(r), o)
		for (let l = 0; l < o; l++) await Promise.all(r);
	if (s.length) throw s[0]
}

function un(n) {
	if (typeof n == "function") return n;
	const e = n._name || n.name;
	return delete n.name, Object.assign(n.setup || (() => {}), n, {
		[u5]: !0,
		_name: e
	})
}

function p5(n, e, t) {
	const i = () => e();
	return s3.set(n), n.vueApp.runWithContext(i)
}

function m5() {
	var e;
	let n;
	return u1() && (n = (e = vu()) == null ? void 0 : e.appContext.app.$nuxt), n = n || s3.tryUse(), n || null
}

function Ke() {
	const n = m5();
	if (!n) throw new Error("[nuxt] instance unavailable");
	return n
}

function Ma(n) {
	return Ke().$config
}

function Jd(n, e, t) {
	Object.defineProperty(n, e, {
		get: () => t
	})
}
const Qd = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;

function g5(n, e) {
	if (typeof n != "string") throw new TypeError("argument str must be a string");
	const t = {},
		r = (e || {}).decode || b5;
	let s = 0;
	for (; s < n.length;) {
		const o = n.indexOf("=", s);
		if (o === -1) break;
		let a = n.indexOf(";", s);
		if (a === -1) a = n.length;
		else if (a < o) {
			s = n.lastIndexOf(";", o - 1) + 1;
			continue
		}
		const l = n.slice(s, o).trim();
		if (t[l] === void 0) {
			let c = n.slice(o + 1, a).trim();
			c.codePointAt(0) === 34 && (c = c.slice(1, -1)), t[l] = v5(c, r)
		}
		s = a + 1
	}
	return t
}

function Uy(n, e, t) {
	const i = t || {},
		r = i.encode || y5;
	if (typeof r != "function") throw new TypeError("option encode is invalid");
	if (!Qd.test(n)) throw new TypeError("argument name is invalid");
	const s = r(e);
	if (s && !Qd.test(s)) throw new TypeError("argument val is invalid");
	let o = n + "=" + s;
	if (i.maxAge !== void 0 && i.maxAge !== null) {
		const a = i.maxAge - 0;
		if (Number.isNaN(a) || !Number.isFinite(a)) throw new TypeError("option maxAge is invalid");
		o += "; Max-Age=" + Math.floor(a)
	}
	if (i.domain) {
		if (!Qd.test(i.domain)) throw new TypeError("option domain is invalid");
		o += "; Domain=" + i.domain
	}
	if (i.path) {
		if (!Qd.test(i.path)) throw new TypeError("option path is invalid");
		o += "; Path=" + i.path
	}
	if (i.expires) {
		if (!_5(i.expires) || Number.isNaN(i.expires.valueOf())) throw new TypeError("option expires is invalid");
		o += "; Expires=" + i.expires.toUTCString()
	}
	if (i.httpOnly && (o += "; HttpOnly"), i.secure && (o += "; Secure"), i.priority) switch (typeof i.priority == "string" ? i.priority.toLowerCase() : i.priority) {
		case "low": {
			o += "; Priority=Low";
			break
		}
		case "medium": {
			o += "; Priority=Medium";
			break
		}
		case "high": {
			o += "; Priority=High";
			break
		}
		default:
			throw new TypeError("option priority is invalid")
	}
	if (i.sameSite) switch (typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite) {
		case !0: {
			o += "; SameSite=Strict";
			break
		}
		case "lax": {
			o += "; SameSite=Lax";
			break
		}
		case "strict": {
			o += "; SameSite=Strict";
			break
		}
		case "none": {
			o += "; SameSite=None";
			break
		}
		default:
			throw new TypeError("option sameSite is invalid")
	}
	return i.partitioned && (o += "; Partitioned"), o
}

function _5(n) {
	return Object.prototype.toString.call(n) === "[object Date]" || n instanceof Date
}

function v5(n, e) {
	try {
		return e(n)
	} catch {
		return n
	}
}

function b5(n) {
	return n.includes("%") ? decodeURIComponent(n) : n
}

function y5(n) {
	return encodeURIComponent(n)
}
const By = Object.freeze({
	ignoreUnknown: !1,
	respectType: !1,
	respectFunctionNames: !1,
	respectFunctionProperties: !1,
	unorderedObjects: !0,
	unorderedArrays: !1,
	unorderedSets: !1,
	excludeKeys: void 0,
	excludeValues: void 0,
	replacer: void 0
});

function zy(n, e) {
	e ? e = {
		...By,
		...e
	} : e = By;
	const t = o3(e);
	return t.dispatch(n), t.toString()
}
const x5 = Object.freeze(["prototype", "__proto__", "constructor"]);

function o3(n) {
	let e = "",
		t = new Map;
	const i = r => {
		e += r
	};
	return {
		toString() {
			return e
		},
		getContext() {
			return t
		},
		dispatch(r) {
			return n.replacer && (r = n.replacer(r)), this[r === null ? "null" : typeof r](r)
		},
		object(r) {
			if (r && typeof r.toJSON == "function") return this.object(r.toJSON());
			const s = Object.prototype.toString.call(r);
			let o = "";
			const a = s.length;
			a < 10 ? o = "unknown:[" + s + "]" : o = s.slice(8, a - 1), o = o.toLowerCase();
			let l = null;
			if ((l = t.get(r)) === void 0) t.set(r, t.size);
			else return this.dispatch("[CIRCULAR:" + l + "]");
			if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(r)) return i("buffer:"), i(r.toString("utf8"));
			if (o !== "object" && o !== "function" && o !== "asyncfunction") this[o] ? this[o](r) : n.ignoreUnknown || this.unkown(r, o);
			else {
				let c = Object.keys(r);
				n.unorderedObjects && (c = c.sort());
				let u = [];
				n.respectType !== !1 && !Vy(r) && (u = x5), n.excludeKeys && (c = c.filter(d => !n.excludeKeys(d)), u = u.filter(d => !n.excludeKeys(d))), i("object:" + (c.length + u.length) + ":");
				const h = d => {
					this.dispatch(d), i(":"), n.excludeValues || this.dispatch(r[d]), i(",")
				};
				for (const d of c) h(d);
				for (const d of u) h(d)
			}
		},
		array(r, s) {
			if (s = s === void 0 ? n.unorderedArrays !== !1 : s, i("array:" + r.length + ":"), !s || r.length <= 1) {
				for (const l of r) this.dispatch(l);
				return
			}
			const o = new Map,
				a = r.map(l => {
					const c = o3(n);
					c.dispatch(l);
					for (const [u, h] of c.getContext()) o.set(u, h);
					return c.toString()
				});
			return t = o, a.sort(), this.array(a, !1)
		},
		date(r) {
			return i("date:" + r.toJSON())
		},
		symbol(r) {
			return i("symbol:" + r.toString())
		},
		unkown(r, s) {
			if (i(s), !!r && (i(":"), r && typeof r.entries == "function")) return this.array(Array.from(r.entries()), !0)
		},
		error(r) {
			return i("error:" + r.toString())
		},
		boolean(r) {
			return i("bool:" + r)
		},
		string(r) {
			i("string:" + r.length + ":"), i(r)
		},
		function (r) {
			i("fn:"), Vy(r) ? this.dispatch("[native]") : this.dispatch(r.toString()), n.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(r.name)), n.respectFunctionProperties && this.object(r)
		},
		number(r) {
			return i("number:" + r)
		},
		xml(r) {
			return i("xml:" + r.toString())
		},
		null() {
			return i("Null")
		},
		undefined() {
			return i("Undefined")
		},
		regexp(r) {
			return i("regex:" + r.toString())
		},
		uint8array(r) {
			return i("uint8array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		uint8clampedarray(r) {
			return i("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(r))
		},
		int8array(r) {
			return i("int8array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		uint16array(r) {
			return i("uint16array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		int16array(r) {
			return i("int16array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		uint32array(r) {
			return i("uint32array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		int32array(r) {
			return i("int32array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		float32array(r) {
			return i("float32array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		float64array(r) {
			return i("float64array:"), this.dispatch(Array.prototype.slice.call(r))
		},
		arraybuffer(r) {
			return i("arraybuffer:"), this.dispatch(new Uint8Array(r))
		},
		url(r) {
			return i("url:" + r.toString())
		},
		map(r) {
			i("map:");
			const s = [...r];
			return this.array(s, n.unorderedSets !== !1)
		},
		set(r) {
			i("set:");
			const s = [...r];
			return this.array(s, n.unorderedSets !== !1)
		},
		file(r) {
			return i("file:"), this.dispatch([r.name, r.size, r.type, r.lastModfied])
		},
		blob() {
			if (n.ignoreUnknown) return i("[blob]");
			throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
		},
		domwindow() {
			return i("domwindow")
		},
		bigint(r) {
			return i("bigint:" + r.toString())
		},
		process() {
			return i("process")
		},
		timer() {
			return i("timer")
		},
		pipe() {
			return i("pipe")
		},
		tcp() {
			return i("tcp")
		},
		udp() {
			return i("udp")
		},
		tty() {
			return i("tty")
		},
		statwatcher() {
			return i("statwatcher")
		},
		securecontext() {
			return i("securecontext")
		},
		connection() {
			return i("connection")
		},
		zlib() {
			return i("zlib")
		},
		context() {
			return i("context")
		},
		nodescript() {
			return i("nodescript")
		},
		httpparser() {
			return i("httpparser")
		},
		dataview() {
			return i("dataview")
		},
		signal() {
			return i("signal")
		},
		fsevent() {
			return i("fsevent")
		},
		tlswrap() {
			return i("tlswrap")
		}
	}
}
const a3 = "[native code] }",
	w5 = a3.length;

function Vy(n) {
	return typeof n != "function" ? !1 : Function.prototype.toString.call(n).slice(-w5) === a3
}

function E5(n, e, t = {}) {
	return n === e || zy(n, t) === zy(e, t)
}

function S5(n, e) {
	return {
		ctx: {
			table: n
		},
		matchAll: t => c3(t, n)
	}
}

function l3(n) {
	const e = {};
	for (const t in n) e[t] = t === "dynamic" ? new Map(Object.entries(n[t]).map(([i, r]) => [i, l3(r)])) : new Map(Object.entries(n[t]));
	return e
}

function T5(n) {
	return S5(l3(n))
}

function c3(n, e, t) {
	n.endsWith("/") && (n = n.slice(0, -1) || "/");
	const i = [];
	for (const [s, o] of Hy(e.wildcard))(n === s || n.startsWith(s + "/")) && i.push(o);
	for (const [s, o] of Hy(e.dynamic))
		if (n.startsWith(s + "/")) {
			const a = "/" + n.slice(s.length).split("/").splice(2).join("/");
			i.push(...c3(a, o))
		} const r = e.static.get(n);
	return r && i.push(r), i.filter(Boolean)
}

function Hy(n) {
	return [...n.entries()].sort((e, t) => e[0].length - t[0].length)
}

function T0(n) {
	if (n === null || typeof n != "object") return !1;
	const e = Object.getPrototypeOf(n);
	return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in n ? !1 : Symbol.toStringTag in n ? Object.prototype.toString.call(n) === "[object Module]" : !0
}

function S_(n, e, t = ".", i) {
	if (!T0(e)) return S_(n, {}, t, i);
	const r = Object.assign({}, e);
	for (const s in n) {
		if (s === "__proto__" || s === "constructor") continue;
		const o = n[s];
		o != null && (i && i(r, s, o, t) || (Array.isArray(o) && Array.isArray(r[s]) ? r[s] = [...o, ...r[s]] : T0(o) && T0(r[s]) ? r[s] = S_(o, r[s], (t ? `${t}.` : "") + s.toString(), i) : r[s] = o))
	}
	return r
}

function u3(n) {
	return (...e) => e.reduce((t, i) => S_(t, i, "", n), {})
}
const Rm = u3(),
	M5 = u3((n, e, t) => {
		if (n[e] !== void 0 && typeof t == "function") return n[e] = t(n[e]), !0
	});

function C5(n, e) {
	try {
		return e in n
	} catch {
		return !1
	}
}
var A5 = Object.defineProperty,
	D5 = (n, e, t) => e in n ? A5(n, e, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: t
	}) : n[e] = t,
	ja = (n, e, t) => (D5(n, typeof e != "symbol" ? e + "" : e, t), t);
class T_ extends Error {
	constructor(e, t = {}) {
		super(e, t), ja(this, "statusCode", 500), ja(this, "fatal", !1), ja(this, "unhandled", !1), ja(this, "statusMessage"), ja(this, "data"), ja(this, "cause"), t.cause && !this.cause && (this.cause = t.cause)
	}
	toJSON() {
		const e = {
			message: this.message,
			statusCode: C_(this.statusCode, 500)
		};
		return this.statusMessage && (e.statusMessage = h3(this.statusMessage)), this.data !== void 0 && (e.data = this.data), e
	}
}
ja(T_, "__h3_error__", !0);

function M_(n) {
	if (typeof n == "string") return new T_(n);
	if (P5(n)) return n;
	const e = new T_(n.message ?? n.statusMessage ?? "", {
		cause: n.cause || n
	});
	if (C5(n, "stack")) try {
		Object.defineProperty(e, "stack", {
			get() {
				return n.stack
			}
		})
	} catch {
		try {
			e.stack = n.stack
		} catch {}
	}
	if (n.data && (e.data = n.data), n.statusCode ? e.statusCode = C_(n.statusCode, e.statusCode) : n.status && (e.statusCode = C_(n.status, e.statusCode)), n.statusMessage ? e.statusMessage = n.statusMessage : n.statusText && (e.statusMessage = n.statusText), e.statusMessage) {
		const t = e.statusMessage;
		h3(e.statusMessage) !== t && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
	}
	return n.fatal !== void 0 && (e.fatal = n.fatal), n.unhandled !== void 0 && (e.unhandled = n.unhandled), e
}

function P5(n) {
	var e;
	return ((e = n == null ? void 0 : n.constructor) == null ? void 0 : e.__h3_error__) === !0
}
const R5 = /[^\u0009\u0020-\u007E]/g;

function h3(n = "") {
	return n.replace(R5, "")
}

function C_(n, e = 200) {
	return !n || (typeof n == "string" && (n = Number.parseInt(n, 10)), n < 100 || n > 999) ? e : n
}
const L5 = Symbol("layout-meta"),
	Lm = Symbol("route"),
	Sr = () => {
		var n;
		return (n = Ke()) == null ? void 0 : n.$router
	},
	Ca = () => u1() ? si(Lm, Ke()._route) : Ke()._route;

function hte(n) {
	return n
}
const k5 = () => {
		try {
			if (Ke()._processingMiddleware) return !0
		} catch {
			return !0
		}
		return !1
	},
	I5 = (n, e) => {
		n || (n = "/");
		const t = typeof n == "string" ? n : g1(n.path || "/", n.query || {}) + (n.hash || "");
		if (e != null && e.open) {
			{
				const {
					target: a = "_blank",
					windowFeatures: l = {}
				} = e.open, c = Object.entries(l).filter(([u, h]) => h !== void 0).map(([u, h]) => `${u.toLowerCase()}=${h}`).join(", ");
				open(t, a, c)
			}
			return Promise.resolve()
		}
		const i = (e == null ? void 0 : e.external) || ao(t, {
			acceptRelative: !0
		});
		if (i) {
			if (!(e != null && e.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
			const a = bu(t).protocol;
			if (a && ML(a)) throw new Error(`Cannot navigate to a URL with '${a}' protocol.`)
		}
		const r = k5();
		if (!i && r) return n;
		const s = Sr(),
			o = Ke();
		return i ? (o._scope.stop(), e != null && e.replace ? location.replace(t) : location.href = t, r ? o.isHydrating ? new Promise(() => {}) : !1 : Promise.resolve()) : e != null && e.replace ? s.replace(n) : s.push(n)
	},
	d3 = "__nuxt_error",
	km = () => Sm(Ke().payload, "error"),
	vc = n => {
		const e = bd(n);
		try {
			const t = Ke(),
				i = km();
			t.hooks.callHook("app:error", e), i.value = i.value || e
		} catch {
			throw e
		}
		return e
	},
	O5 = async (n = {}) => {
		const e = Ke(),
			t = km();
		e.callHook("app:error:cleared", n), n.redirect && await Sr().replace(n.redirect), t.value = null
	}, F5 = n => !!n && typeof n == "object" && d3 in n, bd = n => {
		const e = M_(n);
		return Object.defineProperty(e, d3, {
			value: !0,
			configurable: !1,
			writable: !1
		}), e
	}, N5 = "modulepreload", U5 = function (n, e) {
		return n[0] === "." ? new URL(n, e).href : n
	}, Gy = {}, B5 = function (e, t, i) {
		let r = Promise.resolve();
		if (t && t.length > 0) {
			const s = document.getElementsByTagName("link");
			r = Promise.all(t.map(o => {
				if (o = U5(o, i), o in Gy) return;
				Gy[o] = !0;
				const a = o.endsWith(".css"),
					l = a ? '[rel="stylesheet"]' : "";
				if (!!i)
					for (let h = s.length - 1; h >= 0; h--) {
						const d = s[h];
						if (d.href === o && (!a || d.rel === "stylesheet")) return
					} else if (document.querySelector(`link[href="${o}"]${l}`)) return;
				const u = document.createElement("link");
				if (u.rel = a ? "stylesheet" : N5, a || (u.as = "script", u.crossOrigin = ""), u.href = o, document.head.appendChild(u), a) return new Promise((h, d) => {
					u.addEventListener("load", h), u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${o}`)))
				})
			}))
		}
		return r.then(() => e()).catch(s => {
			const o = new Event("vite:preloadError", {
				cancelable: !0
			});
			if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s
		})
	}, ft = (...n) => B5(...n).catch(e => {
		const t = new Event("nuxt.preloadError");
		throw t.payload = e, window.dispatchEvent(t), e
	}), z5 = -1, V5 = -2, H5 = -3, G5 = -4, W5 = -5, j5 = -6;

function $5(n, e) {
	return q5(JSON.parse(n), e)
}

function q5(n, e) {
	if (typeof n == "number") return r(n, !0);
	if (!Array.isArray(n) || n.length === 0) throw new Error("Invalid input");
	const t = n,
		i = Array(t.length);

	function r(s, o = !1) {
		if (s === z5) return;
		if (s === H5) return NaN;
		if (s === G5) return 1 / 0;
		if (s === W5) return -1 / 0;
		if (s === j5) return -0;
		if (o) throw new Error("Invalid input");
		if (s in i) return i[s];
		const a = t[s];
		if (!a || typeof a != "object") i[s] = a;
		else if (Array.isArray(a))
			if (typeof a[0] == "string") {
				const l = a[0],
					c = e == null ? void 0 : e[l];
				if (c) return i[s] = c(r(a[1]));
				switch (l) {
					case "Date":
						i[s] = new Date(a[1]);
						break;
					case "Set":
						const u = new Set;
						i[s] = u;
						for (let f = 1; f < a.length; f += 1) u.add(r(a[f]));
						break;
					case "Map":
						const h = new Map;
						i[s] = h;
						for (let f = 1; f < a.length; f += 2) h.set(r(a[f]), r(a[f + 1]));
						break;
					case "RegExp":
						i[s] = new RegExp(a[1], a[2]);
						break;
					case "Object":
						i[s] = Object(a[1]);
						break;
					case "BigInt":
						i[s] = BigInt(a[1]);
						break;
					case "null":
						const d = Object.create(null);
						i[s] = d;
						for (let f = 1; f < a.length; f += 2) d[a[f]] = r(a[f + 1]);
						break;
					default:
						throw new Error(`Unknown type ${l}`)
				}
			} else {
				const l = new Array(a.length);
				i[s] = l;
				for (let c = 0; c < a.length; c += 1) {
					const u = a[c];
					u !== V5 && (l[c] = r(u))
				}
			}
		else {
			const l = {};
			i[s] = l;
			for (const c in a) {
				const u = a[c];
				l[c] = r(u)
			}
		}
		return i[s]
	}
	return r(0)
}

function X5(n) {
	return Array.isArray(n) ? n : [n]
}
const Y5 = ["title", "titleTemplate", "script", "style", "noscript"],
	rp = ["base", "meta", "link", "style", "script", "noscript"],
	K5 = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"],
	Z5 = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"],
	f3 = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"],
	J5 = typeof window < "u";

function b1(n) {
	let e = 9;
	for (let t = 0; t < n.length;) e = Math.imul(e ^ n.charCodeAt(t++), 9 ** 9);
	return ((e ^ e >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}

function Wy(n) {
	return n._h || b1(n._d ? n._d : `${n.tag}:${n.textContent||n.innerHTML||""}:${Object.entries(n.props).map(([e,t])=>`${e}:${String(t)}`).join(",")}`)
}

function p3(n, e) {
	const {
		props: t,
		tag: i
	} = n;
	if (Z5.includes(i)) return i;
	if (i === "link" && t.rel === "canonical") return "canonical";
	if (t.charset) return "charset";
	const r = ["id"];
	i === "meta" && r.push("name", "property", "http-equiv");
	for (const s of r)
		if (typeof t[s] < "u") {
			const o = String(t[s]);
			return `${i}:${s}:${o}`
		} return !1
}

function jy(n, e) {
	return n == null ? e || null : typeof n == "function" ? n(e) : n
}
async function Q5(n, e, t) {
	const i = {
		tag: n,
		props: await m3(typeof e == "object" && typeof e != "function" && !(e instanceof Promise) ? {
			...e
		} : {
			[
				["script", "noscript", "style"].includes(n) ? "innerHTML" : "textContent"
			]: e
		}, ["templateParams", "titleTemplate"].includes(n))
	};
	return f3.forEach(r => {
		const s = typeof i.props[r] < "u" ? i.props[r] : t[r];
		typeof s < "u" && ((!["innerHTML", "textContent", "children"].includes(r) || Y5.includes(i.tag)) && (i[r === "children" ? "innerHTML" : r] = s), delete i.props[r])
	}), i.props.body && (i.tagPosition = "bodyClose", delete i.props.body), i.tag === "script" && typeof i.innerHTML == "object" && (i.innerHTML = JSON.stringify(i.innerHTML), i.props.type = i.props.type || "application/json"), Array.isArray(i.props.content) ? i.props.content.map(r => ({
		...i,
		props: {
			...i.props,
			content: r
		}
	})) : i
}

function e6(n, e) {
	var i;
	const t = n === "class" ? " " : ";";
	return typeof e == "object" && !Array.isArray(e) && (e = Object.entries(e).filter(([, r]) => r).map(([r, s]) => n === "style" ? `${r}:${s}` : r)), (i = Array.isArray(e) ? e.join(t) : e) == null ? void 0 : i.split(t).filter(r => r.trim()).filter(Boolean).join(t)
}
async function m3(n, e) {
	for (const t of Object.keys(n)) {
		if (["class", "style"].includes(t)) {
			n[t] = e6(t, n[t]);
			continue
		}
		if (n[t] instanceof Promise && (n[t] = await n[t]), !e && !f3.includes(t)) {
			const i = String(n[t]),
				r = t.startsWith("data-");
			i === "true" || i === "" ? n[t] = r ? "true" : !0 : n[t] || (r && i === "false" ? n[t] = "false" : delete n[t])
		}
	}
	return n
}
const t6 = 10;
async function n6(n) {
	const e = [];
	return Object.entries(n.resolvedInput).filter(([t, i]) => typeof i < "u" && K5.includes(t)).forEach(([t, i]) => {
		const r = X5(i);
		e.push(...r.map(s => Q5(t, s, n)).flat())
	}), (await Promise.all(e)).flat().filter(Boolean).map((t, i) => (t._e = n._i, n.mode && (t._m = n.mode), t._p = (n._i << t6) + i, t))
}
const $y = {
		base: -10,
		title: 10
	},
	qy = {
		critical: -80,
		high: -10,
		low: 20
	};

function Ip(n) {
	let e = 100;
	const t = n.tagPriority;
	return typeof t == "number" ? t : (n.tag === "meta" ? (n.props["http-equiv"] === "content-security-policy" && (e = -30), n.props.charset && (e = -20), n.props.name === "viewport" && (e = -15)) : n.tag === "link" && n.props.rel === "preconnect" ? e = 20 : n.tag in $y && (e = $y[n.tag]), typeof t == "string" && t in qy ? e + qy[t] : e)
}
const i6 = [{
		prefix: "before:",
		offset: -1
	}, {
		prefix: "after:",
		offset: 1
	}],
	Xy = ["onload", "onerror", "onabort", "onprogress", "onloadstart"],
	xo = "%separator";

function sp(n, e, t) {
	if (typeof n != "string" || !n.includes("%")) return n;

	function i(o) {
		let a;
		return ["s", "pageTitle"].includes(o) ? a = e.pageTitle : o.includes(".") ? a = o.split(".").reduce((l, c) => l && l[c] || void 0, e) : a = e[o], typeof a < "u" ? (a || "").replace(/"/g, '\\"') : !1
	}
	let r = n;
	try {
		r = decodeURI(n)
	} catch {}
	return (r.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(o => {
		const a = i(o.slice(1));
		typeof a == "string" && (n = n.replace(new RegExp(`\\${o}(\\W|$)`, "g"), (l, c) => `${a}${c}`).trim())
	}), n.includes(xo) && (n.endsWith(xo) && (n = n.slice(0, -xo.length).trim()), n.startsWith(xo) && (n = n.slice(xo.length).trim()), n = n.replace(new RegExp(`\\${xo}\\s*\\${xo}`, "g"), xo), n = sp(n, {
		separator: t
	}, t)), n
}
async function g3(n, e = {}) {
	var u;
	const t = e.document || n.resolvedOptions.document;
	if (!t || !n.dirty) return;
	const i = {
		shouldRender: !0,
		tags: []
	};
	if (await n.hooks.callHook("dom:beforeRender", i), !i.shouldRender) return;
	const r = (await n.resolveTags()).map(h => ({
		tag: h,
		id: rp.includes(h.tag) ? Wy(h) : h.tag,
		shouldRender: !0
	}));
	let s = n._dom;
	if (!s) {
		s = {
			elMap: {
				htmlAttrs: t.documentElement,
				bodyAttrs: t.body
			}
		};
		for (const h of ["body", "head"]) {
			const d = (u = t[h]) == null ? void 0 : u.children,
				f = [];
			for (const p of [...d].filter(_ => rp.includes(_.tagName.toLowerCase()))) {
				const _ = {
					tag: p.tagName.toLowerCase(),
					props: await m3(p.getAttributeNames().reduce((b, v) => ({
						...b,
						[v]: p.getAttribute(v)
					}), {})),
					innerHTML: p.innerHTML
				};
				let g = 1,
					m = p3(_);
				for (; m && f.find(b => b._d === m);) m = `${m}:${g++}`;
				_._d = m || void 0, f.push(_), s.elMap[p.getAttribute("data-hid") || Wy(_)] = p
			}
		}
	}
	s.pendingSideEffects = {
		...s.sideEffects || {}
	}, s.sideEffects = {};

	function o(h, d, f) {
		const p = `${h}:${d}`;
		s.sideEffects[p] = f, delete s.pendingSideEffects[p]
	}

	function a({
		id: h,
		$el: d,
		tag: f
	}) {
		const p = f.tag.endsWith("Attrs");
		s.elMap[h] = d, p || (["textContent", "innerHTML"].forEach(_ => {
			f[_] && f[_] !== d[_] && (d[_] = f[_])
		}), o(h, "el", () => {
			var _;
			(_ = s.elMap[h]) == null || _.remove(), delete s.elMap[h]
		}));
		for (const [_, g] of Object.entries(f._eventHandlers || {})) d.getAttribute(`data-${_}`) !== "" && ((f.tag === "bodyAttrs" ? t.defaultView : d).addEventListener(_.replace("on", ""), g.bind(d)), d.setAttribute(`data-${_}`, ""));
		Object.entries(f.props).forEach(([_, g]) => {
			const m = `attr:${_}`;
			if (_ === "class")
				for (const b of (g || "").split(" ").filter(Boolean)) p && o(h, `${m}:${b}`, () => d.classList.remove(b)), !d.classList.contains(b) && d.classList.add(b);
			else if (_ === "style")
				for (const b of (g || "").split(";").filter(Boolean)) {
					const [v, ...y] = b.split(":").map(x => x.trim());
					o(h, `${m}:${b}:${v}`, () => {
						d.style.removeProperty(v)
					}), d.style.setProperty(v, y.join(":"))
				} else d.getAttribute(_) !== g && d.setAttribute(_, g === !0 ? "" : String(g)), p && o(h, m, () => d.removeAttribute(_))
		})
	}
	const l = [],
		c = {
			bodyClose: void 0,
			bodyOpen: void 0,
			head: void 0
		};
	for (const h of r) {
		const {
			tag: d,
			shouldRender: f,
			id: p
		} = h;
		if (f) {
			if (d.tag === "title") {
				t.title = d.textContent;
				continue
			}
			h.$el = h.$el || s.elMap[p], h.$el ? a(h) : rp.includes(d.tag) && l.push(h)
		}
	}
	for (const h of l) {
		const d = h.tag.tagPosition || "head";
		h.$el = t.createElement(h.tag.tag), a(h), c[d] = c[d] || t.createDocumentFragment(), c[d].appendChild(h.$el)
	}
	for (const h of r) await n.hooks.callHook("dom:renderTag", h, t, o);
	c.head && t.head.appendChild(c.head), c.bodyOpen && t.body.insertBefore(c.bodyOpen, t.body.firstChild), c.bodyClose && t.body.appendChild(c.bodyClose), Object.values(s.pendingSideEffects).forEach(h => h()), n._dom = s, n.dirty = !1, await n.hooks.callHook("dom:rendered", {
		renders: r
	})
}
async function r6(n, e = {}) {
	const t = e.delayFn || (i => setTimeout(i, 10));
	return n._domUpdatePromise = n._domUpdatePromise || new Promise(i => t(async () => {
		await g3(n, e), delete n._domUpdatePromise, i()
	}))
}

function s6(n) {
	return e => {
		var i, r;
		const t = ((r = (i = e.resolvedOptions.document) == null ? void 0 : i.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : r.innerHTML) || !1;
		return t && e.push(JSON.parse(t)), {
			mode: "client",
			hooks: {
				"entries:updated": function (s) {
					r6(s, n)
				}
			}
		}
	}
}
const o6 = ["templateParams", "htmlAttrs", "bodyAttrs"],
	a6 = {
		hooks: {
			"tag:normalise": function ({
				tag: n
			}) {
				["hid", "vmid", "key"].forEach(i => {
					n.props[i] && (n.key = n.props[i], delete n.props[i])
				});
				const t = p3(n) || (n.key ? `${n.tag}:${n.key}` : !1);
				t && (n._d = t)
			},
			"tags:resolve": function (n) {
				const e = {};
				n.tags.forEach(i => {
					const r = (i.key ? `${i.tag}:${i.key}` : i._d) || i._p,
						s = e[r];
					if (s) {
						let a = i == null ? void 0 : i.tagDuplicateStrategy;
						if (!a && o6.includes(i.tag) && (a = "merge"), a === "merge") {
							const l = s.props;
							["class", "style"].forEach(c => {
								l[c] && (i.props[c] ? (c === "style" && !l[c].endsWith(";") && (l[c] += ";"), i.props[c] = `${l[c]} ${i.props[c]}`) : i.props[c] = l[c])
							}), e[r].props = {
								...l,
								...i.props
							};
							return
						} else if (i._e === s._e) {
							s._duped = s._duped || [], i._d = `${s._d}:${s._duped.length+1}`, s._duped.push(i);
							return
						} else if (Ip(i) > Ip(s)) return
					}
					const o = Object.keys(i.props).length + (i.innerHTML ? 1 : 0) + (i.textContent ? 1 : 0);
					if (rp.includes(i.tag) && o === 0) {
						delete e[r];
						return
					}
					e[r] = i
				});
				const t = [];
				Object.values(e).forEach(i => {
					const r = i._duped;
					delete i._duped, t.push(i), r && t.push(...r)
				}), n.tags = t, n.tags = n.tags.filter(i => !(i.tag === "meta" && (i.props.name || i.props.property) && !i.props.content))
			}
		}
	},
	l6 = {
		mode: "server",
		hooks: {
			"tags:resolve": function (n) {
				const e = {};
				n.tags.filter(t => ["titleTemplate", "templateParams", "title"].includes(t.tag) && t._m === "server").forEach(t => {
					e[t.tag] = t.tag.startsWith("title") ? t.textContent : t.props
				}), Object.keys(e).length && n.tags.push({
					tag: "script",
					innerHTML: JSON.stringify(e),
					props: {
						id: "unhead:payload",
						type: "application/json"
					}
				})
			}
		}
	},
	c6 = ["script", "link", "bodyAttrs"],
	u6 = n => ({
		hooks: {
			"tags:resolve": function (e) {
				for (const t of e.tags.filter(i => c6.includes(i.tag))) Object.entries(t.props).forEach(([i, r]) => {
					i.startsWith("on") && typeof r == "function" && (n.ssr && Xy.includes(i) ? t.props[i] = `this.dataset.${i}fired = true` : delete t.props[i], t._eventHandlers = t._eventHandlers || {}, t._eventHandlers[i] = r)
				}), n.ssr && t._eventHandlers && (t.props.src || t.props.href) && (t.key = t.key || b1(t.props.src || t.props.href))
			},
			"dom:renderTag": function ({
				$el: e,
				tag: t
			}) {
				var i, r;
				for (const s of Object.keys((e == null ? void 0 : e.dataset) || {}).filter(o => Xy.some(a => `${a}fired` === o))) {
					const o = s.replace("fired", "");
					(r = (i = t._eventHandlers) == null ? void 0 : i[o]) == null || r.call(e, new Event(o.replace("on", "")))
				}
			}
		}
	}),
	h6 = ["link", "style", "script", "noscript"],
	d6 = {
		hooks: {
			"tag:normalise": ({
				tag: n
			}) => {
				n.key && h6.includes(n.tag) && (n.props["data-hid"] = n._h = b1(n.key))
			}
		}
	},
	f6 = {
		hooks: {
			"tags:resolve": n => {
				const e = t => {
					var i;
					return (i = n.tags.find(r => r._d === t)) == null ? void 0 : i._p
				};
				for (const {
						prefix: t,
						offset: i
					} of i6)
					for (const r of n.tags.filter(s => typeof s.tagPriority == "string" && s.tagPriority.startsWith(t))) {
						const s = e(r.tagPriority.replace(t, ""));
						typeof s < "u" && (r._p = s + i)
					}
				n.tags.sort((t, i) => t._p - i._p).sort((t, i) => Ip(t) - Ip(i))
			}
		}
	},
	p6 = {
		meta: "content",
		link: "href",
		htmlAttrs: "lang"
	},
	m6 = n => ({
		hooks: {
			"tags:resolve": e => {
				var a;
				const {
					tags: t
				} = e, i = (a = t.find(l => l.tag === "title")) == null ? void 0 : a.textContent, r = t.findIndex(l => l.tag === "templateParams"), s = r !== -1 ? t[r].props : {}, o = s.separator || "|";
				delete s.separator, s.pageTitle = sp(s.pageTitle || i || "", s, o);
				for (const l of t.filter(c => c.processTemplateParams !== !1)) {
					const c = p6[l.tag];
					c && typeof l.props[c] == "string" ? l.props[c] = sp(l.props[c], s, o) : (l.processTemplateParams === !0 || ["titleTemplate", "title"].includes(l.tag)) && ["innerHTML", "textContent"].forEach(u => {
						typeof l[u] == "string" && (l[u] = sp(l[u], s, o))
					})
				}
				n._templateParams = s, n._separator = o, e.tags = t.filter(l => l.tag !== "templateParams")
			}
		}
	}),
	g6 = {
		hooks: {
			"tags:resolve": n => {
				const {
					tags: e
				} = n;
				let t = e.findIndex(r => r.tag === "titleTemplate");
				const i = e.findIndex(r => r.tag === "title");
				if (i !== -1 && t !== -1) {
					const r = jy(e[t].textContent, e[i].textContent);
					r !== null ? e[i].textContent = r || e[i].textContent : delete e[i]
				} else if (t !== -1) {
					const r = jy(e[t].textContent);
					r !== null && (e[t].textContent = r, e[t].tag = "title", t = -1)
				}
				t !== -1 && delete e[t], n.tags = e.filter(Boolean)
			}
		}
	},
	_6 = {
		hooks: {
			"tags:afterResolve": function (n) {
				for (const e of n.tags) typeof e.innerHTML == "string" && (e.innerHTML && ["application/ld+json", "application/json"].includes(e.props.type) ? e.innerHTML = e.innerHTML.replace(/</g, "\\u003C") : e.innerHTML = e.innerHTML.replace(new RegExp(`</${e.tag}`, "g"), `<\\/${e.tag}`))
			}
		}
	};
let _3;

function v6(n = {}) {
	const e = b6(n);
	return e.use(s6()), _3 = e
}

function Yy(n, e) {
	return !n || n === "server" && e || n === "client" && !e
}

function b6(n = {}) {
	const e = r3();
	e.addHooks(n.hooks || {}), n.document = n.document || (J5 ? document : void 0);
	const t = !n.document,
		i = () => {
			a.dirty = !0, e.callHook("entries:updated", a)
		};
	let r = 0,
		s = [];
	const o = [],
		a = {
			plugins: o,
			dirty: !1,
			resolvedOptions: n,
			hooks: e,
			headEntries() {
				return s
			},
			use(l) {
				const c = typeof l == "function" ? l(a) : l;
				(!c.key || !o.some(u => u.key === c.key)) && (o.push(c), Yy(c.mode, t) && e.addHooks(c.hooks || {}))
			},
			push(l, c) {
				c == null || delete c.head;
				const u = {
					_i: r++,
					input: l,
					...c
				};
				return Yy(u.mode, t) && (s.push(u), i()), {
					dispose() {
						s = s.filter(h => h._i !== u._i), e.callHook("entries:updated", a), i()
					},
					patch(h) {
						s = s.map(d => (d._i === u._i && (d.input = u.input = h), d)), i()
					}
				}
			},
			async resolveTags() {
				const l = {
					tags: [],
					entries: [...s]
				};
				await e.callHook("entries:resolve", l);
				for (const c of l.entries) {
					const u = c.resolvedInput || c.input;
					if (c.resolvedInput = await (c.transform ? c.transform(u) : u), c.resolvedInput)
						for (const h of await n6(c)) {
							const d = {
								tag: h,
								entry: c,
								resolvedOptions: a.resolvedOptions
							};
							await e.callHook("tag:normalise", d), l.tags.push(d.tag)
						}
				}
				return await e.callHook("tags:beforeResolve", l), await e.callHook("tags:resolve", l), await e.callHook("tags:afterResolve", l), l.tags
			},
			ssr: t
		};
	return [a6, l6, u6, d6, f6, m6, g6, _6, ...(n == null ? void 0 : n.plugins) || []].forEach(l => a.use(l)), a.hooks.callHook("init", a), a
}

function y6() {
	return _3
}
const x6 = qT.startsWith("3");

function w6(n) {
	return typeof n == "function" ? n() : fe(n)
}

function Op(n, e = "") {
	if (n instanceof Promise) return n;
	const t = w6(n);
	return !n || !t ? t : Array.isArray(t) ? t.map(i => Op(i, e)) : typeof t == "object" ? Object.fromEntries(Object.entries(t).map(([i, r]) => i === "titleTemplate" || i.startsWith("on") ? [i, fe(r)] : [i, Op(r, i)])) : t
}
const E6 = {
		hooks: {
			"entries:resolve": function (n) {
				for (const e of n.entries) e.resolvedInput = Op(e.input)
			}
		}
	},
	v3 = "usehead";

function S6(n) {
	return {
		install(t) {
			x6 && (t.config.globalProperties.$unhead = n, t.config.globalProperties.$head = n, t.provide(v3, n))
		}
	}.install
}

function T6(n = {}) {
	n.domDelayFn = n.domDelayFn || (t => Xi(() => setTimeout(() => t(), 0)));
	const e = v6(n);
	return e.use(E6), e.install = S6(e), e
}
const A_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
	D_ = "__unhead_injection_handler__";

function M6(n) {
	A_[D_] = n
}

function C6() {
	if (D_ in A_) return A_[D_]();
	const n = si(v3);
	return n || y6()
}

function Im(n, e = {}) {
	const t = e.head || C6();
	if (t) return t.ssr ? t.push(n, e) : A6(t, n, e)
}

function A6(n, e, t = {}) {
	const i = tt(!1),
		r = tt({});
	HR(() => {
		r.value = i.value ? {} : Op(e)
	});
	const s = n.push(r.value, t);
	return Vt(r, a => {
		s.patch(a)
	}), vu() && (Sa(() => {
		s.dispose()
	}), a1(() => {
		i.value = !0
	}), o1(() => {
		i.value = !1
	})), s
}

function ls(n) {
	if (typeof n != "object") return n;
	var e, t, i = Object.prototype.toString.call(n);
	if (i === "[object Object]") {
		if (n.constructor !== Object && typeof n.constructor == "function") {
			t = new n.constructor;
			for (e in n) n.hasOwnProperty(e) && t[e] !== n[e] && (t[e] = ls(n[e]))
		} else {
			t = {};
			for (e in n) e === "__proto__" ? Object.defineProperty(t, e, {
				value: ls(n[e]),
				configurable: !0,
				enumerable: !0,
				writable: !0
			}) : t[e] = ls(n[e])
		}
		return t
	}
	if (i === "[object Array]") {
		for (e = n.length, t = Array(e); e--;) t[e] = ls(n[e]);
		return t
	}
	return i === "[object Set]" ? (t = new Set, n.forEach(function (r) {
		t.add(ls(r))
	}), t) : i === "[object Map]" ? (t = new Map, n.forEach(function (r, s) {
		t.set(ls(s), ls(r))
	}), t) : i === "[object Date]" ? new Date(+n) : i === "[object RegExp]" ? (t = new RegExp(n.source, n.flags), t.lastIndex = n.lastIndex, t) : i === "[object DataView]" ? new n.constructor(ls(n.buffer)) : i === "[object ArrayBuffer]" ? n.slice(0) : i.slice(-6) === "Array]" ? new n.constructor(n) : n
}
const D6 = {
		nuxt: {
			buildId: "a24cac2b-b38b-43ca-8c37-8954e8f1b694"
		}
	},
	P6 = M5(D6);

function R6() {
	const n = Ke();
	return n._appConfig || (n._appConfig = Ii(P6)), n._appConfig
}
const P_ = {
		name: "page",
		mode: "out-in"
	},
	L6 = !1,
	k6 = {
		componentName: "NuxtLink"
	},
	I6 = {
		deep: !0
	},
	O6 = "#__nuxt";
let op, b3;

function F6() {
	var e;
	const n = (e = R6().nuxt) == null ? void 0 : e.buildId;
	return op = $fetch(_1(`builds/meta/${n}.json`)), op.then(t => {
		b3 = T5(t.matcher)
	}), op
}

function Om() {
	return op || F6()
}
async function y3(n) {
	return await Om(), Rm({}, ...b3.matchAll(n).reverse())
}

function Ky(n, e = {}) {
	const t = N6(n, e),
		i = Ke(),
		r = i._payloadCache = i._payloadCache || {};
	return t in r || (r[t] = U6(n).then(s => s ? x3(t).then(o => o || (delete r[t], null)) : (r[t] = null, null))), r[t]
}
const Zy = "json";

function N6(n, e = {}) {
	const t = new URL(n, "http://localhost");
	if (t.host !== "localhost" || ao(t.pathname, {
			acceptRelative: !0
		})) throw new Error("Payload URL must not include hostname: " + n);
	const i = e.hash || (e.fresh ? Date.now() : "");
	return Ta(Ma().app.baseURL, t.pathname, i ? `_payload.${i}.${Zy}` : `_payload.${Zy}`)
}
async function x3(n) {
	const e = fetch(n).then(t => t.text().then(w3));
	try {
		return await e
	} catch (t) {
		console.warn("[nuxt] Cannot load payload ", n, t)
	}
	return null
}
async function U6(n = Ca().path) {
	if (n = Pm(n), (await Om()).prerendered.includes(n)) return !0;
	const t = await y3(n);
	return !!t.prerender && !t.redirect
}
let ef = null;
async function B6() {
	if (ef) return ef;
	const n = document.getElementById("__NUXT_DATA__");
	if (!n) return {};
	const e = await w3(n.textContent || ""),
		t = n.dataset.src ? await x3(n.dataset.src) : void 0;
	return ef = {
		...e,
		...t,
		...window.__NUXT__
	}, ef
}
async function w3(n) {
	return await $5(n, Ke()._payloadRevivers)
}

function z6(n, e) {
	Ke()._payloadRevivers[n] = e
}
const Jy = {
		NuxtError: n => bd(n),
		EmptyShallowRef: n => Wc(n === "_" ? void 0 : n === "0n" ? BigInt(0) : Hh(n)),
		EmptyRef: n => tt(n === "_" ? void 0 : n === "0n" ? BigInt(0) : Hh(n)),
		ShallowRef: n => Wc(n),
		ShallowReactive: n => gd(n),
		Ref: n => tt(n),
		Reactive: n => Ii(n)
	},
	V6 = un({
		name: "nuxt:revive-payload:client",
		order: -30,
		async setup(n) {
			let e, t;
			for (const i in Jy) z6(i, Jy[i]);
			Object.assign(n.payload, ([e, t] = Xc(() => n.runWithContext(B6)), e = await e, t(), e)), window.__NUXT__ = n.payload
		}
	}),
	H6 = [],
	G6 = un({
		name: "nuxt:head",
		enforce: "pre",
		setup(n) {
			const e = T6({
				plugins: H6
			});
			M6(() => Ke().vueApp._context.provides.usehead), n.vueApp.use(e); {
				let t = !0;
				const i = async () => {
					t = !1, await g3(e)
				};
				e.hooks.hook("dom:beforeRender", r => {
					r.shouldRender = !t
				}), n.hooks.hook("page:start", () => {
					t = !0
				}), n.hooks.hook("page:finish", () => {
					n.isHydrating || i()
				}), n.hooks.hook("app:error", i), n.hooks.hook("app:suspense:resolve", i)
			}
		}
	});
/*!
 * vue-router v4.3.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const hc = typeof document < "u";

function W6(n) {
	return n.__esModule || n[Symbol.toStringTag] === "Module"
}
const Ut = Object.assign;

function M0(n, e) {
	const t = {};
	for (const i in e) {
		const r = e[i];
		t[i] = ss(r) ? r.map(n) : n(r)
	}
	return t
}
const dh = () => {},
	ss = Array.isArray,
	E3 = /#/g,
	j6 = /&/g,
	$6 = /\//g,
	q6 = /=/g,
	X6 = /\?/g,
	S3 = /\+/g,
	Y6 = /%5B/g,
	K6 = /%5D/g,
	T3 = /%5E/g,
	Z6 = /%60/g,
	M3 = /%7B/g,
	J6 = /%7C/g,
	C3 = /%7D/g,
	Q6 = /%20/g;

function y1(n) {
	return encodeURI("" + n).replace(J6, "|").replace(Y6, "[").replace(K6, "]")
}

function ek(n) {
	return y1(n).replace(M3, "{").replace(C3, "}").replace(T3, "^")
}

function R_(n) {
	return y1(n).replace(S3, "%2B").replace(Q6, "+").replace(E3, "%23").replace(j6, "%26").replace(Z6, "`").replace(M3, "{").replace(C3, "}").replace(T3, "^")
}

function tk(n) {
	return R_(n).replace(q6, "%3D")
}

function nk(n) {
	return y1(n).replace(E3, "%23").replace(X6, "%3F")
}

function ik(n) {
	return n == null ? "" : nk(n).replace($6, "%2F")
}

function Gh(n) {
	try {
		return decodeURIComponent("" + n)
	} catch {}
	return "" + n
}
const rk = /\/$/,
	sk = n => n.replace(rk, "");

function C0(n, e, t = "/") {
	let i, r = {},
		s = "",
		o = "";
	const a = e.indexOf("#");
	let l = e.indexOf("?");
	return a < l && a >= 0 && (l = -1), l > -1 && (i = e.slice(0, l), s = e.slice(l + 1, a > -1 ? a : e.length), r = n(s)), a > -1 && (i = i || e.slice(0, a), o = e.slice(a, e.length)), i = ck(i ?? e, t), {
		fullPath: i + (s && "?") + s + o,
		path: i,
		query: r,
		hash: Gh(o)
	}
}

function ok(n, e) {
	const t = e.query ? n(e.query) : "";
	return e.path + (t && "?") + t + (e.hash || "")
}

function Qy(n, e) {
	return !e || !n.toLowerCase().startsWith(e.toLowerCase()) ? n : n.slice(e.length) || "/"
}

function ak(n, e, t) {
	const i = e.matched.length - 1,
		r = t.matched.length - 1;
	return i > -1 && i === r && Yc(e.matched[i], t.matched[r]) && A3(e.params, t.params) && n(e.query) === n(t.query) && e.hash === t.hash
}

function Yc(n, e) {
	return (n.aliasOf || n) === (e.aliasOf || e)
}

function A3(n, e) {
	if (Object.keys(n).length !== Object.keys(e).length) return !1;
	for (const t in n)
		if (!lk(n[t], e[t])) return !1;
	return !0
}

function lk(n, e) {
	return ss(n) ? ex(n, e) : ss(e) ? ex(e, n) : n === e
}

function ex(n, e) {
	return ss(e) ? n.length === e.length && n.every((t, i) => t === e[i]) : n.length === 1 && n[0] === e
}

function ck(n, e) {
	if (n.startsWith("/")) return n;
	if (!n) return e;
	const t = e.split("/"),
		i = n.split("/"),
		r = i[i.length - 1];
	(r === ".." || r === ".") && i.push("");
	let s = t.length - 1,
		o, a;
	for (o = 0; o < i.length; o++)
		if (a = i[o], a !== ".")
			if (a === "..") s > 1 && s--;
			else break;
	return t.slice(0, s).join("/") + "/" + i.slice(o).join("/")
}
var Wh;
(function (n) {
	n.pop = "pop", n.push = "push"
})(Wh || (Wh = {}));
var fh;
(function (n) {
	n.back = "back", n.forward = "forward", n.unknown = ""
})(fh || (fh = {}));

function uk(n) {
	if (!n)
		if (hc) {
			const e = document.querySelector("base");
			n = e && e.getAttribute("href") || "/", n = n.replace(/^\w+:\/\/[^\/]+/, "")
		} else n = "/";
	return n[0] !== "/" && n[0] !== "#" && (n = "/" + n), sk(n)
}
const hk = /^[^#]+#/;

function dk(n, e) {
	return n.replace(hk, "#") + e
}

function fk(n, e) {
	const t = document.documentElement.getBoundingClientRect(),
		i = n.getBoundingClientRect();
	return {
		behavior: e.behavior,
		left: i.left - t.left - (e.left || 0),
		top: i.top - t.top - (e.top || 0)
	}
}
const Fm = () => ({
	left: window.scrollX,
	top: window.scrollY
});

function pk(n) {
	let e;
	if ("el" in n) {
		const t = n.el,
			i = typeof t == "string" && t.startsWith("#"),
			r = typeof t == "string" ? i ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
		if (!r) return;
		e = fk(r, n)
	} else e = n;
	"scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}

function tx(n, e) {
	return (history.state ? history.state.position - e : -1) + n
}
const L_ = new Map;

function mk(n, e) {
	L_.set(n, e)
}

function gk(n) {
	const e = L_.get(n);
	return L_.delete(n), e
}
let _k = () => location.protocol + "//" + location.host;

function D3(n, e) {
	const {
		pathname: t,
		search: i,
		hash: r
	} = e, s = n.indexOf("#");
	if (s > -1) {
		let a = r.includes(n.slice(s)) ? n.slice(s).length : 1,
			l = r.slice(a);
		return l[0] !== "/" && (l = "/" + l), Qy(l, "")
	}
	return Qy(t, n) + i + r
}

function vk(n, e, t, i) {
	let r = [],
		s = [],
		o = null;
	const a = ({
		state: d
	}) => {
		const f = D3(n, location),
			p = t.value,
			_ = e.value;
		let g = 0;
		if (d) {
			if (t.value = f, e.value = d, o && o === p) {
				o = null;
				return
			}
			g = _ ? d.position - _.position : 0
		} else i(f);
		r.forEach(m => {
			m(t.value, p, {
				delta: g,
				type: Wh.pop,
				direction: g ? g > 0 ? fh.forward : fh.back : fh.unknown
			})
		})
	};

	function l() {
		o = t.value
	}

	function c(d) {
		r.push(d);
		const f = () => {
			const p = r.indexOf(d);
			p > -1 && r.splice(p, 1)
		};
		return s.push(f), f
	}

	function u() {
		const {
			history: d
		} = window;
		d.state && d.replaceState(Ut({}, d.state, {
			scroll: Fm()
		}), "")
	}

	function h() {
		for (const d of s) d();
		s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
	}
	return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u, {
		passive: !0
	}), {
		pauseListeners: l,
		listen: c,
		destroy: h
	}
}

function nx(n, e, t, i = !1, r = !1) {
	return {
		back: n,
		current: e,
		forward: t,
		replaced: i,
		position: window.history.length,
		scroll: r ? Fm() : null
	}
}

function bk(n) {
	const {
		history: e,
		location: t
	} = window, i = {
		value: D3(n, t)
	}, r = {
		value: e.state
	};
	r.value || s(i.value, {
		back: null,
		current: i.value,
		forward: null,
		position: e.length - 1,
		replaced: !0,
		scroll: null
	}, !0);

	function s(l, c, u) {
		const h = n.indexOf("#"),
			d = h > -1 ? (t.host && document.querySelector("base") ? n : n.slice(h)) + l : _k() + n + l;
		try {
			e[u ? "replaceState" : "pushState"](c, "", d), r.value = c
		} catch (f) {
			console.error(f), t[u ? "replace" : "assign"](d)
		}
	}

	function o(l, c) {
		const u = Ut({}, e.state, nx(r.value.back, l, r.value.forward, !0), c, {
			position: r.value.position
		});
		s(l, u, !0), i.value = l
	}

	function a(l, c) {
		const u = Ut({}, r.value, e.state, {
			forward: l,
			scroll: Fm()
		});
		s(u.current, u, !0);
		const h = Ut({}, nx(i.value, l, null), {
			position: u.position + 1
		}, c);
		s(l, h, !1), i.value = l
	}
	return {
		location: i,
		state: r,
		push: a,
		replace: o
	}
}

function P3(n) {
	n = uk(n);
	const e = bk(n),
		t = vk(n, e.state, e.location, e.replace);

	function i(s, o = !0) {
		o || t.pauseListeners(), history.go(s)
	}
	const r = Ut({
		location: "",
		base: n,
		go: i,
		createHref: dk.bind(null, n)
	}, e, t);
	return Object.defineProperty(r, "location", {
		enumerable: !0,
		get: () => e.location.value
	}), Object.defineProperty(r, "state", {
		enumerable: !0,
		get: () => e.state.value
	}), r
}

function yk(n) {
	return n = location.host ? n || location.pathname + location.search : "", n.includes("#") || (n += "#"), P3(n)
}

function xk(n) {
	return typeof n == "string" || n && typeof n == "object"
}

function R3(n) {
	return typeof n == "string" || typeof n == "symbol"
}
const Qr = {
		path: "/",
		name: void 0,
		params: {},
		query: {},
		hash: "",
		fullPath: "/",
		matched: [],
		meta: {},
		redirectedFrom: void 0
	},
	L3 = Symbol("");
var ix;
(function (n) {
	n[n.aborted = 4] = "aborted", n[n.cancelled = 8] = "cancelled", n[n.duplicated = 16] = "duplicated"
})(ix || (ix = {}));

function Kc(n, e) {
	return Ut(new Error, {
		type: n,
		[L3]: !0
	}, e)
}

function Ns(n, e) {
	return n instanceof Error && L3 in n && (e == null || !!(n.type & e))
}
const rx = "[^/]+?",
	wk = {
		sensitive: !1,
		strict: !1,
		start: !0,
		end: !0
	},
	Ek = /[.+*?^${}()[\]/\\]/g;

function Sk(n, e) {
	const t = Ut({}, wk, e),
		i = [];
	let r = t.start ? "^" : "";
	const s = [];
	for (const c of n) {
		const u = c.length ? [] : [90];
		t.strict && !c.length && (r += "/");
		for (let h = 0; h < c.length; h++) {
			const d = c[h];
			let f = 40 + (t.sensitive ? .25 : 0);
			if (d.type === 0) h || (r += "/"), r += d.value.replace(Ek, "\\$&"), f += 40;
			else if (d.type === 1) {
				const {
					value: p,
					repeatable: _,
					optional: g,
					regexp: m
				} = d;
				s.push({
					name: p,
					repeatable: _,
					optional: g
				});
				const b = m || rx;
				if (b !== rx) {
					f += 10;
					try {
						new RegExp(`(${b})`)
					} catch (y) {
						throw new Error(`Invalid custom RegExp for param "${p}" (${b}): ` + y.message)
					}
				}
				let v = _ ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
				h || (v = g && c.length < 2 ? `(?:/${v})` : "/" + v), g && (v += "?"), r += v, f += 20, g && (f += -8), _ && (f += -20), b === ".*" && (f += -50)
			}
			u.push(f)
		}
		i.push(u)
	}
	if (t.strict && t.end) {
		const c = i.length - 1;
		i[c][i[c].length - 1] += .7000000000000001
	}
	t.strict || (r += "/?"), t.end ? r += "$" : t.strict && (r += "(?:/|$)");
	const o = new RegExp(r, t.sensitive ? "" : "i");

	function a(c) {
		const u = c.match(o),
			h = {};
		if (!u) return null;
		for (let d = 1; d < u.length; d++) {
			const f = u[d] || "",
				p = s[d - 1];
			h[p.name] = f && p.repeatable ? f.split("/") : f
		}
		return h
	}

	function l(c) {
		let u = "",
			h = !1;
		for (const d of n) {
			(!h || !u.endsWith("/")) && (u += "/"), h = !1;
			for (const f of d)
				if (f.type === 0) u += f.value;
				else if (f.type === 1) {
				const {
					value: p,
					repeatable: _,
					optional: g
				} = f, m = p in c ? c[p] : "";
				if (ss(m) && !_) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
				const b = ss(m) ? m.join("/") : m;
				if (!b)
					if (g) d.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : h = !0);
					else throw new Error(`Missing required param "${p}"`);
				u += b
			}
		}
		return u || "/"
	}
	return {
		re: o,
		score: i,
		keys: s,
		parse: a,
		stringify: l
	}
}

function Tk(n, e) {
	let t = 0;
	for (; t < n.length && t < e.length;) {
		const i = e[t] - n[t];
		if (i) return i;
		t++
	}
	return n.length < e.length ? n.length === 1 && n[0] === 80 ? -1 : 1 : n.length > e.length ? e.length === 1 && e[0] === 80 ? 1 : -1 : 0
}

function Mk(n, e) {
	let t = 0;
	const i = n.score,
		r = e.score;
	for (; t < i.length && t < r.length;) {
		const s = Tk(i[t], r[t]);
		if (s) return s;
		t++
	}
	if (Math.abs(r.length - i.length) === 1) {
		if (sx(i)) return 1;
		if (sx(r)) return -1
	}
	return r.length - i.length
}

function sx(n) {
	const e = n[n.length - 1];
	return n.length > 0 && e[e.length - 1] < 0
}
const Ck = {
		type: 0,
		value: ""
	},
	Ak = /[a-zA-Z0-9_]/;

function Dk(n) {
	if (!n) return [
		[]
	];
	if (n === "/") return [
		[Ck]
	];
	if (!n.startsWith("/")) throw new Error(`Invalid path "${n}"`);

	function e(f) {
		throw new Error(`ERR (${t})/"${c}": ${f}`)
	}
	let t = 0,
		i = t;
	const r = [];
	let s;

	function o() {
		s && r.push(s), s = []
	}
	let a = 0,
		l, c = "",
		u = "";

	function h() {
		c && (t === 0 ? s.push({
			type: 0,
			value: c
		}) : t === 1 || t === 2 || t === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
			type: 1,
			value: c,
			regexp: u,
			repeatable: l === "*" || l === "+",
			optional: l === "*" || l === "?"
		})) : e("Invalid state to consume buffer"), c = "")
	}

	function d() {
		c += l
	}
	for (; a < n.length;) {
		if (l = n[a++], l === "\\" && t !== 2) {
			i = t, t = 4;
			continue
		}
		switch (t) {
			case 0:
				l === "/" ? (c && h(), o()) : l === ":" ? (h(), t = 1) : d();
				break;
			case 4:
				d(), t = i;
				break;
			case 1:
				l === "(" ? t = 2 : Ak.test(l) ? d() : (h(), t = 0, l !== "*" && l !== "?" && l !== "+" && a--);
				break;
			case 2:
				l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l;
				break;
			case 3:
				h(), t = 0, l !== "*" && l !== "?" && l !== "+" && a--, u = "";
				break;
			default:
				e("Unknown state");
				break
		}
	}
	return t === 2 && e(`Unfinished custom RegExp for param "${c}"`), h(), o(), r
}

function Pk(n, e, t) {
	const i = Sk(Dk(n.path), t),
		r = Ut(i, {
			record: n,
			parent: e,
			children: [],
			alias: []
		});
	return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r), r
}

function Rk(n, e) {
	const t = [],
		i = new Map;
	e = lx({
		strict: !1,
		end: !0,
		sensitive: !1
	}, e);

	function r(u) {
		return i.get(u)
	}

	function s(u, h, d) {
		const f = !d,
			p = Lk(u);
		p.aliasOf = d && d.record;
		const _ = lx(e, u),
			g = [p];
		if ("alias" in u) {
			const v = typeof u.alias == "string" ? [u.alias] : u.alias;
			for (const y of v) g.push(Ut({}, p, {
				components: d ? d.record.components : p.components,
				path: y,
				aliasOf: d ? d.record : p
			}))
		}
		let m, b;
		for (const v of g) {
			const {
				path: y
			} = v;
			if (h && y[0] !== "/") {
				const x = h.record.path,
					S = x[x.length - 1] === "/" ? "" : "/";
				v.path = h.record.path + (y && S + y)
			}
			if (m = Pk(v, h, _), d ? d.alias.push(m) : (b = b || m, b !== m && b.alias.push(m), f && u.name && !ax(m) && o(u.name)), p.children) {
				const x = p.children;
				for (let S = 0; S < x.length; S++) s(x[S], m, d && d.children[S])
			}
			d = d || m, (m.record.components && Object.keys(m.record.components).length || m.record.name || m.record.redirect) && l(m)
		}
		return b ? () => {
			o(b)
		} : dh
	}

	function o(u) {
		if (R3(u)) {
			const h = i.get(u);
			h && (i.delete(u), t.splice(t.indexOf(h), 1), h.children.forEach(o), h.alias.forEach(o))
		} else {
			const h = t.indexOf(u);
			h > -1 && (t.splice(h, 1), u.record.name && i.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
		}
	}

	function a() {
		return t
	}

	function l(u) {
		let h = 0;
		for (; h < t.length && Mk(u, t[h]) >= 0 && (u.record.path !== t[h].record.path || !k3(u, t[h]));) h++;
		t.splice(h, 0, u), u.record.name && !ax(u) && i.set(u.record.name, u)
	}

	function c(u, h) {
		let d, f = {},
			p, _;
		if ("name" in u && u.name) {
			if (d = i.get(u.name), !d) throw Kc(1, {
				location: u
			});
			_ = d.record.name, f = Ut(ox(h.params, d.keys.filter(b => !b.optional).concat(d.parent ? d.parent.keys.filter(b => b.optional) : []).map(b => b.name)), u.params && ox(u.params, d.keys.map(b => b.name))), p = d.stringify(f)
		} else if (u.path != null) p = u.path, d = t.find(b => b.re.test(p)), d && (f = d.parse(p), _ = d.record.name);
		else {
			if (d = h.name ? i.get(h.name) : t.find(b => b.re.test(h.path)), !d) throw Kc(1, {
				location: u,
				currentLocation: h
			});
			_ = d.record.name, f = Ut({}, h.params, u.params), p = d.stringify(f)
		}
		const g = [];
		let m = d;
		for (; m;) g.unshift(m.record), m = m.parent;
		return {
			name: _,
			path: p,
			params: f,
			matched: g,
			meta: Ik(g)
		}
	}
	return n.forEach(u => s(u)), {
		addRoute: s,
		resolve: c,
		removeRoute: o,
		getRoutes: a,
		getRecordMatcher: r
	}
}

function ox(n, e) {
	const t = {};
	for (const i of e) i in n && (t[i] = n[i]);
	return t
}

function Lk(n) {
	return {
		path: n.path,
		redirect: n.redirect,
		name: n.name,
		meta: n.meta || {},
		aliasOf: void 0,
		beforeEnter: n.beforeEnter,
		props: kk(n),
		children: n.children || [],
		instances: {},
		leaveGuards: new Set,
		updateGuards: new Set,
		enterCallbacks: {},
		components: "components" in n ? n.components || null : n.component && {
			default: n.component
		}
	}
}

function kk(n) {
	const e = {},
		t = n.props || !1;
	if ("component" in n) e.default = t;
	else
		for (const i in n.components) e[i] = typeof t == "object" ? t[i] : t;
	return e
}

function ax(n) {
	for (; n;) {
		if (n.record.aliasOf) return !0;
		n = n.parent
	}
	return !1
}

function Ik(n) {
	return n.reduce((e, t) => Ut(e, t.meta), {})
}

function lx(n, e) {
	const t = {};
	for (const i in n) t[i] = i in e ? e[i] : n[i];
	return t
}

function k3(n, e) {
	return e.children.some(t => t === n || k3(n, t))
}

function Ok(n) {
	const e = {};
	if (n === "" || n === "?") return e;
	const i = (n[0] === "?" ? n.slice(1) : n).split("&");
	for (let r = 0; r < i.length; ++r) {
		const s = i[r].replace(S3, " "),
			o = s.indexOf("="),
			a = Gh(o < 0 ? s : s.slice(0, o)),
			l = o < 0 ? null : Gh(s.slice(o + 1));
		if (a in e) {
			let c = e[a];
			ss(c) || (c = e[a] = [c]), c.push(l)
		} else e[a] = l
	}
	return e
}

function cx(n) {
	let e = "";
	for (let t in n) {
		const i = n[t];
		if (t = tk(t), i == null) {
			i !== void 0 && (e += (e.length ? "&" : "") + t);
			continue
		}(ss(i) ? i.map(s => s && R_(s)) : [i && R_(i)]).forEach(s => {
			s !== void 0 && (e += (e.length ? "&" : "") + t, s != null && (e += "=" + s))
		})
	}
	return e
}

function Fk(n) {
	const e = {};
	for (const t in n) {
		const i = n[t];
		i !== void 0 && (e[t] = ss(i) ? i.map(r => r == null ? null : "" + r) : i == null ? i : "" + i)
	}
	return e
}
const I3 = Symbol(""),
	ux = Symbol(""),
	Nm = Symbol(""),
	O3 = Symbol(""),
	k_ = Symbol("");

function Ru() {
	let n = [];

	function e(i) {
		return n.push(i), () => {
			const r = n.indexOf(i);
			r > -1 && n.splice(r, 1)
		}
	}

	function t() {
		n = []
	}
	return {
		add: e,
		list: () => n.slice(),
		reset: t
	}
}

function Nk(n, e, t) {
	const i = () => {
		n[e].delete(t)
	};
	Yi(i), a1(i), o1(() => {
		n[e].add(t)
	}), n[e].add(t)
}

function dte(n) {
	const e = si(I3, {}).value;
	e && Nk(e, "leaveGuards", n)
}

function Vo(n, e, t, i, r, s = o => o()) {
	const o = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
	return () => new Promise((a, l) => {
		const c = d => {
				d === !1 ? l(Kc(4, {
					from: t,
					to: e
				})) : d instanceof Error ? l(d) : xk(d) ? l(Kc(2, {
					from: e,
					to: d
				})) : (o && i.enterCallbacks[r] === o && typeof d == "function" && o.push(d), a())
			},
			u = s(() => n.call(i && i.instances[r], e, t, c));
		let h = Promise.resolve(u);
		n.length < 3 && (h = h.then(c)), h.catch(d => l(d))
	})
}

function A0(n, e, t, i, r = s => s()) {
	const s = [];
	for (const o of n)
		for (const a in o.components) {
			let l = o.components[a];
			if (!(e !== "beforeRouteEnter" && !o.instances[a]))
				if (Uk(l)) {
					const u = (l.__vccOpts || l)[e];
					u && s.push(Vo(u, t, i, o, a, r))
				} else {
					let c = l();
					s.push(() => c.then(u => {
						if (!u) return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${o.path}"`));
						const h = W6(u) ? u.default : u;
						o.components[a] = h;
						const f = (h.__vccOpts || h)[e];
						return f && Vo(f, t, i, o, a, r)()
					}))
				}
		}
	return s
}

function Uk(n) {
	return typeof n == "object" || "displayName" in n || "props" in n || "__vccOpts" in n
}

function hx(n) {
	const e = si(Nm),
		t = si(O3),
		i = Be(() => {
			const l = fe(n.to);
			return e.resolve(l)
		}),
		r = Be(() => {
			const {
				matched: l
			} = i.value, {
				length: c
			} = l, u = l[c - 1], h = t.matched;
			if (!u || !h.length) return -1;
			const d = h.findIndex(Yc.bind(null, u));
			if (d > -1) return d;
			const f = dx(l[c - 2]);
			return c > 1 && dx(u) === f && h[h.length - 1].path !== f ? h.findIndex(Yc.bind(null, l[c - 2])) : d
		}),
		s = Be(() => r.value > -1 && Hk(t.params, i.value.params)),
		o = Be(() => r.value > -1 && r.value === t.matched.length - 1 && A3(t.params, i.value.params));

	function a(l = {}) {
		return Vk(l) ? e[fe(n.replace) ? "replace" : "push"](fe(n.to)).catch(dh) : Promise.resolve()
	}
	return {
		route: i,
		href: Be(() => i.value.href),
		isActive: s,
		isExactActive: o,
		navigate: a
	}
}
const Bk = Qi({
		name: "RouterLink",
		compatConfig: {
			MODE: 3
		},
		props: {
			to: {
				type: [String, Object],
				required: !0
			},
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: {
				type: String,
				default: "page"
			}
		},
		useLink: hx,
		setup(n, {
			slots: e
		}) {
			const t = Ii(hx(n)),
				{
					options: i
				} = si(Nm),
				r = Be(() => ({
					[fx(n.activeClass, i.linkActiveClass, "router-link-active")]: t.isActive,
					[fx(n.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
				}));
			return () => {
				const s = e.default && e.default(t);
				return n.custom ? s : on("a", {
					"aria-current": t.isExactActive ? n.ariaCurrentValue : null,
					href: t.href,
					onClick: t.navigate,
					class: r.value
				}, s)
			}
		}
	}),
	zk = Bk;

function Vk(n) {
	if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) {
		if (n.currentTarget && n.currentTarget.getAttribute) {
			const e = n.currentTarget.getAttribute("target");
			if (/\b_blank\b/i.test(e)) return
		}
		return n.preventDefault && n.preventDefault(), !0
	}
}

function Hk(n, e) {
	for (const t in e) {
		const i = e[t],
			r = n[t];
		if (typeof i == "string") {
			if (i !== r) return !1
		} else if (!ss(r) || r.length !== i.length || i.some((s, o) => s !== r[o])) return !1
	}
	return !0
}

function dx(n) {
	return n ? n.aliasOf ? n.aliasOf.path : n.path : ""
}
const fx = (n, e, t) => n ?? e ?? t,
	Gk = Qi({
		name: "RouterView",
		inheritAttrs: !1,
		props: {
			name: {
				type: String,
				default: "default"
			},
			route: Object
		},
		compatConfig: {
			MODE: 3
		},
		setup(n, {
			attrs: e,
			slots: t
		}) {
			const i = si(k_),
				r = Be(() => n.route || i.value),
				s = si(ux, 0),
				o = Be(() => {
					let c = fe(s);
					const {
						matched: u
					} = r.value;
					let h;
					for (;
						(h = u[c]) && !h.components;) c++;
					return c
				}),
				a = Be(() => r.value.matched[o.value]);
			al(ux, Be(() => o.value + 1)), al(I3, a), al(k_, r);
			const l = tt();
			return Vt(() => [l.value, a.value, n.name], ([c, u, h], [d, f, p]) => {
				u && (u.instances[h] = c, f && f !== u && c && c === d && (u.leaveGuards.size || (u.leaveGuards = f.leaveGuards), u.updateGuards.size || (u.updateGuards = f.updateGuards))), c && u && (!f || !Yc(u, f) || !d) && (u.enterCallbacks[h] || []).forEach(_ => _(c))
			}, {
				flush: "post"
			}), () => {
				const c = r.value,
					u = n.name,
					h = a.value,
					d = h && h.components[u];
				if (!d) return px(t.default, {
					Component: d,
					route: c
				});
				const f = h.props[u],
					p = f ? f === !0 ? c.params : typeof f == "function" ? f(c) : f : null,
					g = on(d, Ut({}, p, e, {
						onVnodeUnmounted: m => {
							m.component.isUnmounted && (h.instances[u] = null)
						},
						ref: l
					}));
				return px(t.default, {
					Component: g,
					route: c
				}) || g
			}
		}
	});

function px(n, e) {
	if (!n) return null;
	const t = n(e);
	return t.length === 1 ? t[0] : t
}
const F3 = Gk;

function Wk(n) {
	const e = Rk(n.routes, n),
		t = n.parseQuery || Ok,
		i = n.stringifyQuery || cx,
		r = n.history,
		s = Ru(),
		o = Ru(),
		a = Ru(),
		l = Wc(Qr);
	let c = Qr;
	hc && n.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
	const u = M0.bind(null, Z => "" + Z),
		h = M0.bind(null, ik),
		d = M0.bind(null, Gh);

	function f(Z, pe) {
		let ce, Ce;
		return R3(Z) ? (ce = e.getRecordMatcher(Z), Ce = pe) : Ce = Z, e.addRoute(Ce, ce)
	}

	function p(Z) {
		const pe = e.getRecordMatcher(Z);
		pe && e.removeRoute(pe)
	}

	function _() {
		return e.getRoutes().map(Z => Z.record)
	}

	function g(Z) {
		return !!e.getRecordMatcher(Z)
	}

	function m(Z, pe) {
		if (pe = Ut({}, pe || l.value), typeof Z == "string") {
			const O = C0(t, Z, pe.path),
				q = e.resolve({
					path: O.path
				}, pe),
				ie = r.createHref(O.fullPath);
			return Ut(O, q, {
				params: d(q.params),
				hash: Gh(O.hash),
				redirectedFrom: void 0,
				href: ie
			})
		}
		let ce;
		if (Z.path != null) ce = Ut({}, Z, {
			path: C0(t, Z.path, pe.path).path
		});
		else {
			const O = Ut({}, Z.params);
			for (const q in O) O[q] == null && delete O[q];
			ce = Ut({}, Z, {
				params: h(O)
			}), pe.params = h(pe.params)
		}
		const Ce = e.resolve(ce, pe),
			Re = Z.hash || "";
		Ce.params = u(d(Ce.params));
		const Y = ok(i, Ut({}, Z, {
				hash: ek(Re),
				path: Ce.path
			})),
			k = r.createHref(Y);
		return Ut({
			fullPath: Y,
			hash: Re,
			query: i === cx ? Fk(Z.query) : Z.query || {}
		}, Ce, {
			redirectedFrom: void 0,
			href: k
		})
	}

	function b(Z) {
		return typeof Z == "string" ? C0(t, Z, l.value.path) : Ut({}, Z)
	}

	function v(Z, pe) {
		if (c !== Z) return Kc(8, {
			from: pe,
			to: Z
		})
	}

	function y(Z) {
		return E(Z)
	}

	function x(Z) {
		return y(Ut(b(Z), {
			replace: !0
		}))
	}

	function S(Z) {
		const pe = Z.matched[Z.matched.length - 1];
		if (pe && pe.redirect) {
			const {
				redirect: ce
			} = pe;
			let Ce = typeof ce == "function" ? ce(Z) : ce;
			return typeof Ce == "string" && (Ce = Ce.includes("?") || Ce.includes("#") ? Ce = b(Ce) : {
				path: Ce
			}, Ce.params = {}), Ut({
				query: Z.query,
				hash: Z.hash,
				params: Ce.path != null ? {} : Z.params
			}, Ce)
		}
	}

	function E(Z, pe) {
		const ce = c = m(Z),
			Ce = l.value,
			Re = Z.state,
			Y = Z.force,
			k = Z.replace === !0,
			O = S(ce);
		if (O) return E(Ut(b(O), {
			state: typeof O == "object" ? Ut({}, Re, O.state) : Re,
			force: Y,
			replace: k
		}), pe || ce);
		const q = ce;
		q.redirectedFrom = pe;
		let ie;
		return !Y && ak(i, Ce, ce) && (ie = Kc(16, {
			to: q,
			from: Ce
		}), ge(Ce, Ce, !0, !1)), (ie ? Promise.resolve(ie) : w(q, Ce)).catch(N => Ns(N) ? Ns(N, 2) ? N : B(N) : R(N, q, Ce)).then(N => {
			if (N) {
				if (Ns(N, 2)) return E(Ut({
					replace: k
				}, b(N.to), {
					state: typeof N.to == "object" ? Ut({}, Re, N.to.state) : Re,
					force: Y
				}), pe || q)
			} else N = U(q, Ce, !0, k, Re);
			return D(q, Ce, N), N
		})
	}

	function C(Z, pe) {
		const ce = v(Z, pe);
		return ce ? Promise.reject(ce) : Promise.resolve()
	}

	function P(Z) {
		const pe = K.values().next().value;
		return pe && typeof pe.runWithContext == "function" ? pe.runWithContext(Z) : Z()
	}

	function w(Z, pe) {
		let ce;
		const [Ce, Re, Y] = jk(Z, pe);
		ce = A0(Ce.reverse(), "beforeRouteLeave", Z, pe);
		for (const O of Ce) O.leaveGuards.forEach(q => {
			ce.push(Vo(q, Z, pe))
		});
		const k = C.bind(null, Z, pe);
		return ce.push(k), Se(ce).then(() => {
			ce = [];
			for (const O of s.list()) ce.push(Vo(O, Z, pe));
			return ce.push(k), Se(ce)
		}).then(() => {
			ce = A0(Re, "beforeRouteUpdate", Z, pe);
			for (const O of Re) O.updateGuards.forEach(q => {
				ce.push(Vo(q, Z, pe))
			});
			return ce.push(k), Se(ce)
		}).then(() => {
			ce = [];
			for (const O of Y)
				if (O.beforeEnter)
					if (ss(O.beforeEnter))
						for (const q of O.beforeEnter) ce.push(Vo(q, Z, pe));
					else ce.push(Vo(O.beforeEnter, Z, pe));
			return ce.push(k), Se(ce)
		}).then(() => (Z.matched.forEach(O => O.enterCallbacks = {}), ce = A0(Y, "beforeRouteEnter", Z, pe, P), ce.push(k), Se(ce))).then(() => {
			ce = [];
			for (const O of o.list()) ce.push(Vo(O, Z, pe));
			return ce.push(k), Se(ce)
		}).catch(O => Ns(O, 8) ? O : Promise.reject(O))
	}

	function D(Z, pe, ce) {
		a.list().forEach(Ce => P(() => Ce(Z, pe, ce)))
	}

	function U(Z, pe, ce, Ce, Re) {
		const Y = v(Z, pe);
		if (Y) return Y;
		const k = pe === Qr,
			O = hc ? history.state : {};
		ce && (Ce || k ? r.replace(Z.fullPath, Ut({
			scroll: k && O && O.scroll
		}, Re)) : r.push(Z.fullPath, Re)), l.value = Z, ge(Z, pe, ce, k), B()
	}
	let j;

	function z() {
		j || (j = r.listen((Z, pe, ce) => {
			if (!ye.listening) return;
			const Ce = m(Z),
				Re = S(Ce);
			if (Re) {
				E(Ut(Re, {
					replace: !0
				}), Ce).catch(dh);
				return
			}
			c = Ce;
			const Y = l.value;
			hc && mk(tx(Y.fullPath, ce.delta), Fm()), w(Ce, Y).catch(k => Ns(k, 12) ? k : Ns(k, 2) ? (E(k.to, Ce).then(O => {
				Ns(O, 20) && !ce.delta && ce.type === Wh.pop && r.go(-1, !1)
			}).catch(dh), Promise.reject()) : (ce.delta && r.go(-ce.delta, !1), R(k, Ce, Y))).then(k => {
				k = k || U(Ce, Y, !1), k && (ce.delta && !Ns(k, 8) ? r.go(-ce.delta, !1) : ce.type === Wh.pop && Ns(k, 20) && r.go(-1, !1)), D(Ce, Y, k)
			}).catch(dh)
		}))
	}
	let H = Ru(),
		F = Ru(),
		G;

	function R(Z, pe, ce) {
		B(Z);
		const Ce = F.list();
		return Ce.length ? Ce.forEach(Re => Re(Z, pe, ce)) : console.error(Z), Promise.reject(Z)
	}

	function Q() {
		return G && l.value !== Qr ? Promise.resolve() : new Promise((Z, pe) => {
			H.add([Z, pe])
		})
	}

	function B(Z) {
		return G || (G = !Z, z(), H.list().forEach(([pe, ce]) => Z ? ce(Z) : pe()), H.reset()), Z
	}

	function ge(Z, pe, ce, Ce) {
		const {
			scrollBehavior: Re
		} = n;
		if (!hc || !Re) return Promise.resolve();
		const Y = !ce && gk(tx(Z.fullPath, 0)) || (Ce || !ce) && history.state && history.state.scroll || null;
		return Xi().then(() => Re(Z, pe, Y)).then(k => k && pk(k)).catch(k => R(k, Z, pe))
	}
	const Ae = Z => r.go(Z);
	let ze;
	const K = new Set,
		ye = {
			currentRoute: l,
			listening: !0,
			addRoute: f,
			removeRoute: p,
			hasRoute: g,
			getRoutes: _,
			resolve: m,
			options: n,
			push: y,
			replace: x,
			go: Ae,
			back: () => Ae(-1),
			forward: () => Ae(1),
			beforeEach: s.add,
			beforeResolve: o.add,
			afterEach: a.add,
			onError: F.add,
			isReady: Q,
			install(Z) {
				const pe = this;
				Z.component("RouterLink", zk), Z.component("RouterView", F3), Z.config.globalProperties.$router = pe, Object.defineProperty(Z.config.globalProperties, "$route", {
					enumerable: !0,
					get: () => fe(l)
				}), hc && !ze && l.value === Qr && (ze = !0, y(r.location).catch(Re => {}));
				const ce = {};
				for (const Re in Qr) Object.defineProperty(ce, Re, {
					get: () => l.value[Re],
					enumerable: !0
				});
				Z.provide(Nm, pe), Z.provide(O3, gd(ce)), Z.provide(k_, l);
				const Ce = Z.unmount;
				K.add(Z), Z.unmount = function () {
					K.delete(Z), K.size < 1 && (c = Qr, j && j(), j = null, l.value = Qr, ze = !1, G = !1), Ce()
				}
			}
		};

	function Se(Z) {
		return Z.reduce((pe, ce) => pe.then(() => P(ce)), Promise.resolve())
	}
	return ye
}

function jk(n, e) {
	const t = [],
		i = [],
		r = [],
		s = Math.max(e.matched.length, n.matched.length);
	for (let o = 0; o < s; o++) {
		const a = e.matched[o];
		a && (n.matched.find(c => Yc(c, a)) ? i.push(a) : t.push(a));
		const l = n.matched[o];
		l && (e.matched.find(c => Yc(c, l)) || r.push(l))
	}
	return [t, i, r]
}
const $k = (n, e) => e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, t => {
		var i;
		return ((i = n.params[t.slice(1)]) == null ? void 0 : i.toString()) || ""
	}),
	I_ = (n, e) => {
		const t = n.route.matched.find(r => {
				var s;
				return ((s = r.components) == null ? void 0 : s.default) === n.Component.type
			}),
			i = e ?? (t == null ? void 0 : t.meta.key) ?? (t && $k(n.route, t));
		return typeof i == "function" ? i(n.route) : i
	},
	qk = (n, e) => ({
		default: () => n ? on(YR, n === !0 ? {} : n, e) : e
	});

function x1(n) {
	return Array.isArray(n) ? n : [n]
}
const nr = {
		middleware: "page-transition"
	},
	ir = {
		middleware: "page-transition"
	},
	rr = {
		middleware: "page-transition"
	},
	sr = {
		middleware: "page-transition"
	},
	or = {
		middleware: "page-transition"
	},
	mx = [{
		name: (nr == null ? void 0 : nr.name) ?? "about",
		path: (nr == null ? void 0 : nr.path) ?? "/about",
		meta: nr || {},
		alias: (nr == null ? void 0 : nr.alias) || [],
		redirect: nr == null ? void 0 : nr.redirect,
		component: () => ft(() => import("./about.B-aplnQ4.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]),
			import.meta.url).then(n => n.default || n)
	}, {
		name: (ir == null ? void 0 : ir.name) ?? "index",
		path: (ir == null ? void 0 : ir.path) ?? "/",
		meta: ir || {},
		alias: (ir == null ? void 0 : ir.alias) || [],
		redirect: ir == null ? void 0 : ir.redirect,
		component: () => ft(() => import("./index.CJ4KHoTM.js"), __vite__mapDeps([24, 3, 4, 6, 7, 25, 26, 27, 13, 28, 29, 30, 9, 10, 11, 1, 2, 12, 14, 15, 5, 8, 16, 17, 18, 19, 20, 21, 22, 31]),
			import.meta.url).then(n => n.default || n)
	}, {
		name: (rr == null ? void 0 : rr.name) ?? "lab",
		path: (rr == null ? void 0 : rr.path) ?? "/lab",
		meta: rr || {},
		alias: (rr == null ? void 0 : rr.alias) || [],
		redirect: rr == null ? void 0 : rr.redirect,
		component: () => ft(() => import("./lab.BusM9PiM.js"), __vite__mapDeps([32, 22, 33]),
			import.meta.url).then(n => n.default || n)
	}, {
		name: (sr == null ? void 0 : sr.name) ?? "work-slug",
		path: (sr == null ? void 0 : sr.path) ?? "/work/:slug()",
		meta: sr || {},
		alias: (sr == null ? void 0 : sr.alias) || [],
		redirect: sr == null ? void 0 : sr.redirect,
		component: () => ft(() => import("./_slug_.BZ6K_0di.js"), __vite__mapDeps([34, 27, 13, 28, 1, 2, 26, 29, 16, 17, 6, 7, 18, 19, 20, 21, 22, 35]),
			import.meta.url).then(n => n.default || n)
	}, {
		name: (or == null ? void 0 : or.name) ?? "work",
		path: (or == null ? void 0 : or.path) ?? "/work",
		meta: or || {},
		alias: (or == null ? void 0 : or.alias) || [],
		redirect: or == null ? void 0 : or.redirect,
		component: () => ft(() => import("./index.kMqy-Dg0.js"), __vite__mapDeps([36, 25, 6, 7, 26, 27, 13, 28, 29, 30, 16, 17, 18, 19, 20, 21, 22, 37]),
			import.meta.url).then(n => n.default || n)
	}],
	Xk = (n, e, t) => (e = e === !0 ? {} : e, {
		default: () => {
			var i;
			return e ? on(n, e, t) : (i = t.default) == null ? void 0 : i.call(t)
		}
	});

function gx(n) {
	const e = (n == null ? void 0 : n.meta.key) ?? n.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, t => {
		var i;
		return ((i = n.params[t.slice(1)]) == null ? void 0 : i.toString()) || ""
	});
	return typeof e == "function" ? e(n) : e
}

function Yk(n, e) {
	return n === e || e === Qr ? !1 : gx(n) !== gx(e) ? !0 : !n.matched.every((i, r) => {
		var s, o;
		return i.components && i.components.default === ((o = (s = e.matched[r]) == null ? void 0 : s.components) == null ? void 0 : o.default)
	})
}
const Kk = {
	scrollBehavior(n, e, t) {
		var c;
		const i = Ke(),
			r = ((c = Sr().options) == null ? void 0 : c.scrollBehaviorType) ?? "auto";
		let s = t || void 0;
		const o = typeof n.meta.scrollToTop == "function" ? n.meta.scrollToTop(n, e) : n.meta.scrollToTop;
		if (!s && e && n && o !== !1 && Yk(n, e) && (s = {
				left: 0,
				top: 0
			}), n.path === e.path) {
			if (e.hash && !n.hash) return {
				left: 0,
				top: 0
			};
			if (n.hash) return {
				el: n.hash,
				top: _x(n.hash),
				behavior: r
			}
		}
		const a = u => !!(u.meta.pageTransition ?? P_),
			l = a(e) && a(n) ? "page:transition:finish" : "page:finish";
		return new Promise(u => {
			i.hooks.hookOnce(l, async () => {
				await Xi(), n.hash && (s = {
					el: n.hash,
					top: _x(n.hash),
					behavior: r
				}), u(s)
			})
		})
	}
};

function _x(n) {
	try {
		const e = document.querySelector(n);
		if (e) return parseFloat(getComputedStyle(e).scrollMarginTop)
	} catch {}
	return 0
}
const Zk = {
		hashMode: !1,
		scrollBehaviorType: "auto"
	},
	ar = {
		...Zk,
		...Kk
	},
	Jk = async n => {
		var l;
		let e, t;
		if (!((l = n.meta) != null && l.validate)) return;
		const i = Ke(),
			r = Sr();
		if (([e, t] = Xc(() => Promise.resolve(n.meta.validate(n))), e = await e, t(), e) === !0) return;
		const o = bd({
				statusCode: 404,
				statusMessage: `Page Not Found: ${n.fullPath}`,
				data: {
					path: n.fullPath
				}
			}),
			a = r.beforeResolve(c => {
				if (a(), c === n) {
					const u = r.afterEach(async () => {
						u(), await i.runWithContext(() => vc(o)), window.history.pushState({}, "", n.fullPath)
					});
					return !1
				}
			})
	}, Qk = async n => {
		let e, t;
		const i = ([e, t] = Xc(() => y3(n.path)), e = await e, t(), e);
		if (i.redirect) return i.redirect
	}, eI = [Jk, Qk], ph = {
		"page-transition": () => ft(() => import("./pageTransition.CHvjBzA7.js"), __vite__mapDeps([]),
			import.meta.url)
	};

function tI(n, e, t) {
	const {
		pathname: i,
		search: r,
		hash: s
	} = e, o = n.indexOf("#");
	if (o > -1) {
		const c = s.includes(n.slice(o)) ? n.slice(o).length : 1;
		let u = s.slice(c);
		return u[0] !== "/" && (u = "/" + u), ky(u, "")
	}
	const a = ky(i, n),
		l = !t || PL(a, t, {
			trailingSlash: !0
		}) ? a : t;
	return l + (l.includes("?") ? "" : r) + s
}
const nI = un({
		name: "nuxt:router",
		enforce: "pre",
		async setup(n) {
			var _, g;
			let e, t, i = Ma().app.baseURL;
			ar.hashMode && !i.includes("#") && (i += "#");
			const r = ((_ = ar.history) == null ? void 0 : _.call(ar, i)) ?? (ar.hashMode ? yk(i) : P3(i)),
				s = ((g = ar.routes) == null ? void 0 : g.call(ar, mx)) ?? mx;
			let o;
			const a = tI(i, window.location, n.payload.path),
				l = Wk({
					...ar,
					scrollBehavior: (m, b, v) => {
						if (b === Qr) {
							o = v;
							return
						}
						if (ar.scrollBehavior) {
							if (l.options.scrollBehavior = ar.scrollBehavior, "scrollRestoration" in window.history) {
								const y = l.beforeEach(() => {
									y(), window.history.scrollRestoration = "manual"
								})
							}
							return ar.scrollBehavior(m, Qr, o || v)
						}
					},
					history: r,
					routes: s
				});
			"scrollRestoration" in window.history && (window.history.scrollRestoration = "auto"), n.vueApp.use(l);
			const c = Wc(l.currentRoute.value);
			l.afterEach((m, b) => {
				c.value = b
			}), Object.defineProperty(n.vueApp.config.globalProperties, "previousRoute", {
				get: () => c.value
			});
			const u = Wc(l.resolve(a)),
				h = () => {
					u.value = l.currentRoute.value
				};
			n.hook("page:finish", h), l.afterEach((m, b) => {
				var v, y, x, S;
				((y = (v = m.matched[0]) == null ? void 0 : v.components) == null ? void 0 : y.default) === ((S = (x = b.matched[0]) == null ? void 0 : x.components) == null ? void 0 : S.default) && h()
			});
			const d = {};
			for (const m in u.value) Object.defineProperty(d, m, {
				get: () => u.value[m]
			});
			n._route = gd(d), n._middleware = n._middleware || {
				global: [],
				named: {}
			};
			const f = km();
			try {
				[e, t] = Xc(() => l.isReady()), await e, t()
			} catch (m) {
				[e, t] = Xc(() => n.runWithContext(() => vc(m))), await e, t()
			}
			const p = n.payload.state._layout;
			return l.beforeEach(async (m, b) => {
				var v;
				await n.callHook("page:loading:start"), m.meta = Ii(m.meta), n.isHydrating && p && !Gc(m.meta.layout) && (m.meta.layout = p), n._processingMiddleware = !0; {
					const y = new Set([...eI, ...n._middleware.global]);
					for (const x of m.matched) {
						const S = x.meta.middleware;
						if (S)
							for (const E of x1(S)) y.add(E)
					}
					for (const x of y) {
						const S = typeof x == "string" ? n._middleware.named[x] || await ((v = ph[x]) == null ? void 0 : v.call(ph).then(C => C.default || C)) : x;
						if (!S) throw new Error(`Unknown route middleware: '${x}'.`);
						const E = await n.runWithContext(() => S(m, b));
						if (!n.payload.serverRendered && n.isHydrating && (E === !1 || E instanceof Error)) {
							const C = E || M_({
								statusCode: 404,
								statusMessage: `Page Not Found: ${a}`
							});
							return await n.runWithContext(() => vc(C)), !1
						}
						if (E !== !0 && (E || E === !1)) return E
					}
				}
			}), l.onError(async () => {
				delete n._processingMiddleware, await n.callHook("page:loading:end")
			}), l.afterEach(async (m, b, v) => {
				delete n._processingMiddleware, !n.isHydrating && f.value && await n.runWithContext(O5), v && await n.callHook("page:loading:end"), m.matched.length === 0 && await n.runWithContext(() => vc(M_({
					statusCode: 404,
					fatal: !1,
					statusMessage: `Page not found: ${m.fullPath}`,
					data: {
						path: m.fullPath
					}
				})))
			}), n.hooks.hookOnce("app:created", async () => {
				try {
					await l.replace({
						...l.resolve(a),
						name: void 0,
						force: !0
					}), l.options.scrollBehavior = ar.scrollBehavior
				} catch (m) {
					await n.runWithContext(() => vc(m))
				}
			}), {
				provide: {
					router: l
				}
			}
		}
	}),
	iI = "$s";

function rI(...n) {
	const e = typeof n[n.length - 1] == "string" ? n.pop() : void 0;
	typeof n[0] != "string" && n.unshift(e);
	const [t, i] = n;
	if (!t || typeof t != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + t);
	if (i !== void 0 && typeof i != "function") throw new Error("[nuxt] [useState] init must be a function: " + i);
	const r = iI + t,
		s = Ke(),
		o = Sm(s.payload.state, r);
	if (o.value === void 0 && i) {
		const a = i();
		if (bn(a)) return s.payload.state[r] = a, a;
		o.value = a
	}
	return o
}
const sI = un({
		name: "nuxt-site-config:init",
		enforce: "pre",
		async setup(n) {
			const e = rI("site-config");
			let t = {};
			return t = e.value || window.__NUXT_SITE_CONFIG__, {
				provide: {
					nuxtSiteConfig: t
				}
			}
		}
	}),
	O_ = globalThis.requestIdleCallback || (n => {
		const e = Date.now(),
			t = {
				didTimeout: !1,
				timeRemaining: () => Math.max(0, 50 - (Date.now() - e))
			};
		return setTimeout(() => {
			n(t)
		}, 1)
	}),
	oI = globalThis.cancelIdleCallback || (n => {
		clearTimeout(n)
	}),
	yd = n => {
		const e = Ke();
		e.isHydrating ? e.hooks.hookOnce("app:suspense:resolve", () => {
			O_(n)
		}) : O_(n)
	},
	aI = un({
		name: "nuxt:payload",
		setup(n) {
			Sr().beforeResolve(async (e, t) => {
				if (e.path === t.path) return;
				const i = await Ky(e.path);
				i && Object.assign(n.static.data, i.data)
			}), yd(() => {
				var e;
				n.hooks.hook("link:prefetch", async t => {
					bu(t).protocol || await Ky(t)
				}), ((e = navigator.connection) == null ? void 0 : e.effectiveType) !== "slow-2g" && setTimeout(Om, 1e3)
			})
		}
	}),
	lI = un(n => {
		let e;
		async function t() {
			const i = await Om();
			e && clearTimeout(e), e = setTimeout(t, 1e3 * 60 * 60);
			const r = await $fetch(_1("builds/latest.json"));
			r.id !== i.id && n.hooks.callHook("app:manifest:update", r)
		}
		yd(() => {
			e = setTimeout(t, 1e3 * 60 * 60)
		})
	}),
	cI = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let N3;
const xd = n => N3 = n,
	U3 = Symbol();

function F_(n) {
	return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function"
}
var mh;
(function (n) {
	n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function"
})(mh || (mh = {}));

function uI() {
	const n = $v(!0),
		e = n.run(() => tt({}));
	let t = [],
		i = [];
	const r = e1({
		install(s) {
			xd(r), r._a = s, s.provide(U3, r), s.config.globalProperties.$pinia = r, i.forEach(o => t.push(o)), i = []
		},
		use(s) {
			return !this._a && !cI ? i.push(s) : t.push(s), this
		},
		_p: t,
		_a: null,
		_e: n,
		_s: new Map,
		state: e
	});
	return r
}
const B3 = () => {};

function vx(n, e, t, i = B3) {
	n.push(e);
	const r = () => {
		const s = n.indexOf(e);
		s > -1 && (n.splice(s, 1), i())
	};
	return !t && wm() && qv(r), r
}

function Ul(n, ...e) {
	n.slice().forEach(t => {
		t(...e)
	})
}
const hI = n => n();

function N_(n, e) {
	n instanceof Map && e instanceof Map && e.forEach((t, i) => n.set(i, t)), n instanceof Set && e instanceof Set && e.forEach(n.add, n);
	for (const t in e) {
		if (!e.hasOwnProperty(t)) continue;
		const i = e[t],
			r = n[t];
		F_(r) && F_(i) && n.hasOwnProperty(t) && !bn(i) && !na(i) ? n[t] = N_(r, i) : n[t] = i
	}
	return n
}
const dI = Symbol();

function fI(n) {
	return !F_(n) || !n.hasOwnProperty(dI)
}
const {
	assign: Oo
} = Object;

function pI(n) {
	return !!(bn(n) && n.effect)
}

function mI(n, e, t, i) {
	const {
		state: r,
		actions: s,
		getters: o
	} = e, a = t.state.value[n];
	let l;

	function c() {
		a || (t.state.value[n] = r ? r() : {});
		const u = xR(t.state.value[n]);
		return Oo(u, s, Object.keys(o || {}).reduce((h, d) => (h[d] = e1(Be(() => {
			xd(t);
			const f = t._s.get(n);
			return o[d].call(f, f)
		})), h), {}))
	}
	return l = z3(n, c, e, t, i, !0), l
}

function z3(n, e, t = {}, i, r, s) {
	let o;
	const a = Oo({
			actions: {}
		}, t),
		l = {
			deep: !0
		};
	let c, u, h = [],
		d = [],
		f;
	const p = i.state.value[n];
	!s && !p && (i.state.value[n] = {}), tt({});
	let _;

	function g(C) {
		let P;
		c = u = !1, typeof C == "function" ? (C(i.state.value[n]), P = {
			type: mh.patchFunction,
			storeId: n,
			events: f
		}) : (N_(i.state.value[n], C), P = {
			type: mh.patchObject,
			payload: C,
			storeId: n,
			events: f
		});
		const w = _ = Symbol();
		Xi().then(() => {
			_ === w && (c = !0)
		}), u = !0, Ul(h, P, i.state.value[n])
	}
	const m = s ? function () {
		const {
			state: P
		} = t, w = P ? P() : {};
		this.$patch(D => {
			Oo(D, w)
		})
	} : B3;

	function b() {
		o.stop(), h = [], d = [], i._s.delete(n)
	}

	function v(C, P) {
		return function () {
			xd(i);
			const w = Array.from(arguments),
				D = [],
				U = [];

			function j(F) {
				D.push(F)
			}

			function z(F) {
				U.push(F)
			}
			Ul(d, {
				args: w,
				name: C,
				store: x,
				after: j,
				onError: z
			});
			let H;
			try {
				H = P.apply(this && this.$id === n ? this : x, w)
			} catch (F) {
				throw Ul(U, F), F
			}
			return H instanceof Promise ? H.then(F => (Ul(D, F), F)).catch(F => (Ul(U, F), Promise.reject(F))) : (Ul(D, H), H)
		}
	}
	const y = {
			_p: i,
			$id: n,
			$onAction: vx.bind(null, d),
			$patch: g,
			$reset: m,
			$subscribe(C, P = {}) {
				const w = vx(h, C, P.detached, () => D()),
					D = o.run(() => Vt(() => i.state.value[n], U => {
						(P.flush === "sync" ? u : c) && C({
							storeId: n,
							type: mh.direct,
							events: f
						}, U)
					}, Oo({}, l, P)));
				return w
			},
			$dispose: b
		},
		x = Ii(y);
	i._s.set(n, x);
	const E = (i._a && i._a.runWithContext || hI)(() => i._e.run(() => (o = $v()).run(e)));
	for (const C in E) {
		const P = E[C];
		if (bn(P) && !pI(P) || na(P)) s || (p && fI(P) && (bn(P) ? P.value = p[C] : N_(P, p[C])), i.state.value[n][C] = P);
		else if (typeof P == "function") {
			const w = v(C, P);
			E[C] = w, a.actions[C] = P
		}
	}
	return Oo(x, E), Oo(Mt(x), E), Object.defineProperty(x, "$state", {
		get: () => i.state.value[n],
		set: C => {
			g(P => {
				Oo(P, C)
			})
		}
	}), i._p.forEach(C => {
		Oo(x, o.run(() => C({
			store: x,
			app: i._a,
			pinia: i,
			options: a
		})))
	}), p && s && t.hydrate && t.hydrate(x.$state, p), c = !0, u = !0, x
}

function V3(n, e, t) {
	let i, r;
	const s = typeof e == "function";
	typeof n == "string" ? (i = n, r = s ? t : e) : (r = n, i = n.id);

	function o(a, l) {
		const c = u1();
		return a = a || (c ? si(U3, null) : null), a && xd(a), a = N3, a._s.has(i) || (s ? z3(i, e, r, a) : mI(i, r, a)), a._s.get(i)
	}
	return o.$id = i, o
}

function $t(n) {
	{
		n = Mt(n);
		const e = {};
		for (const t in n) {
			const i = n[t];
			(bn(i) || na(i)) && (e[t] = Sm(n, t))
		}
		return e
	}
}
const gI = n => n === "defer" || n === !1;

function Za(...n) {
	var p;
	const e = typeof n[n.length - 1] == "string" ? n.pop() : void 0;
	typeof n[0] != "string" && n.unshift(e);
	let [t, i, r = {}] = n;
	if (typeof t != "string") throw new TypeError("[nuxt] [asyncData] key must be a string.");
	if (typeof i != "function") throw new TypeError("[nuxt] [asyncData] handler must be a function.");
	const s = Ke(),
		o = i,
		a = () => null,
		l = () => s.isHydrating ? s.payload.data[t] : s.static.data[t];
	r.server = r.server ?? !0, r.default = r.default ?? a, r.getCachedData = r.getCachedData ?? l, r.lazy = r.lazy ?? !1, r.immediate = r.immediate ?? !0, r.deep = r.deep ?? I6.deep, r.dedupe = r.dedupe ?? "cancel";
	const c = () => ![null, void 0].includes(r.getCachedData(t));
	if (!s._asyncData[t] || !r.immediate) {
		(p = s.payload._errors)[t] ?? (p[t] = null);
		const _ = r.deep ? tt : Wc;
		s._asyncData[t] = {
			data: _(r.getCachedData(t) ?? r.default()),
			pending: tt(!c()),
			error: Sm(s.payload._errors, t),
			status: tt("idle")
		}
	}
	const u = {
		...s._asyncData[t]
	};
	u.refresh = u.execute = (_ = {}) => {
		if (s._asyncDataPromises[t]) {
			if (gI(_.dedupe ?? r.dedupe)) return s._asyncDataPromises[t];
			s._asyncDataPromises[t].cancelled = !0
		}
		if ((_._initial || s.isHydrating && _._initial !== !1) && c()) return Promise.resolve(r.getCachedData(t));
		u.pending.value = !0, u.status.value = "pending";
		const g = new Promise((m, b) => {
			try {
				m(o(s))
			} catch (v) {
				b(v)
			}
		}).then(m => {
			if (g.cancelled) return s._asyncDataPromises[t];
			let b = m;
			r.transform && (b = r.transform(m)), r.pick && (b = _I(b, r.pick)), s.payload.data[t] = b, u.data.value = b, u.error.value = null, u.status.value = "success"
		}).catch(m => {
			if (g.cancelled) return s._asyncDataPromises[t];
			u.error.value = bd(m), u.data.value = fe(r.default()), u.status.value = "error"
		}).finally(() => {
			g.cancelled || (u.pending.value = !1, delete s._asyncDataPromises[t])
		});
		return s._asyncDataPromises[t] = g, s._asyncDataPromises[t]
	};
	const h = () => u.refresh({
			_initial: !0
		}),
		d = r.server !== !1 && s.payload.serverRendered; {
		const _ = vu();
		if (_ && !_._nuxtOnBeforeMountCbs) {
			_._nuxtOnBeforeMountCbs = [];
			const m = _._nuxtOnBeforeMountCbs;
			_ && (l1(() => {
				m.forEach(b => {
					b()
				}), m.splice(0, m.length)
			}), Yi(() => m.splice(0, m.length)))
		}
		d && s.isHydrating && (u.error.value || c()) ? (u.pending.value = !1, u.status.value = u.error.value ? "error" : "success") : _ && (s.payload.serverRendered && s.isHydrating || r.lazy) && r.immediate ? _._nuxtOnBeforeMountCbs.push(h) : r.immediate && h(), r.watch && Vt(r.watch, () => u.refresh());
		const g = s.hook("app:data:refresh", async m => {
			(!m || m.includes(t)) && await u.refresh()
		});
		_ && Yi(g)
	}
	const f = Promise.resolve(s._asyncDataPromises[t]).then(() => u);
	return Object.assign(f, u), f
}
async function U_(n) {
	await new Promise(t => yd(t)), await Ke().hooks.callHookParallel("app:data:refresh", void 0)
}

function _I(n, e) {
	const t = {};
	for (const i of e) t[i] = n[i];
	return t
}
const vI = {
	path: "/",
	watch: !0,
	decode: n => Hh(decodeURIComponent(n)),
	encode: n => encodeURIComponent(typeof n == "string" ? n : JSON.stringify(n))
};

function bx(n, e) {
	var l;
	const t = {
			...vI,
			...e
		},
		i = yx(t) || {};
	let r;
	t.maxAge !== void 0 ? r = t.maxAge * 1e3 : t.expires && (r = t.expires.getTime() - Date.now());
	const s = r !== void 0 && r <= 0,
		o = ls(s ? void 0 : i[n] ?? ((l = t.default) == null ? void 0 : l.call(t))),
		a = r && !s ? xI(o, r) : tt(o); {
		const c = typeof BroadcastChannel > "u" ? null : new BroadcastChannel(`nuxt:cookies:${n}`),
			u = () => {
				t.readonly || E5(a.value, i[n]) || (yI(n, a.value, t), i[n] = ls(a.value), c == null || c.postMessage({
					value: t.encode(a.value)
				}))
			},
			h = f => {
				var _;
				const p = f.refresh ? (_ = yx(t)) == null ? void 0 : _[n] : t.decode(f.value);
				d = !0, i[n] = a.value = p, Xi(() => {
					d = !1
				})
			};
		let d = !1;
		wm() && qv(() => {
			d = !0, u(), c == null || c.close()
		}), c && (c.onmessage = ({
			data: f
		}) => h(f)), t.watch ? Vt(a, () => {
			d || u()
		}, {
			deep: t.watch !== "shallow"
		}) : u()
	}
	return a
}

function yx(n = {}) {
	return g5(document.cookie, n)
}

function bI(n, e, t = {}) {
	return e == null ? Uy(n, e, {
		...t,
		maxAge: -1
	}) : Uy(n, e, t)
}

function yI(n, e, t = {}) {
	document.cookie = bI(n, e, t)
}
const xx = 2147483647;

function xI(n, e) {
	let t, i = 0;
	return wm() && qv(() => {
		clearTimeout(t)
	}), yR((r, s) => {
		function o() {
			clearTimeout(t);
			const a = e - i,
				l = a < xx ? a : xx;
			t = setTimeout(() => {
				if (i += l, i < e) return o();
				n = void 0, s()
			}, l)
		}
		return {
			get() {
				return r(), n
			},
			set(a) {
				o(), n = a, s()
			}
		}
	})
}
async function H3(n, e = Sr()) {
	const {
		path: t,
		matched: i
	} = e.resolve(n);
	if (!i.length || (e._routePreloaded || (e._routePreloaded = new Set), e._routePreloaded.has(t))) return;
	const r = e._preloadPromises = e._preloadPromises || [];
	if (r.length > 4) return Promise.all(r).then(() => H3(n, e));
	e._routePreloaded.add(t);
	const s = i.map(o => {
		var a;
		return (a = o.components) == null ? void 0 : a.default
	}).filter(o => typeof o == "function");
	for (const o of s) {
		const a = Promise.resolve(o()).catch(() => {}).finally(() => r.splice(r.indexOf(a)));
		r.push(a)
	}
	await Promise.all(r)
}

function B_(n = {}) {
	const e = n.path || window.location.pathname;
	let t = {};
	try {
		t = Hh(sessionStorage.getItem("nuxt:reload") || "{}")
	} catch {}
	if (n.force || (t == null ? void 0 : t.path) !== e || (t == null ? void 0 : t.expires) < Date.now()) {
		try {
			sessionStorage.setItem("nuxt:reload", JSON.stringify({
				path: e,
				expires: Date.now() + (n.ttl ?? 1e4)
			}))
		} catch {}
		if (n.persistState) try {
			sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
				state: Ke().payload.state
			}))
		} catch {}
		window.location.pathname !== e ? window.location.href = e : window.location.reload()
	}
}
const wI = Symbol.for("nuxt:client-only"),
	G3 = Qi({
		name: "ClientOnly",
		inheritAttrs: !1,
		props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
		setup(n, {
			slots: e,
			attrs: t
		}) {
			const i = tt(!1);
			return Vn(() => {
				i.value = !0
			}), al(wI, !0), r => {
				var l;
				if (i.value) return (l = e.default) == null ? void 0 : l.call(e);
				const s = e.fallback || e.placeholder;
				if (s) return s();
				const o = r.fallback || r.placeholder || "",
					a = r.fallbackTag || r.placeholderTag || "span";
				return Ye(a, t, o)
			}
		}
	}),
	EI = (...n) => n.find(e => e !== void 0);

function SI(n) {
	const e = n.componentName || "NuxtLink";

	function t(i, r) {
		if (!i || n.trailingSlash !== "append" && n.trailingSlash !== "remove") return i;
		if (typeof i == "string") return wx(i, n.trailingSlash);
		const s = "path" in i ? i.path : r(i).path;
		return {
			...i,
			name: void 0,
			path: wx(s, n.trailingSlash)
		}
	}
	return Qi({
		name: e,
		props: {
			to: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			href: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			target: {
				type: String,
				default: void 0,
				required: !1
			},
			rel: {
				type: String,
				default: void 0,
				required: !1
			},
			noRel: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			prefetch: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			noPrefetch: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			activeClass: {
				type: String,
				default: void 0,
				required: !1
			},
			exactActiveClass: {
				type: String,
				default: void 0,
				required: !1
			},
			prefetchedClass: {
				type: String,
				default: void 0,
				required: !1
			},
			replace: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			ariaCurrentValue: {
				type: String,
				default: void 0,
				required: !1
			},
			external: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			custom: {
				type: Boolean,
				default: void 0,
				required: !1
			}
		},
		setup(i, {
			slots: r
		}) {
			const s = Sr(),
				o = Ma(),
				a = Be(() => {
					const p = i.to || i.href || "";
					return t(p, s.resolve)
				}),
				l = Be(() => typeof a.value == "string" && ao(a.value, {
					acceptRelative: !0
				})),
				c = Be(() => i.target && i.target !== "_self"),
				u = Be(() => i.external || c.value ? !0 : typeof a.value == "object" ? !1 : a.value === "" || l.value),
				h = tt(!1),
				d = tt(null),
				f = p => {
					var _;
					d.value = i.custom ? (_ = p == null ? void 0 : p.$el) == null ? void 0 : _.nextElementSibling : p == null ? void 0 : p.$el
				};
			if (i.prefetch !== !1 && i.noPrefetch !== !0 && i.target !== "_blank" && !MI()) {
				const _ = Ke();
				let g, m = null;
				Vn(() => {
					const b = TI();
					yd(() => {
						g = O_(() => {
							var v;
							(v = d == null ? void 0 : d.value) != null && v.tagName && (m = b.observe(d.value, async () => {
								m == null || m(), m = null;
								const y = typeof a.value == "string" ? a.value : s.resolve(a.value).fullPath;
								await Promise.all([_.hooks.callHook("link:prefetch", y).catch(() => {}), !u.value && H3(a.value, s).catch(() => {})]), h.value = !0
							}))
						})
					})
				}), Sa(() => {
					g && oI(g), m == null || m(), m = null
				})
			}
			return () => {
				var b, v;
				if (!u.value) {
					const y = {
						ref: f,
						to: a.value,
						activeClass: i.activeClass || n.activeClass,
						exactActiveClass: i.exactActiveClass || n.exactActiveClass,
						replace: i.replace,
						ariaCurrentValue: i.ariaCurrentValue,
						custom: i.custom
					};
					return i.custom || (h.value && (y.class = i.prefetchedClass || n.prefetchedClass), y.rel = i.rel || void 0), on(kR("RouterLink"), y, r.default)
				}
				const p = typeof a.value == "object" ? ((b = s.resolve(a.value)) == null ? void 0 : b.href) ?? null : a.value && !i.external && !l.value ? t(Ta(o.app.baseURL, a.value), s.resolve) : a.value || null,
					_ = i.target || null,
					g = EI(i.noRel ? "" : i.rel, n.externalRelAttribute, l.value || c.value ? "noopener noreferrer" : "") || null,
					m = () => I5(p, {
						replace: i.replace
					});
				return i.custom ? r.default ? r.default({
					href: p,
					navigate: m,
					get route() {
						if (!p) return;
						const y = bu(p);
						return {
							path: y.pathname,
							fullPath: y.pathname,
							get query() {
								return Pp(y.search)
							},
							hash: y.hash,
							params: {},
							name: void 0,
							matched: [],
							redirectedFrom: void 0,
							meta: {},
							href: p
						}
					},
					rel: g,
					target: _,
					isExternal: u.value,
					isActive: !1,
					isExactActive: !1
				}) : null : on("a", {
					ref: d,
					href: p,
					rel: g,
					target: _
				}, (v = r.default) == null ? void 0 : v.call(r))
			}
		}
	})
}
const Zc = SI(k6);

function wx(n, e) {
	const t = e === "append" ? Rp : Pm;
	return ao(n) && !n.startsWith("http") ? n : t(n, !0)
}

function TI() {
	const n = Ke();
	if (n._observer) return n._observer;
	let e = null;
	const t = new Map,
		i = (s, o) => (e || (e = new IntersectionObserver(a => {
			for (const l of a) {
				const c = t.get(l.target);
				(l.isIntersecting || l.intersectionRatio > 0) && c && c()
			}
		})), t.set(s, o), e.observe(s), () => {
			t.delete(s), e.unobserve(s), t.size === 0 && (e.disconnect(), e = null)
		});
	return n._observer = {
		observe: i
	}
}

function MI() {
	const n = navigator.connection;
	return !!(n && (n.saveData || /2g/.test(n.effectiveType)))
}
const CI = un(n => {
		const e = uI();
		return n.vueApp.use(e), xd(e), n.payload && n.payload.pinia && (e.state.value = n.payload.pinia), {
			provide: {
				pinia: e
			}
		}
	}),
	AI = xt(() => ft(() => Promise.resolve().then(() => rQ), void 0,
		import.meta.url).then(n => n.default)),
	DI = xt(() => ft(() => import("./AnimatedHeadline.CwK2fN5k.js"), __vite__mapDeps([38, 39]),
		import.meta.url).then(n => n.default)),
	PI = xt(() => ft(() => Promise.resolve().then(() => vZ), void 0,
		import.meta.url).then(n => n.default)),
	RI = xt(() => ft(() => import("./BackToTop.Ct9BdGRn.js"), __vite__mapDeps([40, 41]),
		import.meta.url).then(n => n.default)),
	LI = xt(() => ft(() => Promise.resolve().then(() => MZ), void 0,
		import.meta.url).then(n => n.default)),
	kI = xt(() => ft(() => Promise.resolve().then(() => cJ), void 0,
		import.meta.url).then(n => n.default)),
	II = xt(() => ft(() => import("./Contact.Dv1i-ire.js"), __vite__mapDeps([17, 6, 7, 18]),
		import.meta.url).then(n => n.default)),
	OI = xt(() => ft(() => Promise.resolve().then(() => QZ), void 0,
		import.meta.url).then(n => n.default)),
	FI = xt(() => ft(() => Promise.resolve().then(() => sJ), void 0,
		import.meta.url).then(n => n.default)),
	NI = xt(() => ft(() => Promise.resolve().then(() => rJ), void 0,
		import.meta.url).then(n => n.default)),
	UI = xt(() => ft(() => import("./Footer.BzOP24eX.js"), __vite__mapDeps([16, 17, 6, 7, 18, 19, 20, 21]),
		import.meta.url).then(n => n.default)),
	BI = xt(() => ft(() => import("./Gridlines.BOfamoPD.js"), __vite__mapDeps([42, 43]),
		import.meta.url).then(n => n.default)),
	zI = xt(() => ft(() => Promise.resolve().then(() => WZ), void 0,
		import.meta.url).then(n => n.default)),
	VI = xt(() => ft(() => Promise.resolve().then(() => BZ), void 0,
		import.meta.url).then(n => n.default)),
	HI = xt(() => ft(() => Promise.resolve().then(() => bZ), void 0,
		import.meta.url).then(n => n.default)),
	GI = xt(() => ft(() => Promise.resolve().then(() => wQ), void 0,
		import.meta.url).then(n => n.default)),
	WI = xt(() => ft(() => Promise.resolve().then(() => iJ), void 0,
		import.meta.url).then(n => n.default)),
	jI = xt(() => ft(() => import("./List.CGDOyJDT.js"), __vite__mapDeps([5, 6, 7, 8]),
		import.meta.url).then(n => n.default)),
	$I = xt(() => ft(() => import("./Marquee.UdWGFVIb.js"), __vite__mapDeps([9, 10]),
		import.meta.url).then(n => n.default)),
	qI = xt(() => ft(() => Promise.resolve().then(() => dJ), void 0,
		import.meta.url).then(n => n.default)),
	XI = xt(() => ft(() => Promise.resolve().then(() => oJ), void 0,
		import.meta.url).then(n => n.default)),
	YI = xt(() => ft(() => Promise.resolve().then(() => NZ), void 0,
		import.meta.url).then(n => n.default)),
	KI = xt(() => ft(() => import("./NavBackButton.D5nV_Bw7.js"), __vite__mapDeps([44, 45]),
		import.meta.url).then(n => n.default)),
	ZI = xt(() => ft(() => Promise.resolve().then(() => PZ), void 0,
		import.meta.url).then(n => n.default)),
	JI = xt(() => ft(() => Promise.resolve().then(() => wZ), void 0,
		import.meta.url).then(n => n.default)),
	QI = xt(() => ft(() => Promise.resolve().then(() => GZ), void 0,
		import.meta.url).then(n => n.default)),
	eO = xt(() => ft(() => Promise.resolve().then(() => pZ), void 0,
		import.meta.url).then(n => n.default)),
	tO = xt(() => ft(() => import("./Reel.B9_2rTtk.js"), __vite__mapDeps([3, 4]),
		import.meta.url).then(n => n.default)),
	nO = xt(() => ft(() => import("./SectionTitle.JKfXi8mY.js"), __vite__mapDeps([6, 7]),
		import.meta.url).then(n => n.default)),
	iO = xt(() => ft(() => import("./ServiceItem.m6MsAAC-.js"), __vite__mapDeps([12, 13, 14]),
		import.meta.url).then(n => n.default)),
	rO = xt(() => ft(() => import("./Services.DoNqskIp.js"), __vite__mapDeps([11, 1, 2, 6, 7, 12, 13, 14, 15]),
		import.meta.url).then(n => n.default)),
	sO = xt(() => ft(() => import("./SocialLink.CJVG2S-b.js"), __vite__mapDeps([19, 20]),
		import.meta.url).then(n => n.default)),
	oO = xt(() => ft(() => Promise.resolve().then(() => tte), void 0,
		import.meta.url).then(n => n.default)),
	aO = xt(() => ft(() => import("./Tag.IeZyhnI-.js"), __vite__mapDeps([27, 13, 28]),
		import.meta.url).then(n => n.default)),
	lO = xt(() => ft(() => Promise.resolve().then(() => gZ), void 0,
		import.meta.url).then(n => n.default)),
	cO = xt(() => ft(() => import("./WorkItem.kXh1J7BL.js"), __vite__mapDeps([26, 27, 13, 28, 29]),
		import.meta.url).then(n => n.default)),
	uO = xt(() => ft(() => import("./WorkList.BrTaW_iV.js"), __vite__mapDeps([25, 6, 7, 26, 27, 13, 28, 29, 30]),
		import.meta.url).then(n => n.default)),
	hO = [
		["Accordion", AI],
		["AnimatedHeadline", DI],
		["AnimatedLabel", PI],
		["BackToTop", RI],
		["Border", LI],
		["ButtonClose", kI],
		["Contact", II],
		["CursorCustom", OI],
		["CursorTrigger", FI],
		["Curtain", NI],
		["Footer", UI],
		["Gridlines", BI],
		["Header", zI],
		["HeaderContactButton", VI],
		["HeaderLogo", HI],
		["InViewTracker", GI],
		["LandscapeOrientation", WI],
		["List", jI],
		["Marquee", $I],
		["Modal", qI],
		["ModalOverlay", XI],
		["Nav", YI],
		["NavBackButton", KI],
		["NavContactButton", ZI],
		["NavItem", JI],
		["NavToggle", QI],
		["Preloader", eO],
		["Reel", tO],
		["SectionTitle", nO],
		["ServiceItem", iO],
		["Services", rO],
		["SocialLink", sO],
		["SvgSprite", oO],
		["Tag", aO],
		["TextSplitter", lO],
		["WorkItem", cO],
		["WorkList", uO]
	],
	dO = un({
		name: "nuxt:global-components",
		setup(n) {
			for (const [e, t] of hO) n.vueApp.component(e, t), n.vueApp.component("Lazy" + e, t)
		}
	}),
	tf = {},
	fO = un({
		name: "nuxt:prefetch",
		setup(n) {
			const e = Sr();
			n.hooks.hook("app:mounted", () => {
				e.beforeEach(async t => {
					var r;
					const i = (r = t == null ? void 0 : t.meta) == null ? void 0 : r.layout;
					i && typeof tf[i] == "function" && await tf[i]()
				})
			}), n.hooks.hook("link:prefetch", t => {
				if (ao(t)) return;
				const i = e.resolve(t);
				if (!i) return;
				const r = i.meta.layout;
				let s = x1(i.meta.middleware);
				s = s.filter(o => typeof o == "string");
				for (const o of s) typeof ph[o] == "function" && ph[o]();
				r && typeof tf[r] == "function" && tf[r]()
			})
		}
	});

function D0(...n) {
	var e;
	(e = window.dataLayer) == null || e.push(arguments)
}

function pO({
	tags: n
}) {
	window.dataLayer = window.dataLayer || [];
	for (const e of n)
		for (const t of e.initCommands ?? []) D0(...t);
	D0("js", new Date);
	for (const e of n) D0("config", e.id, e.config)
}

function mO(n) {
	const e = Mt(n),
		t = e.tags.filter(Boolean).map(i => typeof i == "string" ? {
			id: i
		} : i);
	if (n.id) {
		const {
			id: i,
			config: r,
			initCommands: s
		} = e;
		t.unshift({
			id: i,
			config: r,
			initCommands: s
		})
	}
	return t
}
const gO = un({
		parallel: !0,
		setup() {
			const n = Ma().public.gtag,
				e = mO(n);
			if (!e.length || (pO({
					tags: e
				}), !n.enabled)) return;
			const t = n.loadingStrategy === "async" ? "async" : "defer";
			Im({
				script: [{
					src: g1(n.url, {
						id: e[0].id
					}),
					[t]: !0,
					"data-gtag": ""
				}]
			})
		}
	}),
	_O = un(n => {
		Ma().public.prismic.preview && window.addEventListener("prismicPreviewUpdate", t => {
			t.preventDefault(), U_()
		})
	}),
	gs = {
		heading1: "heading1",
		heading2: "heading2",
		heading3: "heading3",
		heading4: "heading4",
		heading5: "heading5",
		heading6: "heading6",
		paragraph: "paragraph",
		preformatted: "preformatted",
		strong: "strong",
		em: "em",
		listItem: "list-item",
		oListItem: "o-list-item",
		list: "group-list-item",
		oList: "group-o-list-item",
		image: "image",
		embed: "embed",
		hyperlink: "hyperlink",
		label: "label",
		span: "span"
	},
	W3 = n => Array.isArray(n) ? `[${n.map(W3).join(", ")}]` : typeof n == "string" ? `"${n}"` : n instanceof Date ? `${n.getTime()}` : `${n}`,
	Gt = n => (t, ...i) => {
		const r = i.map(W3).join(", "),
			s = t && i.length ? ", " : "";
		return `[${n}(${t}${s}${r})]`
	},
	Ex = n => {
		const e = Gt(n);
		return i => e(i)
	},
	vO = n => {
		const e = Gt(n);
		return (...i) => e("", ...i)
	},
	fs = {
		at: Gt("at"),
		not: Gt("not"),
		any: Gt("any"),
		in: Gt("in"),
		fulltext: Gt("fulltext"),
		has: Ex("has"),
		missing: Ex("missing"),
		similar: vO("similar"),
		geopointNear: Gt("geopoint.near"),
		numberLessThan: Gt("number.lt"),
		numberGreaterThan: Gt("number.gt"),
		numberInRange: Gt("number.inRange"),
		dateAfter: Gt("date.after"),
		dateBefore: Gt("date.before"),
		dateBetween: Gt("date.between"),
		dateDayOfMonth: Gt("date.day-of-month"),
		dateDayOfMonthAfter: Gt("date.day-of-month-after"),
		dateDayOfMonthBefore: Gt("date.day-of-month-before"),
		dateDayOfWeek: Gt("date.day-of-week"),
		dateDayOfWeekAfter: Gt("date.day-of-week-after"),
		dateDayOfWeekBefore: Gt("date.day-of-week-before"),
		dateMonth: Gt("date.month"),
		dateMonthAfter: Gt("date.month-after"),
		dateMonthBefore: Gt("date.month-before"),
		dateYear: Gt("date.year"),
		dateHour: Gt("date.hour"),
		dateHourAfter: Gt("date.hour-after"),
		dateHourBefore: Gt("date.hour-before")
	},
	Wo = n => Array.isArray(n) ? n : [n],
	bi = (n = {}, e) => ({
		...n,
		filters: [...n.filters || [], ...Wo(e)]
	}),
	bO = n => typeof n == "function" ? n : () => n,
	Sx = n => fs.at("document.tags", Wo(n));
var yO = Object.defineProperty,
	xO = (n, e, t) => e in n ? yO(n, e, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: t
	}) : n[e] = t,
	Tx = (n, e, t) => (xO(n, typeof e != "symbol" ? e + "" : e, t), t);
class bs extends Error {
	constructor(e = "An invalid API response was returned", t, i) {
		super(e), Tx(this, "url"), Tx(this, "response"), this.url = t, this.response = i
	}
}
const w1 = (n, e) => {
		const t = n.find(i => e(i));
		if (!t) throw new bs("Ref could not be found.", void 0, void 0);
		return t
	},
	Mx = n => w1(n, e => e.isMasterRef),
	P0 = (n, e) => w1(n, t => t.id === e),
	R0 = (n, e) => w1(n, t => t.label === e),
	j3 = "io.prismic.preview",
	wO = Object.freeze(Object.defineProperty({
		__proto__: null,
		preview: j3
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	Cx = n => n.replace(/%3B/g, ";"),
	EO = n => {
		const e = n.split("; ");
		let t;
		for (const i of e) {
			const r = i.split("=");
			if (Cx(r[0]).replace(/%3D/g, "=") === j3) {
				t = Cx(r.slice(1).join("="));
				break
			}
		}
		return t
	},
	SO = n => n.replace(/(\n| )*( |{|})(\n| )*/gm, (e, t, i) => i),
	nf = n => fs.any("document.tags", Wo(n)),
	Bl = n => fs.at("document.type", n);
class Um extends bs {}
class z_ extends bs {}
class TO extends bs {}
class MO extends Um {}
class CO extends Um {}
class AO extends Um {}
class DO extends z_ {}
const $o = {
		Any: "Any",
		Document: "Document",
		Media: "Media",
		Web: "Web"
	},
	$3 = n => {
		var e;
		return {
			link_type: $o.Document,
			id: n.id,
			uid: n.uid || void 0,
			type: n.type,
			tags: n.tags,
			lang: n.lang,
			url: n.url == null ? void 0 : n.url,
			slug: (e = n.slugs) == null ? void 0 : e[0],
			...n.data && Object.keys(n.data).length > 0 ? {
				data: n.data
			} : {}
		}
	},
	wd = (n, ...e) => {
		if (!n) return null;
		const t = "link_type" in n ? n : $3(n),
			[i] = e;
		let r;
		switch (typeof i == "function" || i == null ? r = {
			linkResolver: i
		} : r = {
			...i
		}, t.link_type) {
			case $o.Media:
			case $o.Web:
				return "url" in t ? t.url : null;
			case $o.Document: {
				if ("id" in t && r.linkResolver) {
					const s = r.linkResolver(t);
					if (s != null) return s
				}
				return "url" in t && t.url ? t.url : null
			}
			case $o.Any:
			default:
				return null
		}
	},
	PO = {
		accessToken: "access_token"
	},
	RO = n => typeof n == "string" ? n : n.direction === "desc" ? `${n.field} desc` : n.field,
	LO = (n, e) => {
		const {
			filters: t,
			predicates: i,
			...r
		} = e, s = new URL("documents/search", `${n}/`);
		if (t)
			for (const o of Wo(t)) s.searchParams.append("q", `[${o}]`);
		if (i)
			for (const o of Wo(i)) s.searchParams.append("q", `[${o}]`);
		for (const o in r) {
			const a = PO[o] || o;
			let l = r[o];
			if (a === "orderings") {
				const c = r[a];
				c != null && (l = `[${Wo(c).map(h=>RO(h)).join(",")}]`)
			} else a === "routes" && typeof r[a] == "object" && (l = JSON.stringify(Wo(r[a])));
			l != null && s.searchParams.set(a, Wo(l).join(","))
		}
		return s.toString()
	},
	kO = n => /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(n),
	IO = n => {
		if (kO(n)) return `https://${n}.cdn.prismic.io/api/v2`;
		throw new bs(`An invalid Prismic repository name was given: ${n}`, void 0, void 0)
	},
	OO = n => {
		try {
			return new URL(n).hostname.split(".")[0]
		} catch {
			throw new bs(`An invalid Prismic Rest API V2 endpoint was provided: ${n}`, void 0, void 0)
		}
	},
	q3 = n => {
		try {
			return new URL(n), !0
		} catch {
			return !1
		}
	};
var FO = Object.defineProperty,
	NO = (n, e, t) => e in n ? FO(n, e, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: t
	}) : n[e] = t,
	Xr = (n, e, t) => (NO(n, typeof e != "symbol" ? e + "" : e, t), t);
const UO = 100,
	BO = 5e3,
	zO = 500,
	VO = 1e3;
var cs;
(function (n) {
	n.Master = "Master", n.ReleaseID = "ReleaseID", n.ReleaseLabel = "ReleaseLabel", n.Manual = "Manual"
})(cs || (cs = {}));
const HO = (n, e) => new GO(n, e);
class GO {
	constructor(e, t = {}) {
		if (Xr(this, "endpoint"), Xr(this, "accessToken"), Xr(this, "routes"), Xr(this, "brokenRoute"), Xr(this, "fetchFn"), Xr(this, "fetchOptions"), Xr(this, "defaultParams"), Xr(this, "refState", {
				mode: cs.Master,
				autoPreviewsEnabled: !0
			}), Xr(this, "cachedRepository"), Xr(this, "cachedRepositoryExpiration", 0), Xr(this, "fetchJobs", {}), q3(e) ? this.endpoint = e : this.endpoint = IO(e), this.accessToken = t.accessToken, this.routes = t.routes, this.brokenRoute = t.brokenRoute, this.fetchOptions = t.fetchOptions, this.defaultParams = t.defaultParams, t.ref && this.queryContentFromRef(t.ref), typeof t.fetch == "function") this.fetchFn = t.fetch;
		else if (typeof globalThis.fetch == "function") this.fetchFn = globalThis.fetch;
		else throw new bs("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.", void 0, void 0);
		this.fetchFn === globalThis.fetch && (this.fetchFn = this.fetchFn.bind(globalThis)), this.graphQLFetch = this.graphQLFetch.bind(this)
	}
	enableAutoPreviews() {
		this.refState.autoPreviewsEnabled = !0
	}
	enableAutoPreviewsFromReq(e) {
		this.refState.httpRequest = e, this.refState.autoPreviewsEnabled = !0
	}
	disableAutoPreviews() {
		this.refState.autoPreviewsEnabled = !1
	}
	async get(e) {
		const t = await this.buildQueryURL(e);
		return await this.fetch(t, e)
	}
	async getFirst(e) {
		var t;
		const i = {
			...e
		};
		!(e && e.page) && !(e != null && e.pageSize) && (i.pageSize = ((t = this.defaultParams) == null ? void 0 : t.pageSize) ?? 1);
		const r = await this.buildQueryURL(i),
			o = (await this.fetch(r, e)).results[0];
		if (o) return o;
		throw new z_("No documents were returned", r, void 0)
	}
	async dangerouslyGetAll(e = {}) {
		var t;
		const {
			limit: i = 1 / 0,
			...r
		} = e, s = {
			...r,
			pageSize: Math.min(i, r.pageSize || ((t = this.defaultParams) == null ? void 0 : t.pageSize) || UO)
		}, o = [];
		let a;
		for (;
			(!a || a.next_page) && o.length < i;) {
			const l = a ? a.page + 1 : void 0;
			a = await this.get({
				...s,
				page: l
			}), o.push(...a.results), a.next_page && await new Promise(c => setTimeout(c, zO))
		}
		return o.slice(0, i)
	}
	async getByID(e, t) {
		return await this.getFirst(bi(t, fs.at("document.id", e)))
	}
	async getByIDs(e, t) {
		return await this.get(bi(t, fs.in("document.id", e)))
	}
	async getAllByIDs(e, t) {
		return await this.dangerouslyGetAll(bi(t, fs.in("document.id", e)))
	}
	async getByUID(e, t, i) {
		return await this.getFirst(bi(i, [Bl(e), fs.at(`my.${e}.uid`, t)]))
	}
	async getByUIDs(e, t, i) {
		return await this.get(bi(i, [Bl(e), fs.in(`my.${e}.uid`, t)]))
	}
	async getAllByUIDs(e, t, i) {
		return await this.dangerouslyGetAll(bi(i, [Bl(e), fs.in(`my.${e}.uid`, t)]))
	}
	async getSingle(e, t) {
		return await this.getFirst(bi(t, Bl(e)))
	}
	async getByType(e, t) {
		return await this.get(bi(t, Bl(e)))
	}
	async getAllByType(e, t) {
		return await this.dangerouslyGetAll(bi(t, Bl(e)))
	}
	async getByTag(e, t) {
		return await this.get(bi(t, nf(e)))
	}
	async getAllByTag(e, t) {
		return await this.dangerouslyGetAll(bi(t, nf(e)))
	}
	async getByEveryTag(e, t) {
		return await this.get(bi(t, Sx(e)))
	}
	async getAllByEveryTag(e, t) {
		return await this.dangerouslyGetAll(bi(t, Sx(e)))
	}
	async getBySomeTags(e, t) {
		return await this.get(bi(t, nf(e)))
	}
	async getAllBySomeTags(e, t) {
		return await this.dangerouslyGetAll(bi(t, nf(e)))
	}
	async getRepository(e) {
		const t = new URL(this.endpoint);
		return this.accessToken && t.searchParams.set("access_token", this.accessToken), await this.fetch(t.toString(), e)
	}
	async getRefs(e) {
		return (await this.getRepository(e)).refs
	}
	async getRefByID(e, t) {
		const i = await this.getRefs(t);
		return P0(i, e)
	}
	async getRefByLabel(e, t) {
		const i = await this.getRefs(t);
		return R0(i, e)
	}
	async getMasterRef(e) {
		const t = await this.getRefs(e);
		return Mx(t)
	}
	async getReleases(e) {
		return (await this.getRefs(e)).filter(i => !i.isMasterRef)
	}
	async getReleaseByID(e, t) {
		const i = await this.getReleases(t);
		return P0(i, e)
	}
	async getReleaseByLabel(e, t) {
		const i = await this.getReleases(t);
		return R0(i, e)
	}
	async getTags(e) {
		try {
			const t = await this.getCachedRepositoryForm("tags", e),
				i = new URL(t.action);
			return this.accessToken && i.searchParams.set("access_token", this.accessToken), await this.fetch(i.toString(), e)
		} catch {
			return (await this.getRepository(e)).tags
		}
	}
	async buildQueryURL({
		signal: e,
		fetchOptions: t,
		...i
	} = {}) {
		const r = i.ref || await this.getResolvedRefString({
				signal: e,
				fetchOptions: t
			}),
			s = i.integrationFieldsRef || (await this.getCachedRepository({
				signal: e,
				fetchOptions: t
			})).integrationFieldsRef || void 0;
		return LO(this.endpoint, {
			...this.defaultParams,
			...i,
			ref: r,
			integrationFieldsRef: s,
			routes: i.routes || this.routes,
			brokenRoute: i.brokenRoute || this.brokenRoute,
			accessToken: i.accessToken || this.accessToken
		})
	}
	async resolvePreviewURL(e) {
		var t, i;
		let r = e.documentID,
			s = e.previewToken;
		if (typeof globalThis.location < "u") {
			const o = new URLSearchParams(globalThis.location.search);
			r = r || o.get("documentId"), s = s || o.get("token")
		} else if (this.refState.httpRequest) {
			if ("query" in this.refState.httpRequest) r = r || ((t = this.refState.httpRequest.query) == null ? void 0 : t.documentId), s = s || ((i = this.refState.httpRequest.query) == null ? void 0 : i.token);
			else if ("url" in this.refState.httpRequest && this.refState.httpRequest.url) {
				const o = new URL(this.refState.httpRequest.url, "missing-host://").searchParams;
				r = r || o.get("documentId"), s = s || o.get("token")
			}
		}
		if (r != null && s != null) {
			const o = await this.getByID(r, {
					ref: s,
					lang: "*",
					signal: e.signal,
					fetchOptions: e.fetchOptions
				}),
				a = wd(o, {
					linkResolver: e.linkResolver
				});
			if (typeof a == "string") return a
		}
		return e.defaultURL
	}
	queryLatestContent() {
		this.refState.mode = cs.Master
	}
	queryContentFromReleaseByID(e) {
		this.refState = {
			...this.refState,
			mode: cs.ReleaseID,
			releaseID: e
		}
	}
	queryContentFromReleaseByLabel(e) {
		this.refState = {
			...this.refState,
			mode: cs.ReleaseLabel,
			releaseLabel: e
		}
	}
	queryContentFromRef(e) {
		this.refState = {
			...this.refState,
			mode: cs.Manual,
			ref: e
		}
	}
	async graphQLFetch(e, t) {
		const i = await this.getCachedRepository(),
			r = await this.getResolvedRefString(),
			s = {
				"Prismic-ref": r,
				Authorization: this.accessToken ? `Token ${this.accessToken}` : "",
				...t ? t.headers : {}
			};
		i.integrationFieldsRef && (s["Prismic-integration-field-ref"] = i.integrationFieldsRef);
		const o = {};
		for (const c in s) s[c] && (o[c.toLowerCase()] = s[c]);
		const a = new URL(e);
		a.searchParams.set("ref", r);
		const l = a.searchParams.get("query");
		return l && a.searchParams.set("query", SO(l)), await this.fetchFn(a.toString(), {
			...t,
			headers: o
		})
	}
	async getCachedRepository(e) {
		return (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) && (this.cachedRepositoryExpiration = Date.now() + BO, this.cachedRepository = await this.getRepository(e)), this.cachedRepository
	}
	async getCachedRepositoryForm(e, t) {
		const r = (await this.getCachedRepository(t)).forms[e];
		if (!r) throw new bs(`Form with name "${e}" could not be found`, void 0, void 0);
		return r
	}
	async getResolvedRefString(e) {
		var t, i;
		if (this.refState.autoPreviewsEnabled) {
			let o, a;
			if ((t = this.refState.httpRequest) != null && t.headers ? "get" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get == "function" ? a = this.refState.httpRequest.headers.get("cookie") : "cookie" in this.refState.httpRequest.headers && (a = this.refState.httpRequest.headers.cookie) : (i = globalThis.document) != null && i.cookie && (a = globalThis.document.cookie), a && (o = EO(a)), o) return o
		}
		const r = await this.getCachedRepository(e),
			s = this.refState.mode;
		if (s === cs.ReleaseID) return P0(r.refs, this.refState.releaseID).ref;
		if (s === cs.ReleaseLabel) return R0(r.refs, this.refState.releaseLabel).ref;
		if (s === cs.Manual) {
			const o = await bO(this.refState.ref)();
			if (typeof o == "string") return o
		}
		return Mx(r.refs).ref
	}
	async fetch(e, t = {}) {
		var i, r, s, o;
		const a = {
			...this.fetchOptions,
			...t.fetchOptions,
			headers: {
				...(i = this.fetchOptions) == null ? void 0 : i.headers,
				...(r = t.fetchOptions) == null ? void 0 : r.headers
			},
			signal: ((s = t.fetchOptions) == null ? void 0 : s.signal) || t.signal || ((o = this.fetchOptions) == null ? void 0 : o.signal)
		};
		let l;
		this.fetchJobs[e] && this.fetchJobs[e].has(a.signal) ? l = this.fetchJobs[e].get(a.signal) : (this.fetchJobs[e] = this.fetchJobs[e] || new Map, l = this.fetchFn(e, a).then(async u => {
			let h;
			try {
				h = await u.json()
			} catch {}
			return {
				status: u.status,
				headers: u.headers,
				json: h
			}
		}).finally(() => {
			this.fetchJobs[e].delete(a.signal), this.fetchJobs[e].size === 0 && delete this.fetchJobs[e]
		}), this.fetchJobs[e].set(a.signal, l));
		const c = await l;
		if (c.status !== 404 && c.json == null) throw new bs(void 0, e, c.json);
		switch (c.status) {
			case 200:
				return c.json;
			case 400:
				throw new TO(c.json.message, e, c.json);
			case 401:
			case 403:
				throw new Um(c.json.error || c.json.message, e, c.json);
			case 404:
				throw c.json === void 0 ? new DO(`Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`, e, void 0) : c.json.type === "api_notfound_error" ? new AO(c.json.message, e, c.json) : c.json.type === "api_security_error" && /preview token.*expired/i.test(c.json.message) ? new MO(c.json.message, e, c.json) : new z_(c.json.message, e, c.json);
			case 410:
				throw new CO(c.json.message, e, c.json);
			case 429: {
				const u = Number(c.headers.get("retry-after")),
					h = Number.isNaN(u) ? VO : u;
				return await new Promise((d, f) => {
					setTimeout(async () => {
						try {
							d(await this.fetch(e, t))
						} catch (p) {
							f(p)
						}
					}, h)
				})
			}
		}
		throw new bs(void 0, e, c.json)
	}
}
const WO = n => n ? n.length === 24 ? new Date(n.replace(/(\+|-)(\d{2})(\d{2})$/, ".000$1$2:$3")) : new Date(n) : null,
	jO = n => {
		const e = /^(\/(?!\/)|#)/.test(n),
			t = !e && !/^https?:\/\//.test(n);
		return e && !t
	},
	er = n => n != null,
	X3 = n => !!n.length,
	Bm = n => er(n) ? n.length === 1 && "text" in n[0] ? !!n[0].text : !!n.length : !1,
	$O = Bm,
	Ed = n => er(n) && !!n.url,
	Y3 = Ed,
	zm = n => er(n) && ("id" in n || "url" in n),
	qO = zm,
	XO = zm,
	YO = er,
	KO = er,
	ZO = er,
	JO = er,
	K3 = n => er(K3) && !!n,
	QO = er,
	eF = n => er(n) && !!n.embed_url,
	tF = n => er(n) && "longitude" in n,
	Z3 = er,
	nF = Z3,
	iF = n => er(n) && X3(n),
	rF = n => er(n) && X3(n),
	sF = Object.freeze(Object.defineProperty({
		__proto__: null,
		color: ZO,
		contentRelationship: XO,
		date: YO,
		embed: eF,
		geoPoint: tF,
		group: iF,
		image: Y3,
		imageThumbnail: Ed,
		integrationField: Z3,
		integrationFields: nF,
		keyText: K3,
		link: zm,
		linkToMedia: qO,
		number: JO,
		richText: Bm,
		select: QO,
		sliceZone: rF,
		timestamp: KO,
		title: $O
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	oF = (n, e = {}) => {
		if (n && ("link_type" in n ? zm(n) : n)) {
			const t = "target" in n ? n.target : void 0,
				i = wd(n, e.linkResolver),
				r = i ?? void 0,
				s = typeof r == "string" ? !jO(r) : !1,
				o = e.rel ? e.rel({
					href: r,
					isExternal: s,
					target: t
				}) : s ? "noreferrer" : void 0;
			return {
				href: r,
				target: t,
				rel: o ?? void 0
			}
		}
		return {}
	},
	aF = (n, e = " ") => {
		let t = "";
		for (let i = 0; i < n.length; i++) "text" in n[i] && (t += (t ? e : "") + n[i].text);
		return t
	},
	J3 = (n, ...e) => {
		if (n) {
			const [t] = e;
			let i;
			return typeof t == "string" ? i = {
				separator: t
			} : i = {
				...t
			}, aF(n, i.separator)
		} else return null
	},
	lF = /["'&<>]/,
	E1 = n => {
		const e = "" + n,
			t = lF.exec(e);
		if (!t) return e;
		let i, r = "",
			s = 0,
			o = 0;
		for (s = t.index; s < e.length; s++) {
			switch (e.charCodeAt(s)) {
				case 34:
					i = "&quot;";
					break;
				case 38:
					i = "&amp;";
					break;
				case 39:
					i = "&#39;";
					break;
				case 60:
					i = "&lt;";
					break;
				case 62:
					i = "&gt;";
					break;
				default:
					continue
			}
			o !== s && (r += e.substring(o, s)), o = s + 1, r += i
		}
		return o !== s ? r + e.substring(o, s) : r
	},
	Sd = (n, e) => {
		const t = {
			...e
		};
		"data" in n && "label" in n.data && n.data.label && (t.class = t.class ? `${t.class} ${n.data.label}` : n.data.label);
		const i = [];
		for (const r in t) {
			const s = t[r];
			s && (typeof s == "boolean" ? i.push(r) : i.push(`${r}="${E1(s)}"`))
		}
		return i.length && i.unshift(""), i.join(" ")
	},
	Td = n => n && typeof n != "function" ? n : {},
	Ni = (n, e) => {
		const t = Td(e);
		return ({
			node: i,
			children: r
		}) => `<${n}${Sd(i,t)}>${r}</${n}>`
	},
	cF = n => {
		const e = Td(n);
		return ({
			node: t
		}) => `<pre${Sd(t,e)}>${E1(t.text)}</pre>`
	},
	uF = (n, e) => {
		const t = Td(e);
		return ({
			node: i
		}) => {
			const r = {
				...t,
				src: i.url,
				alt: i.alt,
				copyright: i.copyright
			};
			let s = `<img${Sd(i,r)} />`;
			return i.linkTo && (s = Q3(n)({
				type: "hyperlink",
				node: {
					type: "hyperlink",
					data: i.linkTo,
					start: 0,
					end: 0
				},
				text: "",
				children: s,
				key: ""
			})), `<p class="block-img">${s}</p>`
		}
	},
	hF = n => {
		const e = Td(n);
		return ({
			node: t
		}) => {
			const i = {
				...e,
				"data-oembed": t.oembed.embed_url,
				"data-oembed-type": t.oembed.type,
				"data-oembed-provider": t.oembed.provider_name
			};
			return `<div${Sd(t,i)}>${t.oembed.html}</div>`
		}
	},
	Q3 = (n, e) => {
		const t = Td(e);
		return ({
			node: i,
			children: r
		}) => {
			const s = {
				...t
			};
			return i.data.link_type === $o.Web ? (s.href = i.data.url, s.target = i.data.target, s.rel = "noopener noreferrer") : i.data.link_type === $o.Document ? s.href = wd(i.data, {
				linkResolver: n
			}) : i.data.link_type === $o.Media && (s.href = i.data.url), `<a${Sd(i,s)}>${r}</a>`
		}
	},
	dF = () => ({
		text: n
	}) => n ? E1(n).replace(/\n/g, "<br />") : "",
	Vm = () => (++Vm.i).toString();
Vm.i = 0;
const fF = n => {
		const e = pF(n),
			t = [];
		for (let i = 0; i < e.length; i++) t.push(eM(e[i]));
		return {
			key: Vm(),
			children: t
		}
	},
	gh = (n, e = []) => ({
		key: Vm(),
		type: n.type,
		text: "text" in n ? n.text : void 0,
		node: n,
		children: e
	}),
	L0 = n => gh({
		type: gs.span,
		text: n,
		spans: []
	}),
	pF = n => {
		const e = n.slice(0);
		for (let t = 0; t < e.length; t++) {
			const i = e[t];
			if (i.type === gs.listItem || i.type === gs.oListItem) {
				const r = [i];
				for (; e[t + 1] && e[t + 1].type === i.type;) r.push(e[t + 1]), e.splice(t, 1);
				i.type === gs.listItem ? e[t] = {
					type: gs.list,
					items: r
				} : e[t] = {
					type: gs.oList,
					items: r
				}
			}
		}
		return e
	},
	eM = n => {
		if ("text" in n) return gh(n, tM(n.spans, n));
		if ("items" in n) {
			const e = [];
			for (let t = 0; t < n.items.length; t++) e.push(eM(n.items[t]));
			return gh(n, e)
		}
		return gh(n)
	},
	tM = (n, e, t) => {
		if (!n.length) return [L0(e.text)];
		const i = n.slice(0);
		i.sort((s, o) => s.start - o.start || o.end - s.end);
		const r = [];
		for (let s = 0; s < i.length; s++) {
			const o = i[s],
				a = t && t.start || 0,
				l = o.start - a,
				c = o.end - a,
				u = e.text.slice(l, c),
				h = [];
			for (let f = s; f < i.length; f++) {
				const p = i[f];
				p !== o && (p.start >= o.start && p.end <= o.end ? (h.push(p), i.splice(f, 1), f--) : p.start < o.end && p.end > o.start && (h.push({
					...p,
					end: o.end
				}), i[f] = {
					...p,
					start: o.end
				}))
			}
			s === 0 && l > 0 && r.push(L0(e.text.slice(0, l)));
			const d = {
				...o,
				text: u
			};
			r.push(gh(d, tM(h, {
				...e,
				text: u
			}, o))), c < e.text.length && r.push(L0(e.text.slice(c, i[s + 1] ? i[s + 1].start - a : void 0)))
		}
		return r
	},
	mF = (n, e) => nM(fF(n).children, e),
	nM = (n, e) => {
		const t = [];
		for (let i = 0; i < n.length; i++) {
			const r = n[i],
				s = e(r.type, r.node, r.text, nM(r.children, e), r.key);
			s != null && t.push(s)
		}
		return t
	},
	gF = {
		[gs.listItem]: "listItem",
		[gs.oListItem]: "oListItem",
		[gs.list]: "list",
		[gs.oList]: "oList"
	},
	_F = n => (e, t, i, r, s) => {
		const o = n[gF[e] || e];
		if (o) return o({
			type: e,
			node: t,
			text: i,
			children: r,
			key: s
		})
	},
	vF = (...n) => (...e) => {
		for (let t = 0; t < n.length; t++) {
			const i = n[t];
			if (i) {
				const r = i(...e);
				if (r != null) return r
			}
		}
	},
	k0 = (n, e) => {
		const t = (r, s) => typeof r == "function" ? o => r(o) || s(o) : s,
			i = {
				heading1: t(e == null ? void 0 : e.heading1, Ni("h1", e == null ? void 0 : e.heading1)),
				heading2: t(e == null ? void 0 : e.heading2, Ni("h2", e == null ? void 0 : e.heading2)),
				heading3: t(e == null ? void 0 : e.heading3, Ni("h3", e == null ? void 0 : e.heading3)),
				heading4: t(e == null ? void 0 : e.heading4, Ni("h4", e == null ? void 0 : e.heading4)),
				heading5: t(e == null ? void 0 : e.heading5, Ni("h5", e == null ? void 0 : e.heading5)),
				heading6: t(e == null ? void 0 : e.heading6, Ni("h6", e == null ? void 0 : e.heading6)),
				paragraph: t(e == null ? void 0 : e.paragraph, Ni("p", e == null ? void 0 : e.paragraph)),
				preformatted: t(e == null ? void 0 : e.preformatted, cF(e == null ? void 0 : e.preformatted)),
				strong: t(e == null ? void 0 : e.strong, Ni("strong", e == null ? void 0 : e.strong)),
				em: t(e == null ? void 0 : e.em, Ni("em", e == null ? void 0 : e.em)),
				listItem: t(e == null ? void 0 : e.listItem, Ni("li", e == null ? void 0 : e.listItem)),
				oListItem: t(e == null ? void 0 : e.oListItem, Ni("li", e == null ? void 0 : e.oListItem)),
				list: t(e == null ? void 0 : e.list, Ni("ul", e == null ? void 0 : e.list)),
				oList: t(e == null ? void 0 : e.oList, Ni("ol", e == null ? void 0 : e.oList)),
				image: t(e == null ? void 0 : e.image, uF(n, e == null ? void 0 : e.image)),
				embed: t(e == null ? void 0 : e.embed, hF(e == null ? void 0 : e.embed)),
				hyperlink: t(e == null ? void 0 : e.hyperlink, Q3(n, e == null ? void 0 : e.hyperlink)),
				label: t(e == null ? void 0 : e.label, Ni("span", e == null ? void 0 : e.label)),
				span: t(e == null ? void 0 : e.span, dF())
			};
		return bF(i)
	},
	bF = n => {
		const e = {};
		for (const t in n) {
			const i = n[t];
			i && (e[t] = r => i({
				...r,
				children: r.children.join("")
			}))
		}
		return _F(e)
	},
	iM = (n, ...e) => {
		if (n) {
			const [t, i] = e;
			let r;
			typeof t == "function" || t == null ? r = {
				linkResolver: t,
				serializer: i
			} : r = {
				...t
			};
			let s;
			return r.serializer ? typeof r.serializer == "function" ? s = vF((o, a, l, c, u) => r.serializer(o, a, l, c.join(""), u), k0(r.linkResolver)) : s = k0(r.linkResolver, r.serializer) : s = k0(r.linkResolver), mF(n, s).join("")
		} else return null
	},
	yF = n => n.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`),
	Md = (n, e) => {
		const t = new URL(n);
		for (const r in e) {
			const s = yF(r),
				o = e[r];
			o === void 0 ? t.searchParams.delete(s) : Array.isArray(o) ? t.searchParams.set(s, o.join(",")) : t.searchParams.set(s, `${o}`)
		}
		const i = t.searchParams.get("s");
		return i && (t.searchParams.delete("s"), t.searchParams.append("s", i)), t.toString()
	},
	xF = (n, {
		pixelDensities: e,
		...t
	}) => e.map(i => `${Md(n,{...t,dpr:i})} ${i}x`).join(", "),
	I0 = (n, {
		widths: e,
		...t
	}) => e.map(i => `${Md(n,{...t,w:void 0,width:i})} ${i}w`).join(", "),
	rM = (n, e = {}) => n && Ed(n) ? Md(n.url, e) : null,
	Ax = [640, 828, 1200, 2048, 3840],
	sM = (n, e = {}) => {
		if (n && Ed(n)) {
			let {
				widths: t = Ax,
				...i
			} = e;
			const {
				url: r,
				dimensions: s,
				id: o,
				alt: a,
				copyright: l,
				edit: c,
				...u
			} = n, h = Object.values(u);
			return t === "thumbnails" && h.length < 1 && (t = Ax), {
				src: Md(r, i),
				srcset: t === "thumbnails" ? [I0(r, {
					...i,
					widths: [s.width]
				}), ...h.map(d => I0(d.url, {
					...i,
					widths: [d.dimensions.width]
				}))].join(", ") : I0(n.url, {
					...i,
					widths: t
				})
			}
		} else return null
	},
	wF = [1, 2, 3],
	oM = (n, e = {}) => {
		if (n && Ed(n)) {
			const {
				pixelDensities: t = wF,
				...i
			} = e;
			return {
				src: Md(n.url, i),
				srcset: xF(n.url, {
					...i,
					pixelDensities: t
				})
			}
		} else return null
	},
	aM = Symbol("prismic"),
	EF = (n, e, t) => {
		if (typeof n == "string") return e.default && e.default(t);
		if (e.default) {
			const i = e.default(t);
			return {
				...e,
				default: () => i
			}
		} else return e
	},
	lM = n => {
		const e = /^\/(?!\/)/.test(n),
			t = !e && !/^https?:\/\//i.test(n);
		return e && !t
	},
	Ks = n => _u(n),
	Ls = () => si(aM, {
		options: {
			endpoint: ""
		}
	}),
	SF = "router-link",
	TF = "a",
	MF = "noopener noreferrer",
	CF = n => {
		const {
			options: e
		} = Ls(), t = Be(() => {
			var o, a;
			const l = fe(n.internalComponent) || ((o = e.components) == null ? void 0 : o.linkInternalComponent) || SF,
				c = fe(n.externalComponent) || ((a = e.components) == null ? void 0 : a.linkExternalComponent) || TF;
			return i.value && lM(i.value) && !r.value ? l : c
		}), i = Be(() => {
			const o = fe(n.field),
				a = fe(n.linkResolver) ?? e.linkResolver;
			return wd(o, a) ?? ""
		}), r = Be(() => {
			const o = fe(n.field),
				a = fe(n.target);
			return typeof a < "u" ? a : o && "target" in o && o.target ? o.target : null
		}), s = Be(() => {
			var o;
			const a = fe(n.rel);
			if (typeof a < "u") return a;
			if (r.value === "_blank") {
				const l = fe(n.blankTargetRelAttribute);
				return typeof l < "u" ? l : typeof ((o = e.components) == null ? void 0 : o.linkBlankTargetRelAttribute) < "u" ? e.components.linkBlankTargetRelAttribute : MF
			} else return null
		});
		return {
			type: t,
			href: i,
			target: r,
			rel: s
		}
	},
	AF = Qi({
		name: "PrismicLink",
		props: {
			field: {
				type: Object,
				required: !0
			},
			linkResolver: {
				type: Function,
				default: void 0,
				required: !1
			},
			target: {
				type: String,
				default: void 0,
				required: !1
			},
			rel: {
				type: String,
				default: void 0,
				required: !1
			},
			blankTargetRelAttribute: {
				type: String,
				default: void 0,
				required: !1
			},
			internalComponent: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			},
			externalComponent: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			}
		},
		setup(n, {
			slots: e
		}) {
			if (!n.field) return () => null;
			const {
				type: t,
				href: i,
				target: r,
				rel: s
			} = CF(n);
			return () => {
				const o = t.value === "a" ? "a" : Ks(t.value),
					a = EF(o, e, Ii({
						href: i.value
					}));
				return typeof o == "string" ? on(o, {
					href: i.value,
					target: r.value,
					rel: s.value
				}, a) : on(o, {
					to: i.value,
					target: r.value,
					rel: s.value
				}, a)
			}
		}
	}),
	Dx = AF,
	DF = "div",
	PF = Qi({
		name: "PrismicEmbed",
		props: {
			field: {
				type: Object,
				required: !0
			},
			wrapper: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			}
		},
		setup(n) {
			return n.field ? () => on(Ks(n.wrapper || DF), {
				"data-oembed": n.field.embed_url,
				"data-oembed-type": n.field.type,
				"data-oembed-provider": n.field.provider_name,
				innerHTML: n.field.html || null
			}) : () => null
		}
	}),
	Px = PF,
	RF = "img",
	LF = n => {
		const {
			options: e
		} = Ls(), t = Be(() => {
			var a, l;
			const c = fe(n.field);
			if (!Y3(c)) return {
				src: null,
				srcset: null
			};
			const u = fe(n.imgixParams),
				h = fe(n.widths),
				d = fe(n.pixelDensities);
			return h ? sM(c, {
				...u,
				widths: h === "defaults" ? (a = e.components) == null ? void 0 : a.imageWidthSrcSetDefaults : h
			}) : d ? oM(c, {
				...u,
				pixelDensities: d === "defaults" ? (l = e.components) == null ? void 0 : l.imagePixelDensitySrcSetDefaults : d
			}) : {
				src: rM(c, u),
				srcset: null
			}
		}), i = Be(() => t.value.src), r = Be(() => t.value.srcset), s = Be(() => fe(n.field).alt || ""), o = Be(() => fe(n.field).copyright || null);
		return {
			src: i,
			srcset: r,
			alt: s,
			copyright: o
		}
	},
	kF = Qi({
		name: "PrismicImage",
		props: {
			field: {
				type: Object,
				required: !0
			},
			imageComponent: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			imgixParams: {
				type: Object,
				default: void 0,
				required: !1
			},
			widths: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			pixelDensities: {
				type: [String, Object],
				default: void 0,
				required: !1
			}
		},
		setup(n) {
			if (!n.field) return () => null;
			const {
				options: e
			} = Ls(), t = Be(() => {
				var a;
				return n.imageComponent || ((a = e.components) == null ? void 0 : a.imageComponent) || RF
			}), {
				src: i,
				srcset: r,
				alt: s,
				copyright: o
			} = LF(n);
			return () => {
				const a = {
					src: i.value,
					srcset: r.value,
					alt: s.value
				};
				switch (t.value) {
					case "img":
						return on("img", a);
					default:
						return on(Ks(t.value), {
							...a,
							copyright: o.value
						})
				}
			}
		}
	}),
	Rx = kF,
	IF = "div",
	OF = n => ({
		text: Be(() => {
			const t = fe(n.field);
			return Bm(t) ? J3(fe(t), fe(n.separator)) : fe(n.fallback) ?? ""
		})
	}),
	FF = Qi({
		name: "PrismicText",
		props: {
			field: {
				type: Array,
				default: void 0,
				required: !1
			},
			separator: {
				type: String,
				default: void 0,
				required: !1
			},
			wrapper: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			},
			fallback: {
				type: String,
				default: void 0,
				required: !1
			}
		},
		setup(n) {
			const {
				text: e
			} = OF(n);
			return () => {
				const t = Ks(n.wrapper || IF);
				return on(t, null, {
					default: () => e.value
				})
			}
		}
	}),
	Lx = FF,
	NF = "div",
	UF = n => {
		const {
			options: e
		} = Ls();
		return {
			html: Be(() => {
				const i = fe(n.field);
				if (!Bm(i)) return fe(n.fallback) ?? "";
				const r = fe(n.linkResolver) ?? e.linkResolver,
					s = fe(n.serializer) ?? fe(n.htmlSerializer) ?? e.richTextSerializer ?? e.htmlSerializer;
				return iM(fe(i), r, s)
			})
		}
	},
	BF = Qi({
		name: "PrismicRichText",
		props: {
			field: {
				type: Array,
				default: void 0,
				required: !1
			},
			linkResolver: {
				type: Function,
				default: void 0,
				required: !1
			},
			serializer: {
				type: [Function, Object],
				default: void 0,
				required: !1
			},
			htmlSerializer: {
				type: [Function, Object],
				default: void 0,
				required: !1
			},
			wrapper: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			},
			fallback: {
				type: String,
				default: void 0,
				required: !1
			}
		},
		setup(n) {
			const {
				html: e
			} = UF(n), t = tt(null), i = si(Nm, null);
			if (i) {
				let r = [];
				const s = function (l) {
						l.preventDefault(), i.push(this.href)
					},
					o = () => {
						const l = t.value && "$el" in t.value ? t.value.$el : t.value;
						l && "querySelectorAll" in l && (r = Array.from(l.querySelectorAll("a")).map(c => {
							const u = c.getAttribute("href");
							if (u && lM(u)) {
								const h = s.bind({
									href: u
								});
								return c.addEventListener("click", h), {
									element: c,
									listener: h
								}
							} else return !1
						}).filter(c => c))
					},
					a = () => {
						r.forEach(({
							element: l,
							listener: c
						}) => l.removeEventListener("click", c)), r = []
					};
				Vt(e, () => {
					a(), Xi(o)
				}, {
					immediate: !0
				}), Sa(() => {
					a()
				})
			}
			return () => on(Ks(n.wrapper || NF), {
				innerHTML: e.value,
				ref: t
			})
		}
	}),
	kx = BF,
	zF = () => null,
	VF = Qi({
		name: "SliceZone",
		props: {
			slices: {
				type: Array,
				required: !0
			},
			components: {
				type: Object,
				default: void 0,
				required: !1
			},
			resolver: {
				type: Function,
				default: void 0,
				required: !1
			},
			context: {
				type: null,
				default: void 0,
				required: !1
			},
			defaultComponent: {
				type: Object,
				default: void 0,
				required: !1
			},
			wrapper: {
				type: [String, Object, Function],
				default: void 0,
				required: !1
			}
		},
		setup(n) {
			if (!n.slices) return () => null;
			const {
				options: e
			} = Ls(), t = Be(() => n.slices.map((i, r) => {
				var s;
				const o = "slice_type" in i ? i.slice_type : i.type;
				let a = n.components && o in n.components ? n.components[o] : n.defaultComponent || ((s = e.components) == null ? void 0 : s.sliceZoneDefaultComponent);
				if (n.resolver) {
					const c = n.resolver({
						slice: i,
						sliceName: o,
						i: r
					});
					c && (a = c)
				}
				const l = "id" in i && typeof i.id == "string" ? i.id : `${r}-${JSON.stringify(i)}`;
				if (a) {
					if (i.__mapped) {
						const {
							__mapped: c,
							...u
						} = i;
						return on(Ks(a), {
							key: l,
							...u
						})
					}
					return on(Ks(a), {
						key: l,
						slice: i,
						index: r,
						context: n.context,
						slices: n.slices
					})
				} else return on(Ks(zF), {
					key: l,
					slice: i
				})
			}));
			return () => {
				if (n.wrapper) {
					const i = Ks(n.wrapper);
					return typeof i == "string" ? on(i, null, t.value) : on(i, null, {
						default: () => t.value
					})
				} else return t.value
			}
		}
	}),
	Ix = VF,
	HF = n => {
		let e;
		return n.client ? e = n.client : e = HO(n.endpoint, {
			fetch: async (s, o) => {
				let a;
				return typeof globalThis.fetch == "function" ? a = globalThis.fetch : a = (await ft(() => import("./browser.BRwRRxrx.js").then(l => l.b), __vite__mapDeps([]),
					import.meta.url)).default, await a(s, o)
			},
			...n.clientConfig
		}), {
			options: n,
			...{
				client: e,
				filter: fs,
				cookie: wO
			},
			...{
				asText: J3,
				asHTML: (s, ...o) => {
					const [a, l] = o;
					return iM(s, typeof a == "function" || a == null ? {
						linkResolver: a || n.linkResolver,
						serializer: l || n.richTextSerializer || n.htmlSerializer
					} : {
						linkResolver: n.linkResolver,
						serializer: n.richTextSerializer || n.htmlSerializer,
						...a
					})
				},
				asLink: (s, o) => wd(s, typeof o == "function" ? {
					linkResolver: o
				} : {
					linkResolver: n.linkResolver,
					...o
				}),
				asLinkAttrs: (s, o) => oF(s, {
					linkResolver: n.linkResolver,
					...o
				}),
				asDate: WO,
				asImageSrc: rM,
				asImageWidthSrcSet: sM,
				asImagePixelDensitySrcSet: oM,
				isFilled: sF,
				documentToLinkField: $3
			},
			install(s) {
				s.provide(aM, this), s.config.globalProperties.$prismic = this, n.injectComponents !== !1 && (s.component(Dx.name, Dx), s.component(Px.name, Px), s.component(Rx.name, Rx), s.component(Lx.name, Lx), s.component(kx.name, kx), s.component(Ix.name, Ix))
			}
		}
	},
	rf = void 0,
	GF = void 0,
	WF = void 0,
	jF = un(n => {
		const e = Ma().public.prismic,
			t = e.environment || e.endpoint || (rf == null ? void 0 : rf.endpoint) || "",
			i = HF({
				...e,
				endpoint: t,
				client: rf,
				linkResolver: GF,
				richTextSerializer: WF,
				injectComponents: !1,
				components: {
					linkInternalComponent: Zc,
					linkExternalComponent: Zc,
					...e.components
				}
			});
		if (n.vueApp.use(i), e.preview) {
			const r = bx("io.prismic.preview").value;
			if (r) try {
				const s = typeof r == "string" ? JSON.parse(decodeURIComponent(r)) : r;
				if (Object.keys(s).some(o => o in s && typeof s[o] == "object" && s[o] !== null && "preview" in s[o] && s[o].preview)) {
					let o = !1;
					yd(() => {
						o || U_()
					}), Sr().afterEach(() => {
						o = !0, U_()
					})
				}
			} catch (s) {
				console.warn("Failed to parse Prismic preview cookie", s)
			}
		}
		if (e.toolbar) {
			const r = q3(t) ? OO(t) : t;
			Im({
				script: [{
					key: "prismic-preview",
					src: `https://static.cdn.prismic.io/prismic.min.js?repo=${r}&new=true`,
					async: !0,
					defer: !0,
					crossorigin: "anonymous"
				}]
			})
		} else bx("io.prismic.preview").value = null;
		return {
			provide: {
				prismic: i
			}
		}
	}),
	$F = un({
		name: "nuxt:chunk-reload",
		setup(n) {
			const e = Sr(),
				t = Ma(),
				i = new Set;
			e.beforeEach(() => {
				i.clear()
			}), n.hook("app:chunkError", ({
				error: s
			}) => {
				i.add(s)
			});

			function r(s) {
				const a = "href" in s && s.href[0] === "#" ? t.app.baseURL + s.href : Ta(t.app.baseURL, s.fullPath);
				B_({
					path: a,
					persistState: !0
				})
			}
			n.hook("app:manifest:update", () => {
				e.beforeResolve(r)
			}), e.onError((s, o) => {
				i.has(s) && r(o)
			})
		}
	}),
	qF = un({
		name: "credits",
		parallel: !0,
		async setup() {
			console.log("%c  Front-end by Thomas Aufresne — https://thomasaufresne.com  ", "background-color: #020202; color: #e9e7e2; font-size:10px; padding:8px 10px 6px; border-radius:4px;"), console.log("%c  WebGL by Paul Soulhiard — https://twitter.com/paulsoulhiard  ", "background-color: #020202; color: #e9e7e2; font-size:10px; padding:8px 10px 6px; border-radius:4px;")
		}
	}); /*! Tweakpane 4.0.3 (c) 2016 cocopon, licensed under the MIT license. */
function Kt(n) {
	return n == null
}

function S1(n) {
	return n !== null && typeof n == "object"
}

function V_(n) {
	return n !== null && typeof n == "object"
}

function XF(n, e) {
	if (n.length !== e.length) return !1;
	for (let t = 0; t < n.length; t++)
		if (n[t] !== e[t]) return !1;
	return !0
}

function xl(n, e) {
	return Array.from(new Set([...Object.keys(n), ...Object.keys(e)])).reduce((i, r) => {
		const s = n[r],
			o = e[r];
		return V_(s) && V_(o) ? Object.assign(Object.assign({}, i), {
			[r]: xl(s, o)
		}) : Object.assign(Object.assign({}, i), {
			[r]: r in e ? o : s
		})
	}, {})
}

function T1(n) {
	return S1(n) ? "target" in n : !1
}
const YF = {
	alreadydisposed: () => "View has been already disposed",
	invalidparams: n => `Invalid parameters for '${n.name}'`,
	nomatchingcontroller: n => `No matching controller for '${n.key}'`,
	nomatchingview: n => `No matching view for '${JSON.stringify(n.params)}'`,
	notbindable: () => "Value is not bindable",
	notcompatible: n => `Not compatible with  plugin '${n.id}'`,
	propertynotfound: n => `Property '${n.name}' not found`,
	shouldneverhappen: () => "This error should never happen"
};
class _n {
	static alreadyDisposed() {
		return new _n({
			type: "alreadydisposed"
		})
	}
	static notBindable() {
		return new _n({
			type: "notbindable"
		})
	}
	static notCompatible(e, t) {
		return new _n({
			type: "notcompatible",
			context: {
				id: `${e}.${t}`
			}
		})
	}
	static propertyNotFound(e) {
		return new _n({
			type: "propertynotfound",
			context: {
				name: e
			}
		})
	}
	static shouldNeverHappen() {
		return new _n({
			type: "shouldneverhappen"
		})
	}
	constructor(e) {
		var t;
		this.message = (t = YF[e.type](e.context)) !== null && t !== void 0 ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type
	}
	toString() {
		return this.message
	}
}
class Fp {
	constructor(e, t) {
		this.obj_ = e, this.key = t
	}
	static isBindable(e) {
		return !(e === null || typeof e != "object" && typeof e != "function")
	}
	read() {
		return this.obj_[this.key]
	}
	write(e) {
		this.obj_[this.key] = e
	}
	writeProperty(e, t) {
		const i = this.read();
		if (!Fp.isBindable(i)) throw _n.notBindable();
		if (!(e in i)) throw _n.propertyNotFound(e);
		i[e] = t
	}
}
let Pn = class {
	constructor() {
		this.observers_ = {}
	}
	on(e, t, i) {
		var r;
		let s = this.observers_[e];
		return s || (s = this.observers_[e] = []), s.push({
			handler: t,
			key: (r = i == null ? void 0 : i.key) !== null && r !== void 0 ? r : t
		}), this
	}
	off(e, t) {
		const i = this.observers_[e];
		return i && (this.observers_[e] = i.filter(r => r.key !== t)), this
	}
	emit(e, t) {
		const i = this.observers_[e];
		i && i.forEach(r => {
			r.handler(t)
		})
	}
};
class KF {
	constructor(e, t) {
		var i;
		this.constraint_ = t == null ? void 0 : t.constraint, this.equals_ = (i = t == null ? void 0 : t.equals) !== null && i !== void 0 ? i : (r, s) => r === s, this.emitter = new Pn, this.rawValue_ = e
	}
	get constraint() {
		return this.constraint_
	}
	get rawValue() {
		return this.rawValue_
	}
	set rawValue(e) {
		this.setRawValue(e, {
			forceEmit: !1,
			last: !0
		})
	}
	setRawValue(e, t) {
		const i = t ?? {
				forceEmit: !1,
				last: !0
			},
			r = this.constraint_ ? this.constraint_.constrain(e) : e,
			s = this.rawValue_;
		this.equals_(s, r) && !i.forceEmit || (this.emitter.emit("beforechange", {
			sender: this
		}), this.rawValue_ = r, this.emitter.emit("change", {
			options: i,
			previousRawValue: s,
			rawValue: r,
			sender: this
		}))
	}
}
class ZF {
	constructor(e) {
		this.emitter = new Pn, this.value_ = e
	}
	get rawValue() {
		return this.value_
	}
	set rawValue(e) {
		this.setRawValue(e, {
			forceEmit: !1,
			last: !0
		})
	}
	setRawValue(e, t) {
		const i = t ?? {
				forceEmit: !1,
				last: !0
			},
			r = this.value_;
		r === e && !i.forceEmit || (this.emitter.emit("beforechange", {
			sender: this
		}), this.value_ = e, this.emitter.emit("change", {
			options: i,
			previousRawValue: r,
			rawValue: this.value_,
			sender: this
		}))
	}
}
class JF {
	constructor(e) {
		this.emitter = new Pn, this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_)
	}
	get rawValue() {
		return this.value_.rawValue
	}
	onValueBeforeChange_(e) {
		this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
	onValueChange_(e) {
		this.emitter.emit("change", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
}

function cn(n, e) {
	const t = e == null ? void 0 : e.constraint,
		i = e == null ? void 0 : e.equals;
	return !t && !i ? new ZF(n) : new KF(n, e)
}

function QF(n) {
	return [new JF(n), (e, t) => {
		n.setRawValue(e, t)
	}]
}
class _t {
	constructor(e) {
		this.emitter = new Pn, this.valMap_ = e;
		for (const t in this.valMap_) this.valMap_[t].emitter.on("change", () => {
			this.emitter.emit("change", {
				key: t,
				sender: this
			})
		})
	}
	static createCore(e) {
		return Object.keys(e).reduce((i, r) => Object.assign(i, {
			[r]: cn(e[r])
		}), {})
	}
	static fromObject(e) {
		const t = this.createCore(e);
		return new _t(t)
	}
	get(e) {
		return this.valMap_[e].rawValue
	}
	set(e, t) {
		this.valMap_[e].rawValue = t
	}
	value(e) {
		return this.valMap_[e]
	}
}
class Cd {
	constructor(e) {
		this.values = _t.fromObject({
			max: e.max,
			min: e.min
		})
	}
	constrain(e) {
		const t = this.values.get("max"),
			i = this.values.get("min");
		return Math.min(Math.max(e, i), t)
	}
}
class e8 {
	constructor(e) {
		this.values = _t.fromObject({
			max: e.max,
			min: e.min
		})
	}
	constrain(e) {
		const t = this.values.get("max"),
			i = this.values.get("min");
		let r = e;
		return Kt(i) || (r = Math.max(r, i)), Kt(t) || (r = Math.min(r, t)), r
	}
}
class t8 {
	constructor(e, t = 0) {
		this.step = e, this.origin = t
	}
	constrain(e) {
		const t = this.origin % this.step,
			i = Math.round((e - t) / this.step);
		return t + i * this.step
	}
}
class n8 {
	constructor(e) {
		this.text = e
	}
	evaluate() {
		return Number(this.text)
	}
	toString() {
		return this.text
	}
}
const i8 = {
	"**": (n, e) => Math.pow(n, e),
	"*": (n, e) => n * e,
	"/": (n, e) => n / e,
	"%": (n, e) => n % e,
	"+": (n, e) => n + e,
	"-": (n, e) => n - e,
	"<<": (n, e) => n << e,
	">>": (n, e) => n >> e,
	">>>": (n, e) => n >>> e,
	"&": (n, e) => n & e,
	"^": (n, e) => n ^ e,
	"|": (n, e) => n | e
};
class r8 {
	constructor(e, t, i) {
		this.left = t, this.operator = e, this.right = i
	}
	evaluate() {
		const e = i8[this.operator];
		if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
		return e(this.left.evaluate(), this.right.evaluate())
	}
	toString() {
		return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
	}
}
const s8 = {
	"+": n => n,
	"-": n => -n,
	"~": n => ~n
};
class o8 {
	constructor(e, t) {
		this.operator = e, this.expression = t
	}
	evaluate() {
		const e = s8[this.operator];
		if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
		return e(this.expression.evaluate())
	}
	toString() {
		return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
	}
}

function M1(n) {
	return (e, t) => {
		for (let i = 0; i < n.length; i++) {
			const r = n[i](e, t);
			if (r !== "") return r
		}
		return ""
	}
}

function jh(n, e) {
	var t;
	const i = n.substr(e).match(/^\s+/);
	return (t = i && i[0]) !== null && t !== void 0 ? t : ""
}

function a8(n, e) {
	const t = n.substr(e, 1);
	return t.match(/^[1-9]$/) ? t : ""
}

function $h(n, e) {
	var t;
	const i = n.substr(e).match(/^[0-9]+/);
	return (t = i && i[0]) !== null && t !== void 0 ? t : ""
}

function l8(n, e) {
	const t = $h(n, e);
	if (t !== "") return t;
	const i = n.substr(e, 1);
	if (e += 1, i !== "-" && i !== "+") return "";
	const r = $h(n, e);
	return r === "" ? "" : i + r
}

function C1(n, e) {
	const t = n.substr(e, 1);
	if (e += 1, t.toLowerCase() !== "e") return "";
	const i = l8(n, e);
	return i === "" ? "" : t + i
}

function cM(n, e) {
	const t = n.substr(e, 1);
	if (t === "0") return t;
	const i = a8(n, e);
	return e += i.length, i === "" ? "" : i + $h(n, e)
}

function c8(n, e) {
	const t = cM(n, e);
	if (e += t.length, t === "") return "";
	const i = n.substr(e, 1);
	if (e += i.length, i !== ".") return "";
	const r = $h(n, e);
	return e += r.length, t + i + r + C1(n, e)
}

function u8(n, e) {
	const t = n.substr(e, 1);
	if (e += t.length, t !== ".") return "";
	const i = $h(n, e);
	return e += i.length, i === "" ? "" : t + i + C1(n, e)
}

function h8(n, e) {
	const t = cM(n, e);
	return e += t.length, t === "" ? "" : t + C1(n, e)
}
const d8 = M1([c8, u8, h8]);

function f8(n, e) {
	var t;
	const i = n.substr(e).match(/^[01]+/);
	return (t = i && i[0]) !== null && t !== void 0 ? t : ""
}

function p8(n, e) {
	const t = n.substr(e, 2);
	if (e += t.length, t.toLowerCase() !== "0b") return "";
	const i = f8(n, e);
	return i === "" ? "" : t + i
}

function m8(n, e) {
	var t;
	const i = n.substr(e).match(/^[0-7]+/);
	return (t = i && i[0]) !== null && t !== void 0 ? t : ""
}

function g8(n, e) {
	const t = n.substr(e, 2);
	if (e += t.length, t.toLowerCase() !== "0o") return "";
	const i = m8(n, e);
	return i === "" ? "" : t + i
}

function _8(n, e) {
	var t;
	const i = n.substr(e).match(/^[0-9a-f]+/i);
	return (t = i && i[0]) !== null && t !== void 0 ? t : ""
}

function v8(n, e) {
	const t = n.substr(e, 2);
	if (e += t.length, t.toLowerCase() !== "0x") return "";
	const i = _8(n, e);
	return i === "" ? "" : t + i
}
const b8 = M1([p8, g8, v8]),
	y8 = M1([b8, d8]);

function x8(n, e) {
	const t = y8(n, e);
	return e += t.length, t === "" ? null : {
		evaluable: new n8(t),
		cursor: e
	}
}

function w8(n, e) {
	const t = n.substr(e, 1);
	if (e += t.length, t !== "(") return null;
	const i = hM(n, e);
	if (!i) return null;
	e = i.cursor, e += jh(n, e).length;
	const r = n.substr(e, 1);
	return e += r.length, r !== ")" ? null : {
		evaluable: i.evaluable,
		cursor: e
	}
}

function E8(n, e) {
	var t;
	return (t = x8(n, e)) !== null && t !== void 0 ? t : w8(n, e)
}

function uM(n, e) {
	const t = E8(n, e);
	if (t) return t;
	const i = n.substr(e, 1);
	if (e += i.length, i !== "+" && i !== "-" && i !== "~") return null;
	const r = uM(n, e);
	return r ? (e = r.cursor, {
		cursor: e,
		evaluable: new o8(i, r.evaluable)
	}) : null
}

function S8(n, e, t) {
	t += jh(e, t).length;
	const i = n.filter(r => e.startsWith(r, t))[0];
	return i ? (t += i.length, t += jh(e, t).length, {
		cursor: t,
		operator: i
	}) : null
}

function T8(n, e) {
	return (t, i) => {
		const r = n(t, i);
		if (!r) return null;
		i = r.cursor;
		let s = r.evaluable;
		for (;;) {
			const o = S8(e, t, i);
			if (!o) break;
			i = o.cursor;
			const a = n(t, i);
			if (!a) return null;
			i = a.cursor, s = new r8(o.operator, s, a.evaluable)
		}
		return s ? {
			cursor: i,
			evaluable: s
		} : null
	}
}
const M8 = [
	["**"],
	["*", "/", "%"],
	["+", "-"],
	["<<", ">>>", ">>"],
	["&"],
	["^"],
	["|"]
].reduce((n, e) => T8(n, e), uM);

function hM(n, e) {
	return e += jh(n, e).length, M8(n, e)
}

function C8(n) {
	const e = hM(n, 0);
	return !e || e.cursor + jh(n, e.cursor).length !== n.length ? null : e.evaluable
}

function lo(n) {
	var e;
	const t = C8(n);
	return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null
}

function dM(n) {
	if (typeof n == "number") return n;
	if (typeof n == "string") {
		const e = lo(n);
		if (!Kt(e)) return e
	}
	return 0
}

function A8(n) {
	return String(n)
}

function Ki(n) {
	return e => e.toFixed(Math.max(Math.min(n, 20), 0))
}

function Ot(n, e, t, i, r) {
	const s = (n - e) / (t - e);
	return i + s * (r - i)
}

function Ox(n) {
	return String(n.toFixed(10)).split(".")[1].replace(/0+$/, "").length
}

function Un(n, e, t) {
	return Math.min(Math.max(n, e), t)
}

function fM(n, e) {
	return (n % e + e) % e
}

function D8(n, e) {
	return Kt(n.step) ? Math.max(Ox(e), 2) : Ox(n.step)
}

function pM(n) {
	var e;
	return (e = n.step) !== null && e !== void 0 ? e : 1
}

function mM(n, e) {
	var t;
	const i = Math.abs((t = n.step) !== null && t !== void 0 ? t : e);
	return i === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(i)) - 1)
}

function gM(n, e) {
	return Kt(n.step) ? null : new t8(n.step, e)
}

function _M(n) {
	return !Kt(n.max) && !Kt(n.min) ? new Cd({
		max: n.max,
		min: n.min
	}) : !Kt(n.max) || !Kt(n.min) ? new e8({
		max: n.max,
		min: n.min
	}) : null
}

function vM(n, e) {
	var t, i, r;
	return {
		formatter: (t = n.format) !== null && t !== void 0 ? t : Ki(D8(n, e)),
		keyScale: (i = n.keyScale) !== null && i !== void 0 ? i : pM(n),
		pointerScale: (r = n.pointerScale) !== null && r !== void 0 ? r : mM(n, e)
	}
}

function bM(n) {
	return {
		format: n.optional.function,
		keyScale: n.optional.number,
		max: n.optional.number,
		min: n.optional.number,
		pointerScale: n.optional.number,
		step: n.optional.number
	}
}

function A1(n) {
	return {
		constraint: n.constraint,
		textProps: _t.fromObject(vM(n.params, n.initialValue))
	}
}
class Rl {
	constructor(e) {
		this.controller = e
	}
	get element() {
		return this.controller.view.element
	}
	get disabled() {
		return this.controller.viewProps.get("disabled")
	}
	set disabled(e) {
		this.controller.viewProps.set("disabled", e)
	}
	get hidden() {
		return this.controller.viewProps.get("hidden")
	}
	set hidden(e) {
		this.controller.viewProps.set("hidden", e)
	}
	dispose() {
		this.controller.viewProps.set("disposed", !0)
	}
	importState(e) {
		return this.controller.importState(e)
	}
	exportState() {
		return this.controller.exportState()
	}
}
class Hm {
	constructor(e) {
		this.target = e
	}
}
class Ad extends Hm {
	constructor(e, t, i) {
		super(e), this.value = t, this.last = i ?? !0
	}
}
class P8 extends Hm {
	constructor(e, t) {
		super(e), this.expanded = t
	}
}
class R8 extends Hm {
	constructor(e, t) {
		super(e), this.index = t
	}
}
class L8 extends Hm {
	constructor(e, t) {
		super(e), this.native = t
	}
}
class qh extends Rl {
	constructor(e) {
		super(e), this.onValueChange_ = this.onValueChange_.bind(this), this.emitter_ = new Pn, this.controller.value.emitter.on("change", this.onValueChange_)
	}
	get label() {
		return this.controller.labelController.props.get("label")
	}
	set label(e) {
		this.controller.labelController.props.set("label", e)
	}
	get key() {
		return this.controller.value.binding.target.key
	}
	get tag() {
		return this.controller.tag
	}
	set tag(e) {
		this.controller.tag = e
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
	refresh() {
		this.controller.value.fetch()
	}
	onValueChange_(e) {
		const t = this.controller.value;
		this.emitter_.emit("change", new Ad(this, t.binding.target.read(), e.options.last))
	}
}
class k8 {
	constructor(e, t) {
		this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = t, this.value_ = e, this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.emitter = new Pn
	}
	get rawValue() {
		return this.value_.rawValue
	}
	set rawValue(e) {
		this.value_.rawValue = e
	}
	setRawValue(e, t) {
		this.value_.setRawValue(e, t)
	}
	fetch() {
		this.value_.rawValue = this.binding.read()
	}
	push() {
		this.binding.write(this.value_.rawValue)
	}
	onValueBeforeChange_(e) {
		this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
	onValueChange_(e) {
		this.push(), this.emitter.emit("change", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
}

function I8(n) {
	if (!("binding" in n)) return !1;
	const e = n.binding;
	return T1(e) && "read" in e && "write" in e
}

function O8(n, e) {
	const i = Object.keys(e).reduce((r, s) => {
		if (r === void 0) return;
		const o = e[s],
			a = o(n[s]);
		return a.succeeded ? Object.assign(Object.assign({}, r), {
			[s]: a.value
		}) : void 0
	}, {});
	return i
}

function F8(n, e) {
	return n.reduce((t, i) => {
		if (t === void 0) return;
		const r = e(i);
		if (!(!r.succeeded || r.value === void 0)) return [...t, r.value]
	}, [])
}

function N8(n) {
	return n === null ? !1 : typeof n == "object"
}

function Us(n) {
	return e => t => {
		if (!e && t === void 0) return {
			succeeded: !1,
			value: void 0
		};
		if (e && t === void 0) return {
			succeeded: !0,
			value: void 0
		};
		const i = n(t);
		return i !== void 0 ? {
			succeeded: !0,
			value: i
		} : {
			succeeded: !1,
			value: void 0
		}
	}
}

function Fx(n) {
	return {
		custom: e => Us(e)(n),
		boolean: Us(e => typeof e == "boolean" ? e : void 0)(n),
		number: Us(e => typeof e == "number" ? e : void 0)(n),
		string: Us(e => typeof e == "string" ? e : void 0)(n),
		function: Us(e => typeof e == "function" ? e : void 0)(n),
		constant: e => Us(t => t === e ? e : void 0)(n),
		raw: Us(e => e)(n),
		object: e => Us(t => {
			if (N8(t)) return O8(t, e)
		})(n),
		array: e => Us(t => {
			if (Array.isArray(t)) return F8(t, e)
		})(n)
	}
}
const H_ = {
	optional: Fx(!0),
	required: Fx(!1)
};

function mn(n, e) {
	const t = e(H_),
		i = H_.required.object(t)(n);
	return i.succeeded ? i.value : void 0
}

function Tr(n, e, t, i) {
	if (e && !e(n)) return !1;
	const r = mn(n, t);
	return r ? i(r) : !1
}

function Mr(n, e) {
	var t;
	return xl((t = n == null ? void 0 : n()) !== null && t !== void 0 ? t : {}, e)
}

function ll(n) {
	return "value" in n
}

function yM(n) {
	if (!S1(n) || !("binding" in n)) return !1;
	const e = n.binding;
	return T1(e)
}
const ys = "http://www.w3.org/2000/svg";

function Np(n) {
	n.offsetHeight
}

function U8(n, e) {
	const t = n.style.transition;
	n.style.transition = "none", e(), n.style.transition = t
}

function D1(n) {
	return n.ontouchstart !== void 0
}

function B8() {
	return globalThis
}

function z8() {
	return B8().document
}

function V8(n) {
	const e = n.ownerDocument.defaultView;
	return e && "document" in e ? n.getContext("2d", {
		willReadFrequently: !0
	}) : null
}
const H8 = {
	check: '<path d="M2 8l4 4l8 -8"/>',
	dropdown: '<path d="M5 7h6l-3 3 z"/>',
	p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};

function Gm(n, e) {
	const t = n.createElementNS(ys, "svg");
	return t.innerHTML = H8[e], t
}

function xM(n, e, t) {
	n.insertBefore(e, n.children[t])
}

function P1(n) {
	n.parentElement && n.parentElement.removeChild(n)
}

function wM(n) {
	for (; n.children.length > 0;) n.removeChild(n.children[0])
}

function G8(n) {
	for (; n.childNodes.length > 0;) n.removeChild(n.childNodes[0])
}

function EM(n) {
	return n.relatedTarget ? n.relatedTarget : "explicitOriginalTarget" in n ? n.explicitOriginalTarget : null
}

function io(n, e) {
	n.emitter.on("change", t => {
		e(t.rawValue)
	}), e(n.rawValue)
}

function Ds(n, e, t) {
	io(n.value(e), t)
}
const W8 = "tp";

function Dt(n) {
	return (t, i) => [W8, "-", n, "v", t ? `_${t}` : "", i ? `-${i}` : ""].join("")
}
const Lu = Dt("lbl");

function j8(n, e) {
	const t = n.createDocumentFragment();
	return e.split(`
`).map(r => n.createTextNode(r)).forEach((r, s) => {
		s > 0 && t.appendChild(n.createElement("br")), t.appendChild(r)
	}), t
}
class SM {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(Lu()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(Lu("l")), Ds(t.props, "label", s => {
			Kt(s) ? this.element.classList.add(Lu(void 0, "nol")) : (this.element.classList.remove(Lu(void 0, "nol")), G8(i), i.appendChild(j8(e, s)))
		}), this.element.appendChild(i), this.labelElement = i;
		const r = e.createElement("div");
		r.classList.add(Lu("v")), this.element.appendChild(r), this.valueElement = r
	}
}
class TM {
	constructor(e, t) {
		this.props = t.props, this.valueController = t.valueController, this.viewProps = t.valueController.viewProps, this.view = new SM(e, {
			props: t.props,
			viewProps: this.viewProps
		}), this.view.valueElement.appendChild(this.valueController.view.element)
	}
	importProps(e) {
		return Tr(e, null, t => ({
			label: t.optional.string
		}), t => (this.props.set("label", t.label), !0))
	}
	exportProps() {
		return Mr(null, {
			label: this.props.get("label")
		})
	}
}

function $8() {
	return ["veryfirst", "first", "last", "verylast"]
}
const Nx = Dt(""),
	Ux = {
		veryfirst: "vfst",
		first: "fst",
		last: "lst",
		verylast: "vlst"
	};
class Wm {
	constructor(e) {
		this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
		const t = this.view.element;
		this.blade.value("positions").emitter.on("change", () => {
			$8().forEach(i => {
				t.classList.remove(Nx(void 0, Ux[i]))
			}), this.blade.get("positions").forEach(i => {
				t.classList.add(Nx(void 0, Ux[i]))
			})
		}), this.viewProps.handleDispose(() => {
			P1(t)
		})
	}
	get parent() {
		return this.parent_
	}
	set parent(e) {
		this.parent_ = e, this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
	}
	importState(e) {
		return Tr(e, null, t => ({
			disabled: t.required.boolean,
			hidden: t.required.boolean
		}), t => (this.viewProps.importState(t), !0))
	}
	exportState() {
		return Mr(null, Object.assign({}, this.viewProps.exportState()))
	}
}
class wl extends Wm {
	constructor(e, t) {
		if (t.value !== t.valueController.value) throw _n.shouldNeverHappen();
		const i = t.valueController.viewProps,
			r = new TM(e, {
				blade: t.blade,
				props: t.props,
				valueController: t.valueController
			});
		super(Object.assign(Object.assign({}, t), {
			view: new SM(e, {
				props: t.props,
				viewProps: i
			}),
			viewProps: i
		})), this.labelController = r, this.value = t.value, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
	}
	importState(e) {
		return Tr(e, t => {
			var i, r, s;
			return super.importState(t) && this.labelController.importProps(t) && ((s = (r = (i = this.valueController).importProps) === null || r === void 0 ? void 0 : r.call(i, e)) !== null && s !== void 0 ? s : !0)
		}, t => ({
			value: t.optional.raw
		}), t => (t.value && (this.value.rawValue = t.value), !0))
	}
	exportState() {
		var e, t, i;
		return Mr(() => super.exportState(), Object.assign(Object.assign({
			value: this.value.rawValue
		}, this.labelController.exportProps()), (i = (t = (e = this.valueController).exportProps) === null || t === void 0 ? void 0 : t.call(e)) !== null && i !== void 0 ? i : {}))
	}
}

function Bx(n) {
	const e = Object.assign({}, n);
	return delete e.value, e
}
class MM extends wl {
	constructor(e, t) {
		super(e, t), this.tag = t.tag
	}
	importState(e) {
		return Tr(e, t => super.importState(Bx(e)), t => ({
			tag: t.optional.string
		}), t => (this.tag = t.tag, !0))
	}
	exportState() {
		return Mr(() => Bx(super.exportState()), {
			binding: {
				key: this.value.binding.target.key,
				value: this.value.binding.target.read()
			},
			tag: this.tag
		})
	}
}

function q8(n) {
	return ll(n) && yM(n.value)
}
class X8 extends MM {
	importState(e) {
		return Tr(e, t => super.importState(t), t => ({
			binding: t.required.object({
				value: t.required.raw
			})
		}), t => (this.value.binding.inject(t.binding.value), this.value.fetch(), !0))
	}
}

function Y8(n) {
	return ll(n) && I8(n.value)
}

function CM(n, e) {
	for (; n.length < e;) n.push(void 0)
}

function K8(n) {
	const e = [];
	return CM(e, n), e
}

function Z8(n) {
	const e = n.indexOf(void 0);
	return e < 0 ? n : n.slice(0, e)
}

function J8(n, e) {
	const t = [...Z8(n), e];
	return t.length > n.length ? t.splice(0, t.length - n.length) : CM(t, n.length), t
}
class Q8 {
	constructor(e) {
		this.emitter = new Pn, this.onTick_ = this.onTick_.bind(this), this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.binding = e.binding, this.value_ = cn(K8(e.bufferSize)), this.value_.emitter.on("beforechange", this.onValueBeforeChange_), this.value_.emitter.on("change", this.onValueChange_), this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.fetch()
	}
	get rawValue() {
		return this.value_.rawValue
	}
	set rawValue(e) {
		this.value_.rawValue = e
	}
	setRawValue(e, t) {
		this.value_.setRawValue(e, t)
	}
	fetch() {
		this.value_.rawValue = J8(this.value_.rawValue, this.binding.read())
	}
	onTick_() {
		this.fetch()
	}
	onValueBeforeChange_(e) {
		this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
	onValueChange_(e) {
		this.emitter.emit("change", Object.assign(Object.assign({}, e), {
			sender: this
		}))
	}
}

function eN(n) {
	if (!("binding" in n)) return !1;
	const e = n.binding;
	return T1(e) && "read" in e && !("write" in e)
}
class tN extends MM {
	exportState() {
		return Mr(() => super.exportState(), {
			binding: {
				readonly: !0
			}
		})
	}
}

function nN(n) {
	return ll(n) && eN(n.value)
}
class iN extends Rl {
	get label() {
		return this.controller.labelController.props.get("label")
	}
	set label(e) {
		this.controller.labelController.props.set("label", e)
	}
	get title() {
		var e;
		return (e = this.controller.buttonController.props.get("title")) !== null && e !== void 0 ? e : ""
	}
	set title(e) {
		this.controller.buttonController.props.set("title", e)
	}
	on(e, t) {
		const i = t.bind(this);
		return this.controller.buttonController.emitter.on(e, s => {
			i(new L8(this, s.nativeEvent))
		}), this
	}
	off(e, t) {
		return this.controller.buttonController.emitter.off(e, t), this
	}
}

function rN(n, e, t) {
	t ? n.classList.add(e) : n.classList.remove(e)
}

function yu(n, e) {
	return t => {
		rN(n, e, t)
	}
}

function R1(n, e) {
	io(n, t => {
		e.textContent = t ?? ""
	})
}
const O0 = Dt("btn");
class sN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(O0()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("button");
		i.classList.add(O0("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
		const r = e.createElement("div");
		r.classList.add(O0("t")), R1(t.props.value("title"), r), this.buttonElement.appendChild(r)
	}
}
class oN {
	constructor(e, t) {
		this.emitter = new Pn, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new sN(e, {
			props: this.props,
			viewProps: this.viewProps
		}), this.view.buttonElement.addEventListener("click", this.onClick_)
	}
	importProps(e) {
		return Tr(e, null, t => ({
			title: t.optional.string
		}), t => (this.props.set("title", t.title), !0))
	}
	exportProps() {
		return Mr(null, {
			title: this.props.get("title")
		})
	}
	onClick_(e) {
		this.emitter.emit("click", {
			nativeEvent: e,
			sender: this
		})
	}
}
class zx extends Wm {
	constructor(e, t) {
		const i = new oN(e, {
				props: t.buttonProps,
				viewProps: t.viewProps
			}),
			r = new TM(e, {
				blade: t.blade,
				props: t.labelProps,
				valueController: i
			});
		super({
			blade: t.blade,
			view: r.view,
			viewProps: t.viewProps
		}), this.buttonController = i, this.labelController = r
	}
	importState(e) {
		return Tr(e, t => super.importState(t) && this.buttonController.importProps(t) && this.labelController.importProps(t), () => ({}), () => !0)
	}
	exportState() {
		return Mr(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()))
	}
}
class AM {
	constructor(e) {
		const [t, i] = e.split("-"), r = t.split(".");
		this.major = parseInt(r[0], 10), this.minor = parseInt(r[1], 10), this.patch = parseInt(r[2], 10), this.prerelease = i ?? null
	}
	toString() {
		const e = [this.major, this.minor, this.patch].join(".");
		return this.prerelease !== null ? [e, this.prerelease].join("-") : e
	}
}
const xu = new AM("2.0.3");

function Oi(n) {
	return Object.assign({
		core: xu
	}, n)
}
const aN = Oi({
	id: "button",
	type: "blade",
	accept(n) {
		const e = mn(n, t => ({
			title: t.required.string,
			view: t.required.constant("button"),
			label: t.optional.string
		}));
		return e ? {
			params: e
		} : null
	},
	controller(n) {
		return new zx(n.document, {
			blade: n.blade,
			buttonProps: _t.fromObject({
				title: n.params.title
			}),
			labelProps: _t.fromObject({
				label: n.params.label
			}),
			viewProps: n.viewProps
		})
	},
	api(n) {
		return n.controller instanceof zx ? new iN(n.controller) : null
	}
});

function lN(n, e) {
	return n.addBlade(Object.assign(Object.assign({}, e), {
		view: "button"
	}))
}

function cN(n, e) {
	return n.addBlade(Object.assign(Object.assign({}, e), {
		view: "folder"
	}))
}

function uN(n, e) {
	return n.addBlade(Object.assign(Object.assign({}, e), {
		view: "tab"
	}))
}

function hN(n) {
	return S1(n) ? "refresh" in n && typeof n.refresh == "function" : !1
}

function dN(n, e) {
	if (!Fp.isBindable(n)) throw _n.notBindable();
	return new Fp(n, e)
}
class fN {
	constructor(e, t) {
		this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.controller_ = e, this.emitter_ = new Pn, this.pool_ = t, this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_)
	}
	get children() {
		return this.controller_.rack.children.map(e => this.pool_.createApi(e))
	}
	addBinding(e, t, i) {
		const r = i ?? {},
			s = this.controller_.element.ownerDocument,
			o = this.pool_.createBinding(s, dN(e, t), r),
			a = this.pool_.createBindingApi(o);
		return this.add(a, r.index)
	}
	addFolder(e) {
		return cN(this, e)
	}
	addButton(e) {
		return lN(this, e)
	}
	addTab(e) {
		return uN(this, e)
	}
	add(e, t) {
		const i = e.controller;
		return this.controller_.rack.add(i, t), e
	}
	remove(e) {
		this.controller_.rack.remove(e.controller)
	}
	addBlade(e) {
		const t = this.controller_.element.ownerDocument,
			i = this.pool_.createBlade(t, e),
			r = this.pool_.createApi(i);
		return this.add(r, e.index)
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
	refresh() {
		this.children.forEach(e => {
			hN(e) && e.refresh()
		})
	}
	onRackValueChange_(e) {
		const t = e.bladeController,
			i = this.pool_.createApi(t),
			r = yM(t.value) ? t.value.binding : null;
		this.emitter_.emit("change", new Ad(i, r ? r.target.read() : t.value.rawValue, e.options.last))
	}
}
class L1 extends Rl {
	constructor(e, t) {
		super(e), this.rackApi_ = new fN(e.rackController, t)
	}
	refresh() {
		this.rackApi_.refresh()
	}
}
class k1 extends Wm {
	constructor(e) {
		super({
			blade: e.blade,
			view: e.view,
			viewProps: e.rackController.viewProps
		}), this.rackController = e.rackController
	}
	importState(e) {
		return Tr(e, t => super.importState(t), t => ({
			children: t.required.array(t.required.raw)
		}), t => this.rackController.rack.children.every((i, r) => i.importState(t.children[r])))
	}
	exportState() {
		return Mr(() => super.exportState(), {
			children: this.rackController.rack.children.map(e => e.exportState())
		})
	}
}

function G_(n) {
	return "rackController" in n
}
class pN {
	constructor(e) {
		this.emitter = new Pn, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e
	}
	get items() {
		return this.items_
	}
	allItems() {
		return Array.from(this.cache_)
	}
	find(e) {
		for (const t of this.allItems())
			if (e(t)) return t;
		return null
	}
	includes(e) {
		return this.cache_.has(e)
	}
	add(e, t) {
		if (this.includes(e)) throw _n.shouldNeverHappen();
		const i = t !== void 0 ? t : this.items_.length;
		this.items_.splice(i, 0, e), this.cache_.add(e);
		const r = this.extract_(e);
		r && (r.emitter.on("add", this.onSubListAdd_), r.emitter.on("remove", this.onSubListRemove_), r.allItems().forEach(s => {
			this.cache_.add(s)
		})), this.emitter.emit("add", {
			index: i,
			item: e,
			root: this,
			target: this
		})
	}
	remove(e) {
		const t = this.items_.indexOf(e);
		if (t < 0) return;
		this.items_.splice(t, 1), this.cache_.delete(e);
		const i = this.extract_(e);
		i && (i.allItems().forEach(r => {
			this.cache_.delete(r)
		}), i.emitter.off("add", this.onSubListAdd_), i.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
			index: t,
			item: e,
			root: this,
			target: this
		})
	}
	onSubListAdd_(e) {
		this.cache_.add(e.item), this.emitter.emit("add", {
			index: e.index,
			item: e.item,
			root: this,
			target: e.target
		})
	}
	onSubListRemove_(e) {
		this.cache_.delete(e.item), this.emitter.emit("remove", {
			index: e.index,
			item: e.item,
			root: this,
			target: e.target
		})
	}
}

function mN(n, e) {
	for (let t = 0; t < n.length; t++) {
		const i = n[t];
		if (ll(i) && i.value === e) return i
	}
	return null
}

function gN(n) {
	return G_(n) ? n.rackController.rack.bcSet_ : null
}
class _N {
	constructor(e) {
		var t, i;
		this.emitter = new Pn, this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onRackLayout_ = this.onRackLayout_.bind(this), this.onRackValueChange_ = this.onRackValueChange_.bind(this), this.blade_ = (t = e.blade) !== null && t !== void 0 ? t : null, (i = this.blade_) === null || i === void 0 || i.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = e.viewProps, this.bcSet_ = new pN(gN), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
	}
	get children() {
		return this.bcSet_.items
	}
	add(e, t) {
		var i;
		(i = e.parent) === null || i === void 0 || i.remove(e), e.parent = this, this.bcSet_.add(e, t)
	}
	remove(e) {
		e.parent = null, this.bcSet_.remove(e)
	}
	find(e) {
		return this.bcSet_.allItems().filter(e)
	}
	onSetAdd_(e) {
		this.updatePositions_();
		const t = e.target === e.root;
		if (this.emitter.emit("add", {
				bladeController: e.item,
				index: e.index,
				root: t,
				sender: this
			}), !t) return;
		const i = e.item;
		if (i.viewProps.emitter.on("change", this.onChildViewPropsChange_), i.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), i.viewProps.handleDispose(this.onChildDispose_), ll(i)) i.value.emitter.on("change", this.onChildValueChange_);
		else if (G_(i)) {
			const r = i.rackController.rack;
			if (r) {
				const s = r.emitter;
				s.on("layout", this.onRackLayout_), s.on("valuechange", this.onRackValueChange_)
			}
		}
	}
	onSetRemove_(e) {
		this.updatePositions_();
		const t = e.target === e.root;
		if (this.emitter.emit("remove", {
				bladeController: e.item,
				root: t,
				sender: this
			}), !t) return;
		const i = e.item;
		if (ll(i)) i.value.emitter.off("change", this.onChildValueChange_);
		else if (G_(i)) {
			const r = i.rackController.rack;
			if (r) {
				const s = r.emitter;
				s.off("layout", this.onRackLayout_), s.off("valuechange", this.onRackValueChange_)
			}
		}
	}
	updatePositions_() {
		const e = this.bcSet_.items.filter(r => !r.viewProps.get("hidden")),
			t = e[0],
			i = e[e.length - 1];
		this.bcSet_.items.forEach(r => {
			const s = [];
			r === t && (s.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && s.push("veryfirst")), r === i && (s.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && s.push("verylast")), r.blade.set("positions", s)
		})
	}
	onChildPositionsChange_() {
		this.updatePositions_(), this.emitter.emit("layout", {
			sender: this
		})
	}
	onChildViewPropsChange_(e) {
		this.updatePositions_(), this.emitter.emit("layout", {
			sender: this
		})
	}
	onChildDispose_() {
		this.bcSet_.items.filter(t => t.viewProps.get("disposed")).forEach(t => {
			this.bcSet_.remove(t)
		})
	}
	onChildValueChange_(e) {
		const t = mN(this.find(ll), e.sender);
		if (!t) throw _n.alreadyDisposed();
		this.emitter.emit("valuechange", {
			bladeController: t,
			options: e.options,
			sender: this
		})
	}
	onRackLayout_(e) {
		this.updatePositions_(), this.emitter.emit("layout", {
			sender: this
		})
	}
	onRackValueChange_(e) {
		this.emitter.emit("valuechange", {
			bladeController: e.bladeController,
			options: e.options,
			sender: this
		})
	}
	onBladePositionsChange_() {
		this.updatePositions_()
	}
}
class I1 {
	constructor(e) {
		this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.element = e.element, this.viewProps = e.viewProps;
		const t = new _N({
			blade: e.root ? void 0 : e.blade,
			viewProps: e.viewProps
		});
		t.emitter.on("add", this.onRackAdd_), t.emitter.on("remove", this.onRackRemove_), this.rack = t, this.viewProps.handleDispose(() => {
			for (let i = this.rack.children.length - 1; i >= 0; i--) this.rack.children[i].viewProps.set("disposed", !0)
		})
	}
	onRackAdd_(e) {
		e.root && xM(this.element, e.bladeController.view.element, e.index)
	}
	onRackRemove_(e) {
		e.root && P1(e.bladeController.view.element)
	}
}

function wu() {
	return new _t({
		positions: cn([], {
			equals: XF
		})
	})
}
class Dd extends _t {
	constructor(e) {
		super(e)
	}
	static create(e) {
		const t = {
				completed: !0,
				expanded: e,
				expandedHeight: null,
				shouldFixHeight: !1,
				temporaryExpanded: null
			},
			i = _t.createCore(t);
		return new Dd(i)
	}
	get styleExpanded() {
		var e;
		return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded")
	}
	get styleHeight() {
		if (!this.styleExpanded) return "0";
		const e = this.get("expandedHeight");
		return this.get("shouldFixHeight") && !Kt(e) ? `${e}px` : "auto"
	}
	bindExpandedClass(e, t) {
		const i = () => {
			this.styleExpanded ? e.classList.add(t) : e.classList.remove(t)
		};
		Ds(this, "expanded", i), Ds(this, "temporaryExpanded", i)
	}
	cleanUpTransition() {
		this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
	}
}

function vN(n, e) {
	let t = 0;
	return U8(e, () => {
		n.set("expandedHeight", null), n.set("temporaryExpanded", !0), Np(e), t = e.clientHeight, n.set("temporaryExpanded", null), Np(e)
	}), t
}

function Vx(n, e) {
	e.style.height = n.styleHeight
}

function O1(n, e) {
	n.value("expanded").emitter.on("beforechange", () => {
		if (n.set("completed", !1), Kt(n.get("expandedHeight"))) {
			const t = vN(n, e);
			t > 0 && n.set("expandedHeight", t)
		}
		n.set("shouldFixHeight", !0), Np(e)
	}), n.emitter.on("change", () => {
		Vx(n, e)
	}), Vx(n, e), e.addEventListener("transitionend", t => {
		t.propertyName === "height" && n.cleanUpTransition()
	})
}
class DM extends L1 {
	constructor(e, t) {
		super(e, t), this.emitter_ = new Pn, this.controller.foldable.value("expanded").emitter.on("change", i => {
			this.emitter_.emit("fold", new P8(this, i.sender.rawValue))
		}), this.rackApi_.on("change", i => {
			this.emitter_.emit("change", i)
		})
	}
	get expanded() {
		return this.controller.foldable.get("expanded")
	}
	set expanded(e) {
		this.controller.foldable.set("expanded", e)
	}
	get title() {
		return this.controller.props.get("title")
	}
	set title(e) {
		this.controller.props.set("title", e)
	}
	get children() {
		return this.rackApi_.children
	}
	addBinding(e, t, i) {
		return this.rackApi_.addBinding(e, t, i)
	}
	addFolder(e) {
		return this.rackApi_.addFolder(e)
	}
	addButton(e) {
		return this.rackApi_.addButton(e)
	}
	addTab(e) {
		return this.rackApi_.addTab(e)
	}
	add(e, t) {
		return this.rackApi_.add(e, t)
	}
	remove(e) {
		this.rackApi_.remove(e)
	}
	addBlade(e) {
		return this.rackApi_.addBlade(e)
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
}
const PM = Dt("cnt");
class bN {
	constructor(e, t) {
		var i;
		this.className_ = Dt((i = t.viewName) !== null && i !== void 0 ? i : "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), PM()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), Ds(this.foldable_, "completed", yu(this.element, this.className_(void 0, "cpl")));
		const r = e.createElement("button");
		r.classList.add(this.className_("b")), Ds(t.props, "title", c => {
			Kt(c) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
		}), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r;
		const s = e.createElement("div");
		s.classList.add(this.className_("i")), this.element.appendChild(s);
		const o = e.createElement("div");
		o.classList.add(this.className_("t")), R1(t.props.value("title"), o), this.buttonElement.appendChild(o), this.titleElement = o;
		const a = e.createElement("div");
		a.classList.add(this.className_("m")), this.buttonElement.appendChild(a);
		const l = e.createElement("div");
		l.classList.add(this.className_("c")), this.element.appendChild(l), this.containerElement = l
	}
}
class W_ extends k1 {
	constructor(e, t) {
		var i;
		const r = Dd.create((i = t.expanded) !== null && i !== void 0 ? i : !0),
			s = new bN(e, {
				foldable: r,
				props: t.props,
				viewName: t.root ? "rot" : void 0,
				viewProps: t.viewProps
			});
		super(Object.assign(Object.assign({}, t), {
			rackController: new I1({
				blade: t.blade,
				element: s.containerElement,
				root: t.root,
				viewProps: t.viewProps
			}),
			view: s
		})), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = r, O1(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
			this.foldable.cleanUpTransition()
		}), this.rackController.rack.emitter.on("remove", () => {
			this.foldable.cleanUpTransition()
		}), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
	}
	get document() {
		return this.view.element.ownerDocument
	}
	importState(e) {
		return Tr(e, t => super.importState(t), t => ({
			expanded: t.required.boolean,
			title: t.optional.string
		}), t => (this.foldable.set("expanded", t.expanded), this.props.set("title", t.title), !0))
	}
	exportState() {
		return Mr(() => super.exportState(), {
			expanded: this.foldable.get("expanded"),
			title: this.props.get("title")
		})
	}
	onTitleClick_() {
		this.foldable.set("expanded", !this.foldable.get("expanded"))
	}
}
const yN = Oi({
		id: "folder",
		type: "blade",
		accept(n) {
			const e = mn(n, t => ({
				title: t.required.string,
				view: t.required.constant("folder"),
				expanded: t.optional.boolean
			}));
			return e ? {
				params: e
			} : null
		},
		controller(n) {
			return new W_(n.document, {
				blade: n.blade,
				expanded: n.params.expanded,
				props: _t.fromObject({
					title: n.params.title
				}),
				viewProps: n.viewProps
			})
		},
		api(n) {
			return n.controller instanceof W_ ? new DM(n.controller, n.pool) : null
		}
	}),
	xN = Dt("");

function Hx(n, e) {
	return yu(n, xN(void 0, e))
}
class mo extends _t {
	constructor(e) {
		var t;
		super(e), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = QF(cn(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
	}
	static create(e) {
		var t, i, r;
		const s = e ?? {};
		return new mo(_t.createCore({
			disabled: (t = s.disabled) !== null && t !== void 0 ? t : !1,
			disposed: !1,
			hidden: (i = s.hidden) !== null && i !== void 0 ? i : !1,
			parent: (r = s.parent) !== null && r !== void 0 ? r : null
		}))
	}
	get globalDisabled() {
		return this.globalDisabled_
	}
	bindClassModifiers(e) {
		io(this.globalDisabled_, Hx(e, "disabled")), Ds(this, "hidden", Hx(e, "hidden"))
	}
	bindDisabled(e) {
		io(this.globalDisabled_, t => {
			e.disabled = t
		})
	}
	bindTabIndex(e) {
		io(this.globalDisabled_, t => {
			e.tabIndex = t ? -1 : 0
		})
	}
	handleDispose(e) {
		this.value("disposed").emitter.on("change", t => {
			t && e()
		})
	}
	importState(e) {
		this.set("disabled", e.disabled), this.set("hidden", e.hidden)
	}
	exportState() {
		return {
			disabled: this.get("disabled"),
			hidden: this.get("hidden")
		}
	}
	getGlobalDisabled_() {
		const e = this.get("parent");
		return (e ? e.globalDisabled.rawValue : !1) || this.get("disabled")
	}
	updateGlobalDisabled_() {
		this.setGlobalDisabled_(this.getGlobalDisabled_())
	}
	onDisabledChange_() {
		this.updateGlobalDisabled_()
	}
	onParentGlobalDisabledChange_() {
		this.updateGlobalDisabled_()
	}
	onParentChange_(e) {
		var t;
		const i = e.previousRawValue;
		i == null || i.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (t = this.get("parent")) === null || t === void 0 || t.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_()
	}
}
const Gx = Dt("tbp");
class wN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(Gx()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(Gx("c")), this.element.appendChild(i), this.containerElement = i
	}
}
const ku = Dt("tbi");
class EN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(ku()), t.viewProps.bindClassModifiers(this.element), Ds(t.props, "selected", s => {
			s ? this.element.classList.add(ku(void 0, "sel")) : this.element.classList.remove(ku(void 0, "sel"))
		});
		const i = e.createElement("button");
		i.classList.add(ku("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
		const r = e.createElement("div");
		r.classList.add(ku("t")), R1(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r
	}
}
class SN {
	constructor(e, t) {
		this.emitter = new Pn, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new EN(e, {
			props: t.props,
			viewProps: t.viewProps
		}), this.view.buttonElement.addEventListener("click", this.onClick_)
	}
	onClick_() {
		this.emitter.emit("click", {
			sender: this
		})
	}
}
class j_ extends k1 {
	constructor(e, t) {
		const i = new wN(e, {
			viewProps: t.viewProps
		});
		super(Object.assign(Object.assign({}, t), {
			rackController: new I1({
				blade: t.blade,
				element: i.containerElement,
				viewProps: t.viewProps
			}),
			view: i
		})), this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new SN(e, {
			props: t.itemProps,
			viewProps: mo.create()
		}), this.ic_.emitter.on("click", this.onItemClick_), this.props = t.props, Ds(this.props, "selected", r => {
			this.itemController.props.set("selected", r), this.viewProps.set("hidden", !r)
		})
	}
	get itemController() {
		return this.ic_
	}
	importState(e) {
		return Tr(e, t => super.importState(t), t => ({
			selected: t.required.boolean,
			title: t.required.string
		}), t => (this.ic_.props.set("selected", t.selected), this.ic_.props.set("title", t.title), !0))
	}
	exportState() {
		return Mr(() => super.exportState(), {
			selected: this.ic_.props.get("selected"),
			title: this.ic_.props.get("title")
		})
	}
	onItemClick_() {
		this.props.set("selected", !0)
	}
}
class TN extends L1 {
	constructor(e, t) {
		super(e, t), this.emitter_ = new Pn, this.onSelect_ = this.onSelect_.bind(this), this.pool_ = t, this.rackApi_.on("change", i => {
			this.emitter_.emit("change", i)
		}), this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_)
	}
	get pages() {
		return this.rackApi_.children
	}
	addPage(e) {
		const t = this.controller.view.element.ownerDocument,
			i = new j_(t, {
				blade: wu(),
				itemProps: _t.fromObject({
					selected: !1,
					title: e.title
				}),
				props: _t.fromObject({
					selected: !1
				}),
				viewProps: mo.create()
			}),
			r = this.pool_.createApi(i);
		return this.rackApi_.add(r, e.index)
	}
	removePage(e) {
		this.rackApi_.remove(this.rackApi_.children[e])
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
	onSelect_(e) {
		this.emitter_.emit("select", new R8(this, e.rawValue))
	}
}
class MN extends L1 {
	get title() {
		var e;
		return (e = this.controller.itemController.props.get("title")) !== null && e !== void 0 ? e : ""
	}
	set title(e) {
		this.controller.itemController.props.set("title", e)
	}
	get selected() {
		return this.controller.props.get("selected")
	}
	set selected(e) {
		this.controller.props.set("selected", e)
	}
	get children() {
		return this.rackApi_.children
	}
	addButton(e) {
		return this.rackApi_.addButton(e)
	}
	addFolder(e) {
		return this.rackApi_.addFolder(e)
	}
	addTab(e) {
		return this.rackApi_.addTab(e)
	}
	add(e, t) {
		this.rackApi_.add(e, t)
	}
	remove(e) {
		this.rackApi_.remove(e)
	}
	addBinding(e, t, i) {
		return this.rackApi_.addBinding(e, t, i)
	}
	addBlade(e) {
		return this.rackApi_.addBlade(e)
	}
}
const Wx = -1;
class CN {
	constructor() {
		this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = cn(!0), this.selectedIndex = cn(Wx), this.items_ = []
	}
	add(e, t) {
		const i = t ?? this.items_.length;
		this.items_.splice(i, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_()
	}
	remove(e) {
		const t = this.items_.indexOf(e);
		t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_())
	}
	keepSelection_() {
		if (this.items_.length === 0) {
			this.selectedIndex.rawValue = Wx, this.empty.rawValue = !0;
			return
		}
		const e = this.items_.findIndex(t => t.rawValue);
		e < 0 ? (this.items_.forEach((t, i) => {
			t.rawValue = i === 0
		}), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t, i) => {
			t.rawValue = i === e
		}), this.selectedIndex.rawValue = e), this.empty.rawValue = !1
	}
	onItemSelectedChange_(e) {
		if (e.rawValue) {
			const t = this.items_.findIndex(i => i === e.sender);
			this.items_.forEach((i, r) => {
				i.rawValue = r === t
			}), this.selectedIndex.rawValue = t
		} else this.keepSelection_()
	}
}
const Iu = Dt("tab");
class AN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(Iu(), PM()), t.viewProps.bindClassModifiers(this.element), io(t.empty, yu(this.element, Iu(void 0, "nop")));
		const i = e.createElement("div");
		i.classList.add(Iu("t")), this.element.appendChild(i), this.itemsElement = i;
		const r = e.createElement("div");
		r.classList.add(Iu("i")), this.element.appendChild(r);
		const s = e.createElement("div");
		s.classList.add(Iu("c")), this.element.appendChild(s), this.contentsElement = s
	}
}
class jx extends k1 {
	constructor(e, t) {
		const i = new CN,
			r = new AN(e, {
				empty: i.empty,
				viewProps: t.viewProps
			});
		super({
			blade: t.blade,
			rackController: new I1({
				blade: t.blade,
				element: r.contentsElement,
				viewProps: t.viewProps
			}),
			view: r
		}), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
		const s = this.rackController.rack;
		s.emitter.on("add", this.onRackAdd_), s.emitter.on("remove", this.onRackRemove_), this.tab = i
	}
	add(e, t) {
		this.rackController.rack.add(e, t)
	}
	remove(e) {
		this.rackController.rack.remove(this.rackController.rack.children[e])
	}
	onRackAdd_(e) {
		if (!e.root) return;
		const t = e.bladeController;
		xM(this.view.itemsElement, t.itemController.view.element, e.index), t.itemController.viewProps.set("parent", this.viewProps), this.tab.add(t.props.value("selected"))
	}
	onRackRemove_(e) {
		if (!e.root) return;
		const t = e.bladeController;
		P1(t.itemController.view.element), t.itemController.viewProps.set("parent", null), this.tab.remove(t.props.value("selected"))
	}
}
const RM = Oi({
	id: "tab",
	type: "blade",
	accept(n) {
		const e = mn(n, t => ({
			pages: t.required.array(t.required.object({
				title: t.required.string
			})),
			view: t.required.constant("tab")
		}));
		return !e || e.pages.length === 0 ? null : {
			params: e
		}
	},
	controller(n) {
		const e = new jx(n.document, {
			blade: n.blade,
			viewProps: n.viewProps
		});
		return n.params.pages.forEach(t => {
			const i = new j_(n.document, {
				blade: wu(),
				itemProps: _t.fromObject({
					selected: !1,
					title: t.title
				}),
				props: _t.fromObject({
					selected: !1
				}),
				viewProps: mo.create()
			});
			e.add(i)
		}), e
	},
	api(n) {
		return n.controller instanceof jx ? new TN(n.controller, n.pool) : n.controller instanceof j_ ? new MN(n.controller, n.pool) : null
	}
});

function DN(n, e) {
	const t = n.accept(e.params);
	if (!t) return null;
	const i = mn(e.params, r => ({
		disabled: r.optional.boolean,
		hidden: r.optional.boolean
	}));
	return n.controller({
		blade: wu(),
		document: e.document,
		params: Object.assign(Object.assign({}, t.params), {
			disabled: i == null ? void 0 : i.disabled,
			hidden: i == null ? void 0 : i.hidden
		}),
		viewProps: mo.create({
			disabled: i == null ? void 0 : i.disabled,
			hidden: i == null ? void 0 : i.hidden
		})
	})
}
class F1 extends qh {
	get options() {
		return this.controller.valueController.props.get("options")
	}
	set options(e) {
		this.controller.valueController.props.set("options", e)
	}
}
class PN {
	constructor() {
		this.disabled = !1, this.emitter = new Pn
	}
	dispose() {}
	tick() {
		this.disabled || this.emitter.emit("tick", {
			sender: this
		})
	}
}
class RN {
	constructor(e, t) {
		this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new Pn, this.interval_ = t, this.setTimer_()
	}
	get disabled() {
		return this.disabled_
	}
	set disabled(e) {
		this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_()
	}
	dispose() {
		this.clearTimer_()
	}
	clearTimer_() {
		if (this.timerId_ === null) return;
		const e = this.doc_.defaultView;
		e && e.clearInterval(this.timerId_), this.timerId_ = null
	}
	setTimer_() {
		if (this.clearTimer_(), this.interval_ <= 0) return;
		const e = this.doc_.defaultView;
		e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_))
	}
	onTick_() {
		this.disabled_ || this.emitter.emit("tick", {
			sender: this
		})
	}
}
class Pd {
	constructor(e) {
		this.constraints = e
	}
	constrain(e) {
		return this.constraints.reduce((t, i) => i.constrain(t), e)
	}
}

function Up(n, e) {
	if (n instanceof e) return n;
	if (n instanceof Pd) {
		const t = n.constraints.reduce((i, r) => i || (r instanceof e ? r : null), null);
		if (t) return t
	}
	return null
}
class Rd {
	constructor(e) {
		this.values = _t.fromObject({
			options: e
		})
	}
	constrain(e) {
		const t = this.values.get("options");
		return t.length === 0 || t.filter(r => r.value === e).length > 0 ? e : t[0].value
	}
}

function Ld(n) {
	var e;
	const t = H_;
	if (Array.isArray(n)) return (e = mn({
		items: n
	}, i => ({
		items: i.required.array(i.required.object({
			text: i.required.string,
			value: i.required.raw
		}))
	}))) === null || e === void 0 ? void 0 : e.items;
	if (typeof n == "object") return t.required.raw(n).value
}

function N1(n) {
	if (Array.isArray(n)) return n;
	const e = [];
	return Object.keys(n).forEach(t => {
		e.push({
			text: t,
			value: n[t]
		})
	}), e
}

function U1(n) {
	return Kt(n) ? null : new Rd(N1(n))
}
const F0 = Dt("lst");
class LN {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(F0()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("select");
		i.classList.add(F0("s")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.selectElement = i;
		const r = e.createElement("div");
		r.classList.add(F0("m")), r.appendChild(Gm(e, "dropdown")), this.element.appendChild(r), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, Ds(this.props_, "options", s => {
			wM(this.selectElement), s.forEach(o => {
				const a = e.createElement("option");
				a.textContent = o.text, this.selectElement.appendChild(a)
			}), this.update_()
		})
	}
	update_() {
		const e = this.props_.get("options").map(t => t.value);
		this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue)
	}
	onValueChange_() {
		this.update_()
	}
}
class ga {
	constructor(e, t) {
		this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new LN(e, {
			props: this.props,
			value: this.value,
			viewProps: this.viewProps
		}), this.view.selectElement.addEventListener("change", this.onSelectChange_)
	}
	onSelectChange_(e) {
		const t = e.currentTarget;
		this.value.rawValue = this.props.get("options")[t.selectedIndex].value
	}
	importProps(e) {
		return Tr(e, null, t => ({
			options: t.required.custom(Ld)
		}), t => (this.props.set("options", N1(t.options)), !0))
	}
	exportProps() {
		return Mr(null, {
			options: this.props.get("options")
		})
	}
}
const $x = Dt("pop");
class kN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add($x()), t.viewProps.bindClassModifiers(this.element), io(t.shows, yu(this.element, $x(void 0, "v")))
	}
}
class LM {
	constructor(e, t) {
		this.shows = cn(!1), this.viewProps = t.viewProps, this.view = new kN(e, {
			shows: this.shows,
			viewProps: this.viewProps
		})
	}
}
const qx = Dt("txt");
class IN {
	constructor(e, t) {
		this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(qx()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
		const i = e.createElement("input");
		i.classList.add(qx("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh()
	}
	refresh() {
		const e = this.props_.get("formatter");
		this.inputElement.value = e(this.value_.rawValue)
	}
	onChange_() {
		this.refresh()
	}
}
class Xh {
	constructor(e, t) {
		this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new IN(e, {
			props: t.props,
			value: this.value,
			viewProps: this.viewProps
		}), this.view.inputElement.addEventListener("change", this.onInputChange_)
	}
	onInputChange_(e) {
		const i = e.currentTarget.value,
			r = this.parser_(i);
		Kt(r) || (this.value.rawValue = r), this.view.refresh()
	}
}

function ON(n) {
	return String(n)
}

function kM(n) {
	return n === "false" ? !1 : !!n
}

function Xx(n) {
	return ON(n)
}

function FN(n) {
	return e => n.reduce((t, i) => t !== null ? t : i(e), null)
}
const NN = Ki(0);

function Bp(n) {
	return NN(n) + "%"
}

function IM(n) {
	return String(n)
}

function $_(n) {
	return n
}

function Eu({
	primary: n,
	secondary: e,
	forward: t,
	backward: i
}) {
	let r = !1;

	function s(o) {
		r || (r = !0, o(), r = !1)
	}
	n.emitter.on("change", o => {
		s(() => {
			e.setRawValue(t(n.rawValue, e.rawValue), o.options)
		})
	}), e.emitter.on("change", o => {
		s(() => {
			n.setRawValue(i(n.rawValue, e.rawValue), o.options)
		}), s(() => {
			e.setRawValue(t(n.rawValue, e.rawValue), o.options)
		})
	}), s(() => {
		e.setRawValue(t(n.rawValue, e.rawValue), {
			forceEmit: !1,
			last: !0
		})
	})
}

function zi(n, e) {
	const t = n * (e.altKey ? .1 : 1) * (e.shiftKey ? 10 : 1);
	return e.upKey ? +t : e.downKey ? -t : 0
}

function Yh(n) {
	return {
		altKey: n.altKey,
		downKey: n.key === "ArrowDown",
		shiftKey: n.shiftKey,
		upKey: n.key === "ArrowUp"
	}
}

function co(n) {
	return {
		altKey: n.altKey,
		downKey: n.key === "ArrowLeft",
		shiftKey: n.shiftKey,
		upKey: n.key === "ArrowRight"
	}
}

function UN(n) {
	return n === "ArrowUp" || n === "ArrowDown"
}

function OM(n) {
	return UN(n) || n === "ArrowLeft" || n === "ArrowRight"
}

function N0(n, e) {
	var t, i;
	const r = e.ownerDocument.defaultView,
		s = e.getBoundingClientRect();
	return {
		x: n.pageX - (((t = r && r.scrollX) !== null && t !== void 0 ? t : 0) + s.left),
		y: n.pageY - (((i = r && r.scrollY) !== null && i !== void 0 ? i : 0) + s.top)
	}
}
class Ll {
	constructor(e) {
		this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new Pn, e.addEventListener("touchstart", this.onTouchStart_, {
			passive: !1
		}), e.addEventListener("touchmove", this.onTouchMove_, {
			passive: !0
		}), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_)
	}
	computePosition_(e) {
		const t = this.elem_.getBoundingClientRect();
		return {
			bounds: {
				width: t.width,
				height: t.height
			},
			point: e ? {
				x: e.x,
				y: e.y
			} : null
		}
	}
	onMouseDown_(e) {
		var t;
		e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
		const i = this.elem_.ownerDocument;
		i.addEventListener("mousemove", this.onDocumentMouseMove_), i.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
			altKey: e.altKey,
			data: this.computePosition_(N0(e, this.elem_)),
			sender: this,
			shiftKey: e.shiftKey
		})
	}
	onDocumentMouseMove_(e) {
		this.emitter.emit("move", {
			altKey: e.altKey,
			data: this.computePosition_(N0(e, this.elem_)),
			sender: this,
			shiftKey: e.shiftKey
		})
	}
	onDocumentMouseUp_(e) {
		const t = this.elem_.ownerDocument;
		t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
			altKey: e.altKey,
			data: this.computePosition_(N0(e, this.elem_)),
			sender: this,
			shiftKey: e.shiftKey
		})
	}
	onTouchStart_(e) {
		e.preventDefault();
		const t = e.targetTouches.item(0),
			i = this.elem_.getBoundingClientRect();
		this.emitter.emit("down", {
			altKey: e.altKey,
			data: this.computePosition_(t ? {
				x: t.clientX - i.left,
				y: t.clientY - i.top
			} : void 0),
			sender: this,
			shiftKey: e.shiftKey
		}), this.lastTouch_ = t
	}
	onTouchMove_(e) {
		const t = e.targetTouches.item(0),
			i = this.elem_.getBoundingClientRect();
		this.emitter.emit("move", {
			altKey: e.altKey,
			data: this.computePosition_(t ? {
				x: t.clientX - i.left,
				y: t.clientY - i.top
			} : void 0),
			sender: this,
			shiftKey: e.shiftKey
		}), this.lastTouch_ = t
	}
	onTouchEnd_(e) {
		var t;
		const i = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_,
			r = this.elem_.getBoundingClientRect();
		this.emitter.emit("up", {
			altKey: e.altKey,
			data: this.computePosition_(i ? {
				x: i.clientX - r.left,
				y: i.clientY - r.top
			} : void 0),
			sender: this,
			shiftKey: e.shiftKey
		})
	}
}
const Dr = Dt("txt");
class BN {
	constructor(e, t) {
		this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Dr(), Dr(void 0, "num")), t.arrayPosition && this.element.classList.add(Dr(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("input");
		i.classList.add(Dr("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Dr()), this.inputElement.classList.add(Dr("i"));
		const r = e.createElement("div");
		r.classList.add(Dr("k")), this.element.appendChild(r), this.knobElement = r;
		const s = e.createElementNS(ys, "svg");
		s.classList.add(Dr("g")), this.knobElement.appendChild(s);
		const o = e.createElementNS(ys, "path");
		o.classList.add(Dr("gb")), s.appendChild(o), this.guideBodyElem_ = o;
		const a = e.createElementNS(ys, "path");
		a.classList.add(Dr("gh")), s.appendChild(a), this.guideHeadElem_ = a;
		const l = e.createElement("div");
		l.classList.add(Dt("tt")()), this.knobElement.appendChild(l), this.tooltipElem_ = l, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh()
	}
	onDraggingChange_(e) {
		if (e.rawValue === null) {
			this.element.classList.remove(Dr(void 0, "drg"));
			return
		}
		this.element.classList.add(Dr(void 0, "drg"));
		const t = e.rawValue / this.props_.get("pointerScale"),
			i = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
			r = Un(-i, -4, 4);
		this.guideHeadElem_.setAttributeNS(null, "d", [`M ${i+r},0 L${i},4 L${i+r},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
		const s = this.props_.get("formatter");
		this.tooltipElem_.textContent = s(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`
	}
	refresh() {
		const e = this.props_.get("formatter");
		this.inputElement.value = e(this.value.rawValue)
	}
	onChange_() {
		this.refresh()
	}
}
class kd {
	constructor(e, t) {
		var i;
		this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = (i = t.sliderProps) !== null && i !== void 0 ? i : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = cn(null), this.view = new BN(e, {
			arrayPosition: t.arrayPosition,
			dragging: this.dragging_,
			props: this.props,
			value: this.value,
			viewProps: this.viewProps
		}), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
		const r = new Ll(this.view.knobElement);
		r.emitter.on("down", this.onPointerDown_), r.emitter.on("move", this.onPointerMove_), r.emitter.on("up", this.onPointerUp_)
	}
	constrainValue_(e) {
		var t, i;
		const r = (t = this.sliderProps_) === null || t === void 0 ? void 0 : t.get("min"),
			s = (i = this.sliderProps_) === null || i === void 0 ? void 0 : i.get("max");
		let o = e;
		return r !== void 0 && (o = Math.max(o, r)), s !== void 0 && (o = Math.min(o, s)), o
	}
	onInputChange_(e) {
		const i = e.currentTarget.value,
			r = this.parser_(i);
		Kt(r) || (this.value.rawValue = this.constrainValue_(r)), this.view.refresh()
	}
	onInputKeyDown_(e) {
		const t = zi(this.props.get("keyScale"), Yh(e));
		t !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), {
			forceEmit: !1,
			last: !1
		})
	}
	onInputKeyUp_(e) {
		zi(this.props.get("keyScale"), Yh(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
	onPointerDown_() {
		this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
	}
	computeDraggingValue_(e) {
		if (!e.point) return null;
		const t = e.point.x - e.bounds.width / 2;
		return this.constrainValue_(this.originRawValue_ + t * this.props.get("pointerScale"))
	}
	onPointerMove_(e) {
		const t = this.computeDraggingValue_(e.data);
		t !== null && (this.value.setRawValue(t, {
			forceEmit: !1,
			last: !1
		}), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
	}
	onPointerUp_(e) {
		const t = this.computeDraggingValue_(e.data);
		t !== null && (this.value.setRawValue(t, {
			forceEmit: !0,
			last: !0
		}), this.dragging_.rawValue = null)
	}
}
const U0 = Dt("sld");
class zN {
	constructor(e, t) {
		this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(U0()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(U0("t")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.trackElement = i;
		const r = e.createElement("div");
		r.classList.add(U0("k")), this.trackElement.appendChild(r), this.knobElement = r, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_()
	}
	update_() {
		const e = Un(Ot(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
		this.knobElement.style.width = `${e}%`
	}
	onChange_() {
		this.update_()
	}
}
class VN {
	constructor(e, t) {
		this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new zN(e, {
			props: this.props,
			value: this.value,
			viewProps: this.viewProps
		}), this.ptHandler_ = new Ll(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
	}
	handlePointerEvent_(e, t) {
		e.point && this.value.setRawValue(Ot(Un(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("min"), this.props.get("max")), t)
	}
	onPointerDownOrMove_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !0,
			last: !0
		})
	}
	onKeyDown_(e) {
		const t = zi(this.props.get("keyScale"), co(e));
		t !== 0 && this.value.setRawValue(this.value.rawValue + t, {
			forceEmit: !1,
			last: !1
		})
	}
	onKeyUp_(e) {
		zi(this.props.get("keyScale"), co(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
}
const B0 = Dt("sldtxt");
class HN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(B0());
		const i = e.createElement("div");
		i.classList.add(B0("s")), this.sliderView_ = t.sliderView, i.appendChild(this.sliderView_.element), this.element.appendChild(i);
		const r = e.createElement("div");
		r.classList.add(B0("t")), this.textView_ = t.textView, r.appendChild(this.textView_.element), this.element.appendChild(r)
	}
}
class zp {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new VN(e, {
			props: t.sliderProps,
			value: t.value,
			viewProps: this.viewProps
		}), this.textC_ = new kd(e, {
			parser: t.parser,
			props: t.textProps,
			sliderProps: t.sliderProps,
			value: t.value,
			viewProps: t.viewProps
		}), this.view = new HN(e, {
			sliderView: this.sliderC_.view,
			textView: this.textC_.view
		})
	}
	get sliderController() {
		return this.sliderC_
	}
	get textController() {
		return this.textC_
	}
	importProps(e) {
		return Tr(e, null, t => ({
			max: t.required.number,
			min: t.required.number
		}), t => {
			const i = this.sliderC_.props;
			return i.set("max", t.max), i.set("min", t.min), !0
		})
	}
	exportProps() {
		const e = this.sliderC_.props;
		return Mr(null, {
			max: e.get("max"),
			min: e.get("min")
		})
	}
}

function FM(n) {
	return {
		sliderProps: new _t({
			keyScale: n.keyScale,
			max: n.max,
			min: n.min
		}),
		textProps: new _t({
			formatter: cn(n.formatter),
			keyScale: n.keyScale,
			pointerScale: cn(n.pointerScale)
		})
	}
}
const GN = {
	containerUnitSize: "cnt-usz"
};

function NM(n) {
	return `--${GN[n]}`
}

function Kh(n) {
	return bM(n)
}

function qo(n) {
	if (V_(n)) return mn(n, Kh)
}

function Zs(n, e) {
	if (!n) return;
	const t = [],
		i = gM(n, e);
	i && t.push(i);
	const r = _M(n);
	return r && t.push(r), new Pd(t)
}

function WN(n) {
	return n ? n.major === xu.major : !1
}

function UM(n) {
	if (n === "inline" || n === "popup") return n
}

function Id(n, e) {
	n.write(e)
}
const sf = Dt("ckb");
class jN {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(sf()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("label");
		i.classList.add(sf("l")), this.element.appendChild(i), this.labelElement = i;
		const r = e.createElement("input");
		r.classList.add(sf("i")), r.type = "checkbox", this.labelElement.appendChild(r), this.inputElement = r, t.viewProps.bindDisabled(this.inputElement);
		const s = e.createElement("div");
		s.classList.add(sf("w")), this.labelElement.appendChild(s);
		const o = Gm(e, "check");
		s.appendChild(o), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
	}
	update_() {
		this.inputElement.checked = this.value.rawValue
	}
	onValueChange_() {
		this.update_()
	}
}
class $N {
	constructor(e, t) {
		this.onInputChange_ = this.onInputChange_.bind(this), this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new jN(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.labelElement.addEventListener("mousedown", this.onLabelMouseDown_)
	}
	onInputChange_(e) {
		const t = e.currentTarget;
		this.value.rawValue = t.checked, e.preventDefault(), e.stopPropagation()
	}
	onLabelMouseDown_(e) {
		e.preventDefault()
	}
}

function qN(n) {
	const e = [],
		t = U1(n.options);
	return t && e.push(t), new Pd(e)
}
const XN = Oi({
		id: "input-bool",
		type: "input",
		accept: (n, e) => {
			if (typeof n != "boolean") return null;
			const t = mn(e, i => ({
				options: i.optional.custom(Ld),
				readonly: i.optional.constant(!1)
			}));
			return t ? {
				initialValue: n,
				params: t
			} : null
		},
		binding: {
			reader: n => kM,
			constraint: n => qN(n.params),
			writer: n => Id
		},
		controller: n => {
			const e = n.document,
				t = n.value,
				i = n.constraint,
				r = i && Up(i, Rd);
			return r ? new ga(e, {
				props: new _t({
					options: r.values.value("options")
				}),
				value: t,
				viewProps: n.viewProps
			}) : new $N(e, {
				value: t,
				viewProps: n.viewProps
			})
		},
		api(n) {
			return typeof n.controller.value.rawValue != "boolean" ? null : n.controller.valueController instanceof ga ? new F1(n.controller) : null
		}
	}),
	Oa = Dt("col");
class YN {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(Oa()), t.foldable.bindExpandedClass(this.element, Oa(void 0, "expanded")), Ds(t.foldable, "completed", yu(this.element, Oa(void 0, "cpl")));
		const i = e.createElement("div");
		i.classList.add(Oa("h")), this.element.appendChild(i);
		const r = e.createElement("div");
		r.classList.add(Oa("s")), i.appendChild(r), this.swatchElement = r;
		const s = e.createElement("div");
		if (s.classList.add(Oa("t")), i.appendChild(s), this.textElement = s, t.pickerLayout === "inline") {
			const o = e.createElement("div");
			o.classList.add(Oa("p")), this.element.appendChild(o), this.pickerElement = o
		} else this.pickerElement = null
	}
}

function KN(n, e, t) {
	const i = Un(n / 255, 0, 1),
		r = Un(e / 255, 0, 1),
		s = Un(t / 255, 0, 1),
		o = Math.max(i, r, s),
		a = Math.min(i, r, s),
		l = o - a;
	let c = 0,
		u = 0;
	const h = (a + o) / 2;
	return l !== 0 && (u = l / (1 - Math.abs(o + a - 1)), i === o ? c = (r - s) / l : r === o ? c = 2 + (s - i) / l : c = 4 + (i - r) / l, c = c / 6 + (c < 0 ? 1 : 0)), [c * 360, u * 100, h * 100]
}

function ZN(n, e, t) {
	const i = (n % 360 + 360) % 360,
		r = Un(e / 100, 0, 1),
		s = Un(t / 100, 0, 1),
		o = (1 - Math.abs(2 * s - 1)) * r,
		a = o * (1 - Math.abs(i / 60 % 2 - 1)),
		l = s - o / 2;
	let c, u, h;
	return i >= 0 && i < 60 ? [c, u, h] = [o, a, 0] : i >= 60 && i < 120 ? [c, u, h] = [a, o, 0] : i >= 120 && i < 180 ? [c, u, h] = [0, o, a] : i >= 180 && i < 240 ? [c, u, h] = [0, a, o] : i >= 240 && i < 300 ? [c, u, h] = [a, 0, o] : [c, u, h] = [o, 0, a], [(c + l) * 255, (u + l) * 255, (h + l) * 255]
}

function JN(n, e, t) {
	const i = Un(n / 255, 0, 1),
		r = Un(e / 255, 0, 1),
		s = Un(t / 255, 0, 1),
		o = Math.max(i, r, s),
		a = Math.min(i, r, s),
		l = o - a;
	let c;
	l === 0 ? c = 0 : o === i ? c = 60 * (((r - s) / l % 6 + 6) % 6) : o === r ? c = 60 * ((s - i) / l + 2) : c = 60 * ((i - r) / l + 4);
	const u = o === 0 ? 0 : l / o,
		h = o;
	return [c, u * 100, h * 100]
}

function BM(n, e, t) {
	const i = fM(n, 360),
		r = Un(e / 100, 0, 1),
		s = Un(t / 100, 0, 1),
		o = s * r,
		a = o * (1 - Math.abs(i / 60 % 2 - 1)),
		l = s - o;
	let c, u, h;
	return i >= 0 && i < 60 ? [c, u, h] = [o, a, 0] : i >= 60 && i < 120 ? [c, u, h] = [a, o, 0] : i >= 120 && i < 180 ? [c, u, h] = [0, o, a] : i >= 180 && i < 240 ? [c, u, h] = [0, a, o] : i >= 240 && i < 300 ? [c, u, h] = [a, 0, o] : [c, u, h] = [o, 0, a], [(c + l) * 255, (u + l) * 255, (h + l) * 255]
}

function QN(n, e, t) {
	const i = t + e * (100 - Math.abs(2 * t - 100)) / 200;
	return [n, i !== 0 ? e * (100 - Math.abs(2 * t - 100)) / i : 0, t + e * (100 - Math.abs(2 * t - 100)) / (2 * 100)]
}

function eU(n, e, t) {
	const i = 100 - Math.abs(t * (200 - e) / 100 - 100);
	return [n, i !== 0 ? e * t / i : 0, t * (200 - e) / (2 * 100)]
}

function Ps(n) {
	return [n[0], n[1], n[2]]
}

function jm(n, e) {
	return [n[0], n[1], n[2], e]
}
const tU = {
	hsl: {
		hsl: (n, e, t) => [n, e, t],
		hsv: QN,
		rgb: ZN
	},
	hsv: {
		hsl: eU,
		hsv: (n, e, t) => [n, e, t],
		rgb: BM
	},
	rgb: {
		hsl: KN,
		hsv: JN,
		rgb: (n, e, t) => [n, e, t]
	}
};

function Jc(n, e) {
	return [e === "float" ? 1 : n === "rgb" ? 255 : 360, e === "float" ? 1 : n === "rgb" ? 255 : 100, e === "float" ? 1 : n === "rgb" ? 255 : 100]
}

function nU(n, e) {
	return n === e ? e : fM(n, e)
}

function zM(n, e, t) {
	var i;
	const r = Jc(e, t);
	return [e === "rgb" ? Un(n[0], 0, r[0]) : nU(n[0], r[0]), Un(n[1], 0, r[1]), Un(n[2], 0, r[2]), Un((i = n[3]) !== null && i !== void 0 ? i : 1, 0, 1)]
}

function Yx(n, e, t, i) {
	const r = Jc(e, t),
		s = Jc(e, i);
	return n.map((o, a) => o / r[a] * s[a])
}

function VM(n, e, t) {
	const i = Yx(n, e.mode, e.type, "int"),
		r = tU[e.mode][t.mode](...i);
	return Yx(r, t.mode, "int", t.type)
}
class Pt {
	static black() {
		return new Pt([0, 0, 0], "rgb")
	}
	constructor(e, t) {
		this.type = "int", this.mode = t, this.comps_ = zM(e, t, this.type)
	}
	getComponents(e) {
		return jm(VM(Ps(this.comps_), {
			mode: this.mode,
			type: this.type
		}, {
			mode: e ?? this.mode,
			type: this.type
		}), this.comps_[3])
	}
	toRgbaObject() {
		const e = this.getComponents("rgb");
		return {
			r: e[0],
			g: e[1],
			b: e[2],
			a: e[3]
		}
	}
}
const wo = Dt("colp");
class iU {
	constructor(e, t) {
		this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(wo()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(wo("hsv"));
		const r = e.createElement("div");
		r.classList.add(wo("sv")), this.svPaletteView_ = t.svPaletteView, r.appendChild(this.svPaletteView_.element), i.appendChild(r);
		const s = e.createElement("div");
		s.classList.add(wo("h")), this.hPaletteView_ = t.hPaletteView, s.appendChild(this.hPaletteView_.element), i.appendChild(s), this.element.appendChild(i);
		const o = e.createElement("div");
		if (o.classList.add(wo("rgb")), this.textsView_ = t.textsView, o.appendChild(this.textsView_.element), this.element.appendChild(o), t.alphaViews) {
			this.alphaViews_ = {
				palette: t.alphaViews.palette,
				text: t.alphaViews.text
			};
			const a = e.createElement("div");
			a.classList.add(wo("a"));
			const l = e.createElement("div");
			l.classList.add(wo("ap")), l.appendChild(this.alphaViews_.palette.element), a.appendChild(l);
			const c = e.createElement("div");
			c.classList.add(wo("at")), c.appendChild(this.alphaViews_.text.element), a.appendChild(c), this.element.appendChild(a)
		}
	}
	get allFocusableElements() {
		const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textsView_.modeSelectElement, ...this.textsView_.inputViews.map(t => t.inputElement)];
		return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e
	}
}

function rU(n) {
	return n === "int" ? "int" : n === "float" ? "float" : void 0
}

function B1(n) {
	return mn(n, e => ({
		color: e.optional.object({
			alpha: e.optional.boolean,
			type: e.optional.custom(rU)
		}),
		expanded: e.optional.boolean,
		picker: e.optional.custom(UM),
		readonly: e.optional.constant(!1)
	}))
}

function El(n) {
	return n ? .1 : 1
}

function HM(n) {
	var e;
	return (e = n.color) === null || e === void 0 ? void 0 : e.type
}
class z1 {
	constructor(e, t) {
		this.type = "float", this.mode = t, this.comps_ = zM(e, t, this.type)
	}
	getComponents(e) {
		return jm(VM(Ps(this.comps_), {
			mode: this.mode,
			type: this.type
		}, {
			mode: e ?? this.mode,
			type: this.type
		}), this.comps_[3])
	}
	toRgbaObject() {
		const e = this.getComponents("rgb");
		return {
			r: e[0],
			g: e[1],
			b: e[2],
			a: e[3]
		}
	}
}
const sU = {
	int: (n, e) => new Pt(n, e),
	float: (n, e) => new z1(n, e)
};

function V1(n, e, t) {
	return sU[t](n, e)
}

function oU(n) {
	return n.type === "float"
}

function aU(n) {
	return n.type === "int"
}

function lU(n) {
	const e = n.getComponents(),
		t = Jc(n.mode, "int");
	return new Pt([Math.round(Ot(e[0], 0, 1, 0, t[0])), Math.round(Ot(e[1], 0, 1, 0, t[1])), Math.round(Ot(e[2], 0, 1, 0, t[2])), e[3]], n.mode)
}

function cU(n) {
	const e = n.getComponents(),
		t = Jc(n.mode, "int");
	return new z1([Ot(e[0], 0, t[0], 0, 1), Ot(e[1], 0, t[1], 0, 1), Ot(e[2], 0, t[2], 0, 1), e[3]], n.mode)
}

function ki(n, e) {
	if (n.type === e) return n;
	if (aU(n) && e === "float") return cU(n);
	if (oU(n) && e === "int") return lU(n);
	throw _n.shouldNeverHappen()
}

function uU(n, e) {
	return n.alpha === e.alpha && n.mode === e.mode && n.notation === e.notation && n.type === e.type
}

function Vr(n, e) {
	const t = n.match(/^(.+)%$/);
	return Math.min(t ? parseFloat(t[1]) * .01 * e : parseFloat(n), e)
}
const hU = {
	deg: n => n,
	grad: n => n * 360 / 400,
	rad: n => n * 360 / (2 * Math.PI),
	turn: n => n * 360
};

function GM(n) {
	const e = n.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
	if (!e) return parseFloat(n);
	const t = parseFloat(e[1]),
		i = e[2];
	return hU[i](t)
}

function WM(n) {
	const e = n.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [Vr(e[1], 255), Vr(e[2], 255), Vr(e[3], 255)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t
}

function dU(n) {
	const e = WM(n);
	return e ? new Pt(e, "rgb") : null
}

function jM(n) {
	const e = n.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [Vr(e[1], 255), Vr(e[2], 255), Vr(e[3], 255), Vr(e[4], 1)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t
}

function fU(n) {
	const e = jM(n);
	return e ? new Pt(e, "rgb") : null
}

function $M(n) {
	const e = n.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [GM(e[1]), Vr(e[2], 100), Vr(e[3], 100)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t
}

function pU(n) {
	const e = $M(n);
	return e ? new Pt(e, "hsl") : null
}

function qM(n) {
	const e = n.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [GM(e[1]), Vr(e[2], 100), Vr(e[3], 100), Vr(e[4], 1)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t
}

function mU(n) {
	const e = qM(n);
	return e ? new Pt(e, "hsl") : null
}

function XM(n) {
	const e = n.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
	if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)];
	const t = n.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
	return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : null
}

function gU(n) {
	const e = XM(n);
	return e ? new Pt(e, "rgb") : null
}

function YM(n) {
	const e = n.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
	if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16), Ot(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)];
	const t = n.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
	return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), Ot(parseInt(t[4], 16), 0, 255, 0, 1)] : null
}

function _U(n) {
	const e = YM(n);
	return e ? new Pt(e, "rgb") : null
}

function KM(n) {
	const e = n.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
	if (!e) return null;
	const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t
}

function vU(n) {
	return e => {
		const t = KM(e);
		return t ? V1(t, "rgb", n) : null
	}
}

function ZM(n) {
	const e = n.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
	if (!e) return null;
	const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t
}

function bU(n) {
	return e => {
		const t = ZM(e);
		return t ? V1(t, "rgb", n) : null
	}
}
const yU = [{
	parser: XM,
	result: {
		alpha: !1,
		mode: "rgb",
		notation: "hex"
	}
}, {
	parser: YM,
	result: {
		alpha: !0,
		mode: "rgb",
		notation: "hex"
	}
}, {
	parser: WM,
	result: {
		alpha: !1,
		mode: "rgb",
		notation: "func"
	}
}, {
	parser: jM,
	result: {
		alpha: !0,
		mode: "rgb",
		notation: "func"
	}
}, {
	parser: $M,
	result: {
		alpha: !1,
		mode: "hsl",
		notation: "func"
	}
}, {
	parser: qM,
	result: {
		alpha: !0,
		mode: "hsl",
		notation: "func"
	}
}, {
	parser: KM,
	result: {
		alpha: !1,
		mode: "rgb",
		notation: "object"
	}
}, {
	parser: ZM,
	result: {
		alpha: !0,
		mode: "rgb",
		notation: "object"
	}
}];

function xU(n) {
	return yU.reduce((e, {
		parser: t,
		result: i
	}) => e || (t(n) ? i : null), null)
}

function wU(n, e = "int") {
	const t = xU(n);
	return t ? t.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, t), {
		type: "int"
	}) : t.notation === "func" ? Object.assign(Object.assign({}, t), {
		type: e
	}) : null : null
}

function Od(n) {
	const e = [gU, _U, dU, fU, pU, mU];
	e.push(vU("int"), bU("int"));
	const t = FN(e);
	return i => {
		const r = t(i);
		return r ? ki(r, n) : null
	}
}

function EU(n) {
	const e = Od("int");
	if (typeof n != "string") return Pt.black();
	const t = e(n);
	return t ?? Pt.black()
}

function JM(n) {
	const e = Un(Math.floor(n), 0, 255).toString(16);
	return e.length === 1 ? `0${e}` : e
}

function H1(n, e = "#") {
	const t = Ps(n.getComponents("rgb")).map(JM).join("");
	return `${e}${t}`
}

function G1(n, e = "#") {
	const t = n.getComponents("rgb"),
		i = [t[0], t[1], t[2], t[3] * 255].map(JM).join("");
	return `${e}${i}`
}

function QM(n) {
	const e = Ki(0),
		t = ki(n, "int");
	return `rgb(${Ps(t.getComponents("rgb")).map(r=>e(r)).join(", ")})`
}

function ap(n) {
	const e = Ki(2),
		t = Ki(0);
	return `rgba(${ki(n,"int").getComponents("rgb").map((s,o)=>(o===3?e:t)(s)).join(", ")})`
}

function SU(n) {
	const e = [Ki(0), Bp, Bp],
		t = ki(n, "int");
	return `hsl(${Ps(t.getComponents("hsl")).map((r,s)=>e[s](r)).join(", ")})`
}

function TU(n) {
	const e = [Ki(0), Bp, Bp, Ki(2)];
	return `hsla(${ki(n,"int").getComponents("hsl").map((r,s)=>e[s](r)).join(", ")})`
}

function eC(n, e) {
	const t = Ki(e === "float" ? 2 : 0),
		i = ["r", "g", "b"],
		r = ki(n, e);
	return `{${Ps(r.getComponents("rgb")).map((o,a)=>`${i[a]}: ${t(o)}`).join(", ")}}`
}

function MU(n) {
	return e => eC(e, n)
}

function tC(n, e) {
	const t = Ki(2),
		i = Ki(e === "float" ? 2 : 0),
		r = ["r", "g", "b", "a"];
	return `{${ki(n,e).getComponents("rgb").map((a,l)=>{const c=l===3?t:i;return`${r[l]}: ${c(a)}`}).join(", ")}}`
}

function CU(n) {
	return e => tC(e, n)
}
const AU = [{
	format: {
		alpha: !1,
		mode: "rgb",
		notation: "hex",
		type: "int"
	},
	stringifier: H1
}, {
	format: {
		alpha: !0,
		mode: "rgb",
		notation: "hex",
		type: "int"
	},
	stringifier: G1
}, {
	format: {
		alpha: !1,
		mode: "rgb",
		notation: "func",
		type: "int"
	},
	stringifier: QM
}, {
	format: {
		alpha: !0,
		mode: "rgb",
		notation: "func",
		type: "int"
	},
	stringifier: ap
}, {
	format: {
		alpha: !1,
		mode: "hsl",
		notation: "func",
		type: "int"
	},
	stringifier: SU
}, {
	format: {
		alpha: !0,
		mode: "hsl",
		notation: "func",
		type: "int"
	},
	stringifier: TU
}, ...["int", "float"].reduce((n, e) => [...n, {
	format: {
		alpha: !1,
		mode: "rgb",
		notation: "object",
		type: e
	},
	stringifier: MU(e)
}, {
	format: {
		alpha: !0,
		mode: "rgb",
		notation: "object",
		type: e
	},
	stringifier: CU(e)
}], [])];

function nC(n) {
	return AU.reduce((e, t) => e || (uU(t.format, n) ? t.stringifier : null), null)
}
const Ou = Dt("apl");
class DU {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Ou()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
		const i = e.createElement("div");
		i.classList.add(Ou("b")), this.element.appendChild(i);
		const r = e.createElement("div");
		r.classList.add(Ou("c")), i.appendChild(r), this.colorElem_ = r;
		const s = e.createElement("div");
		s.classList.add(Ou("m")), this.element.appendChild(s), this.markerElem_ = s;
		const o = e.createElement("div");
		o.classList.add(Ou("p")), this.markerElem_.appendChild(o), this.previewElem_ = o, this.update_()
	}
	update_() {
		const e = this.value.rawValue,
			t = e.getComponents("rgb"),
			i = new Pt([t[0], t[1], t[2], 0], "rgb"),
			r = new Pt([t[0], t[1], t[2], 255], "rgb"),
			s = ["to right", ap(i), ap(r)];
		this.colorElem_.style.background = `linear-gradient(${s.join(",")})`, this.previewElem_.style.backgroundColor = ap(e);
		const o = Ot(t[3], 0, 1, 0, 100);
		this.markerElem_.style.left = `${o}%`
	}
	onValueChange_() {
		this.update_()
	}
}
class PU {
	constructor(e, t) {
		this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new DU(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.ptHandler_ = new Ll(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const i = e.point.x / e.bounds.width,
			r = this.value.rawValue,
			[s, o, a] = r.getComponents("hsv");
		this.value.setRawValue(new Pt([s, o, a, i], "hsv"), t)
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !0,
			last: !0
		})
	}
	onKeyDown_(e) {
		const t = zi(El(!0), co(e));
		if (t === 0) return;
		const i = this.value.rawValue,
			[r, s, o, a] = i.getComponents("hsv");
		this.value.setRawValue(new Pt([r, s, o, a + t], "hsv"), {
			forceEmit: !1,
			last: !1
		})
	}
	onKeyUp_(e) {
		zi(El(!0), co(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
}
const zl = Dt("coltxt");

function RU(n) {
	const e = n.createElement("select"),
		t = [{
			text: "RGB",
			value: "rgb"
		}, {
			text: "HSL",
			value: "hsl"
		}, {
			text: "HSV",
			value: "hsv"
		}, {
			text: "HEX",
			value: "hex"
		}];
	return e.appendChild(t.reduce((i, r) => {
		const s = n.createElement("option");
		return s.textContent = r.text, s.value = r.value, i.appendChild(s), i
	}, n.createDocumentFragment())), e
}
class LU {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(zl()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(zl("m")), this.modeElem_ = RU(e), this.modeElem_.classList.add(zl("ms")), i.appendChild(this.modeSelectElement), t.viewProps.bindDisabled(this.modeElem_);
		const r = e.createElement("div");
		r.classList.add(zl("mm")), r.appendChild(Gm(e, "dropdown")), i.appendChild(r), this.element.appendChild(i);
		const s = e.createElement("div");
		s.classList.add(zl("w")), this.element.appendChild(s), this.inputsElem_ = s, this.inputViews_ = t.inputViews, this.applyInputViews_(), io(t.mode, o => {
			this.modeElem_.value = o
		})
	}
	get modeSelectElement() {
		return this.modeElem_
	}
	get inputViews() {
		return this.inputViews_
	}
	set inputViews(e) {
		this.inputViews_ = e, this.applyInputViews_()
	}
	applyInputViews_() {
		wM(this.inputsElem_);
		const e = this.element.ownerDocument;
		this.inputViews_.forEach(t => {
			const i = e.createElement("div");
			i.classList.add(zl("c")), i.appendChild(t.element), this.inputsElem_.appendChild(i)
		})
	}
}

function kU(n) {
	return Ki(n === "float" ? 2 : 0)
}

function IU(n, e, t) {
	const i = Jc(n, e)[t];
	return new Cd({
		min: 0,
		max: i
	})
}

function OU(n, e, t) {
	return new kd(n, {
		arrayPosition: t === 0 ? "fst" : t === 2 ? "lst" : "mid",
		parser: e.parser,
		props: _t.fromObject({
			formatter: kU(e.colorType),
			keyScale: El(!1),
			pointerScale: e.colorType === "float" ? .01 : 1
		}),
		value: cn(0, {
			constraint: IU(e.colorMode, e.colorType, t)
		}),
		viewProps: e.viewProps
	})
}

function FU(n, e) {
	const t = {
		colorMode: e.colorMode,
		colorType: e.colorType,
		parser: lo,
		viewProps: e.viewProps
	};
	return [0, 1, 2].map(i => {
		const r = OU(n, t, i);
		return Eu({
			primary: e.value,
			secondary: r.value,
			forward(s) {
				return ki(s, e.colorType).getComponents(e.colorMode)[i]
			},
			backward(s, o) {
				const a = e.colorMode,
					c = ki(s, e.colorType).getComponents(a);
				c[i] = o;
				const u = V1(jm(Ps(c), c[3]), a, e.colorType);
				return ki(u, "int")
			}
		}), r
	})
}

function NU(n, e) {
	const t = new Xh(n, {
		parser: Od("int"),
		props: _t.fromObject({
			formatter: H1
		}),
		value: cn(Pt.black()),
		viewProps: e.viewProps
	});
	return Eu({
		primary: e.value,
		secondary: t.value,
		forward: i => new Pt(Ps(i.getComponents()), i.mode),
		backward: (i, r) => new Pt(jm(Ps(r.getComponents(i.mode)), i.getComponents()[3]), i.mode)
	}), [t]
}

function UU(n) {
	return n !== "hex"
}
class BU {
	constructor(e, t) {
		this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = cn(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new LU(e, {
			mode: this.colorMode,
			inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
			viewProps: this.viewProps
		}), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
	}
	createComponentControllers_(e) {
		const t = this.colorMode.rawValue;
		return UU(t) ? FU(e, {
			colorMode: t,
			colorType: this.colorType_,
			value: this.value,
			viewProps: this.viewProps
		}) : NU(e, {
			value: this.value,
			viewProps: this.viewProps
		})
	}
	onModeSelectChange_(e) {
		const t = e.currentTarget;
		this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.inputViews = this.ccs_.map(i => i.view)
	}
}
const z0 = Dt("hpl");
class zU {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(z0()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
		const i = e.createElement("div");
		i.classList.add(z0("c")), this.element.appendChild(i);
		const r = e.createElement("div");
		r.classList.add(z0("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_()
	}
	update_() {
		const e = this.value.rawValue,
			[t] = e.getComponents("hsv");
		this.markerElem_.style.backgroundColor = QM(new Pt([t, 100, 100], "hsv"));
		const i = Ot(t, 0, 360, 0, 100);
		this.markerElem_.style.left = `${i}%`
	}
	onValueChange_() {
		this.update_()
	}
}
class VU {
	constructor(e, t) {
		this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new zU(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.ptHandler_ = new Ll(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const i = Ot(Un(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 360),
			r = this.value.rawValue,
			[, s, o, a] = r.getComponents("hsv");
		this.value.setRawValue(new Pt([i, s, o, a], "hsv"), t)
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !0,
			last: !0
		})
	}
	onKeyDown_(e) {
		const t = zi(El(!1), co(e));
		if (t === 0) return;
		const i = this.value.rawValue,
			[r, s, o, a] = i.getComponents("hsv");
		this.value.setRawValue(new Pt([r + t, s, o, a], "hsv"), {
			forceEmit: !1,
			last: !1
		})
	}
	onKeyUp_(e) {
		zi(El(!1), co(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
}
const V0 = Dt("svp"),
	Kx = 64;
class HU {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(V0()), t.viewProps.bindClassModifiers(this.element), t.viewProps.bindTabIndex(this.element);
		const i = e.createElement("canvas");
		i.height = Kx, i.width = Kx, i.classList.add(V0("c")), this.element.appendChild(i), this.canvasElement = i;
		const r = e.createElement("div");
		r.classList.add(V0("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_()
	}
	update_() {
		const e = V8(this.canvasElement);
		if (!e) return;
		const i = this.value.rawValue.getComponents("hsv"),
			r = this.canvasElement.width,
			s = this.canvasElement.height,
			o = e.getImageData(0, 0, r, s),
			a = o.data;
		for (let u = 0; u < s; u++)
			for (let h = 0; h < r; h++) {
				const d = Ot(h, 0, r, 0, 100),
					f = Ot(u, 0, s, 100, 0),
					p = BM(i[0], d, f),
					_ = (u * r + h) * 4;
				a[_] = p[0], a[_ + 1] = p[1], a[_ + 2] = p[2], a[_ + 3] = 255
			}
		e.putImageData(o, 0, 0);
		const l = Ot(i[1], 0, 100, 0, 100);
		this.markerElem_.style.left = `${l}%`;
		const c = Ot(i[2], 0, 100, 100, 0);
		this.markerElem_.style.top = `${c}%`
	}
	onValueChange_() {
		this.update_()
	}
}
class GU {
	constructor(e, t) {
		this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new HU(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.ptHandler_ = new Ll(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const i = Ot(e.point.x, 0, e.bounds.width, 0, 100),
			r = Ot(e.point.y, 0, e.bounds.height, 100, 0),
			[s, , , o] = this.value.rawValue.getComponents("hsv");
		this.value.setRawValue(new Pt([s, i, r, o], "hsv"), t)
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !0,
			last: !0
		})
	}
	onKeyDown_(e) {
		OM(e.key) && e.preventDefault();
		const [t, i, r, s] = this.value.rawValue.getComponents("hsv"), o = El(!1), a = zi(o, co(e)), l = zi(o, Yh(e));
		a === 0 && l === 0 || this.value.setRawValue(new Pt([t, i + a, r + l, s], "hsv"), {
			forceEmit: !1,
			last: !1
		})
	}
	onKeyUp_(e) {
		const t = El(!1),
			i = zi(t, co(e)),
			r = zi(t, Yh(e));
		i === 0 && r === 0 || this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
}
class WU {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new VU(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.svPaletteC_ = new GU(e, {
			value: this.value,
			viewProps: this.viewProps
		}), this.alphaIcs_ = t.supportsAlpha ? {
			palette: new PU(e, {
				value: this.value,
				viewProps: this.viewProps
			}),
			text: new kd(e, {
				parser: lo,
				props: _t.fromObject({
					pointerScale: .01,
					keyScale: .1,
					formatter: Ki(2)
				}),
				value: cn(0, {
					constraint: new Cd({
						min: 0,
						max: 1
					})
				}),
				viewProps: this.viewProps
			})
		} : null, this.alphaIcs_ && Eu({
			primary: this.value,
			secondary: this.alphaIcs_.text.value,
			forward: i => i.getComponents()[3],
			backward: (i, r) => {
				const s = i.getComponents();
				return s[3] = r, new Pt(s, i.mode)
			}
		}), this.textsC_ = new BU(e, {
			colorType: t.colorType,
			value: this.value,
			viewProps: this.viewProps
		}), this.view = new iU(e, {
			alphaViews: this.alphaIcs_ ? {
				palette: this.alphaIcs_.palette.view,
				text: this.alphaIcs_.text.view
			} : null,
			hPaletteView: this.hPaletteC_.view,
			supportsAlpha: t.supportsAlpha,
			svPaletteView: this.svPaletteC_.view,
			textsView: this.textsC_.view,
			viewProps: this.viewProps
		})
	}
	get textsController() {
		return this.textsC_
	}
}
const H0 = Dt("colsw");
class jU {
	constructor(e, t) {
		this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(H0()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(H0("sw")), this.element.appendChild(i), this.swatchElem_ = i;
		const r = e.createElement("button");
		r.classList.add(H0("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r, this.update_()
	}
	update_() {
		const e = this.value.rawValue;
		this.swatchElem_.style.backgroundColor = G1(e)
	}
	onValueChange_() {
		this.update_()
	}
}
class $U {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.view = new jU(e, {
			value: this.value,
			viewProps: this.viewProps
		})
	}
}
class W1 {
	constructor(e, t) {
		this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Dd.create(t.expanded), this.swatchC_ = new $U(e, {
			value: this.value,
			viewProps: this.viewProps
		});
		const i = this.swatchC_.view.buttonElement;
		i.addEventListener("blur", this.onButtonBlur_), i.addEventListener("click", this.onButtonClick_), this.textC_ = new Xh(e, {
			parser: t.parser,
			props: _t.fromObject({
				formatter: t.formatter
			}),
			value: this.value,
			viewProps: this.viewProps
		}), this.view = new YN(e, {
			foldable: this.foldable_,
			pickerLayout: t.pickerLayout
		}), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = t.pickerLayout === "popup" ? new LM(e, {
			viewProps: this.viewProps
		}) : null;
		const r = new WU(e, {
			colorType: t.colorType,
			supportsAlpha: t.supportsAlpha,
			value: this.value,
			viewProps: this.viewProps
		});
		r.view.allFocusableElements.forEach(s => {
			s.addEventListener("blur", this.onPopupChildBlur_), s.addEventListener("keydown", this.onPopupChildKeydown_)
		}), this.pickerC_ = r, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(r.view.element), Eu({
			primary: this.foldable_.value("expanded"),
			secondary: this.popC_.shows,
			forward: s => s,
			backward: (s, o) => o
		})) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), O1(this.foldable_, this.view.pickerElement))
	}
	get textController() {
		return this.textC_
	}
	onButtonBlur_(e) {
		if (!this.popC_) return;
		const t = this.view.element,
			i = e.relatedTarget;
		(!i || !t.contains(i)) && (this.popC_.shows.rawValue = !1)
	}
	onButtonClick_() {
		this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
	}
	onPopupChildBlur_(e) {
		if (!this.popC_) return;
		const t = this.popC_.view.element,
			i = EM(e);
		i && t.contains(i) || i && i === this.swatchC_.view.buttonElement && !D1(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
	}
	onPopupChildKeydown_(e) {
		this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus()
	}
}

function qU(n) {
	return Ps(n.getComponents("rgb")).reduce((e, t) => e << 8 | Math.floor(t) & 255, 0)
}

function XU(n) {
	return n.getComponents("rgb").reduce((e, t, i) => {
		const r = Math.floor(i === 3 ? t * 255 : t) & 255;
		return e << 8 | r
	}, 0) >>> 0
}

function YU(n) {
	return new Pt([n >> 16 & 255, n >> 8 & 255, n & 255], "rgb")
}

function KU(n) {
	return new Pt([n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, Ot(n & 255, 0, 255, 0, 1)], "rgb")
}

function ZU(n) {
	return typeof n != "number" ? Pt.black() : YU(n)
}

function JU(n) {
	return typeof n != "number" ? Pt.black() : KU(n)
}

function lp(n, e) {
	return typeof n != "object" || Kt(n) ? !1 : e in n && typeof n[e] == "number"
}

function iC(n) {
	return lp(n, "r") && lp(n, "g") && lp(n, "b")
}

function rC(n) {
	return iC(n) && lp(n, "a")
}

function sC(n) {
	return iC(n)
}

function j1(n, e) {
	if (n.mode !== e.mode || n.type !== e.type) return !1;
	const t = n.getComponents(),
		i = e.getComponents();
	for (let r = 0; r < t.length; r++)
		if (t[r] !== i[r]) return !1;
	return !0
}

function Zx(n) {
	return "a" in n ? [n.r, n.g, n.b, n.a] : [n.r, n.g, n.b]
}

function QU(n) {
	const e = nC(n);
	return e ? (t, i) => {
		Id(t, e(i))
	} : null
}

function e7(n) {
	const e = n ? XU : qU;
	return (t, i) => {
		Id(t, e(i))
	}
}

function t7(n, e, t) {
	const r = ki(e, t).toRgbaObject();
	n.writeProperty("r", r.r), n.writeProperty("g", r.g), n.writeProperty("b", r.b), n.writeProperty("a", r.a)
}

function n7(n, e, t) {
	const r = ki(e, t).toRgbaObject();
	n.writeProperty("r", r.r), n.writeProperty("g", r.g), n.writeProperty("b", r.b)
}

function i7(n, e) {
	return (t, i) => {
		n ? t7(t, i, e) : n7(t, i, e)
	}
}

function r7(n) {
	var e;
	return !!(!((e = n == null ? void 0 : n.color) === null || e === void 0) && e.alpha)
}

function s7(n) {
	return n ? e => G1(e, "0x") : e => H1(e, "0x")
}

function o7(n) {
	return "color" in n || n.view === "color"
}
const a7 = Oi({
	id: "input-color-number",
	type: "input",
	accept: (n, e) => {
		if (typeof n != "number" || !o7(e)) return null;
		const t = B1(e);
		return t ? {
			initialValue: n,
			params: Object.assign(Object.assign({}, t), {
				supportsAlpha: r7(e)
			})
		} : null
	},
	binding: {
		reader: n => n.params.supportsAlpha ? JU : ZU,
		equals: j1,
		writer: n => e7(n.params.supportsAlpha)
	},
	controller: n => {
		var e, t;
		return new W1(n.document, {
			colorType: "int",
			expanded: (e = n.params.expanded) !== null && e !== void 0 ? e : !1,
			formatter: s7(n.params.supportsAlpha),
			parser: Od("int"),
			pickerLayout: (t = n.params.picker) !== null && t !== void 0 ? t : "popup",
			supportsAlpha: n.params.supportsAlpha,
			value: n.value,
			viewProps: n.viewProps
		})
	}
});

function l7(n, e) {
	if (!sC(n)) return ki(Pt.black(), e);
	if (e === "int") {
		const t = Zx(n);
		return new Pt(t, "rgb")
	}
	if (e === "float") {
		const t = Zx(n);
		return new z1(t, "rgb")
	}
	return ki(Pt.black(), "int")
}

function c7(n) {
	return rC(n)
}

function u7(n) {
	return e => {
		const t = l7(e, n);
		return ki(t, "int")
	}
}

function h7(n, e) {
	return t => n ? tC(t, e) : eC(t, e)
}
const d7 = Oi({
		id: "input-color-object",
		type: "input",
		accept: (n, e) => {
			var t;
			if (!sC(n)) return null;
			const i = B1(e);
			return i ? {
				initialValue: n,
				params: Object.assign(Object.assign({}, i), {
					colorType: (t = HM(e)) !== null && t !== void 0 ? t : "int"
				})
			} : null
		},
		binding: {
			reader: n => u7(n.params.colorType),
			equals: j1,
			writer: n => i7(c7(n.initialValue), n.params.colorType)
		},
		controller: n => {
			var e, t;
			const i = rC(n.initialValue);
			return new W1(n.document, {
				colorType: n.params.colorType,
				expanded: (e = n.params.expanded) !== null && e !== void 0 ? e : !1,
				formatter: h7(i, n.params.colorType),
				parser: Od("int"),
				pickerLayout: (t = n.params.picker) !== null && t !== void 0 ? t : "popup",
				supportsAlpha: i,
				value: n.value,
				viewProps: n.viewProps
			})
		}
	}),
	f7 = Oi({
		id: "input-color-string",
		type: "input",
		accept: (n, e) => {
			if (typeof n != "string" || e.view === "text") return null;
			const t = wU(n, HM(e));
			if (!t) return null;
			const i = nC(t);
			if (!i) return null;
			const r = B1(e);
			return r ? {
				initialValue: n,
				params: Object.assign(Object.assign({}, r), {
					format: t,
					stringifier: i
				})
			} : null
		},
		binding: {
			reader: () => EU,
			equals: j1,
			writer: n => {
				const e = QU(n.params.format);
				if (!e) throw _n.notBindable();
				return e
			}
		},
		controller: n => {
			var e, t;
			return new W1(n.document, {
				colorType: n.params.format.type,
				expanded: (e = n.params.expanded) !== null && e !== void 0 ? e : !1,
				formatter: n.params.stringifier,
				parser: Od("int"),
				pickerLayout: (t = n.params.picker) !== null && t !== void 0 ? t : "popup",
				supportsAlpha: n.params.format.alpha,
				value: n.value,
				viewProps: n.viewProps
			})
		}
	});
class $1 {
	constructor(e) {
		this.components = e.components, this.asm_ = e.assembly
	}
	constrain(e) {
		const t = this.asm_.toComponents(e).map((i, r) => {
			var s, o;
			return (o = (s = this.components[r]) === null || s === void 0 ? void 0 : s.constrain(i)) !== null && o !== void 0 ? o : i
		});
		return this.asm_.fromComponents(t)
	}
}
const Jx = Dt("pndtxt");
class p7 {
	constructor(e, t) {
		this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Jx()), this.textViews.forEach(i => {
			const r = e.createElement("div");
			r.classList.add(Jx("a")), r.appendChild(i.element), this.element.appendChild(r)
		})
	}
}

function m7(n, e, t) {
	return new kd(n, {
		arrayPosition: t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
		parser: e.parser,
		props: e.axes[t].textProps,
		value: cn(0, {
			constraint: e.axes[t].constraint
		}),
		viewProps: e.viewProps
	})
}
class q1 {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((i, r) => m7(e, t, r)), this.acs_.forEach((i, r) => {
			Eu({
				primary: this.value,
				secondary: i.value,
				forward: s => t.assembly.toComponents(s)[r],
				backward: (s, o) => {
					const a = t.assembly.toComponents(s);
					return a[r] = o, t.assembly.fromComponents(a)
				}
			})
		}), this.view = new p7(e, {
			textViews: this.acs_.map(i => i.view)
		})
	}
	get textControllers() {
		return this.acs_
	}
}
class g7 extends qh {
	get max() {
		return this.controller.valueController.sliderController.props.get("max")
	}
	set max(e) {
		this.controller.valueController.sliderController.props.set("max", e)
	}
	get min() {
		return this.controller.valueController.sliderController.props.get("min")
	}
	set min(e) {
		this.controller.valueController.sliderController.props.set("min", e)
	}
}

function _7(n, e) {
	const t = [],
		i = gM(n, e);
	i && t.push(i);
	const r = _M(n);
	r && t.push(r);
	const s = U1(n.options);
	return s && t.push(s), new Pd(t)
}
const v7 = Oi({
	id: "input-number",
	type: "input",
	accept: (n, e) => {
		if (typeof n != "number") return null;
		const t = mn(e, i => Object.assign(Object.assign({}, bM(i)), {
			options: i.optional.custom(Ld),
			readonly: i.optional.constant(!1)
		}));
		return t ? {
			initialValue: n,
			params: t
		} : null
	},
	binding: {
		reader: n => dM,
		constraint: n => _7(n.params, n.initialValue),
		writer: n => Id
	},
	controller: n => {
		const e = n.value,
			t = n.constraint,
			i = t && Up(t, Rd);
		if (i) return new ga(n.document, {
			props: new _t({
				options: i.values.value("options")
			}),
			value: e,
			viewProps: n.viewProps
		});
		const r = vM(n.params, e.rawValue),
			s = t && Up(t, Cd);
		return s ? new zp(n.document, Object.assign(Object.assign({}, FM(Object.assign(Object.assign({}, r), {
			keyScale: cn(r.keyScale),
			max: s.values.value("max"),
			min: s.values.value("min")
		}))), {
			parser: lo,
			value: e,
			viewProps: n.viewProps
		})) : new kd(n.document, {
			parser: lo,
			props: _t.fromObject(r),
			value: e,
			viewProps: n.viewProps
		})
	},
	api(n) {
		return typeof n.controller.value.rawValue != "number" ? null : n.controller.valueController instanceof zp ? new g7(n.controller) : n.controller.valueController instanceof ga ? new F1(n.controller) : null
	}
});
class ra {
	constructor(e = 0, t = 0) {
		this.x = e, this.y = t
	}
	getComponents() {
		return [this.x, this.y]
	}
	static isObject(e) {
		if (Kt(e)) return !1;
		const t = e.x,
			i = e.y;
		return !(typeof t != "number" || typeof i != "number")
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y
	}
	toObject() {
		return {
			x: this.x,
			y: this.y
		}
	}
}
const oC = {
		toComponents: n => n.getComponents(),
		fromComponents: n => new ra(...n)
	},
	Vl = Dt("p2d");
class b7 {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(Vl()), t.viewProps.bindClassModifiers(this.element), io(t.expanded, yu(this.element, Vl(void 0, "expanded")));
		const i = e.createElement("div");
		i.classList.add(Vl("h")), this.element.appendChild(i);
		const r = e.createElement("button");
		r.classList.add(Vl("b")), r.appendChild(Gm(e, "p2dpad")), t.viewProps.bindDisabled(r), i.appendChild(r), this.buttonElement = r;
		const s = e.createElement("div");
		if (s.classList.add(Vl("t")), i.appendChild(s), this.textElement = s, t.pickerLayout === "inline") {
			const o = e.createElement("div");
			o.classList.add(Vl("p")), this.element.appendChild(o), this.pickerElement = o
		} else this.pickerElement = null
	}
}
const Eo = Dt("p2dp");
class y7 {
	constructor(e, t) {
		this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onPropsChange_ = this.onPropsChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onPropsChange_), this.element = e.createElement("div"), this.element.classList.add(Eo()), t.layout === "popup" && this.element.classList.add(Eo(void 0, "p")), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("div");
		i.classList.add(Eo("p")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.padElement = i;
		const r = e.createElementNS(ys, "svg");
		r.classList.add(Eo("g")), this.padElement.appendChild(r), this.svgElem_ = r;
		const s = e.createElementNS(ys, "line");
		s.classList.add(Eo("ax")), s.setAttributeNS(null, "x1", "0"), s.setAttributeNS(null, "y1", "50%"), s.setAttributeNS(null, "x2", "100%"), s.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(s);
		const o = e.createElementNS(ys, "line");
		o.classList.add(Eo("ax")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "0"), o.setAttributeNS(null, "x2", "50%"), o.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(o);
		const a = e.createElementNS(ys, "line");
		a.classList.add(Eo("l")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(a), this.lineElem_ = a;
		const l = e.createElement("div");
		l.classList.add(Eo("m")), this.padElement.appendChild(l), this.markerElem_ = l, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
	}
	get allFocusableElements() {
		return [this.padElement]
	}
	update_() {
		const [e, t] = this.value.rawValue.getComponents(), i = this.props_.get("max"), r = Ot(e, -i, +i, 0, 100), s = Ot(t, -i, +i, 0, 100), o = this.props_.get("invertsY") ? 100 - s : s;
		this.lineElem_.setAttributeNS(null, "x2", `${r}%`), this.lineElem_.setAttributeNS(null, "y2", `${o}%`), this.markerElem_.style.left = `${r}%`, this.markerElem_.style.top = `${o}%`
	}
	onValueChange_() {
		this.update_()
	}
	onPropsChange_() {
		this.update_()
	}
	onFoldableChange_() {
		this.update_()
	}
}

function Qx(n, e, t) {
	return [zi(e[0], co(n)), zi(e[1], Yh(n)) * (t ? 1 : -1)]
}
class x7 {
	constructor(e, t) {
		this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new y7(e, {
			layout: t.layout,
			props: this.props,
			value: this.value,
			viewProps: this.viewProps
		}), this.ptHandler_ = new Ll(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const i = this.props.get("max"),
			r = Ot(e.point.x, 0, e.bounds.width, -i, +i),
			s = Ot(this.props.get("invertsY") ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -i, +i);
		this.value.setRawValue(new ra(r, s), t)
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !1,
			last: !1
		})
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, {
			forceEmit: !0,
			last: !0
		})
	}
	onPadKeyDown_(e) {
		OM(e.key) && e.preventDefault();
		const [t, i] = Qx(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
		t === 0 && i === 0 || this.value.setRawValue(new ra(this.value.rawValue.x + t, this.value.rawValue.y + i), {
			forceEmit: !1,
			last: !1
		})
	}
	onPadKeyUp_(e) {
		const [t, i] = Qx(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
		t === 0 && i === 0 || this.value.setRawValue(this.value.rawValue, {
			forceEmit: !0,
			last: !0
		})
	}
}
class w7 {
	constructor(e, t) {
		var i, r;
		this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Dd.create(t.expanded), this.popC_ = t.pickerLayout === "popup" ? new LM(e, {
			viewProps: this.viewProps
		}) : null;
		const s = new x7(e, {
			layout: t.pickerLayout,
			props: new _t({
				invertsY: cn(t.invertsY),
				max: cn(t.max),
				xKeyScale: t.axes[0].textProps.value("keyScale"),
				yKeyScale: t.axes[1].textProps.value("keyScale")
			}),
			value: this.value,
			viewProps: this.viewProps
		});
		s.view.allFocusableElements.forEach(o => {
			o.addEventListener("blur", this.onPopupChildBlur_), o.addEventListener("keydown", this.onPopupChildKeydown_)
		}), this.pickerC_ = s, this.textC_ = new q1(e, {
			assembly: oC,
			axes: t.axes,
			parser: t.parser,
			value: this.value,
			viewProps: this.viewProps
		}), this.view = new b7(e, {
			expanded: this.foldable_.value("expanded"),
			pickerLayout: t.pickerLayout,
			viewProps: this.viewProps
		}), this.view.textElement.appendChild(this.textC_.view.element), (i = this.view.buttonElement) === null || i === void 0 || i.addEventListener("blur", this.onPadButtonBlur_), (r = this.view.buttonElement) === null || r === void 0 || r.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Eu({
			primary: this.foldable_.value("expanded"),
			secondary: this.popC_.shows,
			forward: o => o,
			backward: (o, a) => a
		})) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), O1(this.foldable_, this.view.pickerElement))
	}
	get textController() {
		return this.textC_
	}
	onPadButtonBlur_(e) {
		if (!this.popC_) return;
		const t = this.view.element,
			i = e.relatedTarget;
		(!i || !t.contains(i)) && (this.popC_.shows.rawValue = !1)
	}
	onPadButtonClick_() {
		this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
	}
	onPopupChildBlur_(e) {
		if (!this.popC_) return;
		const t = this.popC_.view.element,
			i = EM(e);
		i && t.contains(i) || i && i === this.view.buttonElement && !D1(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
	}
	onPopupChildKeydown_(e) {
		this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus()
	}
}

function E7(n) {
	return ra.isObject(n) ? new ra(n.x, n.y) : new ra
}

function S7(n, e) {
	n.writeProperty("x", e.x), n.writeProperty("y", e.y)
}

function T7(n, e) {
	return new $1({
		assembly: oC,
		components: [Zs(Object.assign(Object.assign({}, n), n.x), e.x), Zs(Object.assign(Object.assign({}, n), n.y), e.y)]
	})
}

function ew(n, e) {
	var t, i;
	if (!Kt(n.min) || !Kt(n.max)) return Math.max(Math.abs((t = n.min) !== null && t !== void 0 ? t : 0), Math.abs((i = n.max) !== null && i !== void 0 ? i : 0));
	const r = pM(n);
	return Math.max(Math.abs(r) * 10, Math.abs(e) * 10)
}

function M7(n, e) {
	var t, i;
	const r = ew(xl(n, (t = n.x) !== null && t !== void 0 ? t : {}), e.x),
		s = ew(xl(n, (i = n.y) !== null && i !== void 0 ? i : {}), e.y);
	return Math.max(r, s)
}

function C7(n) {
	if (!("y" in n)) return !1;
	const e = n.y;
	return e && "inverted" in e ? !!e.inverted : !1
}
const A7 = Oi({
	id: "input-point2d",
	type: "input",
	accept: (n, e) => {
		if (!ra.isObject(n)) return null;
		const t = mn(e, i => Object.assign(Object.assign({}, Kh(i)), {
			expanded: i.optional.boolean,
			picker: i.optional.custom(UM),
			readonly: i.optional.constant(!1),
			x: i.optional.custom(qo),
			y: i.optional.object(Object.assign(Object.assign({}, Kh(i)), {
				inverted: i.optional.boolean
			}))
		}));
		return t ? {
			initialValue: n,
			params: t
		} : null
	},
	binding: {
		reader: () => E7,
		constraint: n => T7(n.params, n.initialValue),
		equals: ra.equals,
		writer: () => S7
	},
	controller: n => {
		var e, t;
		const i = n.document,
			r = n.value,
			s = n.constraint,
			o = [n.params.x, n.params.y];
		return new w7(i, {
			axes: r.rawValue.getComponents().map((a, l) => {
				var c;
				return A1({
					constraint: s.components[l],
					initialValue: a,
					params: xl(n.params, (c = o[l]) !== null && c !== void 0 ? c : {})
				})
			}),
			expanded: (e = n.params.expanded) !== null && e !== void 0 ? e : !1,
			invertsY: C7(n.params),
			max: M7(n.params, r.rawValue),
			parser: lo,
			pickerLayout: (t = n.params.picker) !== null && t !== void 0 ? t : "popup",
			value: r,
			viewProps: n.viewProps
		})
	}
});
class Rc {
	constructor(e = 0, t = 0, i = 0) {
		this.x = e, this.y = t, this.z = i
	}
	getComponents() {
		return [this.x, this.y, this.z]
	}
	static isObject(e) {
		if (Kt(e)) return !1;
		const t = e.x,
			i = e.y,
			r = e.z;
		return !(typeof t != "number" || typeof i != "number" || typeof r != "number")
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y && e.z === t.z
	}
	toObject() {
		return {
			x: this.x,
			y: this.y,
			z: this.z
		}
	}
}
const aC = {
	toComponents: n => n.getComponents(),
	fromComponents: n => new Rc(...n)
};

function D7(n) {
	return Rc.isObject(n) ? new Rc(n.x, n.y, n.z) : new Rc
}

function P7(n, e) {
	n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z)
}

function R7(n, e) {
	return new $1({
		assembly: aC,
		components: [Zs(Object.assign(Object.assign({}, n), n.x), e.x), Zs(Object.assign(Object.assign({}, n), n.y), e.y), Zs(Object.assign(Object.assign({}, n), n.z), e.z)]
	})
}
const L7 = Oi({
	id: "input-point3d",
	type: "input",
	accept: (n, e) => {
		if (!Rc.isObject(n)) return null;
		const t = mn(e, i => Object.assign(Object.assign({}, Kh(i)), {
			readonly: i.optional.constant(!1),
			x: i.optional.custom(qo),
			y: i.optional.custom(qo),
			z: i.optional.custom(qo)
		}));
		return t ? {
			initialValue: n,
			params: t
		} : null
	},
	binding: {
		reader: n => D7,
		constraint: n => R7(n.params, n.initialValue),
		equals: Rc.equals,
		writer: n => P7
	},
	controller: n => {
		const e = n.value,
			t = n.constraint,
			i = [n.params.x, n.params.y, n.params.z];
		return new q1(n.document, {
			assembly: aC,
			axes: e.rawValue.getComponents().map((r, s) => {
				var o;
				return A1({
					constraint: t.components[s],
					initialValue: r,
					params: xl(n.params, (o = i[s]) !== null && o !== void 0 ? o : {})
				})
			}),
			parser: lo,
			value: e,
			viewProps: n.viewProps
		})
	}
});
class Lc {
	constructor(e = 0, t = 0, i = 0, r = 0) {
		this.x = e, this.y = t, this.z = i, this.w = r
	}
	getComponents() {
		return [this.x, this.y, this.z, this.w]
	}
	static isObject(e) {
		if (Kt(e)) return !1;
		const t = e.x,
			i = e.y,
			r = e.z,
			s = e.w;
		return !(typeof t != "number" || typeof i != "number" || typeof r != "number" || typeof s != "number")
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
	}
	toObject() {
		return {
			x: this.x,
			y: this.y,
			z: this.z,
			w: this.w
		}
	}
}
const lC = {
	toComponents: n => n.getComponents(),
	fromComponents: n => new Lc(...n)
};

function k7(n) {
	return Lc.isObject(n) ? new Lc(n.x, n.y, n.z, n.w) : new Lc
}

function I7(n, e) {
	n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z), n.writeProperty("w", e.w)
}

function O7(n, e) {
	return new $1({
		assembly: lC,
		components: [Zs(Object.assign(Object.assign({}, n), n.x), e.x), Zs(Object.assign(Object.assign({}, n), n.y), e.y), Zs(Object.assign(Object.assign({}, n), n.z), e.z), Zs(Object.assign(Object.assign({}, n), n.w), e.w)]
	})
}
const F7 = Oi({
	id: "input-point4d",
	type: "input",
	accept: (n, e) => {
		if (!Lc.isObject(n)) return null;
		const t = mn(e, i => Object.assign(Object.assign({}, Kh(i)), {
			readonly: i.optional.constant(!1),
			w: i.optional.custom(qo),
			x: i.optional.custom(qo),
			y: i.optional.custom(qo),
			z: i.optional.custom(qo)
		}));
		return t ? {
			initialValue: n,
			params: t
		} : null
	},
	binding: {
		reader: n => k7,
		constraint: n => O7(n.params, n.initialValue),
		equals: Lc.equals,
		writer: n => I7
	},
	controller: n => {
		const e = n.value,
			t = n.constraint,
			i = [n.params.x, n.params.y, n.params.z, n.params.w];
		return new q1(n.document, {
			assembly: lC,
			axes: e.rawValue.getComponents().map((r, s) => {
				var o;
				return A1({
					constraint: t.components[s],
					initialValue: r,
					params: xl(n.params, (o = i[s]) !== null && o !== void 0 ? o : {})
				})
			}),
			parser: lo,
			value: e,
			viewProps: n.viewProps
		})
	}
});

function N7(n) {
	const e = [],
		t = U1(n.options);
	return t && e.push(t), new Pd(e)
}
const U7 = Oi({
		id: "input-string",
		type: "input",
		accept: (n, e) => {
			if (typeof n != "string") return null;
			const t = mn(e, i => ({
				readonly: i.optional.constant(!1),
				options: i.optional.custom(Ld)
			}));
			return t ? {
				initialValue: n,
				params: t
			} : null
		},
		binding: {
			reader: n => IM,
			constraint: n => N7(n.params),
			writer: n => Id
		},
		controller: n => {
			const e = n.document,
				t = n.value,
				i = n.constraint,
				r = i && Up(i, Rd);
			return r ? new ga(e, {
				props: new _t({
					options: r.values.value("options")
				}),
				value: t,
				viewProps: n.viewProps
			}) : new Xh(e, {
				parser: s => s,
				props: _t.fromObject({
					formatter: $_
				}),
				value: t,
				viewProps: n.viewProps
			})
		},
		api(n) {
			return typeof n.controller.value.rawValue != "string" ? null : n.controller.valueController instanceof ga ? new F1(n.controller) : null
		}
	}),
	Fd = {
		monitor: {
			defaultInterval: 200,
			defaultRows: 3
		}
	},
	tw = Dt("mll");
class B7 {
	constructor(e, t) {
		this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(tw()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("textarea");
		i.classList.add(tw("i")), i.style.height = `calc(var(${NM("containerUnitSize")}) * ${t.rows})`, i.readOnly = !0, t.viewProps.bindDisabled(i), this.element.appendChild(i), this.textareaElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
	}
	update_() {
		const e = this.textareaElem_,
			t = e.scrollTop === e.scrollHeight - e.clientHeight,
			i = [];
		this.value.rawValue.forEach(r => {
			r !== void 0 && i.push(this.formatter_(r))
		}), e.textContent = i.join(`
`), t && (e.scrollTop = e.scrollHeight)
	}
	onValueUpdate_() {
		this.update_()
	}
}
class X1 {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.view = new B7(e, {
			formatter: t.formatter,
			rows: t.rows,
			value: this.value,
			viewProps: this.viewProps
		})
	}
}
const nw = Dt("sgl");
class z7 {
	constructor(e, t) {
		this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(nw()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("input");
		i.classList.add(nw("i")), i.readOnly = !0, i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
	}
	update_() {
		const e = this.value.rawValue,
			t = e[e.length - 1];
		this.inputElement.value = t !== void 0 ? this.formatter_(t) : ""
	}
	onValueUpdate_() {
		this.update_()
	}
}
class Y1 {
	constructor(e, t) {
		this.value = t.value, this.viewProps = t.viewProps, this.view = new z7(e, {
			formatter: t.formatter,
			value: this.value,
			viewProps: this.viewProps
		})
	}
}
const V7 = Oi({
	id: "monitor-bool",
	type: "monitor",
	accept: (n, e) => {
		if (typeof n != "boolean") return null;
		const t = mn(e, i => ({
			readonly: i.required.constant(!0),
			rows: i.optional.number
		}));
		return t ? {
			initialValue: n,
			params: t
		} : null
	},
	binding: {
		reader: n => kM
	},
	controller: n => {
		var e;
		return n.value.rawValue.length === 1 ? new Y1(n.document, {
			formatter: Xx,
			value: n.value,
			viewProps: n.viewProps
		}) : new X1(n.document, {
			formatter: Xx,
			rows: (e = n.params.rows) !== null && e !== void 0 ? e : Fd.monitor.defaultRows,
			value: n.value,
			viewProps: n.viewProps
		})
	}
});
class H7 extends qh {
	get max() {
		return this.controller.valueController.props.get("max")
	}
	set max(e) {
		this.controller.valueController.props.set("max", e)
	}
	get min() {
		return this.controller.valueController.props.get("min")
	}
	set min(e) {
		this.controller.valueController.props.set("min", e)
	}
}
const So = Dt("grl");
class G7 {
	constructor(e, t) {
		this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(So()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
		const i = e.createElementNS(ys, "svg");
		i.classList.add(So("g")), i.style.height = `calc(var(${NM("containerUnitSize")}) * ${t.rows})`, this.element.appendChild(i), this.svgElem_ = i;
		const r = e.createElementNS(ys, "polyline");
		this.svgElem_.appendChild(r), this.lineElem_ = r;
		const s = e.createElement("div");
		s.classList.add(So("t"), Dt("tt")()), this.element.appendChild(s), this.tooltipElem_ = s, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
	}
	get graphElement() {
		return this.svgElem_
	}
	update_() {
		const {
			clientWidth: e,
			clientHeight: t
		} = this.element, i = this.value.rawValue.length - 1, r = this.props_.get("min"), s = this.props_.get("max"), o = [];
		this.value.rawValue.forEach((h, d) => {
			if (h === void 0) return;
			const f = Ot(d, 0, i, 0, e),
				p = Ot(h, r, s, t, 0);
			o.push([f, p].join(","))
		}), this.lineElem_.setAttributeNS(null, "points", o.join(" "));
		const a = this.tooltipElem_,
			l = this.value.rawValue[this.cursor_.rawValue];
		if (l === void 0) {
			a.classList.remove(So("t", "a"));
			return
		}
		const c = Ot(this.cursor_.rawValue, 0, i, 0, e),
			u = Ot(l, r, s, t, 0);
		a.style.left = `${c}px`, a.style.top = `${u}px`, a.textContent = `${this.formatter_(l)}`, a.classList.contains(So("t", "a")) || (a.classList.add(So("t", "a"), So("t", "in")), Np(a), a.classList.remove(So("t", "in")))
	}
	onValueUpdate_() {
		this.update_()
	}
	onCursorChange_() {
		this.update_()
	}
}
class cC {
	constructor(e, t) {
		if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = cn(-1), this.view = new G7(e, {
				cursor: this.cursor_,
				formatter: t.formatter,
				rows: t.rows,
				props: this.props,
				value: this.value,
				viewProps: this.viewProps
			}), !D1(e)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
		else {
			const i = new Ll(this.view.element);
			i.emitter.on("down", this.onGraphPointerDown_), i.emitter.on("move", this.onGraphPointerMove_), i.emitter.on("up", this.onGraphPointerUp_)
		}
	}
	importProps(e) {
		return Tr(e, null, t => ({
			max: t.required.number,
			min: t.required.number
		}), t => (this.props.set("max", t.max), this.props.set("min", t.min), !0))
	}
	exportProps() {
		return Mr(null, {
			max: this.props.get("max"),
			min: this.props.get("min")
		})
	}
	onGraphMouseLeave_() {
		this.cursor_.rawValue = -1
	}
	onGraphMouseMove_(e) {
		const {
			clientWidth: t
		} = this.view.element;
		this.cursor_.rawValue = Math.floor(Ot(e.offsetX, 0, t, 0, this.value.rawValue.length))
	}
	onGraphPointerDown_(e) {
		this.onGraphPointerMove_(e)
	}
	onGraphPointerMove_(e) {
		if (!e.data.point) {
			this.cursor_.rawValue = -1;
			return
		}
		this.cursor_.rawValue = Math.floor(Ot(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length))
	}
	onGraphPointerUp_() {
		this.cursor_.rawValue = -1
	}
}

function q_(n) {
	return Kt(n.format) ? Ki(2) : n.format
}

function W7(n) {
	var e;
	return n.value.rawValue.length === 1 ? new Y1(n.document, {
		formatter: q_(n.params),
		value: n.value,
		viewProps: n.viewProps
	}) : new X1(n.document, {
		formatter: q_(n.params),
		rows: (e = n.params.rows) !== null && e !== void 0 ? e : Fd.monitor.defaultRows,
		value: n.value,
		viewProps: n.viewProps
	})
}

function j7(n) {
	var e, t, i;
	return new cC(n.document, {
		formatter: q_(n.params),
		rows: (e = n.params.rows) !== null && e !== void 0 ? e : Fd.monitor.defaultRows,
		props: _t.fromObject({
			max: (t = n.params.max) !== null && t !== void 0 ? t : 100,
			min: (i = n.params.min) !== null && i !== void 0 ? i : 0
		}),
		value: n.value,
		viewProps: n.viewProps
	})
}

function iw(n) {
	return n.view === "graph"
}
const $7 = Oi({
		id: "monitor-number",
		type: "monitor",
		accept: (n, e) => {
			if (typeof n != "number") return null;
			const t = mn(e, i => ({
				format: i.optional.function,
				max: i.optional.number,
				min: i.optional.number,
				readonly: i.required.constant(!0),
				rows: i.optional.number,
				view: i.optional.string
			}));
			return t ? {
				initialValue: n,
				params: t
			} : null
		},
		binding: {
			defaultBufferSize: n => iw(n) ? 64 : 1,
			reader: n => dM
		},
		controller: n => iw(n.params) ? j7(n) : W7(n),
		api: n => n.controller.valueController instanceof cC ? new H7(n.controller) : null
	}),
	q7 = Oi({
		id: "monitor-string",
		type: "monitor",
		accept: (n, e) => {
			if (typeof n != "string") return null;
			const t = mn(e, i => ({
				multiline: i.optional.boolean,
				readonly: i.required.constant(!0),
				rows: i.optional.number
			}));
			return t ? {
				initialValue: n,
				params: t
			} : null
		},
		binding: {
			reader: n => IM
		},
		controller: n => {
			var e;
			const t = n.value;
			return t.rawValue.length > 1 || n.params.multiline ? new X1(n.document, {
				formatter: $_,
				rows: (e = n.params.rows) !== null && e !== void 0 ? e : Fd.monitor.defaultRows,
				value: t,
				viewProps: n.viewProps
			}) : new Y1(n.document, {
				formatter: $_,
				value: t,
				viewProps: n.viewProps
			})
		}
	});
class X7 {
	constructor() {
		this.map_ = new Map
	}
	get(e) {
		var t;
		return (t = this.map_.get(e)) !== null && t !== void 0 ? t : null
	}
	has(e) {
		return this.map_.has(e)
	}
	add(e, t) {
		return this.map_.set(e, t), e.viewProps.handleDispose(() => {
			this.map_.delete(e)
		}), t
	}
}
class Y7 {
	constructor(e) {
		this.target = e.target, this.reader_ = e.reader, this.writer_ = e.writer
	}
	read() {
		return this.reader_(this.target.read())
	}
	write(e) {
		this.writer_(this.target, e)
	}
	inject(e) {
		this.write(this.reader_(e))
	}
}

function K7(n, e) {
	var t;
	const i = n.accept(e.target.read(), e.params);
	if (Kt(i)) return null;
	const r = {
			target: e.target,
			initialValue: i.initialValue,
			params: i.params
		},
		s = mn(e.params, h => ({
			disabled: h.optional.boolean,
			hidden: h.optional.boolean,
			label: h.optional.string,
			tag: h.optional.string
		})),
		o = n.binding.reader(r),
		a = n.binding.constraint ? n.binding.constraint(r) : void 0,
		l = new Y7({
			reader: o,
			target: e.target,
			writer: n.binding.writer(r)
		}),
		c = new k8(cn(o(i.initialValue), {
			constraint: a,
			equals: n.binding.equals
		}), l),
		u = n.controller({
			constraint: a,
			document: e.document,
			initialValue: i.initialValue,
			params: i.params,
			value: c,
			viewProps: mo.create({
				disabled: s == null ? void 0 : s.disabled,
				hidden: s == null ? void 0 : s.hidden
			})
		});
	return new X8(e.document, {
		blade: wu(),
		props: _t.fromObject({
			label: "label" in e.params ? (t = s == null ? void 0 : s.label) !== null && t !== void 0 ? t : null : e.target.key
		}),
		tag: s == null ? void 0 : s.tag,
		value: c,
		valueController: u
	})
}
class Z7 {
	constructor(e) {
		this.target = e.target, this.reader_ = e.reader
	}
	read() {
		return this.reader_(this.target.read())
	}
}

function J7(n, e) {
	return e === 0 ? new PN : new RN(n, e ?? Fd.monitor.defaultInterval)
}

function Q7(n, e) {
	var t, i, r;
	const s = n.accept(e.target.read(), e.params);
	if (Kt(s)) return null;
	const o = {
			target: e.target,
			initialValue: s.initialValue,
			params: s.params
		},
		a = mn(e.params, d => ({
			bufferSize: d.optional.number,
			disabled: d.optional.boolean,
			hidden: d.optional.boolean,
			interval: d.optional.number,
			label: d.optional.string
		})),
		l = n.binding.reader(o),
		c = (i = (t = a == null ? void 0 : a.bufferSize) !== null && t !== void 0 ? t : n.binding.defaultBufferSize && n.binding.defaultBufferSize(s.params)) !== null && i !== void 0 ? i : 1,
		u = new Q8({
			binding: new Z7({
				reader: l,
				target: e.target
			}),
			bufferSize: c,
			ticker: J7(e.document, a == null ? void 0 : a.interval)
		}),
		h = n.controller({
			document: e.document,
			params: s.params,
			value: u,
			viewProps: mo.create({
				disabled: a == null ? void 0 : a.disabled,
				hidden: a == null ? void 0 : a.hidden
			})
		});
	return h.viewProps.bindDisabled(u.ticker), h.viewProps.handleDispose(() => {
		u.ticker.dispose()
	}), new tN(e.document, {
		blade: wu(),
		props: _t.fromObject({
			label: "label" in e.params ? (r = a == null ? void 0 : a.label) !== null && r !== void 0 ? r : null : e.target.key
		}),
		value: u,
		valueController: h
	})
}
class eB {
	constructor(e) {
		this.pluginsMap_ = {
			blades: [],
			inputs: [],
			monitors: []
		}, this.apiCache_ = e
	}
	getAll() {
		return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
	}
	register(e, t) {
		if (!WN(t.core)) throw _n.notCompatible(e, t.id);
		t.type === "blade" ? this.pluginsMap_.blades.unshift(t) : t.type === "input" ? this.pluginsMap_.inputs.unshift(t) : t.type === "monitor" && this.pluginsMap_.monitors.unshift(t)
	}
	createInput_(e, t, i) {
		return this.pluginsMap_.inputs.reduce((r, s) => r ?? K7(s, {
			document: e,
			target: t,
			params: i
		}), null)
	}
	createMonitor_(e, t, i) {
		return this.pluginsMap_.monitors.reduce((r, s) => r ?? Q7(s, {
			document: e,
			params: i,
			target: t
		}), null)
	}
	createBinding(e, t, i) {
		const r = t.read();
		if (Kt(r)) throw new _n({
			context: {
				key: t.key
			},
			type: "nomatchingcontroller"
		});
		const s = this.createInput_(e, t, i);
		if (s) return s;
		const o = this.createMonitor_(e, t, i);
		if (o) return o;
		throw new _n({
			context: {
				key: t.key
			},
			type: "nomatchingcontroller"
		})
	}
	createBlade(e, t) {
		const i = this.pluginsMap_.blades.reduce((r, s) => r ?? DN(s, {
			document: e,
			params: t
		}), null);
		if (!i) throw new _n({
			type: "nomatchingview",
			context: {
				params: t
			}
		});
		return i
	}
	createInputBindingApi_(e) {
		const t = this.pluginsMap_.inputs.reduce((i, r) => {
			var s, o;
			return i || ((o = (s = r.api) === null || s === void 0 ? void 0 : s.call(r, {
				controller: e
			})) !== null && o !== void 0 ? o : null)
		}, null);
		return this.apiCache_.add(e, t ?? new qh(e))
	}
	createMonitorBindingApi_(e) {
		const t = this.pluginsMap_.monitors.reduce((i, r) => {
			var s, o;
			return i || ((o = (s = r.api) === null || s === void 0 ? void 0 : s.call(r, {
				controller: e
			})) !== null && o !== void 0 ? o : null)
		}, null);
		return this.apiCache_.add(e, t ?? new qh(e))
	}
	createBindingApi(e) {
		if (this.apiCache_.has(e)) return this.apiCache_.get(e);
		if (Y8(e)) return this.createInputBindingApi_(e);
		if (nN(e)) return this.createMonitorBindingApi_(e);
		throw _n.shouldNeverHappen()
	}
	createApi(e) {
		if (this.apiCache_.has(e)) return this.apiCache_.get(e);
		if (q8(e)) return this.createBindingApi(e);
		const t = this.pluginsMap_.blades.reduce((i, r) => i ?? r.api({
			controller: e,
			pool: this
		}), null);
		if (!t) throw _n.shouldNeverHappen();
		return this.apiCache_.add(e, t)
	}
}
const tB = new X7;

function nB() {
	const n = new eB(tB);
	return [A7, L7, F7, U7, v7, f7, d7, a7, XN, V7, q7, $7, aN, yN, RM].forEach(e => {
		n.register("core", e)
	}), n
}
class iB extends Rl {
	constructor(e) {
		super(e), this.emitter_ = new Pn, this.controller.value.emitter.on("change", t => {
			this.emitter_.emit("change", new Ad(this, t.rawValue))
		})
	}
	get label() {
		return this.controller.labelController.props.get("label")
	}
	set label(e) {
		this.controller.labelController.props.set("label", e)
	}
	get options() {
		return this.controller.valueController.props.get("options")
	}
	set options(e) {
		this.controller.valueController.props.set("options", e)
	}
	get value() {
		return this.controller.value.rawValue
	}
	set value(e) {
		this.controller.value.rawValue = e
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
}
class rB extends Rl {}
class sB extends Rl {
	constructor(e) {
		super(e), this.emitter_ = new Pn, this.controller.value.emitter.on("change", t => {
			this.emitter_.emit("change", new Ad(this, t.rawValue))
		})
	}
	get label() {
		return this.controller.labelController.props.get("label")
	}
	set label(e) {
		this.controller.labelController.props.set("label", e)
	}
	get max() {
		return this.controller.valueController.sliderController.props.get("max")
	}
	set max(e) {
		this.controller.valueController.sliderController.props.set("max", e)
	}
	get min() {
		return this.controller.valueController.sliderController.props.get("min")
	}
	set min(e) {
		this.controller.valueController.sliderController.props.set("min", e)
	}
	get value() {
		return this.controller.value.rawValue
	}
	set value(e) {
		this.controller.value.rawValue = e
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
}
class oB extends Rl {
	constructor(e) {
		super(e), this.emitter_ = new Pn, this.controller.value.emitter.on("change", t => {
			this.emitter_.emit("change", new Ad(this, t.rawValue))
		})
	}
	get label() {
		return this.controller.labelController.props.get("label")
	}
	set label(e) {
		this.controller.labelController.props.set("label", e)
	}
	get formatter() {
		return this.controller.valueController.props.get("formatter")
	}
	set formatter(e) {
		this.controller.valueController.props.set("formatter", e)
	}
	get value() {
		return this.controller.value.rawValue
	}
	set value(e) {
		this.controller.value.rawValue = e
	}
	on(e, t) {
		const i = t.bind(this);
		return this.emitter_.on(e, r => {
			i(r)
		}, {
			key: t
		}), this
	}
	off(e, t) {
		return this.emitter_.off(e, t), this
	}
}
const aB = function () {
	return {
		id: "list",
		type: "blade",
		core: xu,
		accept(n) {
			const e = mn(n, t => ({
				options: t.required.custom(Ld),
				value: t.required.raw,
				view: t.required.constant("list"),
				label: t.optional.string
			}));
			return e ? {
				params: e
			} : null
		},
		controller(n) {
			const e = new Rd(N1(n.params.options)),
				t = cn(n.params.value, {
					constraint: e
				}),
				i = new ga(n.document, {
					props: new _t({
						options: e.values.value("options")
					}),
					value: t,
					viewProps: n.viewProps
				});
			return new wl(n.document, {
				blade: n.blade,
				props: _t.fromObject({
					label: n.params.label
				}),
				value: t,
				valueController: i
			})
		},
		api(n) {
			return !(n.controller instanceof wl) || !(n.controller.valueController instanceof ga) ? null : new iB(n.controller)
		}
	}
}();
class lB extends DM {
	constructor(e, t) {
		super(e, t)
	}
	get element() {
		return this.controller.view.element
	}
}
class cB extends W_ {
	constructor(e, t) {
		super(e, {
			expanded: t.expanded,
			blade: t.blade,
			props: t.props,
			root: !0,
			viewProps: t.viewProps
		})
	}
}
const rw = Dt("spr");
class uB {
	constructor(e, t) {
		this.element = e.createElement("div"), this.element.classList.add(rw()), t.viewProps.bindClassModifiers(this.element);
		const i = e.createElement("hr");
		i.classList.add(rw("r")), this.element.appendChild(i)
	}
}
class sw extends Wm {
	constructor(e, t) {
		super(Object.assign(Object.assign({}, t), {
			view: new uB(e, {
				viewProps: t.viewProps
			})
		}))
	}
}
const hB = {
		id: "separator",
		type: "blade",
		core: xu,
		accept(n) {
			const e = mn(n, t => ({
				view: t.required.constant("separator")
			}));
			return e ? {
				params: e
			} : null
		},
		controller(n) {
			return new sw(n.document, {
				blade: n.blade,
				viewProps: n.viewProps
			})
		},
		api(n) {
			return n.controller instanceof sw ? new rB(n.controller) : null
		}
	},
	dB = {
		id: "slider",
		type: "blade",
		core: xu,
		accept(n) {
			const e = mn(n, t => ({
				max: t.required.number,
				min: t.required.number,
				view: t.required.constant("slider"),
				format: t.optional.function,
				label: t.optional.string,
				value: t.optional.number
			}));
			return e ? {
				params: e
			} : null
		},
		controller(n) {
			var e, t;
			const i = (e = n.params.value) !== null && e !== void 0 ? e : 0,
				r = new Cd({
					max: n.params.max,
					min: n.params.min
				}),
				s = cn(i, {
					constraint: r
				}),
				o = new zp(n.document, Object.assign(Object.assign({}, FM({
					formatter: (t = n.params.format) !== null && t !== void 0 ? t : A8,
					keyScale: cn(1),
					max: r.values.value("max"),
					min: r.values.value("min"),
					pointerScale: mM(n.params, i)
				})), {
					parser: lo,
					value: s,
					viewProps: n.viewProps
				}));
			return new wl(n.document, {
				blade: n.blade,
				props: _t.fromObject({
					label: n.params.label
				}),
				value: s,
				valueController: o
			})
		},
		api(n) {
			return !(n.controller instanceof wl) || !(n.controller.valueController instanceof zp) ? null : new sB(n.controller)
		}
	},
	fB = function () {
		return {
			id: "text",
			type: "blade",
			core: xu,
			accept(n) {
				const e = mn(n, t => ({
					parse: t.required.function,
					value: t.required.raw,
					view: t.required.constant("text"),
					format: t.optional.function,
					label: t.optional.string
				}));
				return e ? {
					params: e
				} : null
			},
			controller(n) {
				var e;
				const t = cn(n.params.value),
					i = new Xh(n.document, {
						parser: n.params.parse,
						props: _t.fromObject({
							formatter: (e = n.params.format) !== null && e !== void 0 ? e : r => String(r)
						}),
						value: t,
						viewProps: n.viewProps
					});
				return new wl(n.document, {
					blade: n.blade,
					props: _t.fromObject({
						label: n.params.label
					}),
					value: t,
					valueController: i
				})
			},
			api(n) {
				return !(n.controller instanceof wl) || !(n.controller.valueController instanceof Xh) ? null : new oB(n.controller)
			}
		}
	}();

function pB(n) {
	const e = n.createElement("div");
	return e.classList.add(Dt("dfw")()), n.body && n.body.appendChild(e), e
}

function mB(n, e, t) {
	if (n.querySelector(`style[data-tp-style=${e}]`)) return;
	const i = n.createElement("style");
	i.dataset.tpStyle = e, i.textContent = t, n.head.appendChild(i)
}
class gB extends lB {
	constructor(e) {
		var t, i;
		const r = e ?? {},
			s = (t = r.document) !== null && t !== void 0 ? t : z8(),
			o = nB(),
			a = new cB(s, {
				expanded: r.expanded,
				blade: wu(),
				props: _t.fromObject({
					title: r.title
				}),
				viewProps: mo.create()
			});
		super(a, o), this.pool_ = o, this.containerElem_ = (i = r.container) !== null && i !== void 0 ? i : pB(s), this.containerElem_.appendChild(this.element), this.doc_ = s, this.usesDefaultWrapper_ = !r.container, this.setUpDefaultPlugins_()
	}
	get document() {
		if (!this.doc_) throw _n.alreadyDisposed();
		return this.doc_
	}
	dispose() {
		const e = this.containerElem_;
		if (!e) throw _n.alreadyDisposed();
		if (this.usesDefaultWrapper_) {
			const t = e.parentElement;
			t && t.removeChild(e)
		}
		this.containerElem_ = null, this.doc_ = null, super.dispose()
	}
	registerPlugin(e) {
		e.css && mB(this.document, `plugin-${e.id}`, e.css), ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach(i => {
			this.pool_.register(e.id, i)
		})
	}
	setUpDefaultPlugins_() {
		this.registerPlugin({
			id: "default",
			css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
			plugins: [aB, hB, dB, RM, fB]
		})
	}
}
new AM("4.0.3");
const _B = un({
	name: "gui",
	parallel: !0,
	async setup(n) {
		let e;
		return e = document.createElement("div"), {
			provide: {
				gui: new gB({
					container: e
				})
			}
		}
	}
});

function $s(n) {
	if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return n
}

function uC(n, e) {
	n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var xr = {
		autoSleep: 120,
		force3D: "auto",
		nullTargetWarn: 1,
		units: {
			lineHeight: ""
		}
	},
	Qc = {
		duration: .5,
		overwrite: !1,
		delay: 0
	},
	K1, pi, sn, Hr = 1e8,
	Yt = 1 / Hr,
	X_ = Math.PI * 2,
	vB = X_ / 4,
	bB = 0,
	hC = Math.sqrt,
	yB = Math.cos,
	xB = Math.sin,
	Zn = function (e) {
		return typeof e == "string"
	},
	vn = function (e) {
		return typeof e == "function"
	},
	uo = function (e) {
		return typeof e == "number"
	},
	Z1 = function (e) {
		return typeof e > "u"
	},
	Rs = function (e) {
		return typeof e == "object"
	},
	Vi = function (e) {
		return e !== !1
	},
	J1 = function () {
		return typeof window < "u"
	},
	of = function (e) {
		return vn(e) || Zn(e)
	},
	dC = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () {},
	mi = Array.isArray,
	Y_ = /(?:-?\.?\d|\.)+/gi,
	fC = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
	bc = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
	G0 = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
	pC = /[+-]=-?[.\d]+/,
	mC = /[^,'"\[\]\s]+/gi,
	wB = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
	fn, hs, K_, Q1, wr = {},
	Vp = {},
	gC, _C = function (e) {
		return (Vp = Sl(e, wr)) && Zi
	},
	eb = function (e, t) {
		return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
	},
	Zh = function (e, t) {
		return !t && console.warn(e)
	},
	vC = function (e, t) {
		return e && (wr[e] = t) && Vp && (Vp[e] = t) || wr
	},
	Jh = function () {
		return 0
	},
	EB = {
		suppressEvents: !0,
		isStart: !0,
		kill: !1
	},
	cp = {
		suppressEvents: !0,
		kill: !1
	},
	SB = {
		suppressEvents: !0
	},
	tb = {},
	sa = [],
	Z_ = {},
	bC, fr = {},
	W0 = {},
	ow = 30,
	up = [],
	nb = "",
	ib = function (e) {
		var t = e[0],
			i, r;
		if (Rs(t) || vn(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
			for (r = up.length; r-- && !up[r].targetTest(t););
			i = up[r]
		}
		for (r = e.length; r--;) e[r] && (e[r]._gsap || (e[r]._gsap = new GC(e[r], i))) || e.splice(r, 1);
		return e
	},
	cl = function (e) {
		return e._gsap || ib(Gr(e))[0]._gsap
	},
	yC = function (e, t, i) {
		return (i = e[t]) && vn(i) ? e[t]() : Z1(i) && e.getAttribute && e.getAttribute(t) || i
	},
	Hi = function (e, t) {
		return (e = e.split(",")).forEach(t) || e
	},
	xn = function (e) {
		return Math.round(e * 1e5) / 1e5 || 0
	},
	Xn = function (e) {
		return Math.round(e * 1e7) / 1e7 || 0
	},
	kc = function (e, t) {
		var i = t.charAt(0),
			r = parseFloat(t.substr(2));
		return e = parseFloat(e), i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r
	},
	TB = function (e, t) {
		for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i;);
		return r < i
	},
	Hp = function () {
		var e = sa.length,
			t = sa.slice(0),
			i, r;
		for (Z_ = {}, sa.length = 0, i = 0; i < e; i++) r = t[i], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0)
	},
	xC = function (e, t, i, r) {
		sa.length && !pi && Hp(), e.render(t, i, pi && t < 0 && (e._initted || e._startAt)), sa.length && !pi && Hp()
	},
	wC = function (e) {
		var t = parseFloat(e);
		return (t || t === 0) && (e + "").match(mC).length < 2 ? t : Zn(e) ? e.trim() : e
	},
	EC = function (e) {
		return e
	},
	$r = function (e, t) {
		for (var i in t) i in e || (e[i] = t[i]);
		return e
	},
	MB = function (e) {
		return function (t, i) {
			for (var r in i) r in t || r === "duration" && e || r === "ease" || (t[r] = i[r])
		}
	},
	Sl = function (e, t) {
		for (var i in t) e[i] = t[i];
		return e
	},
	aw = function n(e, t) {
		for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = Rs(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
		return e
	},
	Gp = function (e, t) {
		var i = {},
			r;
		for (r in e) r in t || (i[r] = e[r]);
		return i
	},
	_h = function (e) {
		var t = e.parent || fn,
			i = e.keyframes ? MB(mi(e.keyframes)) : $r;
		if (Vi(e.inherit))
			for (; t;) i(e, t.vars.defaults), t = t.parent || t._dp;
		return e
	},
	CB = function (e, t) {
		for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i];);
		return i < 0
	},
	SC = function (e, t, i, r, s) {
		var o = e[r],
			a;
		if (s)
			for (a = t[s]; o && o[s] > a;) o = o._prev;
		return o ? (t._next = o._next, o._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = o, t.parent = t._dp = e, t
	},
	$m = function (e, t, i, r) {
		i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
		var s = t._prev,
			o = t._next;
		s ? s._next = o : e[i] === t && (e[i] = o), o ? o._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null
	},
	_a = function (e, t) {
		e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
	},
	ul = function (e, t) {
		if (e && (!t || t._end > e._dur || t._start < 0))
			for (var i = e; i;) i._dirty = 1, i = i.parent;
		return e
	},
	AB = function (e) {
		for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
		return e
	},
	J_ = function (e, t, i, r) {
		return e._startAt && (pi ? e._startAt.revert(cp) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r))
	},
	DB = function n(e) {
		return !e || e._ts && n(e.parent)
	},
	lw = function (e) {
		return e._repeat ? eu(e._tTime, e = e.duration() + e._rDelay) * e : 0
	},
	eu = function (e, t) {
		var i = Math.floor(e /= t);
		return e && i === e ? i - 1 : i
	},
	Wp = function (e, t) {
		return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
	},
	qm = function (e) {
		return e._end = Xn(e._start + (e._tDur / Math.abs(e._ts || e._rts || Yt) || 0))
	},
	Xm = function (e, t) {
		var i = e._dp;
		return i && i.smoothChildTiming && e._ts && (e._start = Xn(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), qm(e), i._dirty || ul(i, e)), e
	},
	TC = function (e, t) {
		var i;
		if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = Wp(e.rawTime(), t), (!t._dur || Nd(0, t.totalDuration(), i) - t._tTime > Yt) && t.render(i, !0)), ul(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
			if (e._dur < e.duration())
				for (i = e; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
			e._zTime = -Yt
		}
	},
	_s = function (e, t, i, r) {
		return t.parent && _a(t), t._start = Xn((uo(i) ? i : i || e !== fn ? Lr(e, i, t) : e._time) + t._delay), t._end = Xn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), SC(e, t, "_first", "_last", e._sort ? "_start" : 0), Q_(t) || (e._recent = t), r || TC(e, t), e._ts < 0 && Xm(e, e._tTime), e
	},
	MC = function (e, t) {
		return (wr.ScrollTrigger || eb("scrollTrigger", t)) && wr.ScrollTrigger.create(t, e)
	},
	CC = function (e, t, i, r, s) {
		if (sb(e, t, s), !e._initted) return 1;
		if (!i && e._pt && !pi && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && bC !== mr.frame) return sa.push(e), e._lazy = [s, r], 1
	},
	PB = function n(e) {
		var t = e.parent;
		return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t))
	},
	Q_ = function (e) {
		var t = e.data;
		return t === "isFromStart" || t === "isStart"
	},
	RB = function (e, t, i, r) {
		var s = e.ratio,
			o = t < 0 || !t && (!e._start && PB(e) && !(!e._initted && Q_(e)) || (e._ts < 0 || e._dp._ts < 0) && !Q_(e)) ? 0 : 1,
			a = e._rDelay,
			l = 0,
			c, u, h;
		if (a && e._repeat && (l = Nd(0, e._tDur, t), u = eu(l, a), e._yoyo && u & 1 && (o = 1 - o), u !== eu(e._tTime, a) && (s = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== s || pi || r || e._zTime === Yt || !t && e._zTime) {
			if (!e._initted && CC(e, t, r, i, l)) return;
			for (h = e._zTime, e._zTime = t || (i ? Yt : 0), i || (i = t && !h), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c;) c.r(o, c.d), c = c._next;
			t < 0 && J_(e, t, i, !0), e._onUpdate && !i && br(e, "onUpdate"), l && e._repeat && !i && e.parent && br(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && _a(e, 1), !i && !pi && (br(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
		} else e._zTime || (e._zTime = t)
	},
	LB = function (e, t, i) {
		var r;
		if (i > t)
			for (r = e._first; r && r._start <= i;) {
				if (r.data === "isPause" && r._start > t) return r;
				r = r._next
			} else
				for (r = e._last; r && r._start >= i;) {
					if (r.data === "isPause" && r._start < t) return r;
					r = r._prev
				}
	},
	tu = function (e, t, i, r) {
		var s = e._repeat,
			o = Xn(t) || 0,
			a = e._tTime / e._tDur;
		return a && !r && (e._time *= o / e._dur), e._dur = o, e._tDur = s ? s < 0 ? 1e10 : Xn(o * (s + 1) + e._rDelay * s) : o, a > 0 && !r && Xm(e, e._tTime = e._tDur * a), e.parent && qm(e), i || ul(e.parent, e), e
	},
	cw = function (e) {
		return e instanceof Di ? ul(e) : tu(e, e._dur)
	},
	kB = {
		_start: 0,
		endTime: Jh,
		totalDuration: Jh
	},
	Lr = function n(e, t, i) {
		var r = e.labels,
			s = e._recent || kB,
			o = e.duration() >= Hr ? s.endTime(!1) : e._dur,
			a, l, c;
		return Zn(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o), r[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && i && (l = l / 100 * (mi(i) ? i[0] : i).totalDuration()), a > 1 ? n(e, t.substr(0, a - 1), i) + l : o + l)) : t == null ? o : +t
	},
	vh = function (e, t, i) {
		var r = uo(t[1]),
			s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
			o = t[s],
			a, l;
		if (r && (o.duration = t[1]), o.parent = i, e) {
			for (a = o, l = i; l && !("immediateRender" in a);) a = l.vars.defaults || {}, l = Vi(l.vars.inherit) && l.parent;
			o.immediateRender = Vi(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
		}
		return new Mn(t[0], o, t[s + 1])
	},
	Aa = function (e, t) {
		return e || e === 0 ? t(e) : t
	},
	Nd = function (e, t, i) {
		return i < e ? e : i > t ? t : i
	},
	di = function (e, t) {
		return !Zn(e) || !(t = wB.exec(e)) ? "" : t[1]
	},
	IB = function (e, t, i) {
		return Aa(i, function (r) {
			return Nd(e, t, r)
		})
	},
	ev = [].slice,
	AC = function (e, t) {
		return e && Rs(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Rs(e[0])) && !e.nodeType && e !== hs
	},
	OB = function (e, t, i) {
		return i === void 0 && (i = []), e.forEach(function (r) {
			var s;
			return Zn(r) && !t || AC(r, 1) ? (s = i).push.apply(s, Gr(r)) : i.push(r)
		}) || i
	},
	Gr = function (e, t, i) {
		return sn && !t && sn.selector ? sn.selector(e) : Zn(e) && !i && (K_ || !nu()) ? ev.call((t || Q1).querySelectorAll(e), 0) : mi(e) ? OB(e, i) : AC(e) ? ev.call(e, 0) : e ? [e] : []
	},
	tv = function (e) {
		return e = Gr(e)[0] || Zh("Invalid scope") || {},
			function (t) {
				var i = e.current || e.nativeElement || e;
				return Gr(t, i.querySelectorAll ? i : i === e ? Zh("Invalid scope") || Q1.createElement("div") : e)
			}
	},
	DC = function (e) {
		return e.sort(function () {
			return .5 - Math.random()
		})
	},
	PC = function (e) {
		if (vn(e)) return e;
		var t = Rs(e) ? e : {
				each: e
			},
			i = hl(t.ease),
			r = t.from || 0,
			s = parseFloat(t.base) || 0,
			o = {},
			a = r > 0 && r < 1,
			l = isNaN(r) || a,
			c = t.axis,
			u = r,
			h = r;
		return Zn(r) ? u = h = {
				center: .5,
				edges: .5,
				end: 1
			} [r] || 0 : !a && l && (u = r[0], h = r[1]),
			function (d, f, p) {
				var _ = (p || t).length,
					g = o[_],
					m, b, v, y, x, S, E, C, P;
				if (!g) {
					if (P = t.grid === "auto" ? 0 : (t.grid || [1, Hr])[1], !P) {
						for (E = -Hr; E < (E = p[P++].getBoundingClientRect().left) && P < _;);
						P < _ && P--
					}
					for (g = o[_] = [], m = l ? Math.min(P, _) * u - .5 : r % P, b = P === Hr ? 0 : l ? _ * h / P - .5 : r / P | 0, E = 0, C = Hr, S = 0; S < _; S++) v = S % P - m, y = b - (S / P | 0), g[S] = x = c ? Math.abs(c === "y" ? y : v) : hC(v * v + y * y), x > E && (E = x), x < C && (C = x);
					r === "random" && DC(g), g.max = E - C, g.min = C, g.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (P > _ ? _ - 1 : c ? c === "y" ? _ / P : P : Math.max(P, _ / P)) || 0) * (r === "edges" ? -1 : 1), g.b = _ < 0 ? s - _ : s, g.u = di(t.amount || t.each) || 0, i = i && _ < 0 ? zC(i) : i
				}
				return _ = (g[d] - g.min) / g.max || 0, Xn(g.b + (i ? i(_) : _) * g.v) + g.u
			}
	},
	nv = function (e) {
		var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
		return function (i) {
			var r = Xn(Math.round(parseFloat(i) / e) * e * t);
			return (r - r % 1) / t + (uo(i) ? 0 : di(i))
		}
	},
	RC = function (e, t) {
		var i = mi(e),
			r, s;
		return !i && Rs(e) && (r = i = e.radius || Hr, e.values ? (e = Gr(e.values), (s = !uo(e[0])) && (r *= r)) : e = nv(e.increment)), Aa(t, i ? vn(e) ? function (o) {
			return s = e(o), Math.abs(s - o) <= r ? s : o
		} : function (o) {
			for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = Hr, u = 0, h = e.length, d, f; h--;) s ? (d = e[h].x - a, f = e[h].y - l, d = d * d + f * f) : d = Math.abs(e[h] - a), d < c && (c = d, u = h);
			return u = !r || c <= r ? e[u] : o, s || u === o || uo(o) ? u : u + di(o)
		} : nv(e))
	},
	LC = function (e, t, i, r) {
		return Aa(mi(e) ? !t : i === !0 ? !!(i = 0) : !r, function () {
			return mi(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * r) / r
		})
	},
	FB = function () {
		for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
		return function (r) {
			return t.reduce(function (s, o) {
				return o(s)
			}, r)
		}
	},
	NB = function (e, t) {
		return function (i) {
			return e(parseFloat(i)) + (t || di(i))
		}
	},
	UB = function (e, t, i) {
		return IC(e, t, 0, 1, i)
	},
	kC = function (e, t, i) {
		return Aa(i, function (r) {
			return e[~~t(r)]
		})
	},
	BB = function n(e, t, i) {
		var r = t - e;
		return mi(e) ? kC(e, n(0, e.length), t) : Aa(i, function (s) {
			return (r + (s - e) % r) % r + e
		})
	},
	zB = function n(e, t, i) {
		var r = t - e,
			s = r * 2;
		return mi(e) ? kC(e, n(0, e.length - 1), t) : Aa(i, function (o) {
			return o = (s + (o - e) % s) % s || 0, e + (o > r ? s - o : o)
		})
	},
	Qh = function (e) {
		for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t));) o = e.indexOf(")", r), a = e.charAt(r + 7) === "[", s = e.substr(r + 7, o - r - 7).match(a ? mC : Y_), i += e.substr(t, r - t) + LC(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5), t = o + 1;
		return i + e.substr(t, e.length - t)
	},
	IC = function (e, t, i, r, s) {
		var o = t - e,
			a = r - i;
		return Aa(s, function (l) {
			return i + ((l - e) / o * a || 0)
		})
	},
	VB = function n(e, t, i, r) {
		var s = isNaN(e + t) ? 0 : function (f) {
			return (1 - f) * e + f * t
		};
		if (!s) {
			var o = Zn(e),
				a = {},
				l, c, u, h, d;
			if (i === !0 && (r = 1) && (i = null), o) e = {
				p: e
			}, t = {
				p: t
			};
			else if (mi(e) && !mi(t)) {
				for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++) u.push(n(e[c - 1], e[c]));
				h--, s = function (p) {
					p *= h;
					var _ = Math.min(d, ~~p);
					return u[_](p - _)
				}, i = t
			} else r || (e = Sl(mi(e) ? [] : {}, e));
			if (!u) {
				for (l in t) rb.call(a, e, l, "get", t[l]);
				s = function (p) {
					return lb(p, a) || (o ? e.p : e)
				}
			}
		}
		return Aa(i, s)
	},
	uw = function (e, t, i) {
		var r = e.labels,
			s = Hr,
			o, a, l;
		for (o in r) a = r[o] - t, a < 0 == !!i && a && s > (a = Math.abs(a)) && (l = o, s = a);
		return l
	},
	br = function (e, t, i) {
		var r = e.vars,
			s = r[t],
			o = sn,
			a = e._ctx,
			l, c, u;
		if (s) return l = r[t + "Params"], c = r.callbackScope || e, i && sa.length && Hp(), a && (sn = a), u = l ? s.apply(c, l) : s.call(c), sn = o, u
	},
	Ku = function (e) {
		return _a(e), e.scrollTrigger && e.scrollTrigger.kill(!!pi), e.progress() < 1 && br(e, "onInterrupt"), e
	},
	yc, OC = [],
	FC = function (e) {
		if (e)
			if (e = !e.name && e.default || e, J1() || e.headless) {
				var t = e.name,
					i = vn(e),
					r = t && !i && e.init ? function () {
						this._props = []
					} : e,
					s = {
						init: Jh,
						render: lb,
						add: rb,
						kill: i9,
						modifier: n9,
						rawVars: 0
					},
					o = {
						targetTest: 0,
						get: 0,
						getSetter: ab,
						aliases: {},
						register: 0
					};
				if (nu(), e !== r) {
					if (fr[t]) return;
					$r(r, $r(Gp(e, s), o)), Sl(r.prototype, Sl(s, Gp(e, o))), fr[r.prop = t] = r, e.targetTest && (up.push(r), tb[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
				}
				vC(t, r), e.register && e.register(Zi, r, Gi)
			} else OC.push(e)
	},
	Wt = 255,
	Zu = {
		aqua: [0, Wt, Wt],
		lime: [0, Wt, 0],
		silver: [192, 192, 192],
		black: [0, 0, 0],
		maroon: [128, 0, 0],
		teal: [0, 128, 128],
		blue: [0, 0, Wt],
		navy: [0, 0, 128],
		white: [Wt, Wt, Wt],
		olive: [128, 128, 0],
		yellow: [Wt, Wt, 0],
		orange: [Wt, 165, 0],
		gray: [128, 128, 128],
		purple: [128, 0, 128],
		green: [0, 128, 0],
		red: [Wt, 0, 0],
		pink: [Wt, 192, 203],
		cyan: [0, Wt, Wt],
		transparent: [Wt, Wt, Wt, 0]
	},
	j0 = function (e, t, i) {
		return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Wt + .5 | 0
	},
	NC = function (e, t, i) {
		var r = e ? uo(e) ? [e >> 16, e >> 8 & Wt, e & Wt] : 0 : Zu.black,
			s, o, a, l, c, u, h, d, f, p;
		if (!r) {
			if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Zu[e]) r = Zu[e];
			else if (e.charAt(0) === "#") {
				if (e.length < 6 && (s = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & Wt, r & Wt, parseInt(e.substr(7), 16) / 255];
				e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & Wt, e & Wt]
			} else if (e.substr(0, 3) === "hsl") {
				if (r = p = e.match(Y_), !t) l = +r[0] % 360 / 360, c = +r[1] / 100, u = +r[2] / 100, o = u <= .5 ? u * (c + 1) : u + c - u * c, s = u * 2 - o, r.length > 3 && (r[3] *= 1), r[0] = j0(l + 1 / 3, s, o), r[1] = j0(l, s, o), r[2] = j0(l - 1 / 3, s, o);
				else if (~e.indexOf("=")) return r = e.match(fC), i && r.length < 4 && (r[3] = 1), r
			} else r = e.match(Y_) || Zu.transparent;
			r = r.map(Number)
		}
		return t && !p && (s = r[0] / Wt, o = r[1] / Wt, a = r[2] / Wt, h = Math.max(s, o, a), d = Math.min(s, o, a), u = (h + d) / 2, h === d ? l = c = 0 : (f = h - d, c = u > .5 ? f / (2 - h - d) : f / (h + d), l = h === s ? (o - a) / f + (o < a ? 6 : 0) : h === o ? (a - s) / f + 2 : (s - o) / f + 4, l *= 60), r[0] = ~~(l + .5), r[1] = ~~(c * 100 + .5), r[2] = ~~(u * 100 + .5)), i && r.length < 4 && (r[3] = 1), r
	},
	UC = function (e) {
		var t = [],
			i = [],
			r = -1;
		return e.split(oa).forEach(function (s) {
			var o = s.match(bc) || [];
			t.push.apply(t, o), i.push(r += o.length + 1)
		}), t.c = i, t
	},
	hw = function (e, t, i) {
		var r = "",
			s = (e + r).match(oa),
			o = t ? "hsla(" : "rgba(",
			a = 0,
			l, c, u, h;
		if (!s) return e;
		if (s = s.map(function (d) {
				return (d = NC(d, t, 1)) && o + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
			}), i && (u = UC(e), l = i.c, l.join(r) !== u.c.join(r)))
			for (c = e.replace(oa, "1").split(bc), h = c.length - 1; a < h; a++) r += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (u.length ? u : s.length ? s : i).shift());
		if (!c)
			for (c = e.split(oa), h = c.length - 1; a < h; a++) r += c[a] + s[a];
		return r + c[h]
	},
	oa = function () {
		var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
			e;
		for (e in Zu) n += "|" + e + "\\b";
		return new RegExp(n + ")", "gi")
	}(),
	HB = /hsl[a]?\(/,
	BC = function (e) {
		var t = e.join(" "),
			i;
		if (oa.lastIndex = 0, oa.test(t)) return i = HB.test(t), e[1] = hw(e[1], i), e[0] = hw(e[0], i, UC(e[1])), !0
	},
	ed, mr = function () {
		var n = Date.now,
			e = 500,
			t = 33,
			i = n(),
			r = i,
			s = 1e3 / 240,
			o = s,
			a = [],
			l, c, u, h, d, f, p = function _(g) {
				var m = n() - r,
					b = g === !0,
					v, y, x, S;
				if ((m > e || m < 0) && (i += m - t), r += m, x = r - i, v = x - o, (v > 0 || b) && (S = ++h.frame, d = x - h.time * 1e3, h.time = x = x / 1e3, o += v + (v >= s ? 4 : s - v), y = 1), b || (l = c(_)), y)
					for (f = 0; f < a.length; f++) a[f](x, d, S, g)
			};
		return h = {
			time: 0,
			frame: 0,
			tick: function () {
				p(!0)
			},
			deltaRatio: function (g) {
				return d / (1e3 / (g || 60))
			},
			wake: function () {
				gC && (!K_ && J1() && (hs = K_ = window, Q1 = hs.document || {}, wr.gsap = Zi, (hs.gsapVersions || (hs.gsapVersions = [])).push(Zi.version), _C(Vp || hs.GreenSockGlobals || !hs.gsap && hs || {}), OC.forEach(FC)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && h.sleep(), c = u || function (g) {
					return setTimeout(g, o - h.time * 1e3 + 1 | 0)
				}, ed = 1, p(2))
			},
			sleep: function () {
				(u ? cancelAnimationFrame : clearTimeout)(l), ed = 0, c = Jh
			},
			lagSmoothing: function (g, m) {
				e = g || 1 / 0, t = Math.min(m || 33, e)
			},
			fps: function (g) {
				s = 1e3 / (g || 240), o = h.time * 1e3 + s
			},
			add: function (g, m, b) {
				var v = m ? function (y, x, S, E) {
					g(y, x, S, E), h.remove(v)
				} : g;
				return h.remove(g), a[b ? "unshift" : "push"](v), nu(), v
			},
			remove: function (g, m) {
				~(m = a.indexOf(g)) && a.splice(m, 1) && f >= m && f--
			},
			_listeners: a
		}, h
	}(),
	nu = function () {
		return !ed && mr.wake()
	},
	Tt = {},
	GB = /^[\d.\-M][\d.\-,\s]/,
	WB = /["']/g,
	jB = function (e) {
		for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, o = i.length, a, l, c; s < o; s++) l = i[s], a = s !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[r] = isNaN(c) ? c.replace(WB, "").trim() : +c, r = l.substr(a + 1).trim();
		return t
	},
	$B = function (e) {
		var t = e.indexOf("(") + 1,
			i = e.indexOf(")"),
			r = e.indexOf("(", t);
		return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i)
	},
	qB = function (e) {
		var t = (e + "").split("("),
			i = Tt[t[0]];
		return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [jB(t[1])] : $B(e).split(",").map(wC)) : Tt._CE && GB.test(e) ? Tt._CE("", e) : i
	},
	zC = function (e) {
		return function (t) {
			return 1 - e(1 - t)
		}
	},
	VC = function n(e, t) {
		for (var i = e._first, r; i;) i instanceof Di ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next
	},
	hl = function (e, t) {
		return e && (vn(e) ? e : Tt[e] || qB(e)) || t
	},
	kl = function (e, t, i, r) {
		i === void 0 && (i = function (l) {
			return 1 - t(1 - l)
		}), r === void 0 && (r = function (l) {
			return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
		});
		var s = {
				easeIn: t,
				easeOut: i,
				easeInOut: r
			},
			o;
		return Hi(e, function (a) {
			Tt[a] = wr[a] = s, Tt[o = a.toLowerCase()] = i;
			for (var l in s) Tt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Tt[a + "." + l] = s[l]
		}), s
	},
	HC = function (e) {
		return function (t) {
			return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
		}
	},
	$0 = function n(e, t, i) {
		var r = t >= 1 ? t : 1,
			s = (i || (e ? .3 : .45)) / (t < 1 ? t : 1),
			o = s / X_ * (Math.asin(1 / r) || 0),
			a = function (u) {
				return u === 1 ? 1 : r * Math.pow(2, -10 * u) * xB((u - o) * s) + 1
			},
			l = e === "out" ? a : e === "in" ? function (c) {
				return 1 - a(1 - c)
			} : HC(a);
		return s = X_ / s, l.config = function (c, u) {
			return n(e, c, u)
		}, l
	},
	q0 = function n(e, t) {
		t === void 0 && (t = 1.70158);
		var i = function (o) {
				return o ? --o * o * ((t + 1) * o + t) + 1 : 0
			},
			r = e === "out" ? i : e === "in" ? function (s) {
				return 1 - i(1 - s)
			} : HC(i);
		return r.config = function (s) {
			return n(e, s)
		}, r
	};
Hi("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
	var t = e < 5 ? e + 1 : e;
	kl(n + ",Power" + (t - 1), e ? function (i) {
		return Math.pow(i, t)
	} : function (i) {
		return i
	}, function (i) {
		return 1 - Math.pow(1 - i, t)
	}, function (i) {
		return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2
	})
});
Tt.Linear.easeNone = Tt.none = Tt.Linear.easeIn;
kl("Elastic", $0("in"), $0("out"), $0());
(function (n, e) {
	var t = 1 / e,
		i = 2 * t,
		r = 2.5 * t,
		s = function (a) {
			return a < t ? n * a * a : a < i ? n * Math.pow(a - 1.5 / e, 2) + .75 : a < r ? n * (a -= 2.25 / e) * a + .9375 : n * Math.pow(a - 2.625 / e, 2) + .984375
		};
	kl("Bounce", function (o) {
		return 1 - s(1 - o)
	}, s)
})(7.5625, 2.75);
kl("Expo", function (n) {
	return n ? Math.pow(2, 10 * (n - 1)) : 0
});
kl("Circ", function (n) {
	return -(hC(1 - n * n) - 1)
});
kl("Sine", function (n) {
	return n === 1 ? 1 : -yB(n * vB) + 1
});
kl("Back", q0("in"), q0("out"), q0());
Tt.SteppedEase = Tt.steps = wr.SteppedEase = {
	config: function (e, t) {
		e === void 0 && (e = 1);
		var i = 1 / e,
			r = e + (t ? 0 : 1),
			s = t ? 1 : 0,
			o = 1 - Yt;
		return function (a) {
			return ((r * Nd(0, o, a) | 0) + s) * i
		}
	}
};
Qc.ease = Tt["quad.out"];
Hi("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) {
	return nb += n + "," + n + "Params,"
});
var GC = function (e, t) {
		this.id = bB++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : yC, this.set = t ? t.getSetter : ab
	},
	td = function () {
		function n(t) {
			this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, tu(this, +t.duration, 1, 1), this.data = t.data, sn && (this._ctx = sn, sn.data.push(this)), ed || mr.wake()
		}
		var e = n.prototype;
		return e.delay = function (i) {
			return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay
		}, e.duration = function (i) {
			return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
		}, e.totalDuration = function (i) {
			return arguments.length ? (this._dirty = 0, tu(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
		}, e.totalTime = function (i, r) {
			if (nu(), !arguments.length) return this._tTime;
			var s = this._dp;
			if (s && s.smoothChildTiming && this._ts) {
				for (Xm(this, i), !s._dp || s.parent || TC(s, this); s && s.parent;) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent;
				!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && _s(this._dp, this, this._start - this._delay)
			}
			return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === Yt || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), xC(this, i, r)), this
		}, e.time = function (i, r) {
			return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + lw(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time
		}, e.totalProgress = function (i, r) {
			return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
		}, e.progress = function (i, r) {
			return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + lw(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
		}, e.iteration = function (i, r) {
			var s = this.duration() + this._rDelay;
			return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? eu(this._tTime, s) + 1 : 1
		}, e.timeScale = function (i, r) {
			if (!arguments.length) return this._rts === -Yt ? 0 : this._rts;
			if (this._rts === i) return this;
			var s = this.parent && this._ts ? Wp(this.parent._time, this) : this._tTime;
			return this._rts = +i || 0, this._ts = this._ps || i === -Yt ? 0 : this._rts, this.totalTime(Nd(-Math.abs(this._delay), this._tDur, s), r !== !1), qm(this), AB(this)
		}, e.paused = function (i) {
			return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (nu(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Yt && (this._tTime -= Yt)))), this) : this._ps
		}, e.startTime = function (i) {
			if (arguments.length) {
				this._start = i;
				var r = this.parent || this._dp;
				return r && (r._sort || !this.parent) && _s(r, this, i - this._delay), this
			}
			return this._start
		}, e.endTime = function (i) {
			return this._start + (Vi(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
		}, e.rawTime = function (i) {
			var r = this.parent || this._dp;
			return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Wp(r.rawTime(i), this) : this._tTime : this._tTime
		}, e.revert = function (i) {
			i === void 0 && (i = SB);
			var r = pi;
			return pi = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), pi = r, this
		}, e.globalTime = function (i) {
			for (var r = this, s = arguments.length ? i : r.rawTime(); r;) s = r._start + s / (Math.abs(r._ts) || 1), r = r._dp;
			return !this.parent && this._sat ? this._sat.globalTime(i) : s
		}, e.repeat = function (i) {
			return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, cw(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
		}, e.repeatDelay = function (i) {
			if (arguments.length) {
				var r = this._time;
				return this._rDelay = i, cw(this), r ? this.time(r) : this
			}
			return this._rDelay
		}, e.yoyo = function (i) {
			return arguments.length ? (this._yoyo = i, this) : this._yoyo
		}, e.seek = function (i, r) {
			return this.totalTime(Lr(this, i), Vi(r))
		}, e.restart = function (i, r) {
			return this.play().totalTime(i ? -this._delay : 0, Vi(r))
		}, e.play = function (i, r) {
			return i != null && this.seek(i, r), this.reversed(!1).paused(!1)
		}, e.reverse = function (i, r) {
			return i != null && this.seek(i || this.totalDuration(), r), this.reversed(!0).paused(!1)
		}, e.pause = function (i, r) {
			return i != null && this.seek(i, r), this.paused(!0)
		}, e.resume = function () {
			return this.paused(!1)
		}, e.reversed = function (i) {
			return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Yt : 0)), this) : this._rts < 0
		}, e.invalidate = function () {
			return this._initted = this._act = 0, this._zTime = -Yt, this
		}, e.isActive = function () {
			var i = this.parent || this._dp,
				r = this._start,
				s;
			return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(!0)) >= r && s < this.endTime(!0) - Yt)
		}, e.eventCallback = function (i, r, s) {
			var o = this.vars;
			return arguments.length > 1 ? (r ? (o[i] = r, s && (o[i + "Params"] = s), i === "onUpdate" && (this._onUpdate = r)) : delete o[i], this) : o[i]
		}, e.then = function (i) {
			var r = this;
			return new Promise(function (s) {
				var o = vn(i) ? i : EC,
					a = function () {
						var c = r.then;
						r.then = null, vn(o) && (o = o(r)) && (o.then || o === r) && (r.then = c), s(o), r.then = c
					};
				r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a
			})
		}, e.kill = function () {
			Ku(this)
		}, n
	}();
$r(td.prototype, {
	_time: 0,
	_start: 0,
	_end: 0,
	_tTime: 0,
	_tDur: 0,
	_dirty: 0,
	_repeat: 0,
	_yoyo: !1,
	parent: null,
	_initted: !1,
	_rDelay: 0,
	_ts: 1,
	_dp: 0,
	ratio: 0,
	_zTime: -Yt,
	_prom: 0,
	_ps: !1,
	_rts: 1
});
var Di = function (n) {
	uC(e, n);

	function e(i, r) {
		var s;
		return i === void 0 && (i = {}), s = n.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = Vi(i.sortChildren), fn && _s(i.parent || fn, $s(s), r), i.reversed && s.reverse(), i.paused && s.paused(!0), i.scrollTrigger && MC($s(s), i.scrollTrigger), s
	}
	var t = e.prototype;
	return t.to = function (r, s, o) {
		return vh(0, arguments, this), this
	}, t.from = function (r, s, o) {
		return vh(1, arguments, this), this
	}, t.fromTo = function (r, s, o, a) {
		return vh(2, arguments, this), this
	}, t.set = function (r, s, o) {
		return s.duration = 0, s.parent = this, _h(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Mn(r, s, Lr(this, o), 1), this
	}, t.call = function (r, s, o) {
		return _s(this, Mn.delayedCall(0, r, s), o)
	}, t.staggerTo = function (r, s, o, a, l, c, u) {
		return o.duration = s, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = u, o.parent = this, new Mn(r, o, Lr(this, l)), this
	}, t.staggerFrom = function (r, s, o, a, l, c, u) {
		return o.runBackwards = 1, _h(o).immediateRender = Vi(o.immediateRender), this.staggerTo(r, s, o, a, l, c, u)
	}, t.staggerFromTo = function (r, s, o, a, l, c, u, h) {
		return a.startAt = o, _h(a).immediateRender = Vi(a.immediateRender), this.staggerTo(r, s, a, l, c, u, h)
	}, t.render = function (r, s, o) {
		var a = this._time,
			l = this._dirty ? this.totalDuration() : this._tDur,
			c = this._dur,
			u = r <= 0 ? 0 : Xn(r),
			h = this._zTime < 0 != r < 0 && (this._initted || !c),
			d, f, p, _, g, m, b, v, y, x, S, E;
		if (this !== fn && u > l && r >= 0 && (u = l), u !== this._tTime || o || h) {
			if (a !== this._time && c && (u += this._time - a, r += this._time - a), d = u, y = this._start, v = this._ts, m = !v, h && (c || (a = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) {
				if (S = this._yoyo, g = c + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(g * 100 + r, s, o);
				if (d = Xn(u % g), u === l ? (_ = this._repeat, d = c) : (_ = ~~(u / g), _ && _ === u / g && (d = c, _--), d > c && (d = c)), x = eu(this._tTime, g), !a && this._tTime && x !== _ && this._tTime - x * g - this._dur <= 0 && (x = _), S && _ & 1 && (d = c - d, E = 1), _ !== x && !this._lock) {
					var C = S && x & 1,
						P = C === (S && _ & 1);
					if (_ < x && (C = !C), a = C ? 0 : u % c ? c : u, this._lock = 1, this.render(a || (E ? 0 : Xn(_ * g)), s, !c)._lock = 0, this._tTime = u, !s && this.parent && br(this, "onRepeat"), this.vars.repeatRefresh && !E && (this.invalidate()._lock = 1), a && a !== this._time || m !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
					if (c = this._dur, l = this._tDur, P && (this._lock = 2, a = C ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !E && this.invalidate()), this._lock = 0, !this._ts && !m) return this;
					VC(this, E)
				}
			}
			if (this._hasPause && !this._forcing && this._lock < 2 && (b = LB(this, Xn(a), Xn(d)), b && (u -= d - (d = b._start))), this._tTime = u, this._time = d, this._act = !v, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, a = 0), !a && d && !s && !_ && (br(this, "onStart"), this._tTime !== u)) return this;
			if (d >= a && r >= 0)
				for (f = this._first; f;) {
					if (p = f._next, (f._act || d >= f._start) && f._ts && b !== f) {
						if (f.parent !== this) return this.render(r, s, o);
						if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, s, o), d !== this._time || !this._ts && !m) {
							b = 0, p && (u += this._zTime = -Yt);
							break
						}
					}
					f = p
				} else {
					f = this._last;
					for (var w = r < 0 ? r : d; f;) {
						if (p = f._prev, (f._act || w <= f._end) && f._ts && b !== f) {
							if (f.parent !== this) return this.render(r, s, o);
							if (f.render(f._ts > 0 ? (w - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (w - f._start) * f._ts, s, o || pi && (f._initted || f._startAt)), d !== this._time || !this._ts && !m) {
								b = 0, p && (u += this._zTime = w ? -Yt : Yt);
								break
							}
						}
						f = p
					}
				}
			if (b && !s && (this.pause(), b.render(d >= a ? 0 : -Yt)._zTime = d >= a ? 1 : -1, this._ts)) return this._start = y, qm(this), this.render(r, s, o);
			this._onUpdate && !s && br(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && a) && (y === this._start || Math.abs(v) !== Math.abs(this._ts)) && (this._lock || ((r || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && _a(this, 1), !s && !(r < 0 && !a) && (u || a || !l) && (br(this, u === l && r >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
		}
		return this
	}, t.add = function (r, s) {
		var o = this;
		if (uo(s) || (s = Lr(this, s, r)), !(r instanceof td)) {
			if (mi(r)) return r.forEach(function (a) {
				return o.add(a, s)
			}), this;
			if (Zn(r)) return this.addLabel(r, s);
			if (vn(r)) r = Mn.delayedCall(0, r);
			else return this
		}
		return this !== r ? _s(this, r, s) : this
	}, t.getChildren = function (r, s, o, a) {
		r === void 0 && (r = !0), s === void 0 && (s = !0), o === void 0 && (o = !0), a === void 0 && (a = -Hr);
		for (var l = [], c = this._first; c;) c._start >= a && (c instanceof Mn ? s && l.push(c) : (o && l.push(c), r && l.push.apply(l, c.getChildren(!0, s, o)))), c = c._next;
		return l
	}, t.getById = function (r) {
		for (var s = this.getChildren(1, 1, 1), o = s.length; o--;)
			if (s[o].vars.id === r) return s[o]
	}, t.remove = function (r) {
		return Zn(r) ? this.removeLabel(r) : vn(r) ? this.killTweensOf(r) : ($m(this, r), r === this._recent && (this._recent = this._last), ul(this))
	}, t.totalTime = function (r, s) {
		return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Xn(mr.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), n.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime
	}, t.addLabel = function (r, s) {
		return this.labels[r] = Lr(this, s), this
	}, t.removeLabel = function (r) {
		return delete this.labels[r], this
	}, t.addPause = function (r, s, o) {
		var a = Mn.delayedCall(0, s || Jh, o);
		return a.data = "isPause", this._hasPause = 1, _s(this, a, Lr(this, r))
	}, t.removePause = function (r) {
		var s = this._first;
		for (r = Lr(this, r); s;) s._start === r && s.data === "isPause" && _a(s), s = s._next
	}, t.killTweensOf = function (r, s, o) {
		for (var a = this.getTweensOf(r, o), l = a.length; l--;) Xo !== a[l] && a[l].kill(r, s);
		return this
	}, t.getTweensOf = function (r, s) {
		for (var o = [], a = Gr(r), l = this._first, c = uo(s), u; l;) l instanceof Mn ? TB(l._targets, a) && (c ? (!Xo || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, s)).length && o.push.apply(o, u), l = l._next;
		return o
	}, t.tweenTo = function (r, s) {
		s = s || {};
		var o = this,
			a = Lr(o, r),
			l = s,
			c = l.startAt,
			u = l.onStart,
			h = l.onStartParams,
			d = l.immediateRender,
			f, p = Mn.to(o, $r({
				ease: s.ease || "none",
				lazy: !1,
				immediateRender: !1,
				time: a,
				overwrite: "auto",
				duration: s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || Yt,
				onStart: function () {
					if (o.pause(), !f) {
						var g = s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
						p._dur !== g && tu(p, g, 0, 1).render(p._time, !0, !0), f = 1
					}
					u && u.apply(p, h || [])
				}
			}, s));
		return d ? p.render(0) : p
	}, t.tweenFromTo = function (r, s, o) {
		return this.tweenTo(s, $r({
			startAt: {
				time: Lr(this, r)
			}
		}, o))
	}, t.recent = function () {
		return this._recent
	}, t.nextLabel = function (r) {
		return r === void 0 && (r = this._time), uw(this, Lr(this, r))
	}, t.previousLabel = function (r) {
		return r === void 0 && (r = this._time), uw(this, Lr(this, r), 1)
	}, t.currentLabel = function (r) {
		return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + Yt)
	}, t.shiftChildren = function (r, s, o) {
		o === void 0 && (o = 0);
		for (var a = this._first, l = this.labels, c; a;) a._start >= o && (a._start += r, a._end += r), a = a._next;
		if (s)
			for (c in l) l[c] >= o && (l[c] += r);
		return ul(this)
	}, t.invalidate = function (r) {
		var s = this._first;
		for (this._lock = 0; s;) s.invalidate(r), s = s._next;
		return n.prototype.invalidate.call(this, r)
	}, t.clear = function (r) {
		r === void 0 && (r = !0);
		for (var s = this._first, o; s;) o = s._next, this.remove(s), s = o;
		return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), ul(this)
	}, t.totalDuration = function (r) {
		var s = 0,
			o = this,
			a = o._last,
			l = Hr,
			c, u, h;
		if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
		if (o._dirty) {
			for (h = o.parent; a;) c = a._prev, a._dirty && a.totalDuration(), u = a._start, u > l && o._sort && a._ts && !o._lock ? (o._lock = 1, _s(o, a, u - a._delay, 1)._lock = 0) : l = u, u < 0 && a._ts && (s -= u, (!h && !o._dp || h && h.smoothChildTiming) && (o._start += u / o._ts, o._time -= u, o._tTime -= u), o.shiftChildren(-u, !1, -1 / 0), l = 0), a._end > s && a._ts && (s = a._end), a = c;
			tu(o, o === fn && o._time > s ? o._time : s, 1, 1), o._dirty = 0
		}
		return o._tDur
	}, e.updateRoot = function (r) {
		if (fn._ts && (xC(fn, Wp(r, fn)), bC = mr.frame), mr.frame >= ow) {
			ow += xr.autoSleep || 120;
			var s = fn._first;
			if ((!s || !s._ts) && xr.autoSleep && mr._listeners.length < 2) {
				for (; s && !s._ts;) s = s._next;
				s || mr.sleep()
			}
		}
	}, e
}(td);
$r(Di.prototype, {
	_lock: 0,
	_hasPause: 0,
	_forcing: 0
});
var XB = function (e, t, i, r, s, o, a) {
		var l = new Gi(this._pt, e, t, 0, 1, YC, null, s),
			c = 0,
			u = 0,
			h, d, f, p, _, g, m, b;
		for (l.b = i, l.e = r, i += "", r += "", (m = ~r.indexOf("random(")) && (r = Qh(r)), o && (b = [i, r], o(b, e, t), i = b[0], r = b[1]), d = i.match(G0) || []; h = G0.exec(r);) p = h[0], _ = r.substring(c, h.index), f ? f = (f + 1) % 5 : _.substr(-5) === "rgba(" && (f = 1), p !== d[u++] && (g = parseFloat(d[u - 1]) || 0, l._pt = {
			_next: l._pt,
			p: _ || u === 1 ? _ : ",",
			s: g,
			c: p.charAt(1) === "=" ? kc(g, p) - g : parseFloat(p) - g,
			m: f && f < 4 ? Math.round : 0
		}, c = G0.lastIndex);
		return l.c = c < r.length ? r.substring(c, r.length) : "", l.fp = a, (pC.test(r) || m) && (l.e = 0), this._pt = l, l
	},
	rb = function (e, t, i, r, s, o, a, l, c, u) {
		vn(r) && (r = r(s || 0, e, o));
		var h = e[t],
			d = i !== "get" ? i : vn(h) ? c ? e[t.indexOf("set") || !vn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : h,
			f = vn(h) ? c ? QB : qC : ob,
			p;
		if (Zn(r) && (~r.indexOf("random(") && (r = Qh(r)), r.charAt(1) === "=" && (p = kc(d, r) + (di(d) || 0), (p || p === 0) && (r = p))), !u || d !== r || iv) return !isNaN(d * r) && r !== "" ? (p = new Gi(this._pt, e, t, +d || 0, r - (d || 0), typeof h == "boolean" ? t9 : XC, 0, f), c && (p.fp = c), a && p.modifier(a, this, e), this._pt = p) : (!h && !(t in e) && eb(t, r), XB.call(this, e, t, d, r, f, l || xr.stringFilter, c))
	},
	YB = function (e, t, i, r, s) {
		if (vn(e) && (e = bh(e, s, t, i, r)), !Rs(e) || e.style && e.nodeType || mi(e) || dC(e)) return Zn(e) ? bh(e, s, t, i, r) : e;
		var o = {},
			a;
		for (a in e) o[a] = bh(e[a], s, t, i, r);
		return o
	},
	WC = function (e, t, i, r, s, o) {
		var a, l, c, u;
		if (fr[e] && (a = new fr[e]).init(s, a.rawVars ? t[e] : YB(t[e], r, s, o, i), i, r, o) !== !1 && (i._pt = l = new Gi(i._pt, s, e, 0, 1, a.render, a, 0, a.priority), i !== yc))
			for (c = i._ptLookup[i._targets.indexOf(s)], u = a._props.length; u--;) c[a._props[u]] = l;
		return a
	},
	Xo, iv, sb = function n(e, t, i) {
		var r = e.vars,
			s = r.ease,
			o = r.startAt,
			a = r.immediateRender,
			l = r.lazy,
			c = r.onUpdate,
			u = r.runBackwards,
			h = r.yoyoEase,
			d = r.keyframes,
			f = r.autoRevert,
			p = e._dur,
			_ = e._startAt,
			g = e._targets,
			m = e.parent,
			b = m && m.data === "nested" ? m.vars.targets : g,
			v = e._overwrite === "auto" && !K1,
			y = e.timeline,
			x, S, E, C, P, w, D, U, j, z, H, F, G;
		if (y && (!d || !s) && (s = "none"), e._ease = hl(s, Qc.ease), e._yEase = h ? zC(hl(h === !0 ? s : h, Qc.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !y && !!r.runBackwards, !y || d && !r.stagger) {
			if (U = g[0] ? cl(g[0]).harness : 0, F = U && r[U.prop], x = Gp(r, tb), _ && (_._zTime < 0 && _.progress(1), t < 0 && u && a && !f ? _.render(-1, !0) : _.revert(u && p ? cp : EB), _._lazy = 0), o) {
				if (_a(e._startAt = Mn.set(g, $r({
						data: "isStart",
						overwrite: !1,
						parent: m,
						immediateRender: !0,
						lazy: !_ && Vi(l),
						startAt: null,
						delay: 0,
						onUpdate: c && function () {
							return br(e, "onUpdate")
						},
						stagger: 0
					}, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (pi || !a && !f) && e._startAt.revert(cp), a && p && t <= 0 && i <= 0) {
					t && (e._zTime = t);
					return
				}
			} else if (u && p && !_) {
				if (t && (a = !1), E = $r({
						overwrite: !1,
						data: "isFromStart",
						lazy: a && !_ && Vi(l),
						immediateRender: a,
						stagger: 0,
						parent: m
					}, x), F && (E[U.prop] = F), _a(e._startAt = Mn.set(g, E)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (pi ? e._startAt.revert(cp) : e._startAt.render(-1, !0)), e._zTime = t, !a) n(e._startAt, Yt, Yt);
				else if (!t) return
			}
			for (e._pt = e._ptCache = 0, l = p && Vi(l) || l && !p, S = 0; S < g.length; S++) {
				if (P = g[S], D = P._gsap || ib(g)[S]._gsap, e._ptLookup[S] = z = {}, Z_[D.id] && sa.length && Hp(), H = b === g ? S : b.indexOf(P), U && (j = new U).init(P, F || x, e, H, b) !== !1 && (e._pt = C = new Gi(e._pt, P, j.name, 0, 1, j.render, j, 0, j.priority), j._props.forEach(function (R) {
						z[R] = C
					}), j.priority && (w = 1)), !U || F)
					for (E in x) fr[E] && (j = WC(E, x, e, H, P, b)) ? j.priority && (w = 1) : z[E] = C = rb.call(e, P, E, "get", x[E], H, b, 0, r.stringFilter);
				e._op && e._op[S] && e.kill(P, e._op[S]), v && e._pt && (Xo = e, fn.killTweensOf(P, z, e.globalTime(t)), G = !e.parent, Xo = 0), e._pt && l && (Z_[D.id] = 1)
			}
			w && KC(e), e._onInit && e._onInit(e)
		}
		e._onUpdate = c, e._initted = (!e._op || e._pt) && !G, d && t <= 0 && y.render(Hr, !0, !0)
	},
	KB = function (e, t, i, r, s, o, a, l) {
		var c = (e._pt && e._ptCache || (e._ptCache = {}))[t],
			u, h, d, f;
		if (!c)
			for (c = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length; f--;) {
				if (u = d[f][t], u && u.d && u.d._pt)
					for (u = u.d._pt; u && u.p !== t && u.fp !== t;) u = u._next;
				if (!u) return iv = 1, e.vars[t] = "+=0", sb(e, a), iv = 0, l ? Zh(t + " not eligible for reset") : 1;
				c.push(u)
			}
		for (f = c.length; f--;) h = c[f], u = h._pt || h, u.s = (r || r === 0) && !s ? r : u.s + (r || 0) + o * u.c, u.c = i - u.s, h.e && (h.e = xn(i) + di(h.e)), h.b && (h.b = u.s + di(h.b))
	},
	ZB = function (e, t) {
		var i = e[0] ? cl(e[0]).harness : 0,
			r = i && i.aliases,
			s, o, a, l;
		if (!r) return t;
		s = Sl({}, t);
		for (o in r)
			if (o in s)
				for (l = r[o].split(","), a = l.length; a--;) s[l[a]] = s[o];
		return s
	},
	JB = function (e, t, i, r) {
		var s = t.ease || r || "power1.inOut",
			o, a;
		if (mi(t)) a = i[e] || (i[e] = []), t.forEach(function (l, c) {
			return a.push({
				t: c / (t.length - 1) * 100,
				v: l,
				e: s
			})
		});
		else
			for (o in t) a = i[o] || (i[o] = []), o === "ease" || a.push({
				t: parseFloat(e),
				v: t[o],
				e: s
			})
	},
	bh = function (e, t, i, r, s) {
		return vn(e) ? e.call(t, i, r, s) : Zn(e) && ~e.indexOf("random(") ? Qh(e) : e
	},
	jC = nb + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
	$C = {};
Hi(jC + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
	return $C[n] = 1
});
var Mn = function (n) {
	uC(e, n);

	function e(i, r, s, o) {
		var a;
		typeof r == "number" && (s.duration = r, r = s, s = null), a = n.call(this, o ? r : _h(r)) || this;
		var l = a.vars,
			c = l.duration,
			u = l.delay,
			h = l.immediateRender,
			d = l.stagger,
			f = l.overwrite,
			p = l.keyframes,
			_ = l.defaults,
			g = l.scrollTrigger,
			m = l.yoyoEase,
			b = r.parent || fn,
			v = (mi(i) || dC(i) ? uo(i[0]) : "length" in r) ? [i] : Gr(i),
			y, x, S, E, C, P, w, D;
		if (a._targets = v.length ? ib(v) : Zh("GSAP target " + i + " not found. https://gsap.com", !xr.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = f, p || d || of (c) || of (u)) {
			if (r = a.vars, y = a.timeline = new Di({
					data: "nested",
					defaults: _ || {},
					targets: b && b.data === "nested" ? b.vars.targets : v
				}), y.kill(), y.parent = y._dp = $s(a), y._start = 0, d || of (c) || of (u)) {
				if (E = v.length, w = d && PC(d), Rs(d))
					for (C in d) ~jC.indexOf(C) && (D || (D = {}), D[C] = d[C]);
				for (x = 0; x < E; x++) S = Gp(r, $C), S.stagger = 0, m && (S.yoyoEase = m), D && Sl(S, D), P = v[x], S.duration = +bh(c, $s(a), x, P, v), S.delay = (+bh(u, $s(a), x, P, v) || 0) - a._delay, !d && E === 1 && S.delay && (a._delay = u = S.delay, a._start += u, S.delay = 0), y.to(P, S, w ? w(x, P, v) : 0), y._ease = Tt.none;
				y.duration() ? c = u = 0 : a.timeline = 0
			} else if (p) {
				_h($r(y.vars.defaults, {
					ease: "none"
				})), y._ease = hl(p.ease || r.ease || "none");
				var U = 0,
					j, z, H;
				if (mi(p)) p.forEach(function (F) {
					return y.to(v, F, ">")
				}), y.duration();
				else {
					S = {};
					for (C in p) C === "ease" || C === "easeEach" || JB(C, p[C], S, p.easeEach);
					for (C in S)
						for (j = S[C].sort(function (F, G) {
								return F.t - G.t
							}), U = 0, x = 0; x < j.length; x++) z = j[x], H = {
							ease: z.e,
							duration: (z.t - (x ? j[x - 1].t : 0)) / 100 * c
						}, H[C] = z.v, y.to(v, H, U), U += H.duration;
					y.duration() < c && y.to({}, {
						duration: c - y.duration()
					})
				}
			}
			c || a.duration(c = y.duration())
		} else a.timeline = 0;
		return f === !0 && !K1 && (Xo = $s(a), fn.killTweensOf(v), Xo = 0), _s(b, $s(a), s), r.reversed && a.reverse(), r.paused && a.paused(!0), (h || !c && !p && a._start === Xn(b._time) && Vi(h) && DB($s(a)) && b.data !== "nested") && (a._tTime = -Yt, a.render(Math.max(0, -u) || 0)), g && MC($s(a), g), a
	}
	var t = e.prototype;
	return t.render = function (r, s, o) {
		var a = this._time,
			l = this._tDur,
			c = this._dur,
			u = r < 0,
			h = r > l - Yt && !u ? l : r < Yt ? 0 : r,
			d, f, p, _, g, m, b, v, y;
		if (!c) RB(this, r, s, o);
		else if (h !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
			if (d = h, v = this.timeline, this._repeat) {
				if (_ = c + this._rDelay, this._repeat < -1 && u) return this.totalTime(_ * 100 + r, s, o);
				if (d = Xn(h % _), h === l ? (p = this._repeat, d = c) : (p = ~~(h / _), p && p === Xn(h / _) && (d = c, p--), d > c && (d = c)), m = this._yoyo && p & 1, m && (y = this._yEase, d = c - d), g = eu(this._tTime, _), d === a && !o && this._initted && p === g) return this._tTime = h, this;
				p !== g && (v && this._yEase && VC(v, m), this.vars.repeatRefresh && !m && !this._lock && this._time !== _ && this._initted && (this._lock = o = 1, this.render(Xn(_ * p), !0).invalidate()._lock = 0))
			}
			if (!this._initted) {
				if (CC(this, u ? r : d, o, s, h)) return this._tTime = 0, this;
				if (a !== this._time && !(o && this.vars.repeatRefresh && p !== g)) return this;
				if (c !== this._dur) return this.render(r, s, o)
			}
			if (this._tTime = h, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = b = (y || this._ease)(d / c), this._from && (this.ratio = b = 1 - b), d && !a && !s && !p && (br(this, "onStart"), this._tTime !== h)) return this;
			for (f = this._pt; f;) f.r(b, f.d), f = f._next;
			v && v.render(r < 0 ? r : v._dur * v._ease(d / this._dur), s, o) || this._startAt && (this._zTime = r), this._onUpdate && !s && (u && J_(this, r, s, o), br(this, "onUpdate")), this._repeat && p !== g && this.vars.onRepeat && !s && this.parent && br(this, "onRepeat"), (h === this._tDur || !h) && this._tTime === h && (u && !this._onUpdate && J_(this, r, !0, !0), (r || !c) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && _a(this, 1), !s && !(u && !a) && (h || a || m) && (br(this, h === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom()))
		}
		return this
	}, t.targets = function () {
		return this._targets
	}, t.invalidate = function (r) {
		return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), n.prototype.invalidate.call(this, r)
	}, t.resetTo = function (r, s, o, a, l) {
		ed || mr.wake(), this._ts || this.play();
		var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
			u;
		return this._initted || sb(this, c), u = this._ease(c / this._dur), KB(this, r, s, o, a, u, c, l) ? this.resetTo(r, s, o, a, 1) : (Xm(this, 0), this.parent || SC(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
	}, t.kill = function (r, s) {
		if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? Ku(this) : this;
		if (this.timeline) {
			var o = this.timeline.totalDuration();
			return this.timeline.killTweensOf(r, s, Xo && Xo.vars.overwrite !== !0)._first || Ku(this), this.parent && o !== this.timeline.totalDuration() && tu(this, this._dur * this.timeline._tDur / o, 0, 1), this
		}
		var a = this._targets,
			l = r ? Gr(r) : a,
			c = this._ptLookup,
			u = this._pt,
			h, d, f, p, _, g, m;
		if ((!s || s === "all") && CB(a, l)) return s === "all" && (this._pt = 0), Ku(this);
		for (h = this._op = this._op || [], s !== "all" && (Zn(s) && (_ = {}, Hi(s, function (b) {
				return _[b] = 1
			}), s = _), s = ZB(a, s)), m = a.length; m--;)
			if (~l.indexOf(a[m])) {
				d = c[m], s === "all" ? (h[m] = s, p = d, f = {}) : (f = h[m] = h[m] || {}, p = s);
				for (_ in p) g = d && d[_], g && ((!("kill" in g.d) || g.d.kill(_) === !0) && $m(this, g, "_pt"), delete d[_]), f !== "all" && (f[_] = 1)
			} return this._initted && !this._pt && u && Ku(this), this
	}, e.to = function (r, s) {
		return new e(r, s, arguments[2])
	}, e.from = function (r, s) {
		return vh(1, arguments)
	}, e.delayedCall = function (r, s, o, a) {
		return new e(s, 0, {
			immediateRender: !1,
			lazy: !1,
			overwrite: !1,
			delay: r,
			onComplete: s,
			onReverseComplete: s,
			onCompleteParams: o,
			onReverseCompleteParams: o,
			callbackScope: a
		})
	}, e.fromTo = function (r, s, o) {
		return vh(2, arguments)
	}, e.set = function (r, s) {
		return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s)
	}, e.killTweensOf = function (r, s, o) {
		return fn.killTweensOf(r, s, o)
	}, e
}(td);
$r(Mn.prototype, {
	_targets: [],
	_lazy: 0,
	_startAt: 0,
	_op: 0,
	_onInit: 0
});
Hi("staggerTo,staggerFrom,staggerFromTo", function (n) {
	Mn[n] = function () {
		var e = new Di,
			t = ev.call(arguments, 0);
		return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t)
	}
});
var ob = function (e, t, i) {
		return e[t] = i
	},
	qC = function (e, t, i) {
		return e[t](i)
	},
	QB = function (e, t, i, r) {
		return e[t](r.fp, i)
	},
	e9 = function (e, t, i) {
		return e.setAttribute(t, i)
	},
	ab = function (e, t) {
		return vn(e[t]) ? qC : Z1(e[t]) && e.setAttribute ? e9 : ob
	},
	XC = function (e, t) {
		return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
	},
	t9 = function (e, t) {
		return t.set(t.t, t.p, !!(t.s + t.c * e), t)
	},
	YC = function (e, t) {
		var i = t._pt,
			r = "";
		if (!e && t.b) r = t.b;
		else if (e === 1 && t.e) r = t.e;
		else {
			for (; i;) r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r, i = i._next;
			r += t.c
		}
		t.set(t.t, t.p, r, t)
	},
	lb = function (e, t) {
		for (var i = t._pt; i;) i.r(e, i.d), i = i._next
	},
	n9 = function (e, t, i, r) {
		for (var s = this._pt, o; s;) o = s._next, s.p === r && s.modifier(e, t, i), s = o
	},
	i9 = function (e) {
		for (var t = this._pt, i, r; t;) r = t._next, t.p === e && !t.op || t.op === e ? $m(this, t, "_pt") : t.dep || (i = 1), t = r;
		return !i
	},
	r9 = function (e, t, i, r) {
		r.mSet(e, t, r.m.call(r.tween, i, r.mt), r)
	},
	KC = function (e) {
		for (var t = e._pt, i, r, s, o; t;) {
			for (i = t._next, r = s; r && r.pr > t.pr;) r = r._next;
			(t._prev = r ? r._prev : o) ? t._prev._next = t: s = t, (t._next = r) ? r._prev = t : o = t, t = i
		}
		e._pt = s
	},
	Gi = function () {
		function n(t, i, r, s, o, a, l, c, u) {
			this.t = i, this.s = s, this.c = o, this.p = r, this.r = a || XC, this.d = l || this, this.set = c || ob, this.pr = u || 0, this._next = t, t && (t._prev = this)
		}
		var e = n.prototype;
		return e.modifier = function (i, r, s) {
			this.mSet = this.mSet || this.set, this.set = r9, this.m = i, this.mt = s, this.tween = r
		}, n
	}();
Hi(nb + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) {
	return tb[n] = 1
});
wr.TweenMax = wr.TweenLite = Mn;
wr.TimelineLite = wr.TimelineMax = Di;
fn = new Di({
	sortChildren: !1,
	defaults: Qc,
	autoRemoveChildren: !0,
	id: "root",
	smoothChildTiming: !0
});
xr.stringFilter = BC;
var dl = [],
	hp = {},
	s9 = [],
	dw = 0,
	o9 = 0,
	X0 = function (e) {
		return (hp[e] || s9).map(function (t) {
			return t()
		})
	},
	rv = function () {
		var e = Date.now(),
			t = [];
		e - dw > 2 && (X0("matchMediaInit"), dl.forEach(function (i) {
			var r = i.queries,
				s = i.conditions,
				o, a, l, c;
			for (a in r) o = hs.matchMedia(r[a]).matches, o && (l = 1), o !== s[a] && (s[a] = o, c = 1);
			c && (i.revert(), l && t.push(i))
		}), X0("matchMediaRevert"), t.forEach(function (i) {
			return i.onMatch(i, function (r) {
				return i.add(null, r)
			})
		}), dw = e, X0("matchMedia"))
	},
	ZC = function () {
		function n(t, i) {
			this.selector = i && tv(i), this.data = [], this._r = [], this.isReverted = !1, this.id = o9++, t && this.add(t)
		}
		var e = n.prototype;
		return e.add = function (i, r, s) {
			vn(i) && (s = r, r = i, i = vn);
			var o = this,
				a = function () {
					var c = sn,
						u = o.selector,
						h;
					return c && c !== o && c.data.push(o), s && (o.selector = tv(s)), sn = o, h = r.apply(o, arguments), vn(h) && o._r.push(h), sn = c, o.selector = u, o.isReverted = !1, h
				};
			return o.last = a, i === vn ? a(o, function (l) {
				return o.add(null, l)
			}) : i ? o[i] = a : a
		}, e.ignore = function (i) {
			var r = sn;
			sn = null, i(this), sn = r
		}, e.getTweens = function () {
			var i = [];
			return this.data.forEach(function (r) {
				return r instanceof n ? i.push.apply(i, r.getTweens()) : r instanceof Mn && !(r.parent && r.parent.data === "nested") && i.push(r)
			}), i
		}, e.clear = function () {
			this._r.length = this.data.length = 0
		}, e.kill = function (i, r) {
			var s = this;
			if (i ? function () {
					for (var a = s.getTweens(), l = s.data.length, c; l--;) c = s.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function (u) {
						return a.splice(a.indexOf(u), 1)
					}));
					for (a.map(function (u) {
							return {
								g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
								t: u
							}
						}).sort(function (u, h) {
							return h.g - u.g || -1 / 0
						}).forEach(function (u) {
							return u.t.revert(i)
						}), l = s.data.length; l--;) c = s.data[l], c instanceof Di ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof Mn) && c.revert && c.revert(i);
					s._r.forEach(function (u) {
						return u(i, s)
					}), s.isReverted = !0
				}() : this.data.forEach(function (a) {
					return a.kill && a.kill()
				}), this.clear(), r)
				for (var o = dl.length; o--;) dl[o].id === this.id && dl.splice(o, 1)
		}, e.revert = function (i) {
			this.kill(i || {})
		}, n
	}(),
	a9 = function () {
		function n(t) {
			this.contexts = [], this.scope = t, sn && sn.data.push(this)
		}
		var e = n.prototype;
		return e.add = function (i, r, s) {
			Rs(i) || (i = {
				matches: i
			});
			var o = new ZC(0, s || this.scope),
				a = o.conditions = {},
				l, c, u;
			sn && !o.selector && (o.selector = sn.selector), this.contexts.push(o), r = o.add("onMatch", r), o.queries = i;
			for (c in i) c === "all" ? u = 1 : (l = hs.matchMedia(i[c]), l && (dl.indexOf(o) < 0 && dl.push(o), (a[c] = l.matches) && (u = 1), l.addListener ? l.addListener(rv) : l.addEventListener("change", rv)));
			return u && r(o, function (h) {
				return o.add(null, h)
			}), this
		}, e.revert = function (i) {
			this.kill(i || {})
		}, e.kill = function (i) {
			this.contexts.forEach(function (r) {
				return r.kill(i, !0)
			})
		}, n
	}(),
	jp = {
		registerPlugin: function () {
			for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
			t.forEach(function (r) {
				return FC(r)
			})
		},
		timeline: function (e) {
			return new Di(e)
		},
		getTweensOf: function (e, t) {
			return fn.getTweensOf(e, t)
		},
		getProperty: function (e, t, i, r) {
			Zn(e) && (e = Gr(e)[0]);
			var s = cl(e || {}).get,
				o = i ? EC : wC;
			return i === "native" && (i = ""), e && (t ? o((fr[t] && fr[t].get || s)(e, t, i, r)) : function (a, l, c) {
				return o((fr[a] && fr[a].get || s)(e, a, l, c))
			})
		},
		quickSetter: function (e, t, i) {
			if (e = Gr(e), e.length > 1) {
				var r = e.map(function (u) {
						return Zi.quickSetter(u, t, i)
					}),
					s = r.length;
				return function (u) {
					for (var h = s; h--;) r[h](u)
				}
			}
			e = e[0] || {};
			var o = fr[t],
				a = cl(e),
				l = a.harness && (a.harness.aliases || {})[t] || t,
				c = o ? function (u) {
					var h = new o;
					yc._pt = 0, h.init(e, i ? u + i : u, yc, 0, [e]), h.render(1, h), yc._pt && lb(1, yc)
				} : a.set(e, l);
			return o ? c : function (u) {
				return c(e, l, i ? u + i : u, a, 1)
			}
		},
		quickTo: function (e, t, i) {
			var r, s = Zi.to(e, Sl((r = {}, r[t] = "+=0.1", r.paused = !0, r), i || {})),
				o = function (l, c, u) {
					return s.resetTo(t, l, c, u)
				};
			return o.tween = s, o
		},
		isTweening: function (e) {
			return fn.getTweensOf(e, !0).length > 0
		},
		defaults: function (e) {
			return e && e.ease && (e.ease = hl(e.ease, Qc.ease)), aw(Qc, e || {})
		},
		config: function (e) {
			return aw(xr, e || {})
		},
		registerEffect: function (e) {
			var t = e.name,
				i = e.effect,
				r = e.plugins,
				s = e.defaults,
				o = e.extendTimeline;
			(r || "").split(",").forEach(function (a) {
				return a && !fr[a] && !wr[a] && Zh(t + " effect requires " + a + " plugin.")
			}), W0[t] = function (a, l, c) {
				return i(Gr(a), $r(l || {}, s), c)
			}, o && (Di.prototype[t] = function (a, l, c) {
				return this.add(W0[t](a, Rs(l) ? l : (c = l) && {}, this), c)
			})
		},
		registerEase: function (e, t) {
			Tt[e] = hl(t)
		},
		parseEase: function (e, t) {
			return arguments.length ? hl(e, t) : Tt
		},
		getById: function (e) {
			return fn.getById(e)
		},
		exportRoot: function (e, t) {
			e === void 0 && (e = {});
			var i = new Di(e),
				r, s;
			for (i.smoothChildTiming = Vi(e.smoothChildTiming), fn.remove(i), i._dp = 0, i._time = i._tTime = fn._time, r = fn._first; r;) s = r._next, (t || !(!r._dur && r instanceof Mn && r.vars.onComplete === r._targets[0])) && _s(i, r, r._start - r._delay), r = s;
			return _s(fn, i, 0), i
		},
		context: function (e, t) {
			return e ? new ZC(e, t) : sn
		},
		matchMedia: function (e) {
			return new a9(e)
		},
		matchMediaRefresh: function () {
			return dl.forEach(function (e) {
				var t = e.conditions,
					i, r;
				for (r in t) t[r] && (t[r] = !1, i = 1);
				i && e.revert()
			}) || rv()
		},
		addEventListener: function (e, t) {
			var i = hp[e] || (hp[e] = []);
			~i.indexOf(t) || i.push(t)
		},
		removeEventListener: function (e, t) {
			var i = hp[e],
				r = i && i.indexOf(t);
			r >= 0 && i.splice(r, 1)
		},
		utils: {
			wrap: BB,
			wrapYoyo: zB,
			distribute: PC,
			random: LC,
			snap: RC,
			normalize: UB,
			getUnit: di,
			clamp: IB,
			splitColor: NC,
			toArray: Gr,
			selector: tv,
			mapRange: IC,
			pipe: FB,
			unitize: NB,
			interpolate: VB,
			shuffle: DC
		},
		install: _C,
		effects: W0,
		ticker: mr,
		updateRoot: Di.updateRoot,
		plugins: fr,
		globalTimeline: fn,
		core: {
			PropTween: Gi,
			globals: vC,
			Tween: Mn,
			Timeline: Di,
			Animation: td,
			getCache: cl,
			_removeLinkedListItem: $m,
			reverting: function () {
				return pi
			},
			context: function (e) {
				return e && sn && (sn.data.push(e), e._ctx = sn), sn
			},
			suppressOverwrites: function (e) {
				return K1 = e
			}
		}
	};
Hi("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
	return jp[n] = Mn[n]
});
mr.add(Di.updateRoot);
yc = jp.to({}, {
	duration: 0
});
var l9 = function (e, t) {
		for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
		return i
	},
	c9 = function (e, t) {
		var i = e._targets,
			r, s, o;
		for (r in t)
			for (s = i.length; s--;) o = e._ptLookup[s][r], o && (o = o.d) && (o._pt && (o = l9(o, r)), o && o.modifier && o.modifier(t[r], e, i[s], r))
	},
	Y0 = function (e, t) {
		return {
			name: e,
			rawVars: 1,
			init: function (r, s, o) {
				o._onInit = function (a) {
					var l, c;
					if (Zn(s) && (l = {}, Hi(s, function (u) {
							return l[u] = 1
						}), s = l), t) {
						l = {};
						for (c in s) l[c] = t(s[c]);
						s = l
					}
					c9(a, s)
				}
			}
		}
	},
	Zi = jp.registerPlugin({
		name: "attr",
		init: function (e, t, i, r, s) {
			var o, a, l;
			this.tween = i;
			for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], r, s, 0, 0, o), a.op = o, a.b = l, this._props.push(o)
		},
		render: function (e, t) {
			for (var i = t._pt; i;) pi ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next
		}
	}, {
		name: "endArray",
		init: function (e, t) {
			for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
		}
	}, Y0("roundProps", nv), Y0("modifiers"), Y0("snap", RC)) || jp;
Mn.version = Di.version = Zi.version = "3.12.5";
gC = 1;
J1() && nu();
Tt.Power0;
Tt.Power1;
Tt.Power2;
Tt.Power3;
Tt.Power4;
Tt.Linear;
Tt.Quad;
Tt.Cubic;
Tt.Quart;
Tt.Quint;
Tt.Strong;
Tt.Elastic;
Tt.Back;
Tt.SteppedEase;
Tt.Bounce;
Tt.Sine;
Tt.Expo;
Tt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var fw, Yo, Ic, cb, el, pw, ub, u9 = function () {
		return typeof window < "u"
	},
	ho = {},
	$a = 180 / Math.PI,
	Oc = Math.PI / 180,
	Hl = Math.atan2,
	mw = 1e8,
	hb = /([A-Z])/g,
	h9 = /(left|right|width|margin|padding|x)/i,
	d9 = /[\s,\(]\S/,
	xs = {
		autoAlpha: "opacity,visibility",
		scale: "scaleX,scaleY",
		alpha: "opacity"
	},
	sv = function (e, t) {
		return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
	},
	f9 = function (e, t) {
		return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
	},
	p9 = function (e, t) {
		return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
	},
	m9 = function (e, t) {
		var i = t.s + t.c * e;
		t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
	},
	JC = function (e, t) {
		return t.set(t.t, t.p, e ? t.e : t.b, t)
	},
	QC = function (e, t) {
		return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
	},
	g9 = function (e, t, i) {
		return e.style[t] = i
	},
	_9 = function (e, t, i) {
		return e.style.setProperty(t, i)
	},
	v9 = function (e, t, i) {
		return e._gsap[t] = i
	},
	b9 = function (e, t, i) {
		return e._gsap.scaleX = e._gsap.scaleY = i
	},
	y9 = function (e, t, i, r, s) {
		var o = e._gsap;
		o.scaleX = o.scaleY = i, o.renderTransform(s, o)
	},
	x9 = function (e, t, i, r, s) {
		var o = e._gsap;
		o[t] = i, o.renderTransform(s, o)
	},
	pn = "transform",
	Wi = pn + "Origin",
	w9 = function n(e, t) {
		var i = this,
			r = this.target,
			s = r.style,
			o = r._gsap;
		if (e in ho && s) {
			if (this.tfm = this.tfm || {}, e !== "transform") e = xs[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (a) {
				return i.tfm[a] = Xs(r, a)
			}) : this.tfm[e] = o.x ? o[e] : Xs(r, e), e === Wi && (this.tfm.zOrigin = o.zOrigin);
			else return xs.transform.split(",").forEach(function (a) {
				return n.call(i, a, t)
			});
			if (this.props.indexOf(pn) >= 0) return;
			o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Wi, t, "")), e = pn
		}(s || t) && this.props.push(e, t, s[e])
	},
	eA = function (e) {
		e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
	},
	E9 = function () {
		var e = this.props,
			t = this.target,
			i = t.style,
			r = t._gsap,
			s, o;
		for (s = 0; s < e.length; s += 3) e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(hb, "-$1").toLowerCase());
		if (this.tfm) {
			for (o in this.tfm) r[o] = this.tfm[o];
			r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = ub(), (!s || !s.isStart) && !i[pn] && (eA(i), r.zOrigin && i[Wi] && (i[Wi] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1)
		}
	},
	tA = function (e, t) {
		var i = {
			target: e,
			props: [],
			revert: E9,
			save: w9
		};
		return e._gsap || Zi.core.getCache(e), t && t.split(",").forEach(function (r) {
			return i.save(r)
		}), i
	},
	nA, ov = function (e, t) {
		var i = Yo.createElementNS ? Yo.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Yo.createElement(e);
		return i && i.style ? i : Yo.createElement(e)
	},
	Ts = function n(e, t, i) {
		var r = getComputedStyle(e);
		return r[t] || r.getPropertyValue(t.replace(hb, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, iu(t) || t, 1) || ""
	},
	gw = "O,Moz,ms,Ms,Webkit".split(","),
	iu = function (e, t, i) {
		var r = t || el,
			s = r.style,
			o = 5;
		if (e in s && !i) return e;
		for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(gw[o] + e in s););
		return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? gw[o] : "") + e
	},
	av = function () {
		u9() && window.document && (fw = window, Yo = fw.document, Ic = Yo.documentElement, el = ov("div") || {
			style: {}
		}, ov("div"), pn = iu(pn), Wi = pn + "Origin", el.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", nA = !!iu("perspective"), ub = Zi.core.reverting, cb = 1)
	},
	K0 = function n(e) {
		var t = ov("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
			i = this.parentNode,
			r = this.nextSibling,
			s = this.style.cssText,
			o;
		if (Ic.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
			o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n
		} catch {} else this._gsapBBox && (o = this._gsapBBox());
		return i && (r ? i.insertBefore(this, r) : i.appendChild(this)), Ic.removeChild(t), this.style.cssText = s, o
	},
	_w = function (e, t) {
		for (var i = t.length; i--;)
			if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
	},
	iA = function (e) {
		var t;
		try {
			t = e.getBBox()
		} catch {
			t = K0.call(e, !0)
		}
		return t && (t.width || t.height) || e.getBBox === K0 || (t = K0.call(e, !0)), t && !t.width && !t.x && !t.y ? {
			x: +_w(e, ["x", "cx", "x1"]) || 0,
			y: +_w(e, ["y", "cy", "y1"]) || 0,
			width: 0,
			height: 0
		} : t
	},
	rA = function (e) {
		return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && iA(e))
	},
	Tl = function (e, t) {
		if (t) {
			var i = e.style,
				r;
			t in ho && t !== Wi && (t = pn), i.removeProperty ? (r = t.substr(0, 2), (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(r === "--" ? t : t.replace(hb, "-$1").toLowerCase())) : i.removeAttribute(t)
		}
	},
	Ko = function (e, t, i, r, s, o) {
		var a = new Gi(e._pt, t, i, 0, 1, o ? QC : JC);
		return e._pt = a, a.b = r, a.e = s, e._props.push(i), a
	},
	vw = {
		deg: 1,
		rad: 1,
		turn: 1
	},
	S9 = {
		grid: 1,
		flex: 1
	},
	va = function n(e, t, i, r) {
		var s = parseFloat(i) || 0,
			o = (i + "").trim().substr((s + "").length) || "px",
			a = el.style,
			l = h9.test(t),
			c = e.tagName.toLowerCase() === "svg",
			u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
			h = 100,
			d = r === "px",
			f = r === "%",
			p, _, g, m;
		if (r === o || !s || vw[r] || vw[o]) return s;
		if (o !== "px" && !d && (s = n(e, t, i, "px")), m = e.getCTM && rA(e), (f || o === "%") && (ho[t] || ~t.indexOf("adius"))) return p = m ? e.getBBox()[l ? "width" : "height"] : e[u], xn(f ? s / p * h : s / 100 * p);
		if (a[l ? "width" : "height"] = h + (d ? o : r), _ = ~t.indexOf("adius") || r === "em" && e.appendChild && !c ? e : e.parentNode, m && (_ = (e.ownerSVGElement || {}).parentNode), (!_ || _ === Yo || !_.appendChild) && (_ = Yo.body), g = _._gsap, g && f && g.width && l && g.time === mr.time && !g.uncache) return xn(s / g.width * h);
		if (f && (t === "height" || t === "width")) {
			var b = e.style[t];
			e.style[t] = h + r, p = e[u], b ? e.style[t] = b : Tl(e, t)
		} else(f || o === "%") && !S9[Ts(_, "display")] && (a.position = Ts(e, "position")), _ === e && (a.position = "static"), _.appendChild(el), p = el[u], _.removeChild(el), a.position = "absolute";
		return l && f && (g = cl(_), g.time = mr.time, g.width = _[u]), xn(d ? p * s / h : p && s ? h / p * s : 0)
	},
	Xs = function (e, t, i, r) {
		var s;
		return cb || av(), t in xs && t !== "transform" && (t = xs[t], ~t.indexOf(",") && (t = t.split(",")[0])), ho[t] && t !== "transform" ? (s = id(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : qp(Ts(e, Wi)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = $p[t] && $p[t](e, t, i) || Ts(e, t) || yC(e, t) || (t === "opacity" ? 1 : 0))), i && !~(s + "").trim().indexOf(" ") ? va(e, t, s, i) + i : s
	},
	T9 = function (e, t, i, r) {
		if (!i || i === "none") {
			var s = iu(t, e, 1),
				o = s && Ts(e, s, 1);
			o && o !== i ? (t = s, i = o) : t === "borderColor" && (i = Ts(e, "borderTopColor"))
		}
		var a = new Gi(this._pt, e.style, t, 0, 1, YC),
			l = 0,
			c = 0,
			u, h, d, f, p, _, g, m, b, v, y, x;
		if (a.b = i, a.e = r, i += "", r += "", r === "auto" && (_ = e.style[t], e.style[t] = r, r = Ts(e, t) || r, _ ? e.style[t] = _ : Tl(e, t)), u = [i, r], BC(u), i = u[0], r = u[1], d = i.match(bc) || [], x = r.match(bc) || [], x.length) {
			for (; h = bc.exec(r);) g = h[0], b = r.substring(l, h.index), p ? p = (p + 1) % 5 : (b.substr(-5) === "rgba(" || b.substr(-5) === "hsla(") && (p = 1), g !== (_ = d[c++] || "") && (f = parseFloat(_) || 0, y = _.substr((f + "").length), g.charAt(1) === "=" && (g = kc(f, g) + y), m = parseFloat(g), v = g.substr((m + "").length), l = bc.lastIndex - v.length, v || (v = v || xr.units[t] || y, l === r.length && (r += v, a.e += v)), y !== v && (f = va(e, t, _, v) || 0), a._pt = {
				_next: a._pt,
				p: b || c === 1 ? b : ",",
				s: f,
				c: m - f,
				m: p && p < 4 || t === "zIndex" ? Math.round : 0
			});
			a.c = l < r.length ? r.substring(l, r.length) : ""
		} else a.r = t === "display" && r === "none" ? QC : JC;
		return pC.test(r) && (a.e = 0), this._pt = a, a
	},
	bw = {
		top: "0%",
		bottom: "100%",
		left: "0%",
		right: "100%",
		center: "50%"
	},
	M9 = function (e) {
		var t = e.split(" "),
			i = t[0],
			r = t[1] || "50%";
		return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i, i = r, r = e), t[0] = bw[i] || i, t[1] = bw[r] || r, t.join(" ")
	},
	C9 = function (e, t) {
		if (t.tween && t.tween._time === t.tween._dur) {
			var i = t.t,
				r = i.style,
				s = t.u,
				o = i._gsap,
				a, l, c;
			if (s === "all" || s === !0) r.cssText = "", l = 1;
			else
				for (s = s.split(","), c = s.length; --c > -1;) a = s[c], ho[a] && (l = 1, a = a === "transformOrigin" ? Wi : pn), Tl(i, a);
			l && (Tl(i, pn), o && (o.svg && i.removeAttribute("transform"), id(i, 1), o.uncache = 1, eA(r)))
		}
	},
	$p = {
		clearProps: function (e, t, i, r, s) {
			if (s.data !== "isFromStart") {
				var o = e._pt = new Gi(e._pt, t, i, 0, 0, C9);
				return o.u = r, o.pr = -10, o.tween = s, e._props.push(i), 1
			}
		}
	},
	nd = [1, 0, 0, 1, 0, 0],
	sA = {},
	oA = function (e) {
		return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
	},
	yw = function (e) {
		var t = Ts(e, pn);
		return oA(t) ? nd : t.substr(7).match(fC).map(xn)
	},
	db = function (e, t) {
		var i = e._gsap || cl(e),
			r = e.style,
			s = yw(e),
			o, a, l, c;
		return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? nd : s) : (s === nd && !e.offsetParent && e !== Ic && !i.svg && (l = r.display, r.display = "block", o = e.parentNode, (!o || !e.offsetParent) && (c = 1, a = e.nextElementSibling, Ic.appendChild(e)), s = yw(e), l ? r.display = l : Tl(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Ic.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
	},
	lv = function (e, t, i, r, s, o) {
		var a = e._gsap,
			l = s || db(e, !0),
			c = a.xOrigin || 0,
			u = a.yOrigin || 0,
			h = a.xOffset || 0,
			d = a.yOffset || 0,
			f = l[0],
			p = l[1],
			_ = l[2],
			g = l[3],
			m = l[4],
			b = l[5],
			v = t.split(" "),
			y = parseFloat(v[0]) || 0,
			x = parseFloat(v[1]) || 0,
			S, E, C, P;
		i ? l !== nd && (E = f * g - p * _) && (C = y * (g / E) + x * (-_ / E) + (_ * b - g * m) / E, P = y * (-p / E) + x * (f / E) - (f * b - p * m) / E, y = C, x = P) : (S = iA(e), y = S.x + (~v[0].indexOf("%") ? y / 100 * S.width : y), x = S.y + (~(v[1] || v[0]).indexOf("%") ? x / 100 * S.height : x)), r || r !== !1 && a.smooth ? (m = y - c, b = x - u, a.xOffset = h + (m * f + b * _) - m, a.yOffset = d + (m * p + b * g) - b) : a.xOffset = a.yOffset = 0, a.xOrigin = y, a.yOrigin = x, a.smooth = !!r, a.origin = t, a.originIsAbsolute = !!i, e.style[Wi] = "0px 0px", o && (Ko(o, a, "xOrigin", c, y), Ko(o, a, "yOrigin", u, x), Ko(o, a, "xOffset", h, a.xOffset), Ko(o, a, "yOffset", d, a.yOffset)), e.setAttribute("data-svg-origin", y + " " + x)
	},
	id = function (e, t) {
		var i = e._gsap || new GC(e);
		if ("x" in i && !t && !i.uncache) return i;
		var r = e.style,
			s = i.scaleX < 0,
			o = "px",
			a = "deg",
			l = getComputedStyle(e),
			c = Ts(e, Wi) || "0",
			u, h, d, f, p, _, g, m, b, v, y, x, S, E, C, P, w, D, U, j, z, H, F, G, R, Q, B, ge, Ae, ze, K, ye;
		return u = h = d = _ = g = m = b = v = y = 0, f = p = 1, i.svg = !!(e.getCTM && rA(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[pn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[pn] !== "none" ? l[pn] : "")), r.scale = r.rotate = r.translate = "none"), E = db(e, i.svg), i.svg && (i.uncache ? (R = e.getBBox(), c = i.xOrigin - R.x + "px " + (i.yOrigin - R.y) + "px", G = "") : G = !t && e.getAttribute("data-svg-origin"), lv(e, G || c, !!G || i.originIsAbsolute, i.smooth !== !1, E)), x = i.xOrigin || 0, S = i.yOrigin || 0, E !== nd && (D = E[0], U = E[1], j = E[2], z = E[3], u = H = E[4], h = F = E[5], E.length === 6 ? (f = Math.sqrt(D * D + U * U), p = Math.sqrt(z * z + j * j), _ = D || U ? Hl(U, D) * $a : 0, b = j || z ? Hl(j, z) * $a + _ : 0, b && (p *= Math.abs(Math.cos(b * Oc))), i.svg && (u -= x - (x * D + S * j), h -= S - (x * U + S * z))) : (ye = E[6], ze = E[7], B = E[8], ge = E[9], Ae = E[10], K = E[11], u = E[12], h = E[13], d = E[14], C = Hl(ye, Ae), g = C * $a, C && (P = Math.cos(-C), w = Math.sin(-C), G = H * P + B * w, R = F * P + ge * w, Q = ye * P + Ae * w, B = H * -w + B * P, ge = F * -w + ge * P, Ae = ye * -w + Ae * P, K = ze * -w + K * P, H = G, F = R, ye = Q), C = Hl(-j, Ae), m = C * $a, C && (P = Math.cos(-C), w = Math.sin(-C), G = D * P - B * w, R = U * P - ge * w, Q = j * P - Ae * w, K = z * w + K * P, D = G, U = R, j = Q), C = Hl(U, D), _ = C * $a, C && (P = Math.cos(C), w = Math.sin(C), G = D * P + U * w, R = H * P + F * w, U = U * P - D * w, F = F * P - H * w, D = G, H = R), g && Math.abs(g) + Math.abs(_) > 359.9 && (g = _ = 0, m = 180 - m), f = xn(Math.sqrt(D * D + U * U + j * j)), p = xn(Math.sqrt(F * F + ye * ye)), C = Hl(H, F), b = Math.abs(C) > 2e-4 ? C * $a : 0, y = K ? 1 / (K < 0 ? -K : K) : 0), i.svg && (G = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !oA(Ts(e, pn)), G && e.setAttribute("transform", G))), Math.abs(b) > 90 && Math.abs(b) < 270 && (s ? (f *= -1, b += _ <= 0 ? 180 : -180, _ += _ <= 0 ? 180 : -180) : (p *= -1, b += b <= 0 ? 180 : -180)), t = t || i.uncache, i.x = u - ((i.xPercent = u && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o, i.y = h - ((i.yPercent = h && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o, i.z = d + o, i.scaleX = xn(f), i.scaleY = xn(p), i.rotation = xn(_) + a, i.rotationX = xn(g) + a, i.rotationY = xn(m) + a, i.skewX = b + a, i.skewY = v + a, i.transformPerspective = y + o, (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (r[Wi] = qp(c)), i.xOffset = i.yOffset = 0, i.force3D = xr.force3D, i.renderTransform = i.svg ? D9 : nA ? aA : A9, i.uncache = 0, i
	},
	qp = function (e) {
		return (e = e.split(" "))[0] + " " + e[1]
	},
	Z0 = function (e, t, i) {
		var r = di(t);
		return xn(parseFloat(t) + parseFloat(va(e, "x", i + "px", r))) + r
	},
	A9 = function (e, t) {
		t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, aA(e, t)
	},
	Fa = "0deg",
	Fu = "0px",
	Na = ") ",
	aA = function (e, t) {
		var i = t || this,
			r = i.xPercent,
			s = i.yPercent,
			o = i.x,
			a = i.y,
			l = i.z,
			c = i.rotation,
			u = i.rotationY,
			h = i.rotationX,
			d = i.skewX,
			f = i.skewY,
			p = i.scaleX,
			_ = i.scaleY,
			g = i.transformPerspective,
			m = i.force3D,
			b = i.target,
			v = i.zOrigin,
			y = "",
			x = m === "auto" && e && e !== 1 || m === !0;
		if (v && (h !== Fa || u !== Fa)) {
			var S = parseFloat(u) * Oc,
				E = Math.sin(S),
				C = Math.cos(S),
				P;
			S = parseFloat(h) * Oc, P = Math.cos(S), o = Z0(b, o, E * P * -v), a = Z0(b, a, -Math.sin(S) * -v), l = Z0(b, l, C * P * -v + v)
		}
		g !== Fu && (y += "perspective(" + g + Na), (r || s) && (y += "translate(" + r + "%, " + s + "%) "), (x || o !== Fu || a !== Fu || l !== Fu) && (y += l !== Fu || x ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + Na), c !== Fa && (y += "rotate(" + c + Na), u !== Fa && (y += "rotateY(" + u + Na), h !== Fa && (y += "rotateX(" + h + Na), (d !== Fa || f !== Fa) && (y += "skew(" + d + ", " + f + Na), (p !== 1 || _ !== 1) && (y += "scale(" + p + ", " + _ + Na), b.style[pn] = y || "translate(0, 0)"
	},
	D9 = function (e, t) {
		var i = t || this,
			r = i.xPercent,
			s = i.yPercent,
			o = i.x,
			a = i.y,
			l = i.rotation,
			c = i.skewX,
			u = i.skewY,
			h = i.scaleX,
			d = i.scaleY,
			f = i.target,
			p = i.xOrigin,
			_ = i.yOrigin,
			g = i.xOffset,
			m = i.yOffset,
			b = i.forceCSS,
			v = parseFloat(o),
			y = parseFloat(a),
			x, S, E, C, P;
		l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= Oc, c *= Oc, x = Math.cos(l) * h, S = Math.sin(l) * h, E = Math.sin(l - c) * -d, C = Math.cos(l - c) * d, c && (u *= Oc, P = Math.tan(c - u), P = Math.sqrt(1 + P * P), E *= P, C *= P, u && (P = Math.tan(u), P = Math.sqrt(1 + P * P), x *= P, S *= P)), x = xn(x), S = xn(S), E = xn(E), C = xn(C)) : (x = h, C = d, S = E = 0), (v && !~(o + "").indexOf("px") || y && !~(a + "").indexOf("px")) && (v = va(f, "x", o, "px"), y = va(f, "y", a, "px")), (p || _ || g || m) && (v = xn(v + p - (p * x + _ * E) + g), y = xn(y + _ - (p * S + _ * C) + m)), (r || s) && (P = f.getBBox(), v = xn(v + r / 100 * P.width), y = xn(y + s / 100 * P.height)), P = "matrix(" + x + "," + S + "," + E + "," + C + "," + v + "," + y + ")", f.setAttribute("transform", P), b && (f.style[pn] = P)
	},
	P9 = function (e, t, i, r, s) {
		var o = 360,
			a = Zn(s),
			l = parseFloat(s) * (a && ~s.indexOf("rad") ? $a : 1),
			c = l - r,
			u = r + c + "deg",
			h, d;
		return a && (h = s.split("_")[1], h === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -o)), h === "cw" && c < 0 ? c = (c + o * mw) % o - ~~(c / o) * o : h === "ccw" && c > 0 && (c = (c - o * mw) % o - ~~(c / o) * o)), e._pt = d = new Gi(e._pt, t, i, r, c, f9), d.e = u, d.u = "deg", e._props.push(i), d
	},
	xw = function (e, t) {
		for (var i in t) e[i] = t[i];
		return e
	},
	R9 = function (e, t, i) {
		var r = xw({}, i._gsap),
			s = "perspective,force3D,transformOrigin,svgOrigin",
			o = i.style,
			a, l, c, u, h, d, f, p;
		r.svg ? (c = i.getAttribute("transform"), i.setAttribute("transform", ""), o[pn] = t, a = id(i, 1), Tl(i, pn), i.setAttribute("transform", c)) : (c = getComputedStyle(i)[pn], o[pn] = t, a = id(i, 1), o[pn] = c);
		for (l in ho) c = r[l], u = a[l], c !== u && s.indexOf(l) < 0 && (f = di(c), p = di(u), h = f !== p ? va(i, l, c, p) : parseFloat(c), d = parseFloat(u), e._pt = new Gi(e._pt, a, l, h, d - h, sv), e._pt.u = p || 0, e._props.push(l));
		xw(a, r)
	};
Hi("padding,margin,Width,Radius", function (n, e) {
	var t = "Top",
		i = "Right",
		r = "Bottom",
		s = "Left",
		o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (a) {
			return e < 2 ? n + a : "border" + a + n
		});
	$p[e > 1 ? "border" + n : n] = function (a, l, c, u, h) {
		var d, f;
		if (arguments.length < 4) return d = o.map(function (p) {
			return Xs(a, p, c)
		}), f = d.join(" "), f.split(d[0]).length === 5 ? d[0] : f;
		d = (u + "").split(" "), f = {}, o.forEach(function (p, _) {
			return f[p] = d[_] = d[_] || d[(_ - 1) / 2 | 0]
		}), a.init(l, f, h)
	}
});
var lA = {
	name: "css",
	register: av,
	targetTest: function (e) {
		return e.style && e.nodeType
	},
	init: function (e, t, i, r, s) {
		var o = this._props,
			a = e.style,
			l = i.vars.startAt,
			c, u, h, d, f, p, _, g, m, b, v, y, x, S, E, C;
		cb || av(), this.styles = this.styles || tA(e), C = this.styles.props, this.tween = i;
		for (_ in t)
			if (_ !== "autoRound" && (u = t[_], !(fr[_] && WC(_, t, i, r, e, s)))) {
				if (f = typeof u, p = $p[_], f === "function" && (u = u.call(i, r, e, s), f = typeof u), f === "string" && ~u.indexOf("random(") && (u = Qh(u)), p) p(this, e, _, u, i) && (E = 1);
				else if (_.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(_) + "").trim(), u += "", oa.lastIndex = 0, oa.test(c) || (g = di(c), m = di(u)), m ? g !== m && (c = va(e, _, c, m) + m) : g && (u += g), this.add(a, "setProperty", c, u, r, s, 0, 0, _), o.push(_), C.push(_, 0, a[_]);
				else if (f !== "undefined") {
					if (l && _ in l ? (c = typeof l[_] == "function" ? l[_].call(i, r, e, s) : l[_], Zn(c) && ~c.indexOf("random(") && (c = Qh(c)), di(c + "") || c === "auto" || (c += xr.units[_] || di(Xs(e, _)) || ""), (c + "").charAt(1) === "=" && (c = Xs(e, _))) : c = Xs(e, _), d = parseFloat(c), b = f === "string" && u.charAt(1) === "=" && u.substr(0, 2), b && (u = u.substr(2)), h = parseFloat(u), _ in xs && (_ === "autoAlpha" && (d === 1 && Xs(e, "visibility") === "hidden" && h && (d = 0), C.push("visibility", 0, a.visibility), Ko(this, a, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), _ !== "scale" && _ !== "transform" && (_ = xs[_], ~_.indexOf(",") && (_ = _.split(",")[0]))), v = _ in ho, v) {
						if (this.styles.save(_), y || (x = e._gsap, x.renderTransform && !t.parseTransform || id(e, t.parseTransform), S = t.smoothOrigin !== !1 && x.smooth, y = this._pt = new Gi(this._pt, a, pn, 0, 1, x.renderTransform, x, 0, -1), y.dep = 1), _ === "scale") this._pt = new Gi(this._pt, x, "scaleY", x.scaleY, (b ? kc(x.scaleY, b + h) : h) - x.scaleY || 0, sv), this._pt.u = 0, o.push("scaleY", _), _ += "X";
						else if (_ === "transformOrigin") {
							C.push(Wi, 0, a[Wi]), u = M9(u), x.svg ? lv(e, u, 0, S, 0, this) : (m = parseFloat(u.split(" ")[2]) || 0, m !== x.zOrigin && Ko(this, x, "zOrigin", x.zOrigin, m), Ko(this, a, _, qp(c), qp(u)));
							continue
						} else if (_ === "svgOrigin") {
							lv(e, u, 1, S, 0, this);
							continue
						} else if (_ in sA) {
							P9(this, x, _, d, b ? kc(d, b + u) : u);
							continue
						} else if (_ === "smoothOrigin") {
							Ko(this, x, "smooth", x.smooth, u);
							continue
						} else if (_ === "force3D") {
							x[_] = u;
							continue
						} else if (_ === "transform") {
							R9(this, u, e);
							continue
						}
					} else _ in a || (_ = iu(_) || _);
					if (v || (h || h === 0) && (d || d === 0) && !d9.test(u) && _ in a) g = (c + "").substr((d + "").length), h || (h = 0), m = di(u) || (_ in xr.units ? xr.units[_] : g), g !== m && (d = va(e, _, c, m)), this._pt = new Gi(this._pt, v ? x : a, _, d, (b ? kc(d, b + h) : h) - d, !v && (m === "px" || _ === "zIndex") && t.autoRound !== !1 ? m9 : sv), this._pt.u = m || 0, g !== m && m !== "%" && (this._pt.b = c, this._pt.r = p9);
					else if (_ in a) T9.call(this, e, _, c, b ? b + u : u);
					else if (_ in e) this.add(e, _, c || e[_], b ? b + u : u, r, s);
					else if (_ !== "parseTransform") {
						eb(_, u);
						continue
					}
					v || (_ in a ? C.push(_, 0, a[_]) : C.push(_, 1, c || e[_])), o.push(_)
				}
			} E && KC(this)
	},
	render: function (e, t) {
		if (t.tween._time || !ub())
			for (var i = t._pt; i;) i.r(e, i.d), i = i._next;
		else t.styles.revert()
	},
	get: Xs,
	aliases: xs,
	getSetter: function (e, t, i) {
		var r = xs[t];
		return r && r.indexOf(",") < 0 && (t = r), t in ho && t !== Wi && (e._gsap.x || Xs(e, "x")) ? i && pw === i ? t === "scale" ? b9 : v9 : (pw = i || {}) && (t === "scale" ? y9 : x9) : e.style && !Z1(e.style[t]) ? g9 : ~t.indexOf("-") ? _9 : ab(e, t)
	},
	core: {
		_removeProperty: Tl,
		_getMatrix: db
	}
};
Zi.utils.checkPrefix = iu;
Zi.core.getStyleSaver = tA;
(function (n, e, t, i) {
	var r = Hi(n + "," + e + "," + t, function (s) {
		ho[s] = 1
	});
	Hi(e, function (s) {
		xr.units[s] = "deg", sA[s] = 1
	}), xs[r[13]] = n + "," + e, Hi(i, function (s) {
		var o = s.split(":");
		xs[o[1]] = r[o[0]]
	})
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Hi("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) {
	xr.units[n] = "px"
});
Zi.registerPlugin(lA);
var lt = Zi.registerPlugin(lA) || Zi;
lt.core.Tween;

function L9(n, e) {
	for (var t = 0; t < e.length; t++) {
		var i = e[t];
		i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i)
	}
}

function k9(n, e, t) {
	return e && L9(n.prototype, e), n
}
/*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var ri, dp, gr, Zo, Jo, Fc, cA, qa, yh, uA, Js, Jr, hA, dA = function () {
		return ri || typeof window < "u" && (ri = window.gsap) && ri.registerPlugin && ri
	},
	fA = 1,
	xc = [],
	yt = [],
	Ms = [],
	xh = Date.now,
	cv = function (e, t) {
		return t
	},
	I9 = function () {
		var e = yh.core,
			t = e.bridge || {},
			i = e._scrollers,
			r = e._proxies;
		i.push.apply(i, yt), r.push.apply(r, Ms), yt = i, Ms = r, cv = function (o, a) {
			return t[o](a)
		}
	},
	aa = function (e, t) {
		return ~Ms.indexOf(e) && Ms[Ms.indexOf(e) + 1][t]
	},
	wh = function (e) {
		return !!~uA.indexOf(e)
	},
	Ei = function (e, t, i, r, s) {
		return e.addEventListener(t, i, {
			passive: r !== !1,
			capture: !!s
		})
	},
	yi = function (e, t, i, r) {
		return e.removeEventListener(t, i, !!r)
	},
	af = "scrollLeft",
	lf = "scrollTop",
	uv = function () {
		return Js && Js.isPressed || yt.cache++
	},
	Xp = function (e, t) {
		var i = function r(s) {
			if (s || s === 0) {
				fA && (gr.history.scrollRestoration = "manual");
				var o = Js && Js.isPressed;
				s = r.v = Math.round(s) || (Js && Js.iOS ? 1 : 0), e(s), r.cacheID = yt.cache, o && cv("ss", s)
			} else(t || yt.cache !== r.cacheID || cv("ref")) && (r.cacheID = yt.cache, r.v = e());
			return r.v + r.offset
		};
		return i.offset = 0, e && i
	},
	Pi = {
		s: af,
		p: "left",
		p2: "Left",
		os: "right",
		os2: "Right",
		d: "width",
		d2: "Width",
		a: "x",
		sc: Xp(function (n) {
			return arguments.length ? gr.scrollTo(n, On.sc()) : gr.pageXOffset || Zo[af] || Jo[af] || Fc[af] || 0
		})
	},
	On = {
		s: lf,
		p: "top",
		p2: "Top",
		os: "bottom",
		os2: "Bottom",
		d: "height",
		d2: "Height",
		a: "y",
		op: Pi,
		sc: Xp(function (n) {
			return arguments.length ? gr.scrollTo(Pi.sc(), n) : gr.pageYOffset || Zo[lf] || Jo[lf] || Fc[lf] || 0
		})
	},
	Bi = function (e, t) {
		return (t && t._ctx && t._ctx.selector || ri.utils.toArray)(e)[0] || (typeof e == "string" && ri.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
	},
	ba = function (e, t) {
		var i = t.s,
			r = t.sc;
		wh(e) && (e = Zo.scrollingElement || Jo);
		var s = yt.indexOf(e),
			o = r === On.sc ? 1 : 2;
		!~s && (s = yt.push(e) - 1), yt[s + o] || Ei(e, "scroll", uv);
		var a = yt[s + o],
			l = a || (yt[s + o] = Xp(aa(e, i), !0) || (wh(e) ? r : Xp(function (c) {
				return arguments.length ? e[i] = c : e[i]
			})));
		return l.target = e, a || (l.smooth = ri.getProperty(e, "scrollBehavior") === "smooth"), l
	},
	hv = function (e, t, i) {
		var r = e,
			s = e,
			o = xh(),
			a = o,
			l = t || 50,
			c = Math.max(500, l * 3),
			u = function (p, _) {
				var g = xh();
				_ || g - o > l ? (s = r, r = p, a = o, o = g) : i ? r += p : r = s + (p - s) / (g - a) * (o - a)
			},
			h = function () {
				s = r = i ? 0 : r, a = o = 0
			},
			d = function (p) {
				var _ = a,
					g = s,
					m = xh();
				return (p || p === 0) && p !== r && u(p), o === a || m - a > c ? 0 : (r + (i ? g : -g)) / ((i ? m : o) - _) * 1e3
			};
		return {
			update: u,
			reset: h,
			getVelocity: d
		}
	},
	Nu = function (e, t) {
		return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
	},
	ww = function (e) {
		var t = Math.max.apply(Math, e),
			i = Math.min.apply(Math, e);
		return Math.abs(t) >= Math.abs(i) ? t : i
	},
	pA = function () {
		yh = ri.core.globals().ScrollTrigger, yh && yh.core && I9()
	},
	mA = function (e) {
		return ri = e || dA(), !dp && ri && typeof document < "u" && document.body && (gr = window, Zo = document, Jo = Zo.documentElement, Fc = Zo.body, uA = [gr, Zo, Jo, Fc], ri.utils.clamp, hA = ri.core.context || function () {}, qa = "onpointerenter" in Fc ? "pointer" : "mouse", cA = wn.isTouch = gr.matchMedia && gr.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in gr || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Jr = wn.eventTypes = ("ontouchstart" in Jo ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Jo ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () {
			return fA = 0
		}, 500), pA(), dp = 1), dp
	};
Pi.op = On;
yt.cache = 0;
var wn = function () {
	function n(t) {
		this.init(t)
	}
	var e = n.prototype;
	return e.init = function (i) {
		dp || mA(ri) || console.warn("Please gsap.registerPlugin(Observer)"), yh || pA();
		var r = i.tolerance,
			s = i.dragMinimum,
			o = i.type,
			a = i.target,
			l = i.lineHeight,
			c = i.debounce,
			u = i.preventDefault,
			h = i.onStop,
			d = i.onStopDelay,
			f = i.ignore,
			p = i.wheelSpeed,
			_ = i.event,
			g = i.onDragStart,
			m = i.onDragEnd,
			b = i.onDrag,
			v = i.onPress,
			y = i.onRelease,
			x = i.onRight,
			S = i.onLeft,
			E = i.onUp,
			C = i.onDown,
			P = i.onChangeX,
			w = i.onChangeY,
			D = i.onChange,
			U = i.onToggleX,
			j = i.onToggleY,
			z = i.onHover,
			H = i.onHoverEnd,
			F = i.onMove,
			G = i.ignoreCheck,
			R = i.isNormalizer,
			Q = i.onGestureStart,
			B = i.onGestureEnd,
			ge = i.onWheel,
			Ae = i.onEnable,
			ze = i.onDisable,
			K = i.onClick,
			ye = i.scrollSpeed,
			Se = i.capture,
			Z = i.allowClicks,
			pe = i.lockAxis,
			ce = i.onLockAxis;
		this.target = a = Bi(a) || Jo, this.vars = i, f && (f = ri.utils.toArray(f)), r = r || 1e-9, s = s || 0, p = p || 1, ye = ye || 1, o = o || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(gr.getComputedStyle(Fc).lineHeight) || 22);
		var Ce, Re, Y, k, O, q, ie, N = this,
			me = 0,
			ve = 0,
			xe = i.passive || !u,
			A = ba(a, Pi),
			T = ba(a, On),
			$ = A(),
			re = T(),
			se = ~o.indexOf("touch") && !~o.indexOf("pointer") && Jr[0] === "pointerdown",
			ue = wh(a),
			Me = a.ownerDocument || Zo,
			Le = [0, 0, 0],
			we = [0, 0, 0],
			Te = 0,
			je = function () {
				return Te = xh()
			},
			M = function (Ve, $e) {
				return (N.event = Ve) && f && ~f.indexOf(Ve.target) || $e && se && Ve.pointerType !== "touch" || G && G(Ve, $e)
			},
			W = function () {
				N._vx.reset(), N._vy.reset(), Re.pause(), h && h(N)
			},
			le = function () {
				var Ve = N.deltaX = ww(Le),
					$e = N.deltaY = ww(we),
					Pe = Math.abs(Ve) >= r,
					Ze = Math.abs($e) >= r;
				D && (Pe || Ze) && D(N, Ve, $e, Le, we), Pe && (x && N.deltaX > 0 && x(N), S && N.deltaX < 0 && S(N), P && P(N), U && N.deltaX < 0 != me < 0 && U(N), me = N.deltaX, Le[0] = Le[1] = Le[2] = 0), Ze && (C && N.deltaY > 0 && C(N), E && N.deltaY < 0 && E(N), w && w(N), j && N.deltaY < 0 != ve < 0 && j(N), ve = N.deltaY, we[0] = we[1] = we[2] = 0), (k || Y) && (F && F(N), Y && (b(N), Y = !1), k = !1), q && !(q = !1) && ce && ce(N), O && (ge(N), O = !1), Ce = 0
			},
			J = function (Ve, $e, Pe) {
				Le[Pe] += Ve, we[Pe] += $e, N._vx.update(Ve), N._vy.update($e), c ? Ce || (Ce = requestAnimationFrame(le)) : le()
			},
			oe = function (Ve, $e) {
				pe && !ie && (N.axis = ie = Math.abs(Ve) > Math.abs($e) ? "x" : "y", q = !0), ie !== "y" && (Le[2] += Ve, N._vx.update(Ve, !0)), ie !== "x" && (we[2] += $e, N._vy.update($e, !0)), c ? Ce || (Ce = requestAnimationFrame(le)) : le()
			},
			_e = function (Ve) {
				if (!M(Ve, 1)) {
					Ve = Nu(Ve, u);
					var $e = Ve.clientX,
						Pe = Ve.clientY,
						Ze = $e - N.x,
						Je = Pe - N.y,
						ot = N.isDragging;
					N.x = $e, N.y = Pe, (ot || Math.abs(N.startX - $e) >= s || Math.abs(N.startY - Pe) >= s) && (b && (Y = !0), ot || (N.isDragging = !0), oe(Ze, Je), ot || g && g(N))
				}
			},
			I = N.onPress = function (He) {
				M(He, 1) || He && He.button || (N.axis = ie = null, Re.pause(), N.isPressed = !0, He = Nu(He), me = ve = 0, N.startX = N.x = He.clientX, N.startY = N.y = He.clientY, N._vx.reset(), N._vy.reset(), Ei(R ? a : Me, Jr[1], _e, xe, !0), N.deltaX = N.deltaY = 0, v && v(N))
			},
			ee = N.onRelease = function (He) {
				if (!M(He, 1)) {
					yi(R ? a : Me, Jr[1], _e, !0);
					var Ve = !isNaN(N.y - N.startY),
						$e = N.isDragging,
						Pe = $e && (Math.abs(N.x - N.startX) > 3 || Math.abs(N.y - N.startY) > 3),
						Ze = Nu(He);
					!Pe && Ve && (N._vx.reset(), N._vy.reset(), u && Z && ri.delayedCall(.08, function () {
						if (xh() - Te > 300 && !He.defaultPrevented) {
							if (He.target.click) He.target.click();
							else if (Me.createEvent) {
								var Je = Me.createEvent("MouseEvents");
								Je.initMouseEvent("click", !0, !0, gr, 1, Ze.screenX, Ze.screenY, Ze.clientX, Ze.clientY, !1, !1, !1, !1, 0, null), He.target.dispatchEvent(Je)
							}
						}
					})), N.isDragging = N.isGesturing = N.isPressed = !1, h && $e && !R && Re.restart(!0), m && $e && m(N), y && y(N, Pe)
				}
			},
			De = function (Ve) {
				return Ve.touches && Ve.touches.length > 1 && (N.isGesturing = !0) && Q(Ve, N.isDragging)
			},
			V = function () {
				return (N.isGesturing = !1) || B(N)
			},
			be = function (Ve) {
				if (!M(Ve)) {
					var $e = A(),
						Pe = T();
					J(($e - $) * ye, (Pe - re) * ye, 1), $ = $e, re = Pe, h && Re.restart(!0)
				}
			},
			te = function (Ve) {
				if (!M(Ve)) {
					Ve = Nu(Ve, u), ge && (O = !0);
					var $e = (Ve.deltaMode === 1 ? l : Ve.deltaMode === 2 ? gr.innerHeight : 1) * p;
					J(Ve.deltaX * $e, Ve.deltaY * $e, 0), h && !R && Re.restart(!0)
				}
			},
			Ee = function (Ve) {
				if (!M(Ve)) {
					var $e = Ve.clientX,
						Pe = Ve.clientY,
						Ze = $e - N.x,
						Je = Pe - N.y;
					N.x = $e, N.y = Pe, k = !0, h && Re.restart(!0), (Ze || Je) && oe(Ze, Je)
				}
			},
			Ie = function (Ve) {
				N.event = Ve, z(N)
			},
			st = function (Ve) {
				N.event = Ve, H(N)
			},
			Et = function (Ve) {
				return M(Ve) || Nu(Ve, u) && K(N)
			};
		Re = N._dc = ri.delayedCall(d || .25, W).pause(), N.deltaX = N.deltaY = 0, N._vx = hv(0, 50, !0), N._vy = hv(0, 50, !0), N.scrollX = A, N.scrollY = T, N.isDragging = N.isGesturing = N.isPressed = !1, hA(this), N.enable = function (He) {
			return N.isEnabled || (Ei(ue ? Me : a, "scroll", uv), o.indexOf("scroll") >= 0 && Ei(ue ? Me : a, "scroll", be, xe, Se), o.indexOf("wheel") >= 0 && Ei(a, "wheel", te, xe, Se), (o.indexOf("touch") >= 0 && cA || o.indexOf("pointer") >= 0) && (Ei(a, Jr[0], I, xe, Se), Ei(Me, Jr[2], ee), Ei(Me, Jr[3], ee), Z && Ei(a, "click", je, !0, !0), K && Ei(a, "click", Et), Q && Ei(Me, "gesturestart", De), B && Ei(Me, "gestureend", V), z && Ei(a, qa + "enter", Ie), H && Ei(a, qa + "leave", st), F && Ei(a, qa + "move", Ee)), N.isEnabled = !0, He && He.type && I(He), Ae && Ae(N)), N
		}, N.disable = function () {
			N.isEnabled && (xc.filter(function (He) {
				return He !== N && wh(He.target)
			}).length || yi(ue ? Me : a, "scroll", uv), N.isPressed && (N._vx.reset(), N._vy.reset(), yi(R ? a : Me, Jr[1], _e, !0)), yi(ue ? Me : a, "scroll", be, Se), yi(a, "wheel", te, Se), yi(a, Jr[0], I, Se), yi(Me, Jr[2], ee), yi(Me, Jr[3], ee), yi(a, "click", je, !0), yi(a, "click", Et), yi(Me, "gesturestart", De), yi(Me, "gestureend", V), yi(a, qa + "enter", Ie), yi(a, qa + "leave", st), yi(a, qa + "move", Ee), N.isEnabled = N.isPressed = N.isDragging = !1, ze && ze(N))
		}, N.kill = N.revert = function () {
			N.disable();
			var He = xc.indexOf(N);
			He >= 0 && xc.splice(He, 1), Js === N && (Js = 0)
		}, xc.push(N), R && wh(a) && (Js = N), N.enable(_)
	}, k9(n, [{
		key: "velocityX",
		get: function () {
			return this._vx.getVelocity()
		}
	}, {
		key: "velocityY",
		get: function () {
			return this._vy.getVelocity()
		}
	}]), n
}();
wn.version = "3.12.5";
wn.create = function (n) {
	return new wn(n)
};
wn.register = mA;
wn.getAll = function () {
	return xc.slice()
};
wn.getById = function (n) {
	return xc.filter(function (e) {
		return e.vars.id === n
	})[0]
};
dA() && ri.registerPlugin(wn);
/*!
 * ScrollTrigger 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var We, dc, St, dn, es, en, gA, Yp, rd, Eh, Ju, cf, ci, Ym, dv, Mi, Ew, Sw, fc, _A, J0, vA, Ti, fv, bA, yA, Fo, pv, fb, Nc, pb, Kp, mv, Q0, uf = 1,
	ui = Date.now,
	eg = ui(),
	jr = 0,
	Qu = 0,
	Tw = function (e, t, i) {
		var r = dr(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
		return i["_" + t + "Clamp"] = r, r ? e.substr(6, e.length - 7) : e
	},
	Mw = function (e, t) {
		return t && (!dr(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
	},
	O9 = function n() {
		return Qu && requestAnimationFrame(n)
	},
	Cw = function () {
		return Ym = 1
	},
	Aw = function () {
		return Ym = 0
	},
	ds = function (e) {
		return e
	},
	eh = function (e) {
		return Math.round(e * 1e5) / 1e5 || 0
	},
	xA = function () {
		return typeof window < "u"
	},
	wA = function () {
		return We || xA() && (We = window.gsap) && We.registerPlugin && We
	},
	Ml = function (e) {
		return !!~gA.indexOf(e)
	},
	EA = function (e) {
		return (e === "Height" ? pb : St["inner" + e]) || es["client" + e] || en["client" + e]
	},
	SA = function (e) {
		return aa(e, "getBoundingClientRect") || (Ml(e) ? function () {
			return _p.width = St.innerWidth, _p.height = pb, _p
		} : function () {
			return Ys(e)
		})
	},
	F9 = function (e, t, i) {
		var r = i.d,
			s = i.d2,
			o = i.a;
		return (o = aa(e, "getBoundingClientRect")) ? function () {
			return o()[r]
		} : function () {
			return (t ? EA(s) : e["client" + s]) || 0
		}
	},
	N9 = function (e, t) {
		return !t || ~Ms.indexOf(e) ? SA(e) : function () {
			return _p
		}
	},
	ws = function (e, t) {
		var i = t.s,
			r = t.d2,
			s = t.d,
			o = t.a;
		return Math.max(0, (i = "scroll" + r) && (o = aa(e, i)) ? o() - SA(e)()[s] : Ml(e) ? (es[i] || en[i]) - EA(r) : e[i] - e["offset" + r])
	},
	hf = function (e, t) {
		for (var i = 0; i < fc.length; i += 3)(!t || ~t.indexOf(fc[i + 1])) && e(fc[i], fc[i + 1], fc[i + 2])
	},
	dr = function (e) {
		return typeof e == "string"
	},
	Ri = function (e) {
		return typeof e == "function"
	},
	th = function (e) {
		return typeof e == "number"
	},
	Xa = function (e) {
		return typeof e == "object"
	},
	Uu = function (e, t, i) {
		return e && e.progress(t ? 0 : 1) && i && e.pause()
	},
	tg = function (e, t) {
		if (e.enabled) {
			var i = e._ctx ? e._ctx.add(function () {
				return t(e)
			}) : t(e);
			i && i.totalTime && (e.callbackAnimation = i)
		}
	},
	Gl = Math.abs,
	TA = "left",
	MA = "top",
	mb = "right",
	gb = "bottom",
	fl = "width",
	pl = "height",
	Sh = "Right",
	Th = "Left",
	Mh = "Top",
	Ch = "Bottom",
	Tn = "padding",
	Or = "margin",
	ru = "Width",
	_b = "Height",
	kn = "px",
	Fr = function (e) {
		return St.getComputedStyle(e)
	},
	U9 = function (e) {
		var t = Fr(e).position;
		e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
	},
	Dw = function (e, t) {
		for (var i in t) i in e || (e[i] = t[i]);
		return e
	},
	Ys = function (e, t) {
		var i = t && Fr(e)[dv] !== "matrix(1, 0, 0, 1, 0, 0)" && We.to(e, {
				x: 0,
				y: 0,
				xPercent: 0,
				yPercent: 0,
				rotation: 0,
				rotationX: 0,
				rotationY: 0,
				scale: 1,
				skewX: 0,
				skewY: 0
			}).progress(1),
			r = e.getBoundingClientRect();
		return i && i.progress(0).kill(), r
	},
	Zp = function (e, t) {
		var i = t.d2;
		return e["offset" + i] || e["client" + i] || 0
	},
	CA = function (e) {
		var t = [],
			i = e.labels,
			r = e.duration(),
			s;
		for (s in i) t.push(i[s] / r);
		return t
	},
	B9 = function (e) {
		return function (t) {
			return We.utils.snap(CA(e), t)
		}
	},
	vb = function (e) {
		var t = We.utils.snap(e),
			i = Array.isArray(e) && e.slice(0).sort(function (r, s) {
				return r - s
			});
		return i ? function (r, s, o) {
			o === void 0 && (o = .001);
			var a;
			if (!s) return t(r);
			if (s > 0) {
				for (r -= o, a = 0; a < i.length; a++)
					if (i[a] >= r) return i[a];
				return i[a - 1]
			} else
				for (a = i.length, r += o; a--;)
					if (i[a] <= r) return i[a];
			return i[0]
		} : function (r, s, o) {
			o === void 0 && (o = .001);
			var a = t(r);
			return !s || Math.abs(a - r) < o || a - r < 0 == s < 0 ? a : t(s < 0 ? r - e : r + e)
		}
	},
	z9 = function (e) {
		return function (t, i) {
			return vb(CA(e))(t, i.direction)
		}
	},
	df = function (e, t, i, r) {
		return i.split(",").forEach(function (s) {
			return e(t, s, r)
		})
	},
	Wn = function (e, t, i, r, s) {
		return e.addEventListener(t, i, {
			passive: !r,
			capture: !!s
		})
	},
	Gn = function (e, t, i, r) {
		return e.removeEventListener(t, i, !!r)
	},
	ff = function (e, t, i) {
		i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i))
	},
	Pw = {
		startColor: "green",
		endColor: "red",
		indent: 0,
		fontSize: "16px",
		fontWeight: "normal"
	},
	pf = {
		toggleActions: "play",
		anticipatePin: 0
	},
	Jp = {
		top: 0,
		left: 0,
		center: .5,
		bottom: 1,
		right: 1
	},
	fp = function (e, t) {
		if (dr(e)) {
			var i = e.indexOf("="),
				r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
			~i && (e.indexOf("%") > i && (r *= t / 100), e = e.substr(0, i - 1)), e = r + (e in Jp ? Jp[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
		}
		return e
	},
	mf = function (e, t, i, r, s, o, a, l) {
		var c = s.startColor,
			u = s.endColor,
			h = s.fontSize,
			d = s.indent,
			f = s.fontWeight,
			p = dn.createElement("div"),
			_ = Ml(i) || aa(i, "pinType") === "fixed",
			g = e.indexOf("scroller") !== -1,
			m = _ ? en : i,
			b = e.indexOf("start") !== -1,
			v = b ? c : u,
			y = "border-color:" + v + ";font-size:" + h + ";color:" + v + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
		return y += "position:" + ((g || l) && _ ? "fixed;" : "absolute;"), (g || l || !_) && (y += (r === On ? mb : gb) + ":" + (o + parseFloat(d)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = b, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = y, p.innerText = t || t === 0 ? e + "-" + t : e, m.children[0] ? m.insertBefore(p, m.children[0]) : m.appendChild(p), p._offset = p["offset" + r.op.d2], pp(p, 0, r, b), p
	},
	pp = function (e, t, i, r) {
		var s = {
				display: "block"
			},
			o = i[r ? "os2" : "p2"],
			a = i[r ? "p2" : "os2"];
		e._isFlipped = r, s[i.a + "Percent"] = r ? -100 : 0, s[i.a] = r ? "1px" : 0, s["border" + o + ru] = 1, s["border" + a + ru] = 0, s[i.p] = t + "px", We.set(e, s)
	},
	bt = [],
	gv = {},
	sd, Rw = function () {
		return ui() - jr > 34 && (sd || (sd = requestAnimationFrame(ro)))
	},
	Wl = function () {
		(!Ti || !Ti.isPressed || Ti.startX > en.clientWidth) && (yt.cache++, Ti ? sd || (sd = requestAnimationFrame(ro)) : ro(), jr || Al("scrollStart"), jr = ui())
	},
	ng = function () {
		yA = St.innerWidth, bA = St.innerHeight
	},
	nh = function () {
		yt.cache++, !ci && !vA && !dn.fullscreenElement && !dn.webkitFullscreenElement && (!fv || yA !== St.innerWidth || Math.abs(St.innerHeight - bA) > St.innerHeight * .25) && Yp.restart(!0)
	},
	Cl = {},
	V9 = [],
	AA = function n() {
		return Gn(at, "scrollEnd", n) || tl(!0)
	},
	Al = function (e) {
		return Cl[e] && Cl[e].map(function (t) {
			return t()
		}) || V9
	},
	hr = [],
	DA = function (e) {
		for (var t = 0; t < hr.length; t += 5)(!e || hr[t + 4] && hr[t + 4].query === e) && (hr[t].style.cssText = hr[t + 1], hr[t].getBBox && hr[t].setAttribute("transform", hr[t + 2] || ""), hr[t + 3].uncache = 1)
	},
	bb = function (e, t) {
		var i;
		for (Mi = 0; Mi < bt.length; Mi++) i = bt[Mi], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
		Kp = !0, t && DA(t), t || Al("revert")
	},
	PA = function (e, t) {
		yt.cache++, (t || !Ci) && yt.forEach(function (i) {
			return Ri(i) && i.cacheID++ && (i.rec = 0)
		}), dr(e) && (St.history.scrollRestoration = fb = e)
	},
	Ci, ml = 0,
	Lw, H9 = function () {
		if (Lw !== ml) {
			var e = Lw = ml;
			requestAnimationFrame(function () {
				return e === ml && tl(!0)
			})
		}
	},
	RA = function () {
		en.appendChild(Nc), pb = !Ti && Nc.offsetHeight || St.innerHeight, en.removeChild(Nc)
	},
	kw = function (e) {
		return rd(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (t) {
			return t.style.display = e ? "none" : "block"
		})
	},
	tl = function (e, t) {
		if (jr && !e && !Kp) {
			Wn(at, "scrollEnd", AA);
			return
		}
		RA(), Ci = at.isRefreshing = !0, yt.forEach(function (r) {
			return Ri(r) && ++r.cacheID && (r.rec = r())
		});
		var i = Al("refreshInit");
		_A && at.sort(), t || bb(), yt.forEach(function (r) {
			Ri(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"), r(0))
		}), bt.slice(0).forEach(function (r) {
			return r.refresh()
		}), Kp = !1, bt.forEach(function (r) {
			if (r._subPinOffset && r.pin) {
				var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight",
					o = r.pin[s];
				r.revert(!0, 1), r.adjustPinSpacing(r.pin[s] - o), r.refresh()
			}
		}), mv = 1, kw(!0), bt.forEach(function (r) {
			var s = ws(r.scroller, r._dir),
				o = r.vars.end === "max" || r._endClamp && r.end > s,
				a = r._startClamp && r.start >= s;
			(o || a) && r.setPositions(a ? s - 1 : r.start, o ? Math.max(a ? s : r.start + 1, s) : r.end, !0)
		}), kw(!1), mv = 0, i.forEach(function (r) {
			return r && r.render && r.render(-1)
		}), yt.forEach(function (r) {
			Ri(r) && (r.smooth && requestAnimationFrame(function () {
				return r.target.style.scrollBehavior = "smooth"
			}), r.rec && r(r.rec))
		}), PA(fb, 1), Yp.pause(), ml++, Ci = 2, ro(2), bt.forEach(function (r) {
			return Ri(r.vars.onRefresh) && r.vars.onRefresh(r)
		}), Ci = at.isRefreshing = !1, Al("refresh")
	},
	_v = 0,
	mp = 1,
	Ah, ro = function (e) {
		if (e === 2 || !Ci && !Kp) {
			at.isUpdating = !0, Ah && Ah.update(0);
			var t = bt.length,
				i = ui(),
				r = i - eg >= 50,
				s = t && bt[0].scroll();
			if (mp = _v > s ? -1 : 1, Ci || (_v = s), r && (jr && !Ym && i - jr > 200 && (jr = 0, Al("scrollEnd")), Ju = eg, eg = i), mp < 0) {
				for (Mi = t; Mi-- > 0;) bt[Mi] && bt[Mi].update(0, r);
				mp = 1
			} else
				for (Mi = 0; Mi < t; Mi++) bt[Mi] && bt[Mi].update(0, r);
			at.isUpdating = !1
		}
		sd = 0
	},
	vv = [TA, MA, gb, mb, Or + Ch, Or + Sh, Or + Mh, Or + Th, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
	gp = vv.concat([fl, pl, "boxSizing", "max" + ru, "max" + _b, "position", Or, Tn, Tn + Mh, Tn + Sh, Tn + Ch, Tn + Th]),
	G9 = function (e, t, i) {
		Uc(i);
		var r = e._gsap;
		if (r.spacerIsNative) Uc(r.spacerState);
		else if (e._gsap.swappedIn) {
			var s = t.parentNode;
			s && (s.insertBefore(e, t), s.removeChild(t))
		}
		e._gsap.swappedIn = !1
	},
	ig = function (e, t, i, r) {
		if (!e._gsap.swappedIn) {
			for (var s = vv.length, o = t.style, a = e.style, l; s--;) l = vv[s], o[l] = i[l];
			o.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (o.display = "inline-block"), a[gb] = a[mb] = "auto", o.flexBasis = i.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[fl] = Zp(e, Pi) + kn, o[pl] = Zp(e, On) + kn, o[Tn] = a[Or] = a[MA] = a[TA] = "0", Uc(r), a[fl] = a["max" + ru] = i[fl], a[pl] = a["max" + _b] = i[pl], a[Tn] = i[Tn], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
		}
	},
	W9 = /([A-Z])/g,
	Uc = function (e) {
		if (e) {
			var t = e.t.style,
				i = e.length,
				r = 0,
				s, o;
			for ((e.t._gsap || We.core.getCache(e.t)).uncache = 1; r < i; r += 2) o = e[r + 1], s = e[r], o ? t[s] = o : t[s] && t.removeProperty(s.replace(W9, "-$1").toLowerCase())
		}
	},
	gf = function (e) {
		for (var t = gp.length, i = e.style, r = [], s = 0; s < t; s++) r.push(gp[s], i[gp[s]]);
		return r.t = e, r
	},
	j9 = function (e, t, i) {
		for (var r = [], s = e.length, o = i ? 8 : 0, a; o < s; o += 2) a = e[o], r.push(a, a in t ? t[a] : e[o + 1]);
		return r.t = e.t, r
	},
	_p = {
		left: 0,
		top: 0
	},
	Iw = function (e, t, i, r, s, o, a, l, c, u, h, d, f, p) {
		Ri(e) && (e = e(l)), dr(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? fp("0" + e.substr(3), i) : 0));
		var _ = f ? f.time() : 0,
			g, m, b;
		if (f && f.seek(0), isNaN(e) || (e = +e), th(e)) f && (e = We.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, e)), a && pp(a, i, r, !0);
		else {
			Ri(t) && (t = t(l));
			var v = (e || "0").split(" "),
				y, x, S, E;
			b = Bi(t, l) || en, y = Ys(b) || {}, (!y || !y.left && !y.top) && Fr(b).display === "none" && (E = b.style.display, b.style.display = "block", y = Ys(b), E ? b.style.display = E : b.style.removeProperty("display")), x = fp(v[0], y[r.d]), S = fp(v[1] || "0", i), e = y[r.p] - c[r.p] - u + x + s - S, a && pp(a, S, r, i - S < 20 || a._isStart && S > 20), i -= i - S
		}
		if (p && (l[p] = e || -.001, e < 0 && (e = 0)), o) {
			var C = e + i,
				P = o._isStart;
			g = "scroll" + r.d2, pp(o, C, r, P && C > 20 || !P && (h ? Math.max(en[g], es[g]) : o.parentNode[g]) <= C + 1), h && (c = Ys(a), h && (o.style[r.op.p] = c[r.op.p] - r.op.m - o._offset + kn))
		}
		return f && b && (g = Ys(b), f.seek(d), m = Ys(b), f._caScrollDist = g[r.p] - m[r.p], e = e / f._caScrollDist * d), f && f.seek(_), f ? e : Math.round(e)
	},
	$9 = /(webkit|moz|length|cssText|inset)/i,
	Ow = function (e, t, i, r) {
		if (e.parentNode !== t) {
			var s = e.style,
				o, a;
			if (t === en) {
				e._stOrig = s.cssText, a = Fr(e);
				for (o in a) !+o && !$9.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
				s.top = i, s.left = r
			} else s.cssText = e._stOrig;
			We.core.getCache(e).uncache = 1, t.appendChild(e)
		}
	},
	LA = function (e, t, i) {
		var r = t,
			s = r;
		return function (o) {
			var a = Math.round(e());
			return a !== r && a !== s && Math.abs(a - r) > 3 && Math.abs(a - s) > 3 && (o = a, i && i()), s = r, r = o, o
		}
	},
	_f = function (e, t, i) {
		var r = {};
		r[t.p] = "+=" + i, We.set(e, r)
	},
	Fw = function (e, t) {
		var i = ba(e, t),
			r = "_scroll" + t.p2,
			s = function o(a, l, c, u, h) {
				var d = o.tween,
					f = l.onComplete,
					p = {};
				c = c || i();
				var _ = LA(i, c, function () {
					d.kill(), o.tween = 0
				});
				return h = u && h || 0, u = u || a - c, d && d.kill(), l[r] = a, l.inherit = !1, l.modifiers = p, p[r] = function () {
					return _(c + u * d.ratio + h * d.ratio * d.ratio)
				}, l.onUpdate = function () {
					yt.cache++, o.tween && ro()
				}, l.onComplete = function () {
					o.tween = 0, f && f.call(d)
				}, d = o.tween = We.to(e, l), d
			};
		return e[r] = i, i.wheelHandler = function () {
			return s.tween && s.tween.kill() && (s.tween = 0)
		}, Wn(e, "wheel", i.wheelHandler), at.isTouch && Wn(e, "touchmove", i.wheelHandler), s
	},
	at = function () {
		function n(t, i) {
			dc || n.register(We) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), pv(this), this.init(t, i)
		}
		var e = n.prototype;
		return e.init = function (i, r) {
			if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Qu) {
				this.update = this.refresh = this.kill = ds;
				return
			}
			i = Dw(dr(i) || th(i) || i.nodeType ? {
				trigger: i
			} : i, pf);
			var s = i,
				o = s.onUpdate,
				a = s.toggleClass,
				l = s.id,
				c = s.onToggle,
				u = s.onRefresh,
				h = s.scrub,
				d = s.trigger,
				f = s.pin,
				p = s.pinSpacing,
				_ = s.invalidateOnRefresh,
				g = s.anticipatePin,
				m = s.onScrubComplete,
				b = s.onSnapComplete,
				v = s.once,
				y = s.snap,
				x = s.pinReparent,
				S = s.pinSpacer,
				E = s.containerAnimation,
				C = s.fastScrollEnd,
				P = s.preventOverlaps,
				w = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? Pi : On,
				D = !h && h !== 0,
				U = Bi(i.scroller || St),
				j = We.core.getCache(U),
				z = Ml(U),
				H = ("pinType" in i ? i.pinType : aa(U, "pinType") || z && "fixed") === "fixed",
				F = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
				G = D && i.toggleActions.split(" "),
				R = "markers" in i ? i.markers : pf.markers,
				Q = z ? 0 : parseFloat(Fr(U)["border" + w.p2 + ru]) || 0,
				B = this,
				ge = i.onRefreshInit && function () {
					return i.onRefreshInit(B)
				},
				Ae = F9(U, z, w),
				ze = N9(U, z),
				K = 0,
				ye = 0,
				Se = 0,
				Z = ba(U, w),
				pe, ce, Ce, Re, Y, k, O, q, ie, N, me, ve, xe, A, T, $, re, se, ue, Me, Le, we, Te, je, M, W, le, J, oe, _e, I, ee, De, V, be, te, Ee, Ie, st;
			if (B._startClamp = B._endClamp = !1, B._dir = w, g *= 45, B.scroller = U, B.scroll = E ? E.time.bind(E) : Z, Re = Z(), B.vars = i, r = r || i.animation, "refreshPriority" in i && (_A = 1, i.refreshPriority === -9999 && (Ah = B)), j.tweenScroll = j.tweenScroll || {
					top: Fw(U, On),
					left: Fw(U, Pi)
				}, B.tweenTo = pe = j.tweenScroll[w.p], B.scrubDuration = function (Pe) {
					De = th(Pe) && Pe, De ? ee ? ee.duration(Pe) : ee = We.to(r, {
						ease: "expo",
						totalProgress: "+=0",
						inherit: !1,
						duration: De,
						paused: !0,
						onComplete: function () {
							return m && m(B)
						}
					}) : (ee && ee.progress(1).kill(), ee = 0)
				}, r && (r.vars.lazy = !1, r._initted && !B.isReverted || r.vars.immediateRender !== !1 && i.immediateRender !== !1 && r.duration() && r.render(0, !0, !0), B.animation = r.pause(), r.scrollTrigger = B, B.scrubDuration(h), _e = 0, l || (l = r.vars.id)), y && ((!Xa(y) || y.push) && (y = {
					snapTo: y
				}), "scrollBehavior" in en.style && We.set(z ? [en, es] : U, {
					scrollBehavior: "auto"
				}), yt.forEach(function (Pe) {
					return Ri(Pe) && Pe.target === (z ? dn.scrollingElement || es : U) && (Pe.smooth = !1)
				}), Ce = Ri(y.snapTo) ? y.snapTo : y.snapTo === "labels" ? B9(r) : y.snapTo === "labelsDirectional" ? z9(r) : y.directional !== !1 ? function (Pe, Ze) {
					return vb(y.snapTo)(Pe, ui() - ye < 500 ? 0 : Ze.direction)
				} : We.utils.snap(y.snapTo), V = y.duration || {
					min: .1,
					max: 2
				}, V = Xa(V) ? Eh(V.min, V.max) : Eh(V, V), be = We.delayedCall(y.delay || De / 2 || .1, function () {
					var Pe = Z(),
						Ze = ui() - ye < 500,
						Je = pe.tween;
					if ((Ze || Math.abs(B.getVelocity()) < 10) && !Je && !Ym && K !== Pe) {
						var ot = (Pe - k) / A,
							hn = r && !D ? r.totalProgress() : ot,
							vt = Ze ? 0 : (hn - I) / (ui() - Ju) * 1e3 || 0,
							qt = We.utils.clamp(-ot, 1 - ot, Gl(vt / 2) * vt / .185),
							Rn = ot + (y.inertia === !1 ? 0 : qt),
							Jt, Xt, Ft = y,
							tr = Ft.onStart,
							L = Ft.onInterrupt,
							ne = Ft.onComplete;
						if (Jt = Ce(Rn, B), th(Jt) || (Jt = Rn), Xt = Math.round(k + Jt * A), Pe <= O && Pe >= k && Xt !== Pe) {
							if (Je && !Je._initted && Je.data <= Gl(Xt - Pe)) return;
							y.inertia === !1 && (qt = Jt - ot), pe(Xt, {
								duration: V(Gl(Math.max(Gl(Rn - hn), Gl(Jt - hn)) * .185 / vt / .05 || 0)),
								ease: y.ease || "power3",
								data: Gl(Xt - Pe),
								onInterrupt: function () {
									return be.restart(!0) && L && L(B)
								},
								onComplete: function () {
									B.update(), K = Z(), r && (ee ? ee.resetTo("totalProgress", Jt, r._tTime / r._tDur) : r.progress(Jt)), _e = I = r && !D ? r.totalProgress() : B.progress, b && b(B), ne && ne(B)
								}
							}, Pe, qt * A, Xt - Pe - qt * A), tr && tr(B, pe.tween)
						}
					} else B.isActive && K !== Pe && be.restart(!0)
				}).pause()), l && (gv[l] = B), d = B.trigger = Bi(d || f !== !0 && f), st = d && d._gsap && d._gsap.stRevert, st && (st = st(B)), f = f === !0 ? d : Bi(f), dr(a) && (a = {
					targets: d,
					className: a
				}), f && (p === !1 || p === Or || (p = !p && f.parentNode && f.parentNode.style && Fr(f.parentNode).display === "flex" ? !1 : Tn), B.pin = f, ce = We.core.getCache(f), ce.spacer ? T = ce.pinState : (S && (S = Bi(S), S && !S.nodeType && (S = S.current || S.nativeElement), ce.spacerIsNative = !!S, S && (ce.spacerState = gf(S))), ce.spacer = se = S || dn.createElement("div"), se.classList.add("pin-spacer"), l && se.classList.add("pin-spacer-" + l), ce.pinState = T = gf(f)), i.force3D !== !1 && We.set(f, {
					force3D: !0
				}), B.spacer = se = ce.spacer, oe = Fr(f), je = oe[p + w.os2], Me = We.getProperty(f), Le = We.quickSetter(f, w.a, kn), ig(f, se, oe), re = gf(f)), R) {
				ve = Xa(R) ? Dw(R, Pw) : Pw, N = mf("scroller-start", l, U, w, ve, 0), me = mf("scroller-end", l, U, w, ve, 0, N), ue = N["offset" + w.op.d2];
				var Et = Bi(aa(U, "content") || U);
				q = this.markerStart = mf("start", l, Et, w, ve, ue, 0, E), ie = this.markerEnd = mf("end", l, Et, w, ve, ue, 0, E), E && (Ie = We.quickSetter([q, ie], w.a, kn)), !H && !(Ms.length && aa(U, "fixedMarkers") === !0) && (U9(z ? en : U), We.set([N, me], {
					force3D: !0
				}), W = We.quickSetter(N, w.a, kn), J = We.quickSetter(me, w.a, kn))
			}
			if (E) {
				var He = E.vars.onUpdate,
					Ve = E.vars.onUpdateParams;
				E.eventCallback("onUpdate", function () {
					B.update(0, 0, 1), He && He.apply(E, Ve || [])
				})
			}
			if (B.previous = function () {
					return bt[bt.indexOf(B) - 1]
				}, B.next = function () {
					return bt[bt.indexOf(B) + 1]
				}, B.revert = function (Pe, Ze) {
					if (!Ze) return B.kill(!0);
					var Je = Pe !== !1 || !B.enabled,
						ot = ci;
					Je !== B.isReverted && (Je && (te = Math.max(Z(), B.scroll.rec || 0), Se = B.progress, Ee = r && r.progress()), q && [q, ie, N, me].forEach(function (hn) {
						return hn.style.display = Je ? "none" : "block"
					}), Je && (ci = B, B.update(Je)), f && (!x || !B.isActive) && (Je ? G9(f, se, T) : ig(f, se, Fr(f), M)), Je || B.update(Je), ci = ot, B.isReverted = Je)
				}, B.refresh = function (Pe, Ze, Je, ot) {
					if (!((ci || !B.enabled) && !Ze)) {
						if (f && Pe && jr) {
							Wn(n, "scrollEnd", AA);
							return
						}!Ci && ge && ge(B), ci = B, pe.tween && !Je && (pe.tween.kill(), pe.tween = 0), ee && ee.pause(), _ && r && r.revert({
							kill: !1
						}).invalidate(), B.isReverted || B.revert(!0, !0), B._subPinOffset = !1;
						var hn = Ae(),
							vt = ze(),
							qt = E ? E.duration() : ws(U, w),
							Rn = A <= .01,
							Jt = 0,
							Xt = ot || 0,
							Ft = Xa(Je) ? Je.end : i.end,
							tr = i.endTrigger || d,
							L = Xa(Je) ? Je.start : i.start || (i.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"),
							ne = B.pinnedContainer = i.pinnedContainer && Bi(i.pinnedContainer, B),
							de = d && Math.max(0, bt.indexOf(B)) || 0,
							he = de,
							ae, Ne, qe, nt, Xe, Qe, it, dt, tn, Ln, Nt, vi, Ht;
						for (R && Xa(Je) && (vi = We.getProperty(N, w.p), Ht = We.getProperty(me, w.p)); he--;) Qe = bt[he], Qe.end || Qe.refresh(0, 1) || (ci = B), it = Qe.pin, it && (it === d || it === f || it === ne) && !Qe.isReverted && (Ln || (Ln = []), Ln.unshift(Qe), Qe.revert(!0, !0)), Qe !== bt[he] && (de--, he--);
						for (Ri(L) && (L = L(B)), L = Tw(L, "start", B), k = Iw(L, d, hn, w, Z(), q, N, B, vt, Q, H, qt, E, B._startClamp && "_startClamp") || (f ? -.001 : 0), Ri(Ft) && (Ft = Ft(B)), dr(Ft) && !Ft.indexOf("+=") && (~Ft.indexOf(" ") ? Ft = (dr(L) ? L.split(" ")[0] : "") + Ft : (Jt = fp(Ft.substr(2), hn), Ft = dr(L) ? L : (E ? We.utils.mapRange(0, E.duration(), E.scrollTrigger.start, E.scrollTrigger.end, k) : k) + Jt, tr = d)), Ft = Tw(Ft, "end", B), O = Math.max(k, Iw(Ft || (tr ? "100% 0" : qt), tr, hn, w, Z() + Jt, ie, me, B, vt, Q, H, qt, E, B._endClamp && "_endClamp")) || -.001, Jt = 0, he = de; he--;) Qe = bt[he], it = Qe.pin, it && Qe.start - Qe._pinPush <= k && !E && Qe.end > 0 && (ae = Qe.end - (B._startClamp ? Math.max(0, Qe.start) : Qe.start), (it === d && Qe.start - Qe._pinPush < k || it === ne) && isNaN(L) && (Jt += ae * (1 - Qe.progress)), it === f && (Xt += ae));
						if (k += Jt, O += Jt, B._startClamp && (B._startClamp += Jt), B._endClamp && !Ci && (B._endClamp = O || -.001, O = Math.min(O, ws(U, w))), A = O - k || (k -= .01) && .001, Rn && (Se = We.utils.clamp(0, 1, We.utils.normalize(k, O, te))), B._pinPush = Xt, q && Jt && (ae = {}, ae[w.a] = "+=" + Jt, ne && (ae[w.p] = "-=" + Z()), We.set([q, ie], ae)), f && !(mv && B.end >= ws(U, w))) ae = Fr(f), nt = w === On, qe = Z(), we = parseFloat(Me(w.a)) + Xt, !qt && O > 1 && (Nt = (z ? dn.scrollingElement || es : U).style, Nt = {
							style: Nt,
							value: Nt["overflow" + w.a.toUpperCase()]
						}, z && Fr(en)["overflow" + w.a.toUpperCase()] !== "scroll" && (Nt.style["overflow" + w.a.toUpperCase()] = "scroll")), ig(f, se, ae), re = gf(f), Ne = Ys(f, !0), dt = H && ba(U, nt ? Pi : On)(), p ? (M = [p + w.os2, A + Xt + kn], M.t = se, he = p === Tn ? Zp(f, w) + A + Xt : 0, he && (M.push(w.d, he + kn), se.style.flexBasis !== "auto" && (se.style.flexBasis = he + kn)), Uc(M), ne && bt.forEach(function (ct) {
							ct.pin === ne && ct.vars.pinSpacing !== !1 && (ct._subPinOffset = !0)
						}), H && Z(te)) : (he = Zp(f, w), he && se.style.flexBasis !== "auto" && (se.style.flexBasis = he + kn)), H && (Xe = {
							top: Ne.top + (nt ? qe - k : dt) + kn,
							left: Ne.left + (nt ? dt : qe - k) + kn,
							boxSizing: "border-box",
							position: "fixed"
						}, Xe[fl] = Xe["max" + ru] = Math.ceil(Ne.width) + kn, Xe[pl] = Xe["max" + _b] = Math.ceil(Ne.height) + kn, Xe[Or] = Xe[Or + Mh] = Xe[Or + Sh] = Xe[Or + Ch] = Xe[Or + Th] = "0", Xe[Tn] = ae[Tn], Xe[Tn + Mh] = ae[Tn + Mh], Xe[Tn + Sh] = ae[Tn + Sh], Xe[Tn + Ch] = ae[Tn + Ch], Xe[Tn + Th] = ae[Tn + Th], $ = j9(T, Xe, x), Ci && Z(0)), r ? (tn = r._initted, J0(1), r.render(r.duration(), !0, !0), Te = Me(w.a) - we + A + Xt, le = Math.abs(A - Te) > 1, H && le && $.splice($.length - 2, 2), r.render(0, !0, !0), tn || r.invalidate(!0), r.parent || r.totalTime(r.totalTime()), J0(0)) : Te = A, Nt && (Nt.value ? Nt.style["overflow" + w.a.toUpperCase()] = Nt.value : Nt.style.removeProperty("overflow-" + w.a));
						else if (d && Z() && !E)
							for (Ne = d.parentNode; Ne && Ne !== en;) Ne._pinOffset && (k -= Ne._pinOffset, O -= Ne._pinOffset), Ne = Ne.parentNode;
						Ln && Ln.forEach(function (ct) {
							return ct.revert(!1, !0)
						}), B.start = k, B.end = O, Re = Y = Ci ? te : Z(), !E && !Ci && (Re < te && Z(te), B.scroll.rec = 0), B.revert(!1, !0), ye = ui(), be && (K = -1, be.restart(!0)), ci = 0, r && D && (r._initted || Ee) && r.progress() !== Ee && r.progress(Ee || 0, !0).render(r.time(), !0, !0), (Rn || Se !== B.progress || E || _) && (r && !D && r.totalProgress(E && k < -.001 && !Se ? We.utils.normalize(k, O, 0) : Se, !0), B.progress = Rn || (Re - k) / A === Se ? 0 : Se), f && p && (se._pinOffset = Math.round(B.progress * Te)), ee && ee.invalidate(), isNaN(vi) || (vi -= We.getProperty(N, w.p), Ht -= We.getProperty(me, w.p), _f(N, w, vi), _f(q, w, vi - (ot || 0)), _f(me, w, Ht), _f(ie, w, Ht - (ot || 0))), Rn && !Ci && B.update(), u && !Ci && !xe && (xe = !0, u(B), xe = !1)
					}
				}, B.getVelocity = function () {
					return (Z() - Y) / (ui() - Ju) * 1e3 || 0
				}, B.endAnimation = function () {
					Uu(B.callbackAnimation), r && (ee ? ee.progress(1) : r.paused() ? D || Uu(r, B.direction < 0, 1) : Uu(r, r.reversed()))
				}, B.labelToScroll = function (Pe) {
					return r && r.labels && (k || B.refresh() || k) + r.labels[Pe] / r.duration() * A || 0
				}, B.getTrailing = function (Pe) {
					var Ze = bt.indexOf(B),
						Je = B.direction > 0 ? bt.slice(0, Ze).reverse() : bt.slice(Ze + 1);
					return (dr(Pe) ? Je.filter(function (ot) {
						return ot.vars.preventOverlaps === Pe
					}) : Je).filter(function (ot) {
						return B.direction > 0 ? ot.end <= k : ot.start >= O
					})
				}, B.update = function (Pe, Ze, Je) {
					if (!(E && !Je && !Pe)) {
						var ot = Ci === !0 ? te : B.scroll(),
							hn = Pe ? 0 : (ot - k) / A,
							vt = hn < 0 ? 0 : hn > 1 ? 1 : hn || 0,
							qt = B.progress,
							Rn, Jt, Xt, Ft, tr, L, ne, de;
						if (Ze && (Y = Re, Re = E ? Z() : ot, y && (I = _e, _e = r && !D ? r.totalProgress() : vt)), g && f && !ci && !uf && jr && (!vt && k < ot + (ot - Y) / (ui() - Ju) * g ? vt = 1e-4 : vt === 1 && O > ot + (ot - Y) / (ui() - Ju) * g && (vt = .9999)), vt !== qt && B.enabled) {
							if (Rn = B.isActive = !!vt && vt < 1, Jt = !!qt && qt < 1, L = Rn !== Jt, tr = L || !!vt != !!qt, B.direction = vt > qt ? 1 : -1, B.progress = vt, tr && !ci && (Xt = vt && !qt ? 0 : vt === 1 ? 1 : qt === 1 ? 2 : 3, D && (Ft = !L && G[Xt + 1] !== "none" && G[Xt + 1] || G[Xt], de = r && (Ft === "complete" || Ft === "reset" || Ft in r))), P && (L || de) && (de || h || !r) && (Ri(P) ? P(B) : B.getTrailing(P).forEach(function (qe) {
									return qe.endAnimation()
								})), D || (ee && !ci && !uf ? (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", vt, r._tTime / r._tDur) : (ee.vars.totalProgress = vt, ee.invalidate().restart())) : r && r.totalProgress(vt, !!(ci && (ye || Pe)))), f) {
								if (Pe && p && (se.style[p + w.os2] = je), !H) Le(eh(we + Te * vt));
								else if (tr) {
									if (ne = !Pe && vt > qt && O + 1 > ot && ot + 1 >= ws(U, w), x)
										if (!Pe && (Rn || ne)) {
											var he = Ys(f, !0),
												ae = ot - k;
											Ow(f, en, he.top + (w === On ? ae : 0) + kn, he.left + (w === On ? 0 : ae) + kn)
										} else Ow(f, se);
									Uc(Rn || ne ? $ : re), le && vt < 1 && Rn || Le(we + (vt === 1 && !ne ? Te : 0))
								}
							}
							y && !pe.tween && !ci && !uf && be.restart(!0), a && (L || v && vt && (vt < 1 || !Q0)) && rd(a.targets).forEach(function (qe) {
								return qe.classList[Rn || v ? "add" : "remove"](a.className)
							}), o && !D && !Pe && o(B), tr && !ci ? (D && (de && (Ft === "complete" ? r.pause().totalProgress(1) : Ft === "reset" ? r.restart(!0).pause() : Ft === "restart" ? r.restart(!0) : r[Ft]()), o && o(B)), (L || !Q0) && (c && L && tg(B, c), F[Xt] && tg(B, F[Xt]), v && (vt === 1 ? B.kill(!1, 1) : F[Xt] = 0), L || (Xt = vt === 1 ? 1 : 3, F[Xt] && tg(B, F[Xt]))), C && !Rn && Math.abs(B.getVelocity()) > (th(C) ? C : 2500) && (Uu(B.callbackAnimation), ee ? ee.progress(1) : Uu(r, Ft === "reverse" ? 1 : !vt, 1))) : D && o && !ci && o(B)
						}
						if (J) {
							var Ne = E ? ot / E.duration() * (E._caScrollDist || 0) : ot;
							W(Ne + (N._isFlipped ? 1 : 0)), J(Ne)
						}
						Ie && Ie(-ot / E.duration() * (E._caScrollDist || 0))
					}
				}, B.enable = function (Pe, Ze) {
					B.enabled || (B.enabled = !0, Wn(U, "resize", nh), z || Wn(U, "scroll", Wl), ge && Wn(n, "refreshInit", ge), Pe !== !1 && (B.progress = Se = 0, Re = Y = K = Z()), Ze !== !1 && B.refresh())
				}, B.getTween = function (Pe) {
					return Pe && pe ? pe.tween : ee
				}, B.setPositions = function (Pe, Ze, Je, ot) {
					if (E) {
						var hn = E.scrollTrigger,
							vt = E.duration(),
							qt = hn.end - hn.start;
						Pe = hn.start + qt * Pe / vt, Ze = hn.start + qt * Ze / vt
					}
					B.refresh(!1, !1, {
						start: Mw(Pe, Je && !!B._startClamp),
						end: Mw(Ze, Je && !!B._endClamp)
					}, ot), B.update()
				}, B.adjustPinSpacing = function (Pe) {
					if (M && Pe) {
						var Ze = M.indexOf(w.d) + 1;
						M[Ze] = parseFloat(M[Ze]) + Pe + kn, M[1] = parseFloat(M[1]) + Pe + kn, Uc(M)
					}
				}, B.disable = function (Pe, Ze) {
					if (B.enabled && (Pe !== !1 && B.revert(!0, !0), B.enabled = B.isActive = !1, Ze || ee && ee.pause(), te = 0, ce && (ce.uncache = 1), ge && Gn(n, "refreshInit", ge), be && (be.pause(), pe.tween && pe.tween.kill() && (pe.tween = 0)), !z)) {
						for (var Je = bt.length; Je--;)
							if (bt[Je].scroller === U && bt[Je] !== B) return;
						Gn(U, "resize", nh), z || Gn(U, "scroll", Wl)
					}
				}, B.kill = function (Pe, Ze) {
					B.disable(Pe, Ze), ee && !Ze && ee.kill(), l && delete gv[l];
					var Je = bt.indexOf(B);
					Je >= 0 && bt.splice(Je, 1), Je === Mi && mp > 0 && Mi--, Je = 0, bt.forEach(function (ot) {
						return ot.scroller === B.scroller && (Je = 1)
					}), Je || Ci || (B.scroll.rec = 0), r && (r.scrollTrigger = null, Pe && r.revert({
						kill: !1
					}), Ze || r.kill()), q && [q, ie, N, me].forEach(function (ot) {
						return ot.parentNode && ot.parentNode.removeChild(ot)
					}), Ah === B && (Ah = 0), f && (ce && (ce.uncache = 1), Je = 0, bt.forEach(function (ot) {
						return ot.pin === f && Je++
					}), Je || (ce.spacer = 0)), i.onKill && i.onKill(B)
				}, bt.push(B), B.enable(!1, !1), st && st(B), r && r.add && !A) {
				var $e = B.update;
				B.update = function () {
					B.update = $e, k || O || B.refresh()
				}, We.delayedCall(.01, B.update), A = .01, k = O = 0
			} else B.refresh();
			f && H9()
		}, n.register = function (i) {
			return dc || (We = i || wA(), xA() && window.document && n.enable(), dc = Qu), dc
		}, n.defaults = function (i) {
			if (i)
				for (var r in i) pf[r] = i[r];
			return pf
		}, n.disable = function (i, r) {
			Qu = 0, bt.forEach(function (o) {
				return o[r ? "kill" : "disable"](i)
			}), Gn(St, "wheel", Wl), Gn(dn, "scroll", Wl), clearInterval(cf), Gn(dn, "touchcancel", ds), Gn(en, "touchstart", ds), df(Gn, dn, "pointerdown,touchstart,mousedown", Cw), df(Gn, dn, "pointerup,touchend,mouseup", Aw), Yp.kill(), hf(Gn);
			for (var s = 0; s < yt.length; s += 3) ff(Gn, yt[s], yt[s + 1]), ff(Gn, yt[s], yt[s + 2])
		}, n.enable = function () {
			if (St = window, dn = document, es = dn.documentElement, en = dn.body, We && (rd = We.utils.toArray, Eh = We.utils.clamp, pv = We.core.context || ds, J0 = We.core.suppressOverwrites || ds, fb = St.history.scrollRestoration || "auto", _v = St.pageYOffset, We.core.globals("ScrollTrigger", n), en)) {
				Qu = 1, Nc = document.createElement("div"), Nc.style.height = "100vh", Nc.style.position = "absolute", RA(), O9(), wn.register(We), n.isTouch = wn.isTouch, Fo = wn.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), fv = wn.isTouch === 1, Wn(St, "wheel", Wl), gA = [St, dn, es, en], We.matchMedia ? (n.matchMedia = function (l) {
					var c = We.matchMedia(),
						u;
					for (u in l) c.add(u, l[u]);
					return c
				}, We.addEventListener("matchMediaInit", function () {
					return bb()
				}), We.addEventListener("matchMediaRevert", function () {
					return DA()
				}), We.addEventListener("matchMedia", function () {
					tl(0, 1), Al("matchMedia")
				}), We.matchMedia("(orientation: portrait)", function () {
					return ng(), ng
				})) : console.warn("Requires GSAP 3.11.0 or later"), ng(), Wn(dn, "scroll", Wl);
				var i = en.style,
					r = i.borderTopStyle,
					s = We.core.Animation.prototype,
					o, a;
				for (s.revert || Object.defineProperty(s, "revert", {
						value: function () {
							return this.time(-.01, !0)
						}
					}), i.borderTopStyle = "solid", o = Ys(en), On.m = Math.round(o.top + On.sc()) || 0, Pi.m = Math.round(o.left + Pi.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), cf = setInterval(Rw, 250), We.delayedCall(.5, function () {
						return uf = 0
					}), Wn(dn, "touchcancel", ds), Wn(en, "touchstart", ds), df(Wn, dn, "pointerdown,touchstart,mousedown", Cw), df(Wn, dn, "pointerup,touchend,mouseup", Aw), dv = We.utils.checkPrefix("transform"), gp.push(dv), dc = ui(), Yp = We.delayedCall(.2, tl).pause(), fc = [dn, "visibilitychange", function () {
						var l = St.innerWidth,
							c = St.innerHeight;
						dn.hidden ? (Ew = l, Sw = c) : (Ew !== l || Sw !== c) && nh()
					}, dn, "DOMContentLoaded", tl, St, "load", tl, St, "resize", nh], hf(Wn), bt.forEach(function (l) {
						return l.enable(0, 1)
					}), a = 0; a < yt.length; a += 3) ff(Gn, yt[a], yt[a + 1]), ff(Gn, yt[a], yt[a + 2])
			}
		}, n.config = function (i) {
			"limitCallbacks" in i && (Q0 = !!i.limitCallbacks);
			var r = i.syncInterval;
			r && clearInterval(cf) || (cf = r) && setInterval(Rw, r), "ignoreMobileResize" in i && (fv = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && (hf(Gn) || hf(Wn, i.autoRefreshEvents || "none"), vA = (i.autoRefreshEvents + "").indexOf("resize") === -1)
		}, n.scrollerProxy = function (i, r) {
			var s = Bi(i),
				o = yt.indexOf(s),
				a = Ml(s);
			~o && yt.splice(o, a ? 6 : 2), r && (a ? Ms.unshift(St, r, en, r, es, r) : Ms.unshift(s, r))
		}, n.clearMatchMedia = function (i) {
			bt.forEach(function (r) {
				return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0)
			})
		}, n.isInViewport = function (i, r, s) {
			var o = (dr(i) ? Bi(i) : i).getBoundingClientRect(),
				a = o[s ? fl : pl] * r || 0;
			return s ? o.right - a > 0 && o.left + a < St.innerWidth : o.bottom - a > 0 && o.top + a < St.innerHeight
		}, n.positionInViewport = function (i, r, s) {
			dr(i) && (i = Bi(i));
			var o = i.getBoundingClientRect(),
				a = o[s ? fl : pl],
				l = r == null ? a / 2 : r in Jp ? Jp[r] * a : ~r.indexOf("%") ? parseFloat(r) * a / 100 : parseFloat(r) || 0;
			return s ? (o.left + l) / St.innerWidth : (o.top + l) / St.innerHeight
		}, n.killAll = function (i) {
			if (bt.slice(0).forEach(function (s) {
					return s.vars.id !== "ScrollSmoother" && s.kill()
				}), i !== !0) {
				var r = Cl.killAll || [];
				Cl = {}, r.forEach(function (s) {
					return s()
				})
			}
		}, n
	}();
at.version = "3.12.5";
at.saveStyles = function (n) {
	return n ? rd(n).forEach(function (e) {
		if (e && e.style) {
			var t = hr.indexOf(e);
			t >= 0 && hr.splice(t, 5), hr.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), We.core.getCache(e), pv())
		}
	}) : hr
};
at.revert = function (n, e) {
	return bb(!n, e)
};
at.create = function (n, e) {
	return new at(n, e)
};
at.refresh = function (n) {
	return n ? nh() : (dc || at.register()) && tl(!0)
};
at.update = function (n) {
	return ++yt.cache && ro(n === !0 ? 2 : 0)
};
at.clearScrollMemory = PA;
at.maxScroll = function (n, e) {
	return ws(n, e ? Pi : On)
};
at.getScrollFunc = function (n, e) {
	return ba(Bi(n), e ? Pi : On)
};
at.getById = function (n) {
	return gv[n]
};
at.getAll = function () {
	return bt.filter(function (n) {
		return n.vars.id !== "ScrollSmoother"
	})
};
at.isScrolling = function () {
	return !!jr
};
at.snapDirectional = vb;
at.addEventListener = function (n, e) {
	var t = Cl[n] || (Cl[n] = []);
	~t.indexOf(e) || t.push(e)
};
at.removeEventListener = function (n, e) {
	var t = Cl[n],
		i = t && t.indexOf(e);
	i >= 0 && t.splice(i, 1)
};
at.batch = function (n, e) {
	var t = [],
		i = {},
		r = e.interval || .016,
		s = e.batchMax || 1e9,
		o = function (c, u) {
			var h = [],
				d = [],
				f = We.delayedCall(r, function () {
					u(h, d), h = [], d = []
				}).pause();
			return function (p) {
				h.length || f.restart(!0), h.push(p.trigger), d.push(p), s <= h.length && f.progress(1)
			}
		},
		a;
	for (a in e) i[a] = a.substr(0, 2) === "on" && Ri(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
	return Ri(s) && (s = s(), Wn(at, "refresh", function () {
		return s = e.batchMax()
	})), rd(n).forEach(function (l) {
		var c = {};
		for (a in i) c[a] = i[a];
		c.trigger = l, t.push(at.create(c))
	}), t
};
var Nw = function (e, t, i, r) {
		return t > r ? e(r) : t < 0 && e(0), i > r ? (r - t) / (i - t) : i < 0 ? t / (t - i) : 1
	},
	rg = function n(e, t) {
		t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (wn.isTouch ? " pinch-zoom" : "") : "none", e === es && n(en, t)
	},
	vf = {
		auto: 1,
		scroll: 1
	},
	q9 = function (e) {
		var t = e.event,
			i = e.target,
			r = e.axis,
			s = (t.changedTouches ? t.changedTouches[0] : t).target,
			o = s._gsap || We.core.getCache(s),
			a = ui(),
			l;
		if (!o._isScrollT || a - o._isScrollT > 2e3) {
			for (; s && s !== en && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(vf[(l = Fr(s)).overflowY] || vf[l.overflowX]));) s = s.parentNode;
			o._isScroll = s && s !== i && !Ml(s) && (vf[(l = Fr(s)).overflowY] || vf[l.overflowX]), o._isScrollT = a
		}(o._isScroll || r === "x") && (t.stopPropagation(), t._gsapAllow = !0)
	},
	kA = function (e, t, i, r) {
		return wn.create({
			target: e,
			capture: !0,
			debounce: !1,
			lockAxis: !0,
			type: t,
			onWheel: r = r && q9,
			onPress: r,
			onDrag: r,
			onScroll: r,
			onEnable: function () {
				return i && Wn(dn, wn.eventTypes[0], Bw, !1, !0)
			},
			onDisable: function () {
				return Gn(dn, wn.eventTypes[0], Bw, !0)
			}
		})
	},
	X9 = /(input|label|select|textarea)/i,
	Uw, Bw = function (e) {
		var t = X9.test(e.target.tagName);
		(t || Uw) && (e._gsapAllow = !0, Uw = t)
	},
	Y9 = function (e) {
		Xa(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
		var t = e,
			i = t.normalizeScrollX,
			r = t.momentum,
			s = t.allowNestedScroll,
			o = t.onRelease,
			a, l, c = Bi(e.target) || es,
			u = We.core.globals().ScrollSmoother,
			h = u && u.get(),
			d = Fo && (e.content && Bi(e.content) || h && e.content !== !1 && !h.smooth() && h.content()),
			f = ba(c, On),
			p = ba(c, Pi),
			_ = 1,
			g = (wn.isTouch && St.visualViewport ? St.visualViewport.scale * St.visualViewport.width : St.outerWidth) / St.innerWidth,
			m = 0,
			b = Ri(r) ? function () {
				return r(a)
			} : function () {
				return r || 2.8
			},
			v, y, x = kA(c, e.type, !0, s),
			S = function () {
				return y = !1
			},
			E = ds,
			C = ds,
			P = function () {
				l = ws(c, On), C = Eh(Fo ? 1 : 0, l), i && (E = Eh(0, ws(c, Pi))), v = ml
			},
			w = function () {
				d._gsap.y = eh(parseFloat(d._gsap.y) + f.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", f.offset = f.cacheID = 0
			},
			D = function () {
				if (y) {
					requestAnimationFrame(S);
					var R = eh(a.deltaY / 2),
						Q = C(f.v - R);
					if (d && Q !== f.v + f.offset) {
						f.offset = Q - f.v;
						var B = eh((parseFloat(d && d._gsap.y) || 0) - f.offset);
						d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + B + ", 0, 1)", d._gsap.y = B + "px", f.cacheID = yt.cache, ro()
					}
					return !0
				}
				f.offset && w(), y = !0
			},
			U, j, z, H, F = function () {
				P(), U.isActive() && U.vars.scrollY > l && (f() > l ? U.progress(1) && f(l) : U.resetTo("scrollY", l))
			};
		return d && We.set(d, {
			y: "+=0"
		}), e.ignoreCheck = function (G) {
			return Fo && G.type === "touchmove" && D() || _ > 1.05 && G.type !== "touchstart" || a.isGesturing || G.touches && G.touches.length > 1
		}, e.onPress = function () {
			y = !1;
			var G = _;
			_ = eh((St.visualViewport && St.visualViewport.scale || 1) / g), U.pause(), G !== _ && rg(c, _ > 1.01 ? !0 : i ? !1 : "x"), j = p(), z = f(), P(), v = ml
		}, e.onRelease = e.onGestureStart = function (G, R) {
			if (f.offset && w(), !R) H.restart(!0);
			else {
				yt.cache++;
				var Q = b(),
					B, ge;
				i && (B = p(), ge = B + Q * .05 * -G.velocityX / .227, Q *= Nw(p, B, ge, ws(c, Pi)), U.vars.scrollX = E(ge)), B = f(), ge = B + Q * .05 * -G.velocityY / .227, Q *= Nw(f, B, ge, ws(c, On)), U.vars.scrollY = C(ge), U.invalidate().duration(Q).play(.01), (Fo && U.vars.scrollY >= l || B >= l - 1) && We.to({}, {
					onUpdate: F,
					duration: Q
				})
			}
			o && o(G)
		}, e.onWheel = function () {
			U._ts && U.pause(), ui() - m > 1e3 && (v = 0, m = ui())
		}, e.onChange = function (G, R, Q, B, ge) {
			if (ml !== v && P(), R && i && p(E(B[2] === R ? j + (G.startX - G.x) : p() + R - B[1])), Q) {
				f.offset && w();
				var Ae = ge[2] === Q,
					ze = Ae ? z + G.startY - G.y : f() + Q - ge[1],
					K = C(ze);
				Ae && ze !== K && (z += K - ze), f(K)
			}(Q || R) && ro()
		}, e.onEnable = function () {
			rg(c, i ? !1 : "x"), at.addEventListener("refresh", F), Wn(St, "resize", F), f.smooth && (f.target.style.scrollBehavior = "auto", f.smooth = p.smooth = !1), x.enable()
		}, e.onDisable = function () {
			rg(c, !0), Gn(St, "resize", F), at.removeEventListener("refresh", F), x.kill()
		}, e.lockAxis = e.lockAxis !== !1, a = new wn(e), a.iOS = Fo, Fo && !f() && f(1), Fo && We.ticker.add(ds), H = a._dc, U = We.to(a, {
			ease: "power4",
			paused: !0,
			inherit: !1,
			scrollX: i ? "+=0.1" : "+=0",
			scrollY: "+=0.1",
			modifiers: {
				scrollY: LA(f, f(), function () {
					return U.pause()
				})
			},
			onUpdate: ro,
			onComplete: H.vars.onComplete
		}), a
	};
at.sort = function (n) {
	return bt.sort(n || function (e, t) {
		return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
	})
};
at.observe = function (n) {
	return new wn(n)
};
at.normalizeScroll = function (n) {
	if (typeof n > "u") return Ti;
	if (n === !0 && Ti) return Ti.enable();
	if (n === !1) {
		Ti && Ti.kill(), Ti = n;
		return
	}
	var e = n instanceof wn ? n : Y9(n);
	return Ti && Ti.target === e.target && Ti.kill(), Ml(e.target) && (Ti = e), e
};
at.core = {
	_getVelocityProp: hv,
	_inputObserver: kA,
	_scrollers: yt,
	_proxies: Ms,
	bridge: {
		ss: function () {
			jr || Al("scrollStart"), jr = ui()
		},
		ref: function () {
			return ci
		}
	}
};
wA() && We.registerPlugin(at);
/*!
 * VelocityTracker: 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
let ps, bv, Dh, IA, pc, wc, yv, OA, FA = () => ps || typeof window < "u" && (ps = window.gsap),
	xv = {},
	K9 = n => Math.round(n * 1e4) / 1e4,
	wv = n => OA(n).id,
	ih = n => xv[wv(typeof n == "string" ? Dh(n)[0] : n)],
	zw = n => {
		let e = pc,
			t;
		if (n - yv >= .05)
			for (yv = n; e;) t = e.g(e.t, e.p), (t !== e.v1 || n - e.t1 > .2) && (e.v2 = e.v1, e.v1 = t, e.t2 = e.t1, e.t1 = n), e = e._next
	},
	Z9 = {
		deg: 360,
		rad: Math.PI * 2
	},
	sg = () => {
		ps = FA(), ps && (Dh = ps.utils.toArray, IA = ps.utils.getUnit, OA = ps.core.getCache, wc = ps.ticker, bv = 1)
	};
class J9 {
	constructor(e, t, i, r) {
		this.t = e, this.p = t, this.g = e._gsap.get, this.rCap = Z9[i || IA(this.g(e, t))], this.v1 = this.v2 = 0, this.t1 = this.t2 = wc.time, r && (this._next = r, r._prev = this)
	}
}
class Il {
	constructor(e, t) {
		bv || sg(), this.target = Dh(e)[0], xv[wv(this.target)] = this, this._props = {}, t && this.add(t)
	}
	static register(e) {
		ps = e, sg()
	}
	get(e, t) {
		let i = this._props[e] || console.warn("Not tracking " + e + " velocity."),
			r, s, o;
		return r = parseFloat(t ? i.v1 : i.g(i.t, i.p)), s = r - parseFloat(i.v2), o = i.rCap, o && (s = s % o, s !== s % (o / 2) && (s = s < 0 ? s + o : s - o)), K9(s / ((t ? i.t1 : wc.time) - i.t2))
	}
	getAll() {
		let e = {},
			t = this._props,
			i;
		for (i in t) e[i] = this.get(i);
		return e
	}
	isTracking(e) {
		return e in this._props
	}
	add(e, t) {
		e in this._props || (pc || (wc.add(zw), yv = wc.time), pc = this._props[e] = new J9(this.target, e, t, pc))
	}
	remove(e) {
		let t = this._props[e],
			i, r;
		t && (i = t._prev, r = t._next, i && (i._next = r), r ? r._prev = i : pc === t && (wc.remove(zw), pc = 0), delete this._props[e])
	}
	kill(e) {
		for (let t in this._props) this.remove(t);
		e || delete xv[wv(this.target)]
	}
	static track(e, t, i) {
		bv || sg();
		let r = [],
			s = Dh(e),
			o = t.split(","),
			a = (i || "").split(","),
			l = s.length,
			c, u;
		for (; l--;) {
			for (c = ih(s[l]) || new Il(s[l]), u = o.length; u--;) c.add(o[u], a[u] || a[0]);
			r.push(c)
		}
		return r
	}
	static untrack(e, t) {
		let i = (t || "").split(",");
		Dh(e).forEach(r => {
			let s = ih(r);
			s && (i.length ? i.forEach(o => s.remove(o)) : s.kill(1))
		})
	}
	static isTracking(e, t) {
		let i = ih(e);
		return i && i.isTracking(t)
	}
	static getVelocity(e, t) {
		let i = ih(e);
		return !i || !i.isTracking(t) ? console.warn("Not tracking velocity of " + t) : i.get(t)
	}
}
Il.getByTarget = ih;
FA() && ps.registerPlugin(Il);
/*!
 * InertiaPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
let In, NA, Vw, UA, Ev, Ph, BA, zA, VA, yb, HA, Rh, Sv, GA, Qp = Il.getByTarget,
	WA = () => In || typeof window < "u" && (In = window.gsap) && In.registerPlugin && In,
	Q9 = n => typeof n == "string",
	od = n => typeof n == "number",
	la = n => typeof n == "object",
	Tv = n => typeof n == "function",
	ez = 1,
	jA = Array.isArray,
	tz = n => n,
	gl = 1e10,
	Hw = 1 / gl,
	$A = .05,
	nz = n => Math.round(n * 1e4) / 1e4,
	iz = (n, e, t) => {
		for (let i in e) !(i in n) && i !== t && (n[i] = e[i]);
		return n
	},
	qA = n => {
		let e = {},
			t, i;
		for (t in n) e[t] = la(i = n[t]) && !jA(i) ? qA(i) : i;
		return e
	},
	Gw = (n, e, t, i, r) => {
		let s = e.length,
			o = 0,
			a = gl,
			l, c, u, h;
		if (la(n)) {
			for (; s--;) {
				l = e[s], c = 0;
				for (u in n) h = l[u] - n[u], c += h * h;
				c < a && (o = s, a = c)
			}
			if ((r || gl) < gl && r < Math.sqrt(a)) return n
		} else
			for (; s--;) l = e[s], c = l - n, c < 0 && (c = -c), c < a && l >= i && l <= t && (o = s, a = c);
		return e[o]
	},
	XA = (n, e, t, i, r, s, o) => {
		if (n.end === "auto") return n;
		let a = n.end,
			l, c;
		if (t = isNaN(t) ? gl : t, i = isNaN(i) ? -gl : i, la(e)) {
			if (l = e.calculated ? e : (Tv(a) ? a(e, o) : Gw(e, a, t, i, s)) || e, !e.calculated) {
				for (c in l) e[c] = l[c];
				e.calculated = !0
			}
			l = l[r]
		} else l = Tv(a) ? a(e, o) : jA(a) ? Gw(e, a, t, i, s) : parseFloat(a);
		return l > t ? l = t : l < i && (l = i), {
			max: l,
			min: l,
			unitFactor: n.unitFactor
		}
	},
	em = (n, e, t) => isNaN(n[e]) ? t : +n[e],
	xb = (n, e) => e * $A * n / yb,
	Ww = (n, e, t) => Math.abs((e - n) * yb / t / $A),
	YA = {
		resistance: 1,
		checkpoint: 1,
		preventOvershoot: 1,
		linkedProps: 1,
		radius: 1,
		duration: 1
	},
	KA = (n, e, t, i) => {
		if (e.linkedProps) {
			let r = e.linkedProps.split(","),
				s = {},
				o, a, l, c, u, h;
			for (o = 0; o < r.length; o++) a = r[o], l = e[a], l && (od(l.velocity) ? c = l.velocity : (u = u || Qp(n), c = u && u.isTracking(a) ? u.get(a) : 0), h = Math.abs(c / em(l, "resistance", i)), s[a] = parseFloat(t(n, a)) + xb(c, h));
			return s
		}
	},
	rz = (n, e, t = 10, i = .2, r = 1, s = 0) => {
		if (Q9(n) && (n = UA(n)[0]), !n) return 0;
		let o = 0,
			a = gl,
			l = e.inertia || e,
			c = VA(n).get,
			u = em(l, "resistance", Ph.resistance),
			h, d, f, p, _, g, m, b, v, y;
		y = KA(n, l, c, u);
		for (h in l) YA[h] || (d = l[h], la(d) || (b = b || Qp(n), b && b.isTracking(h) ? d = od(d) ? {
			velocity: d
		} : {
			velocity: b.get(h)
		} : (p = +d || 0, f = Math.abs(p / u))), la(d) && (od(d.velocity) ? p = d.velocity : (b = b || Qp(n), p = b && b.isTracking(h) ? b.get(h) : 0), f = HA(i, t, Math.abs(p / em(d, "resistance", u))), _ = parseFloat(c(n, h)) || 0, g = _ + xb(p, f), "end" in d && (d = XA(d, y && h in y ? y : g, d.max, d.min, h, l.radius, p), s && (Rh === e && (Rh = l = qA(e)), l[h] = iz(d, l[h], "end"))), "max" in d && g > +d.max + Hw ? (v = d.unitFactor || Ph.unitFactors[h] || 1, m = _ > d.max && d.min !== d.max || p * v > -15 && p * v < 45 ? i + (t - i) * .1 : Ww(_, d.max, p), m + r < a && (a = m + r)) : "min" in d && g < +d.min - Hw && (v = d.unitFactor || Ph.unitFactors[h] || 1, m = _ < d.min && d.min !== d.max || p * v > -45 && p * v < 15 ? i + (t - i) * .1 : Ww(_, d.min, p), m + r < a && (a = m + r)), m > o && (o = m)), f > o && (o = f));
		return o > a && (o = a), o > t ? t : o < i ? i : o
	},
	jw = () => {
		In = WA(), In && (Vw = In.parseEase, UA = In.utils.toArray, BA = In.utils.getUnit, VA = In.core.getCache, HA = In.utils.clamp, Sv = In.core.getStyleSaver, GA = In.core.reverting || function () {}, Ev = Vw("power3"), yb = Ev(.05), zA = In.core.PropTween, In.config({
			resistance: 100,
			unitFactors: {
				time: 1e3,
				totalTime: 1e3,
				progress: 1e3,
				totalProgress: 1e3
			}
		}), Ph = In.config(), In.registerPlugin(Il), NA = 1)
	};
const wb = {
	version: "3.12.5",
	name: "inertia",
	register(n) {
		In = n, jw()
	},
	init(n, e, t, i, r) {
		NA || jw();
		let s = Qp(n);
		if (e === "auto") {
			if (!s) {
				console.warn("No inertia tracking on " + n + ". InertiaPlugin.track(target) first.");
				return
			}
			e = s.getAll()
		}
		this.styles = Sv && typeof n.style == "object" && Sv(n), this.target = n, this.tween = t, Rh = e;
		let o = n._gsap,
			a = o.get,
			l = e.duration,
			c = la(l),
			u = e.preventOvershoot || c && l.overshoot === 0,
			h = em(e, "resistance", Ph.resistance),
			d = od(l) ? l : rz(n, e, c && l.max || 10, c && l.min || .2, c && "overshoot" in l ? +l.overshoot : u ? 0 : 1, !0),
			f, p, _, g, m, b, v, y, x;
		e = Rh, Rh = 0, x = KA(n, e, a, h);
		for (f in e) YA[f] || (p = e[f], Tv(p) && (p = p(i, n, r)), od(p) ? m = p : la(p) && !isNaN(p.velocity) ? m = +p.velocity : s && s.isTracking(f) ? m = s.get(f) : console.warn("ERROR: No velocity was defined for " + n + " property: " + f), b = xb(m, d), y = 0, _ = a(n, f), g = BA(_), _ = parseFloat(_), la(p) && (v = _ + b, "end" in p && (p = XA(p, x && f in x ? x : v, p.max, p.min, f, e.radius, m)), "max" in p && +p.max < v ? u || p.preventOvershoot ? b = p.max - _ : y = p.max - _ - b : "min" in p && +p.min > v && (u || p.preventOvershoot ? b = p.min - _ : y = p.min - _ - b)), this._props.push(f), this.styles && this.styles.save(f), this._pt = new zA(this._pt, n, f, _, 0, tz, 0, o.set(n, f, this)), this._pt.u = g || 0, this._pt.c1 = b, this._pt.c2 = y);
		return t.duration(d), ez
	},
	render(n, e) {
		let t = e._pt;
		if (n = Ev(e.tween._time / e.tween._dur), n || !GA())
			for (; t;) t.set(t.t, t.p, nz(t.s + t.c1 * n + t.c2 * n * n) + t.u, t.d, n), t = t._next;
		else e.styles.revert()
	}
};
"track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(n => wb[n] = Il[n]);
WA() && In.registerPlugin(wb);
/*!
 * strings: 3.11.3
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
const sz = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

function ZA(n) {
	let e = n.nodeType,
		t = "";
	if (e === 1 || e === 9 || e === 11) {
		if (typeof n.textContent == "string") return n.textContent;
		for (n = n.firstChild; n; n = n.nextSibling) t += ZA(n)
	} else if (e === 3 || e === 4) return n.nodeValue;
	return t
}
/*!
 * SplitText: 3.11.3
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
let nl, JA, QA, oz = /(?:\r|\n|\t\t)/g,
	az = /(?:\s\s+)/g,
	lz = () => {
		nl = document, JA = window, QA = 1
	},
	eD = n => JA.getComputedStyle(n),
	cz = Array.isArray,
	$w = [].slice,
	Eb = (n, e) => {
		let t;
		return cz(n) ? n : (t = typeof n) == "string" && !e && n ? $w.call(nl.querySelectorAll(n), 0) : n && t === "object" && "length" in n ? $w.call(n, 0) : n ? [n] : []
	},
	Sb = n => n.position === "absolute" || n.absolute === !0,
	uz = (n, e) => {
		let t = e.length,
			i;
		for (; --t > -1;)
			if (i = e[t], n.substr(0, i.length) === i) return i.length
	},
	hz = " style='position:relative;display:inline-block;'",
	qw = (n = "", e) => {
		let t = ~n.indexOf("++"),
			i = 1;
		return t && (n = n.split("++").join("")), () => "<" + e + hz + (n ? " class='" + n + (t ? i++ : "") + "'>" : ">")
	},
	Tb = (n, e, t) => {
		let i = n.nodeType;
		if (i === 1 || i === 9 || i === 11)
			for (n = n.firstChild; n; n = n.nextSibling) Tb(n, e, t);
		else(i === 3 || i === 4) && (n.nodeValue = n.nodeValue.split(e).join(t))
	},
	og = (n, e) => {
		let t = e.length;
		for (; --t > -1;) n.push(e[t])
	},
	Xw = (n, e, t) => {
		let i;
		for (; n && n !== e;) {
			if (i = n._next || n.nextSibling, i) return i.textContent.charAt(0) === t;
			n = n.parentNode || n._parent
		}
	},
	tD = n => {
		let e = Eb(n.childNodes),
			t = e.length,
			i, r;
		for (i = 0; i < t; i++) r = e[i], r._isSplit ? tD(r) : i && r.previousSibling && r.previousSibling.nodeType === 3 ? (r.previousSibling.nodeValue += r.nodeType === 3 ? r.nodeValue : r.firstChild.nodeValue, n.removeChild(r)) : r.nodeType !== 3 && (n.insertBefore(r.firstChild, r), n.removeChild(r))
	},
	as = (n, e) => parseFloat(e[n]) || 0,
	dz = (n, e, t, i, r, s, o) => {
		let a = eD(n),
			l = as("paddingLeft", a),
			c = -999,
			u = as("borderBottomWidth", a) + as("borderTopWidth", a),
			h = as("borderLeftWidth", a) + as("borderRightWidth", a),
			d = as("paddingTop", a) + as("paddingBottom", a),
			f = as("paddingLeft", a) + as("paddingRight", a),
			p = as("fontSize", a) * (e.lineThreshold || .2),
			_ = a.textAlign,
			g = [],
			m = [],
			b = [],
			v = e.wordDelimiter || " ",
			y = e.tag ? e.tag : e.span ? "span" : "div",
			x = e.type || e.split || "chars,words,lines",
			S = r && ~x.indexOf("lines") ? [] : null,
			E = ~x.indexOf("words"),
			C = ~x.indexOf("chars"),
			P = Sb(e),
			w = e.linesClass,
			D = ~(w || "").indexOf("++"),
			U = [],
			j = a.display === "flex",
			z = n.style.display,
			H, F, G, R, Q, B, ge, Ae, ze, K, ye, Se;
		for (D && (w = w.split("++").join("")), j && (n.style.display = "block"), F = n.getElementsByTagName("*"), G = F.length, Q = [], H = 0; H < G; H++) Q[H] = F[H];
		if (S || P)
			for (H = 0; H < G; H++) R = Q[H], B = R.parentNode === n, (B || P || C && !E) && (Se = R.offsetTop, S && B && Math.abs(Se - c) > p && (R.nodeName !== "BR" || H === 0) && (ge = [], S.push(ge), c = Se), P && (R._x = R.offsetLeft, R._y = Se, R._w = R.offsetWidth, R._h = R.offsetHeight), S && ((R._isSplit && B || !C && B || E && B || !E && R.parentNode.parentNode === n && !R.parentNode._isSplit) && (ge.push(R), R._x -= l, Xw(R, n, v) && (R._wordEnd = !0)), R.nodeName === "BR" && (R.nextSibling && R.nextSibling.nodeName === "BR" || H === 0) && S.push([])));
		for (H = 0; H < G; H++) {
			if (R = Q[H], B = R.parentNode === n, R.nodeName === "BR") {
				S || P ? (R.parentNode && R.parentNode.removeChild(R), Q.splice(H--, 1), G--) : E || n.appendChild(R);
				continue
			}
			if (P && (ze = R.style, !E && !B && (R._x += R.parentNode._x, R._y += R.parentNode._y), ze.left = R._x + "px", ze.top = R._y + "px", ze.position = "absolute", ze.display = "block", ze.width = R._w + 1 + "px", ze.height = R._h + "px"), !E && C)
				if (R._isSplit)
					for (R._next = F = R.nextSibling, R.parentNode.appendChild(R); F && F.nodeType === 3 && F.textContent === " ";) R._next = F.nextSibling, R.parentNode.appendChild(F), F = F.nextSibling;
				else R.parentNode._isSplit ? (R._parent = R.parentNode, !R.previousSibling && R.firstChild && (R.firstChild._isFirst = !0), R.nextSibling && R.nextSibling.textContent === " " && !R.nextSibling.nextSibling && U.push(R.nextSibling), R._next = R.nextSibling && R.nextSibling._isFirst ? null : R.nextSibling, R.parentNode.removeChild(R), Q.splice(H--, 1), G--) : B || (Se = !R.nextSibling && Xw(R.parentNode, n, v), R.parentNode._parent && R.parentNode._parent.appendChild(R), Se && R.parentNode.appendChild(nl.createTextNode(" ")), y === "span" && (R.style.display = "inline"), g.push(R));
			else R.parentNode._isSplit && !R._isSplit && R.innerHTML !== "" ? m.push(R) : C && !R._isSplit && (y === "span" && (R.style.display = "inline"), g.push(R))
		}
		for (H = U.length; --H > -1;) U[H].parentNode.removeChild(U[H]);
		if (S) {
			for (P && (K = nl.createElement(y), n.appendChild(K), ye = K.offsetWidth + "px", Se = K.offsetParent === n ? 0 : n.offsetLeft, n.removeChild(K)), ze = n.style.cssText, n.style.cssText = "display:none;"; n.firstChild;) n.removeChild(n.firstChild);
			for (Ae = v === " " && (!P || !E && !C), H = 0; H < S.length; H++) {
				for (ge = S[H], K = nl.createElement(y), K.style.cssText = "display:block;text-align:" + _ + ";position:" + (P ? "absolute;" : "relative;"), w && (K.className = w + (D ? H + 1 : "")), b.push(K), G = ge.length, F = 0; F < G; F++) ge[F].nodeName !== "BR" && (R = ge[F], K.appendChild(R), Ae && R._wordEnd && K.appendChild(nl.createTextNode(" ")), P && (F === 0 && (K.style.top = R._y + "px", K.style.left = l + Se + "px"), R.style.top = "0px", Se && (R.style.left = R._x - Se + "px")));
				G === 0 ? K.innerHTML = "&nbsp;" : !E && !C && (tD(K), Tb(K, " ", " ")), P && (K.style.width = ye, K.style.height = R._h + "px"), n.appendChild(K)
			}
			n.style.cssText = ze
		}
		P && (o > n.clientHeight && (n.style.height = o - d + "px", n.clientHeight < o && (n.style.height = o + u + "px")), s > n.clientWidth && (n.style.width = s - f + "px", n.clientWidth < s && (n.style.width = s + h + "px"))), j && (z ? n.style.display = z : n.style.removeProperty("display")), og(t, g), E && og(i, m), og(r, b)
	},
	fz = (n, e, t, i) => {
		let r = e.tag ? e.tag : e.span ? "span" : "div",
			s = e.type || e.split || "chars,words,lines",
			o = ~s.indexOf("chars"),
			a = Sb(e),
			l = e.wordDelimiter || " ",
			c = l !== " " ? "" : a ? "&#173; " : " ",
			u = "</" + r + ">",
			h = 1,
			d = e.specialChars ? typeof e.specialChars == "function" ? e.specialChars : uz : null,
			f, p, _, g, m, b, v, y, x = nl.createElement("div"),
			S = n.parentNode;
		for (S.insertBefore(x, n), x.textContent = n.nodeValue, S.removeChild(n), n = x, f = ZA(n), v = f.indexOf("<") !== -1, e.reduceWhiteSpace !== !1 && (f = f.replace(az, " ").replace(oz, "")), v && (f = f.split("<").join("{{LT}}")), m = f.length, p = (f.charAt(0) === " " ? c : "") + t(), _ = 0; _ < m; _++)
			if (b = f.charAt(_), d && (y = d(f.substr(_), e.specialChars))) b = f.substr(_, y || 1), p += o && b !== " " ? i() + b + "</" + r + ">" : b, _ += y - 1;
			else if (b === l && f.charAt(_ - 1) !== l && _) {
			for (p += h ? u : "", h = 0; f.charAt(_ + 1) === l;) p += c, _++;
			_ === m - 1 ? p += c : f.charAt(_ + 1) !== ")" && (p += c + t(), h = 1)
		} else b === "{" && f.substr(_, 6) === "{{LT}}" ? (p += o ? i() + "{{LT}}</" + r + ">" : "{{LT}}", _ += 5) : b.charCodeAt(0) >= 55296 && b.charCodeAt(0) <= 56319 || f.charCodeAt(_ + 1) >= 65024 && f.charCodeAt(_ + 1) <= 65039 ? (g = ((f.substr(_, 12).split(sz) || [])[1] || "").length || 2, p += o && b !== " " ? i() + f.substr(_, g) + "</" + r + ">" : f.substr(_, g), _ += g - 1) : p += o && b !== " " ? i() + b + "</" + r + ">" : b;
		n.outerHTML = p + (h ? u : ""), v && Tb(S, "{{LT}}", "<")
	},
	nD = (n, e, t, i) => {
		let r = Eb(n.childNodes),
			s = r.length,
			o = Sb(e),
			a, l;
		if (n.nodeType !== 3 || s > 1) {
			for (e.absolute = !1, a = 0; a < s; a++) l = r[a], l._next = l._isFirst = l._parent = l._wordEnd = null, (l.nodeType !== 3 || /\S+/.test(l.nodeValue)) && (o && l.nodeType !== 3 && eD(l).display === "inline" && (l.style.display = "inline-block", l.style.position = "relative"), l._isSplit = !0, nD(l, e, t, i));
			e.absolute = o, n._isSplit = !0;
			return
		}
		fz(n, e, t, i)
	};
class _l {
	constructor(e, t) {
		QA || lz(), this.elements = Eb(e), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t)
	}
	split(e) {
		this.isSplit && this.revert(), this.vars = e = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
		let t = this.elements.length,
			i = e.tag ? e.tag : e.span ? "span" : "div",
			r = qw(e.wordsClass, i),
			s = qw(e.charsClass, i),
			o, a, l;
		for (; --t > -1;) l = this.elements[t], this._originals[t] = l.innerHTML, o = l.clientHeight, a = l.clientWidth, nD(l, e, r, s), dz(l, e, this.chars, this.words, this.lines, a, o);
		return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
	}
	revert() {
		let e = this._originals;
		if (!e) throw "revert() call wasn't scoped properly.";
		return this.elements.forEach((t, i) => t.innerHTML = e[i]), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
	}
	static create(e, t) {
		return new _l(e, t)
	}
}
_l.version = "3.11.3";
/*!
 * ScrollToPlugin 3.11.5
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
let Li, iD, so, Es, ca, rD, sD, bf, oD = () => typeof window < "u",
	aD = () => Li || oD() && (Li = window.gsap) && Li.registerPlugin && Li,
	lD = n => typeof n == "string",
	Yw = n => typeof n == "function",
	ad = (n, e) => {
		let t = e === "x" ? "Width" : "Height",
			i = "scroll" + t,
			r = "client" + t;
		return n === so || n === Es || n === ca ? Math.max(Es[i], ca[i]) - (so["inner" + t] || Es[r] || ca[r]) : n[i] - n["offset" + t]
	},
	ld = (n, e) => {
		let t = "scroll" + (e === "x" ? "Left" : "Top");
		return n === so && (n.pageXOffset != null ? t = "page" + e.toUpperCase() + "Offset" : n = Es[t] != null ? Es : ca), () => n[t]
	},
	pz = (n, e, t, i) => {
		if (Yw(n) && (n = n(e, t, i)), typeof n != "object") return lD(n) && n !== "max" && n.charAt(1) !== "=" ? {
			x: n,
			y: n
		} : {
			y: n
		};
		if (n.nodeType) return {
			y: n,
			x: n
		}; {
			let r = {},
				s;
			for (s in n) r[s] = s !== "onAutoKill" && Yw(n[s]) ? n[s](e, t, i) : n[s];
			return r
		}
	},
	cD = (n, e) => {
		if (n = rD(n)[0], !n || !n.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
			x: 0,
			y: 0
		};
		let t = n.getBoundingClientRect(),
			i = !e || e === so || e === ca,
			r = i ? {
				top: Es.clientTop - (so.pageYOffset || Es.scrollTop || ca.scrollTop || 0),
				left: Es.clientLeft - (so.pageXOffset || Es.scrollLeft || ca.scrollLeft || 0)
			} : e.getBoundingClientRect(),
			s = {
				x: t.left - r.left,
				y: t.top - r.top
			};
		return !i && e && (s.x += ld(e, "x")(), s.y += ld(e, "y")()), s
	},
	Kw = (n, e, t, i, r) => !isNaN(n) && typeof n != "object" ? parseFloat(n) - r : lD(n) && n.charAt(1) === "=" ? parseFloat(n.substr(2)) * (n.charAt(0) === "-" ? -1 : 1) + i - r : n === "max" ? ad(e, t) - r : Math.min(ad(e, t), cD(n, e)[t] - r),
	Zw = () => {
		Li = aD(), oD() && Li && typeof document < "u" && document.body && (so = window, ca = document.body, Es = document.documentElement, rD = Li.utils.toArray, Li.config({
			autoKillThreshold: 7
		}), sD = Li.config(), iD = 1)
	};
const Ud = {
	version: "3.11.5",
	name: "scrollTo",
	rawVars: 1,
	register(n) {
		Li = n, Zw()
	},
	init(n, e, t, i, r) {
		iD || Zw();
		let s = this,
			o = Li.getProperty(n, "scrollSnapType");
		s.isWin = n === so, s.target = n, s.tween = t, e = pz(e, i, n, r), s.vars = e, s.autoKill = !!e.autoKill, s.getX = ld(n, "x"), s.getY = ld(n, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), bf || (bf = Li.core.globals().ScrollTrigger), Li.getProperty(n, "scrollBehavior") === "smooth" && Li.set(n, {
			scrollBehavior: "auto"
		}), o && o !== "none" && (s.snap = 1, s.snapInline = n.style.scrollSnapType, n.style.scrollSnapType = "none"), e.x != null ? (s.add(s, "x", s.x, Kw(e.x, n, "x", s.x, e.offsetX || 0), i, r), s._props.push("scrollTo_x")) : s.skipX = 1, e.y != null ? (s.add(s, "y", s.y, Kw(e.y, n, "y", s.y, e.offsetY || 0), i, r), s._props.push("scrollTo_y")) : s.skipY = 1
	},
	render(n, e) {
		let t = e._pt,
			{
				target: i,
				tween: r,
				autoKill: s,
				xPrev: o,
				yPrev: a,
				isWin: l,
				snap: c,
				snapInline: u
			} = e,
			h, d, f, p, _;
		for (; t;) t.r(n, t.d), t = t._next;
		h = l || !e.skipX ? e.getX() : o, d = l || !e.skipY ? e.getY() : a, f = d - a, p = h - o, _ = sD.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), s && (!e.skipX && (p > _ || p < -_) && h < ad(i, "x") && (e.skipX = 1), !e.skipY && (f > _ || f < -_) && d < ad(i, "y") && (e.skipY = 1), e.skipX && e.skipY && (r.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(r, e.vars.onAutoKillParams || []))), l ? so.scrollTo(e.skipX ? h : e.x, e.skipY ? d : e.y) : (e.skipY || (i.scrollTop = e.y), e.skipX || (i.scrollLeft = e.x)), c && (n === 1 || n === 0) && (d = i.scrollTop, h = i.scrollLeft, u ? i.style.scrollSnapType = u : i.style.removeProperty("scroll-snap-type"), i.scrollTop = d + 1, i.scrollLeft = h + 1, i.scrollTop = d, i.scrollLeft = h), e.xPrev = e.x, e.yPrev = e.y, bf && bf.update()
	},
	kill(n) {
		let e = n === "scrollTo";
		(e || n === "scrollTo_x") && (this.skipX = 1), (e || n === "scrollTo_y") && (this.skipY = 1)
	}
};
Ud.max = ad;
Ud.getOffset = cD;
Ud.buildGetter = ld;
aD() && Li.registerPlugin(Ud);
const mz = un({
	name: "gsap",
	parallel: !0,
	dependsOn: ["viewport"],
	async setup() {
		const {
			$viewport: n,
			hook: e
		} = Ke(), t = document.querySelector("main"), i = n.width < 768;
		lt.registerPlugin(at, Ud, _l, wb), at.defaults({
			scroller: i ? t : document.body
		}), at.config({
			ignoreMobileResize: !1
		}), e("WINDOW:RESISZE", r), e("PRELOADER:BEFOREEXIT", at.refresh(!0));

		function r() {
			at.defaults({
				scroller: i ? t : document.body
			})
		}
		lt.defaults({
			ease: "power2.out"
		})
	}
});

function uD(n, e, t) {
	return Math.max(n, Math.min(e, t))
}
class gz {
	advance(e) {
		var a;
		if (!this.isRunning) return;
		let t = !1;
		if (this.lerp) this.value = (i = this.value, r = this.to, s = 60 * this.lerp, o = e, function (l, c, u) {
			return (1 - u) * l + u * c
		}(i, r, 1 - Math.exp(-s * o))), Math.round(this.value) === this.to && (this.value = this.to, t = !0);
		else {
			this.currentTime += e;
			const l = uD(0, this.currentTime / this.duration, 1);
			t = l >= 1;
			const c = t ? 1 : this.easing(l);
			this.value = this.from + (this.to - this.from) * c
		}
		var i, r, s, o;
		(a = this.onUpdate) == null || a.call(this, this.value, t), t && this.stop()
	}
	stop() {
		this.isRunning = !1
	}
	fromTo(e, t, {
		lerp: i = .1,
		duration: r = 1,
		easing: s = l => l,
		onStart: o,
		onUpdate: a
	}) {
		this.from = this.value = e, this.to = t, this.lerp = i, this.duration = r, this.easing = s, this.currentTime = 0, this.isRunning = !0, o == null || o(), this.onUpdate = a
	}
}
class _z {
	constructor({
		wrapper: e,
		content: t,
		autoResize: i = !0,
		debounce: r = 250
	} = {}) {
		Fs(this, "resize", () => {
			this.onWrapperResize(), this.onContentResize()
		});
		Fs(this, "onWrapperResize", () => {
			this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
		});
		Fs(this, "onContentResize", () => {
			this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
		});
		this.wrapper = e, this.content = t, i && (this.debouncedResize = function (s, o) {
			let a;
			return function () {
				let l = arguments,
					c = this;
				clearTimeout(a), a = setTimeout(function () {
					s.apply(c, l)
				}, o)
			}
		}(this.resize, r), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
	}
	destroy() {
		var e, t;
		(e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
	}
	get limit() {
		return {
			x: this.scrollWidth - this.width,
			y: this.scrollHeight - this.height
		}
	}
}
class hD {
	constructor() {
		this.events = {}
	}
	emit(e, ...t) {
		let i = this.events[e] || [];
		for (let r = 0, s = i.length; r < s; r++) i[r](...t)
	}
	on(e, t) {
		var i;
		return (i = this.events[e]) != null && i.push(t) || (this.events[e] = [t]), () => {
			var r;
			this.events[e] = (r = this.events[e]) == null ? void 0 : r.filter(s => t !== s)
		}
	}
	off(e, t) {
		var i;
		this.events[e] = (i = this.events[e]) == null ? void 0 : i.filter(r => t !== r)
	}
	destroy() {
		this.events = {}
	}
}
const Jw = 100 / 6;
class vz {
	constructor(e, {
		wheelMultiplier: t = 1,
		touchMultiplier: i = 1
	}) {
		Fs(this, "onTouchStart", e => {
			const {
				clientX: t,
				clientY: i
			} = e.targetTouches ? e.targetTouches[0] : e;
			this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = {
				x: 0,
				y: 0
			}, this.emitter.emit("scroll", {
				deltaX: 0,
				deltaY: 0,
				event: e
			})
		});
		Fs(this, "onTouchMove", e => {
			const {
				clientX: t,
				clientY: i
			} = e.targetTouches ? e.targetTouches[0] : e, r = -(t - this.touchStart.x) * this.touchMultiplier, s = -(i - this.touchStart.y) * this.touchMultiplier;
			this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = {
				x: r,
				y: s
			}, this.emitter.emit("scroll", {
				deltaX: r,
				deltaY: s,
				event: e
			})
		});
		Fs(this, "onTouchEnd", e => {
			this.emitter.emit("scroll", {
				deltaX: this.lastDelta.x,
				deltaY: this.lastDelta.y,
				event: e
			})
		});
		Fs(this, "onWheel", e => {
			let {
				deltaX: t,
				deltaY: i,
				deltaMode: r
			} = e;
			t *= r === 1 ? Jw : r === 2 ? this.windowWidth : 1, i *= r === 1 ? Jw : r === 2 ? this.windowHeight : 1, t *= this.wheelMultiplier, i *= this.wheelMultiplier, this.emitter.emit("scroll", {
				deltaX: t,
				deltaY: i,
				event: e
			})
		});
		Fs(this, "onWindowResize", () => {
			this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
		});
		this.element = e, this.wheelMultiplier = t, this.touchMultiplier = i, this.touchStart = {
			x: null,
			y: null
		}, this.emitter = new hD, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
			passive: !1
		}), this.element.addEventListener("touchstart", this.onTouchStart, {
			passive: !1
		}), this.element.addEventListener("touchmove", this.onTouchMove, {
			passive: !1
		}), this.element.addEventListener("touchend", this.onTouchEnd, {
			passive: !1
		})
	}
	on(e, t) {
		return this.emitter.on(e, t)
	}
	destroy() {
		this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
			passive: !1
		}), this.element.removeEventListener("touchstart", this.onTouchStart, {
			passive: !1
		}), this.element.removeEventListener("touchmove", this.onTouchMove, {
			passive: !1
		}), this.element.removeEventListener("touchend", this.onTouchEnd, {
			passive: !1
		})
	}
}
class bz {
	constructor({
		wrapper: e = window,
		content: t = document.documentElement,
		wheelEventsTarget: i = e,
		eventsTarget: r = i,
		smoothWheel: s = !0,
		syncTouch: o = !1,
		syncTouchLerp: a = .075,
		touchInertiaMultiplier: l = 35,
		duration: c,
		easing: u = v => Math.min(1, 1.001 - Math.pow(2, -10 * v)),
		lerp: h = !c && .1,
		infinite: d = !1,
		orientation: f = "vertical",
		gestureOrientation: p = "vertical",
		touchMultiplier: _ = 1,
		wheelMultiplier: g = 1,
		autoResize: m = !0,
		__experimental__naiveDimensions: b = !1
	} = {}) {
		this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
			deltaX: v,
			deltaY: y,
			event: x
		}) => {
			if (x.ctrlKey) return;
			const S = x.type.includes("touch"),
				E = x.type.includes("wheel");
			if (this.options.syncTouch && S && x.type === "touchstart" && !this.isStopped && !this.isLocked) return void this.reset();
			const C = v === 0 && y === 0,
				P = this.options.gestureOrientation === "vertical" && y === 0 || this.options.gestureOrientation === "horizontal" && v === 0;
			if (C || P) return;
			let w = x.composedPath();
			if (w = w.slice(0, w.indexOf(this.rootElement)), w.find(z => {
					var H, F, G, R, Q;
					return ((H = z.hasAttribute) === null || H === void 0 ? void 0 : H.call(z, "data-lenis-prevent")) || S && ((F = z.hasAttribute) === null || F === void 0 ? void 0 : F.call(z, "data-lenis-prevent-touch")) || E && ((G = z.hasAttribute) === null || G === void 0 ? void 0 : G.call(z, "data-lenis-prevent-wheel")) || ((R = z.classList) === null || R === void 0 ? void 0 : R.contains("lenis")) && !(!((Q = z.classList) === null || Q === void 0) && Q.contains("lenis-stopped"))
				})) return;
			if (this.isStopped || this.isLocked) return void x.preventDefault();
			if (this.isSmooth = this.options.syncTouch && S || this.options.smoothWheel && E, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
			x.preventDefault();
			let D = y;
			this.options.gestureOrientation === "both" ? D = Math.abs(y) > Math.abs(v) ? y : v : this.options.gestureOrientation === "horizontal" && (D = v);
			const U = S && this.options.syncTouch,
				j = S && x.type === "touchend" && Math.abs(D) > 5;
			j && (D = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + D, Object.assign({
				programmatic: !1
			}, U ? {
				lerp: j ? this.options.syncTouchLerp : 1
			} : {
				lerp: this.options.lerp,
				duration: this.options.duration,
				easing: this.options.easing
			}))
		}, this.onNativeScroll = () => {
			if (!this.__preventNextScrollEvent && !this.isScrolling) {
				const v = this.animatedScroll;
				this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - v), this.emit()
			}
		}, window.lenisVersion = "1.0.42", e !== document.documentElement && e !== document.body || (e = window), this.options = {
			wrapper: e,
			content: t,
			wheelEventsTarget: i,
			eventsTarget: r,
			smoothWheel: s,
			syncTouch: o,
			syncTouchLerp: a,
			touchInertiaMultiplier: l,
			duration: c,
			easing: u,
			lerp: h,
			infinite: d,
			gestureOrientation: p,
			orientation: f,
			touchMultiplier: _,
			wheelMultiplier: g,
			autoResize: m,
			__experimental__naiveDimensions: b
		}, this.animate = new gz, this.emitter = new hD, this.dimensions = new _z({
			wrapper: e,
			content: t,
			autoResize: m
		}), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = o || s, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new vz(r, {
			touchMultiplier: _,
			wheelMultiplier: g
		}), this.virtualScroll.on("scroll", this.onVirtualScroll)
	}
	destroy() {
		this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
	}
	on(e, t) {
		return this.emitter.on(e, t)
	}
	off(e, t) {
		return this.emitter.off(e, t)
	}
	setScroll(e) {
		this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
	}
	resize() {
		this.dimensions.resize()
	}
	emit() {
		this.emitter.emit("scroll", this)
	}
	reset() {
		this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
	}
	start() {
		this.isStopped && (this.isStopped = !1, this.reset())
	}
	stop() {
		this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
	}
	raf(e) {
		const t = e - (this.time || e);
		this.time = e, this.animate.advance(.001 * t)
	}
	scrollTo(e, {
		offset: t = 0,
		immediate: i = !1,
		lock: r = !1,
		duration: s = this.options.duration,
		easing: o = this.options.easing,
		lerp: a = !s && this.options.lerp,
		onComplete: l,
		force: c = !1,
		programmatic: u = !0
	} = {}) {
		if (!this.isStopped && !this.isLocked || c) {
			if (["top", "left", "start"].includes(e)) e = 0;
			else if (["bottom", "right", "end"].includes(e)) e = this.limit;
			else {
				let h;
				if (typeof e == "string" ? h = document.querySelector(e) : e != null && e.nodeType && (h = e), h) {
					if (this.options.wrapper !== window) {
						const f = this.options.wrapper.getBoundingClientRect();
						t -= this.isHorizontal ? f.left : f.top
					}
					const d = h.getBoundingClientRect();
					e = (this.isHorizontal ? d.left : d.top) + this.animatedScroll
				}
			}
			if (typeof e == "number") {
				if (e += t, e = Math.round(e), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : e = uD(0, e, this.limit), i) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void(l == null || l(this));
				if (!u) {
					if (e === this.targetScroll) return;
					this.targetScroll = e
				}
				this.animate.fromTo(this.animatedScroll, e, {
					duration: s,
					easing: o,
					lerp: a,
					onStart: () => {
						r && (this.isLocked = !0), this.isScrolling = !0
					},
					onUpdate: (h, d) => {
						this.isScrolling = !0, this.velocity = h - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = h, this.setScroll(this.scroll), u && (this.targetScroll = h), d || this.emit(), d && (this.reset(), this.emit(), l == null || l(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {
							delete this.__preventNextScrollEvent
						}))
					}
				})
			}
		}
	}
	get rootElement() {
		return this.options.wrapper === window ? document.documentElement : this.options.wrapper
	}
	get limit() {
		return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
	}
	get isHorizontal() {
		return this.options.orientation === "horizontal"
	}
	get actualScroll() {
		return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
	}
	get scroll() {
		return this.options.infinite ? (e = this.animatedScroll, t = this.limit, (e % t + t) % t) : this.animatedScroll;
		var e, t
	}
	get progress() {
		return this.limit === 0 ? 1 : this.scroll / this.limit
	}
	get isSmooth() {
		return this.__isSmooth
	}
	set isSmooth(e) {
		this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClassName("lenis-smooth", e))
	}
	get isScrolling() {
		return this.__isScrolling
	}
	set isScrolling(e) {
		this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClassName("lenis-scrolling", e))
	}
	get isStopped() {
		return this.__isStopped
	}
	set isStopped(e) {
		this.__isStopped !== e && (this.__isStopped = e, this.toggleClassName("lenis-stopped", e))
	}
	get isLocked() {
		return this.__isLocked
	}
	set isLocked(e) {
		this.__isLocked !== e && (this.__isLocked = e, this.toggleClassName("lenis-locked", e))
	}
	get className() {
		let e = "lenis";
		return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
	}
	toggleClassName(e, t) {
		this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this)
	}
}
const Ct = V3("app", {
		state: () => ({
			windowSize: {
				width: 0,
				height: 0
			},
			isNavOpen: !1,
			isContactModalOpen: !1,
			isTouch: !1,
			isFontLoaded: !1,
			isLoaderDone: !1,
			triggerThreshold: "top 70%",
			isTransitioning: !1,
			isTransitionBlurVisible: !1,
			isCanvasVisible: !1,
			isCanvasAbsolute: !1,
			isCursorPointer: !1,
			isCurtainDark: !1,
			hasCurtainFadeIn: !1,
			isModalOpen: !1,
			scrollMode: null
		}),
		getters: {},
		actions: {
			setScrollMode(n) {
				this.scrollMode = n
			},
			setCursorPointer(n) {
				this.isCursorPointer = n
			},
			setCanvasAbsolute(n) {
				this.isCanvasAbsolute = n
			},
			setCanvasVisible(n) {
				this.isCanvasVisible = n
			},
			setWindowSize({
				width: n,
				height: e
			}) {
				this.windowSize = {
					width: n,
					height: e
				}
			},
			setIsTouch(n) {
				this.isTouch = n
			},
			setIsNavOpen() {
				this.isNavOpen = !this.isNavOpen
			},
			setIsLoaderDone() {
				this.isLoaderDone = !this.isLoaderDone
			},
			setIsTransitioning() {
				this.isTransitioning = !this.isTransitioning
			},
			setIsTransitionBlurVisible() {
				this.isTransitionBlurVisible = !this.isTransitionBlurVisible
			},
			setIsCurtainDark(n = !1) {
				this.isCurtainDark = n
			},
			setHasCurtainFadeIn(n = !1) {
				this.hasCurtainFadeIn = n
			},
			setIsContactModalOpen() {
				this.isContactModalOpen = !this.isContactModalOpen
			},
			setIsModalOpen() {
				this.isModalOpen = !this.isModalOpen
			},
			setIsFontLoaded() {
				this.isFontLoaded = !0
			},
			clear() {
				this.$reset()
			}
		}
	}),
	yz = un({
		name: "lenis",
		parallel: !0,
		dependsOn: ["viewport"],
		async setup(n) {
			const {
				$viewport: e
			} = Ke(), t = Ct(), i = e.width < 768;
			t.setScrollMode(i ? "mobile" : "desktop");
			const r = new bz({
				wrapper: i ? document.querySelector("main") : window,
				duration: .8,
				syncTouch: !1,
				easing: l => 1 - Math.pow(1 - l, 4)
			});
			window.scrollTo(0, 0);
			const s = l => {
				at.update(), n.callHook("SCROLL:UPDATE", {
					progress: l.scroll,
					velocity: l.velocity
				})
			};
			r.on("scroll", s);
			const o = (l, c, u) => {
					r.raf(l * 1e3)
				},
				a = () => {
					r.options.wrapper = i ? document.querySelector("main") : window
				};
			return n.hook("WINDOW:RESIZE", a), n.hook("WINDOW:ORIENTATION", () => {
				r.scrollTo(0, 0), window.scrollTo(0, 0)
			}), lt.ticker.add(o), {
				provide: {
					lenis: r
				}
			}
		}
	});

function Mv() {
	let n, e;
	const t = new Promise((i, r) => {
		n = i, e = r
	});
	return t.resolve = n, t.reject = e, t
}

function xz(n, e = 1, t = {}, i) {
	const r = t.bind || null,
		s = t.trail != null ? !!t.trail : !0;
	t.tail != null && t.tail;
	let o, a, l, c = null,
		u = s,
		h = !1;

	function d() {
		c = null, s && !h && (u = !0), n.call(r, o, a, l)
	}
	return function (f, p, _) {
		clearTimeout(c), c = null, o = f, a = p, l = _, s && u && (u = !1, n.call(r, o, a, l)), c === null && (c = setTimeout(d, e))
	}
}
const wz = un({
		name: "preloader",
		parallel: !0,
		async setup() {
			let n = 0,
				e = 0,
				t = !1,
				i, r = Promise.resolve();
			const {
				callHook: s
			} = Ke(), o = Mv(), a = Mv(), l = Ii({
				progress: 0,
				taskCount: 0,
				taskFinished: 0,
				finished: !1,
				hidden: !1,
				destroyed: !1,
				onEnter: o,
				onLeave: a,
				task: p,
				createTask: d
			});
			async function c() {
				t || (t = !0, s("PRELOADER:ASSETSLOADED"), Promise.resolve().then(() => o).then(() => l.finished = !0).then(() => s("PRELOADER:BEFOREEXIT")).then(() => a).then(() => f).then(() => l.destroyed = !0))
			}

			function u() {
				l.progress >= 1 && c()
			}

			function h(g) {
				e += g, l.taskCount = Math.max(n, e)
			}

			function d({
				weight: g = 1
			} = {}) {
				let m = !1;
				return h(g), {
					get finished() {
						return m
					},
					finish() {
						m || (m = !0, _(g))
					}
				}
			}

			function f() {
				i && i(), l.hidden = !0
			}

			function p(g, {
				weight: m = 1,
				graceful: b = !0
			} = {}) {
				return h(m), r.then(() => typeof g == "function" ? g() : g).then(v => (_(m), v)).catch(v => {
					console.error(v), b && _(m)
				})
			}

			function _(g) {
				l.taskFinished += g;
				const m = l.taskFinished / l.taskCount;
				l.progress = Math.max(0, Math.min(1, Math.max(l.progress, m)))
			}
			return i = GR(() => u(l.progress)), {
				provide: {
					preloader: l
				}
			}
		}
	}),
	Ez = un(async n => {
		const e = Sr(),
			{
				setIsCurtainDark: t,
				setHasCurtainFadeIn: i
			} = Ct();
		e.beforeEach((r, s) => {
			s.name !== r.name && (r.name === "lab" || r.name === "about") ? t(!0) : t(!1), s.name !== r.name && r.name === "index" ? i(!0) : i(!1)
		})
	}),
	Sz = un({
		name: "serviceworker",
		parallel: !0,
		async setup() {
			var n, e;
			(e = (n = navigator == null ? void 0 : navigator.serviceWorker) == null ? void 0 : n.getRegistrations()) == null || e.then(t => {
				t == null || t.forEach(i => {
					i == null || i.unregister()
				})
			})
		}
	});
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Mb = "162",
	jl = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	},
	$l = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	},
	Tz = 0,
	Qw = 1,
	Mz = 2,
	dD = 1,
	Cz = 2,
	js = 3,
	fo = 0,
	ji = 1,
	_r = 2,
	ua = 0,
	ha = 1,
	e2 = 2,
	t2 = 3,
	n2 = 4,
	Az = 5,
	Ja = 100,
	Dz = 101,
	Pz = 102,
	i2 = 103,
	r2 = 104,
	Rz = 200,
	Lz = 201,
	kz = 202,
	Iz = 203,
	Cv = 204,
	Av = 205,
	Oz = 206,
	Fz = 207,
	Nz = 208,
	Uz = 209,
	Bz = 210,
	zz = 211,
	Vz = 212,
	Hz = 213,
	Gz = 214,
	Wz = 0,
	jz = 1,
	$z = 2,
	tm = 3,
	qz = 4,
	Xz = 5,
	Yz = 6,
	Kz = 7,
	fD = 0,
	Zz = 1,
	Jz = 2,
	da = 0,
	Qz = 1,
	eV = 2,
	tV = 3,
	nV = 4,
	iV = 5,
	rV = 6,
	sV = 7,
	s2 = "attached",
	oV = "detached",
	pD = 300,
	su = 301,
	ou = 302,
	cd = 303,
	Dv = 304,
	Km = 306,
	ya = 1e3,
	Nr = 1001,
	nm = 1002,
	$n = 1003,
	Pv = 1004,
	mc = 1005,
	jn = 1006,
	vp = 1007,
	Qs = 1008,
	fa = 1009,
	aV = 1010,
	lV = 1011,
	Cb = 1012,
	mD = 1013,
	Qo = 1014,
	ns = 1015,
	au = 1016,
	gD = 1017,
	_D = 1018,
	vl = 1020,
	cV = 1021,
	vr = 1023,
	uV = 1024,
	hV = 1025,
	bl = 1026,
	lu = 1027,
	Lh = 1028,
	vD = 1029,
	bD = 1030,
	yD = 1031,
	xD = 1033,
	ag = 33776,
	lg = 33777,
	cg = 33778,
	ug = 33779,
	o2 = 35840,
	a2 = 35841,
	l2 = 35842,
	c2 = 35843,
	wD = 36196,
	u2 = 37492,
	h2 = 37496,
	d2 = 37808,
	f2 = 37809,
	p2 = 37810,
	m2 = 37811,
	g2 = 37812,
	_2 = 37813,
	v2 = 37814,
	b2 = 37815,
	y2 = 37816,
	x2 = 37817,
	w2 = 37818,
	E2 = 37819,
	S2 = 37820,
	T2 = 37821,
	hg = 36492,
	M2 = 36494,
	C2 = 36495,
	dV = 36283,
	A2 = 36284,
	D2 = 36285,
	P2 = 36286,
	ud = 2300,
	cu = 2301,
	dg = 2302,
	R2 = 2400,
	L2 = 2401,
	k2 = 2402,
	fV = 2500,
	pV = 0,
	ED = 1,
	Rv = 2,
	mV = 3200,
	gV = 3201,
	SD = 0,
	_V = 1,
	jo = "",
	qn = "srgb",
	Jn = "srgb-linear",
	Ab = "display-p3",
	Zm = "display-p3-linear",
	im = "linear",
	Qt = "srgb",
	rm = "rec709",
	sm = "p3",
	ql = 7680,
	I2 = 519,
	vV = 512,
	bV = 513,
	yV = 514,
	TD = 515,
	xV = 516,
	wV = 517,
	EV = 518,
	SV = 519,
	om = 35044,
	TV = 35048,
	O2 = "300 es",
	Lv = 1035,
	eo = 2e3,
	am = 2001;
class Ol {
	addEventListener(e, t) {
		this._listeners === void 0 && (this._listeners = {});
		const i = this._listeners;
		i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
	}
	hasEventListener(e, t) {
		if (this._listeners === void 0) return !1;
		const i = this._listeners;
		return i[e] !== void 0 && i[e].indexOf(t) !== -1
	}
	removeEventListener(e, t) {
		if (this._listeners === void 0) return;
		const r = this._listeners[e];
		if (r !== void 0) {
			const s = r.indexOf(t);
			s !== -1 && r.splice(s, 1)
		}
	}
	dispatchEvent(e) {
		if (this._listeners === void 0) return;
		const i = this._listeners[e.type];
		if (i !== void 0) {
			e.target = this;
			const r = i.slice(0);
			for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
			e.target = null
		}
	}
}
const ai = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let F2 = 1234567;
const kh = Math.PI / 180,
	uu = 180 / Math.PI;

function rs() {
	const n = Math.random() * 4294967295 | 0,
		e = Math.random() * 4294967295 | 0,
		t = Math.random() * 4294967295 | 0,
		i = Math.random() * 4294967295 | 0;
	return (ai[n & 255] + ai[n >> 8 & 255] + ai[n >> 16 & 255] + ai[n >> 24 & 255] + "-" + ai[e & 255] + ai[e >> 8 & 255] + "-" + ai[e >> 16 & 15 | 64] + ai[e >> 24 & 255] + "-" + ai[t & 63 | 128] + ai[t >> 8 & 255] + "-" + ai[t >> 16 & 255] + ai[t >> 24 & 255] + ai[i & 255] + ai[i >> 8 & 255] + ai[i >> 16 & 255] + ai[i >> 24 & 255]).toLowerCase()
}

function ti(n, e, t) {
	return Math.max(e, Math.min(t, n))
}

function Db(n, e) {
	return (n % e + e) % e
}

function MV(n, e, t, i, r) {
	return i + (n - e) * (r - i) / (t - e)
}

function CV(n, e, t) {
	return n !== e ? (t - n) / (e - n) : 0
}

function Ih(n, e, t) {
	return (1 - t) * n + t * e
}

function AV(n, e, t, i) {
	return Ih(n, e, 1 - Math.exp(-t * i))
}

function DV(n, e = 1) {
	return e - Math.abs(Db(n, e * 2) - e)
}

function PV(n, e, t) {
	return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n))
}

function RV(n, e, t) {
	return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10))
}

function LV(n, e) {
	return n + Math.floor(Math.random() * (e - n + 1))
}

function kV(n, e) {
	return n + Math.random() * (e - n)
}

function IV(n) {
	return n * (.5 - Math.random())
}

function OV(n) {
	n !== void 0 && (F2 = n);
	let e = F2 += 1831565813;
	return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function FV(n) {
	return n * kh
}

function NV(n) {
	return n * uu
}

function kv(n) {
	return (n & n - 1) === 0 && n !== 0
}

function UV(n) {
	return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}

function lm(n) {
	return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}

function BV(n, e, t, i, r) {
	const s = Math.cos,
		o = Math.sin,
		a = s(t / 2),
		l = o(t / 2),
		c = s((e + i) / 2),
		u = o((e + i) / 2),
		h = s((e - i) / 2),
		d = o((e - i) / 2),
		f = s((i - e) / 2),
		p = o((i - e) / 2);
	switch (r) {
		case "XYX":
			n.set(a * u, l * h, l * d, a * c);
			break;
		case "YZY":
			n.set(l * d, a * u, l * h, a * c);
			break;
		case "ZXZ":
			n.set(l * h, l * d, a * u, a * c);
			break;
		case "XZX":
			n.set(a * u, l * p, l * f, a * c);
			break;
		case "YXY":
			n.set(l * f, a * u, l * p, a * c);
			break;
		case "ZYZ":
			n.set(l * p, l * f, a * u, a * c);
			break;
		default:
			console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
	}
}

function is(n, e) {
	switch (e.constructor) {
		case Float32Array:
			return n;
		case Uint32Array:
			return n / 4294967295;
		case Uint16Array:
			return n / 65535;
		case Uint8Array:
			return n / 255;
		case Int32Array:
			return Math.max(n / 2147483647, -1);
		case Int16Array:
			return Math.max(n / 32767, -1);
		case Int8Array:
			return Math.max(n / 127, -1);
		default:
			throw new Error("Invalid component type.")
	}
}

function Bt(n, e) {
	switch (e.constructor) {
		case Float32Array:
			return n;
		case Uint32Array:
			return Math.round(n * 4294967295);
		case Uint16Array:
			return Math.round(n * 65535);
		case Uint8Array:
			return Math.round(n * 255);
		case Int32Array:
			return Math.round(n * 2147483647);
		case Int16Array:
			return Math.round(n * 32767);
		case Int8Array:
			return Math.round(n * 127);
		default:
			throw new Error("Invalid component type.")
	}
}
const MD = {
	DEG2RAD: kh,
	RAD2DEG: uu,
	generateUUID: rs,
	clamp: ti,
	euclideanModulo: Db,
	mapLinear: MV,
	inverseLerp: CV,
	lerp: Ih,
	damp: AV,
	pingpong: DV,
	smoothstep: PV,
	smootherstep: RV,
	randInt: LV,
	randFloat: kV,
	randFloatSpread: IV,
	seededRandom: OV,
	degToRad: FV,
	radToDeg: NV,
	isPowerOfTwo: kv,
	ceilPowerOfTwo: UV,
	floorPowerOfTwo: lm,
	setQuaternionFromProperEuler: BV,
	normalize: Bt,
	denormalize: is
};
class Oe {
	constructor(e = 0, t = 0) {
		Oe.prototype.isVector2 = !0, this.x = e, this.y = t
	}
	get width() {
		return this.x
	}
	set width(e) {
		this.x = e
	}
	get height() {
		return this.y
	}
	set height(e) {
		this.y = e
	}
	set(e, t) {
		return this.x = e, this.y = t, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this
	}
	add(e) {
		return this.x += e.x, this.y += e.y, this
	}
	addScalar(e) {
		return this.x += e, this.y += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this
	}
	sub(e) {
		return this.x -= e.x, this.y -= e.y, this
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this
	}
	multiply(e) {
		return this.x *= e.x, this.y *= e.y, this
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this
	}
	divide(e) {
		return this.x /= e.x, this.y /= e.y, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	applyMatrix3(e) {
		const t = this.x,
			i = this.y,
			r = e.elements;
		return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y
	}
	cross(e) {
		return this.x * e.y - this.y * e.x
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (t === 0) return Math.PI / 2;
		const i = this.dot(e) / t;
		return Math.acos(ti(i, -1, 1))
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e))
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			i = this.y - e.y;
		return t * t + i * i
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
	}
	lerpVectors(e, t, i) {
		return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
	}
	equals(e) {
		return e.x === this.x && e.y === this.y
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e
	}
	fromBufferAttribute(e, t) {
		return this.x = e.getX(t), this.y = e.getY(t), this
	}
	rotateAround(e, t) {
		const i = Math.cos(t),
			r = Math.sin(t),
			s = this.x - e.x,
			o = this.y - e.y;
		return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y
	}
}
class gt {
	constructor(e, t, i, r, s, o, a, l, c) {
		gt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, c)
	}
	set(e, t, i, r, s, o, a, l, c) {
		const u = this.elements;
		return u[0] = e, u[1] = r, u[2] = a, u[3] = t, u[4] = s, u[5] = l, u[6] = i, u[7] = o, u[8] = c, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
	}
	copy(e) {
		const t = this.elements,
			i = e.elements;
		return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
	}
	extractBasis(e, t, i) {
		return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
	}
	setFromMatrix4(e) {
		const t = e.elements;
		return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
	}
	multiply(e) {
		return this.multiplyMatrices(this, e)
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this)
	}
	multiplyMatrices(e, t) {
		const i = e.elements,
			r = t.elements,
			s = this.elements,
			o = i[0],
			a = i[3],
			l = i[6],
			c = i[1],
			u = i[4],
			h = i[7],
			d = i[2],
			f = i[5],
			p = i[8],
			_ = r[0],
			g = r[3],
			m = r[6],
			b = r[1],
			v = r[4],
			y = r[7],
			x = r[2],
			S = r[5],
			E = r[8];
		return s[0] = o * _ + a * b + l * x, s[3] = o * g + a * v + l * S, s[6] = o * m + a * y + l * E, s[1] = c * _ + u * b + h * x, s[4] = c * g + u * v + h * S, s[7] = c * m + u * y + h * E, s[2] = d * _ + f * b + p * x, s[5] = d * g + f * v + p * S, s[8] = d * m + f * y + p * E, this
	}
	multiplyScalar(e) {
		const t = this.elements;
		return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			r = e[2],
			s = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			u = e[8];
		return t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
	}
	invert() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			r = e[2],
			s = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			u = e[8],
			h = u * o - a * c,
			d = a * l - u * s,
			f = c * s - o * l,
			p = t * h + i * d + r * f;
		if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const _ = 1 / p;
		return e[0] = h * _, e[1] = (r * c - u * i) * _, e[2] = (a * i - r * o) * _, e[3] = d * _, e[4] = (u * t - r * l) * _, e[5] = (r * s - a * t) * _, e[6] = f * _, e[7] = (i * l - c * t) * _, e[8] = (o * t - i * s) * _, this
	}
	transpose() {
		let e;
		const t = this.elements;
		return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
	}
	getNormalMatrix(e) {
		return this.setFromMatrix4(e).invert().transpose()
	}
	transposeIntoArray(e) {
		const t = this.elements;
		return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
	}
	setUvTransform(e, t, i, r, s, o, a) {
		const l = Math.cos(s),
			c = Math.sin(s);
		return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1), this
	}
	scale(e, t) {
		return this.premultiply(fg.makeScale(e, t)), this
	}
	rotate(e) {
		return this.premultiply(fg.makeRotation(-e)), this
	}
	translate(e, t) {
		return this.premultiply(fg.makeTranslation(e, t)), this
	}
	makeTranslation(e, t) {
		return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
	}
	makeRotation(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
	}
	makeScale(e, t) {
		return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
	}
	equals(e) {
		const t = this.elements,
			i = e.elements;
		for (let r = 0; r < 9; r++)
			if (t[r] !== i[r]) return !1;
		return !0
	}
	fromArray(e, t = 0) {
		for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
		return this
	}
	toArray(e = [], t = 0) {
		const i = this.elements;
		return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
	}
	clone() {
		return new this.constructor().fromArray(this.elements)
	}
}
const fg = new gt;

function CD(n) {
	for (let e = n.length - 1; e >= 0; --e)
		if (n[e] >= 65535) return !0;
	return !1
}

function hd(n) {
	return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}

function zV() {
	const n = hd("canvas");
	return n.style.display = "block", n
}
const N2 = {};

function AD(n) {
	n in N2 || (N2[n] = !0, console.warn(n))
}
const U2 = new gt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
	B2 = new gt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
	yf = {
		[Jn]: {
			transfer: im,
			primaries: rm,
			toReference: n => n,
			fromReference: n => n
		},
		[qn]: {
			transfer: Qt,
			primaries: rm,
			toReference: n => n.convertSRGBToLinear(),
			fromReference: n => n.convertLinearToSRGB()
		},
		[Zm]: {
			transfer: im,
			primaries: sm,
			toReference: n => n.applyMatrix3(B2),
			fromReference: n => n.applyMatrix3(U2)
		},
		[Ab]: {
			transfer: Qt,
			primaries: sm,
			toReference: n => n.convertSRGBToLinear().applyMatrix3(B2),
			fromReference: n => n.applyMatrix3(U2).convertLinearToSRGB()
		}
	},
	VV = new Set([Jn, Zm]),
	Lt = {
		enabled: !0,
		_workingColorSpace: Jn,
		get workingColorSpace() {
			return this._workingColorSpace
		},
		set workingColorSpace(n) {
			if (!VV.has(n)) throw new Error(`Unsupported working color space, "${n}".`);
			this._workingColorSpace = n
		},
		convert: function (n, e, t) {
			if (this.enabled === !1 || e === t || !e || !t) return n;
			const i = yf[e].toReference,
				r = yf[t].fromReference;
			return r(i(n))
		},
		fromWorkingColorSpace: function (n, e) {
			return this.convert(n, this._workingColorSpace, e)
		},
		toWorkingColorSpace: function (n, e) {
			return this.convert(n, e, this._workingColorSpace)
		},
		getPrimaries: function (n) {
			return yf[n].primaries
		},
		getTransfer: function (n) {
			return n === jo ? im : yf[n].transfer
		}
	};

function Bc(n) {
	return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}

function pg(n) {
	return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Xl;
class DD {
	static getDataURL(e) {
		if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
		let t;
		if (e instanceof HTMLCanvasElement) t = e;
		else {
			Xl === void 0 && (Xl = hd("canvas")), Xl.width = e.width, Xl.height = e.height;
			const i = Xl.getContext("2d");
			e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Xl
		}
		return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
	}
	static sRGBToLinear(e) {
		if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
			const t = hd("canvas");
			t.width = e.width, t.height = e.height;
			const i = t.getContext("2d");
			i.drawImage(e, 0, 0, e.width, e.height);
			const r = i.getImageData(0, 0, e.width, e.height),
				s = r.data;
			for (let o = 0; o < s.length; o++) s[o] = Bc(s[o] / 255) * 255;
			return i.putImageData(r, 0, 0), t
		} else if (e.data) {
			const t = e.data.slice(0);
			for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Bc(t[i] / 255) * 255) : t[i] = Bc(t[i]);
			return {
				data: t,
				width: e.width,
				height: e.height
			}
		} else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
	}
}
let HV = 0;
class PD {
	constructor(e = null) {
		this.isSource = !0, Object.defineProperty(this, "id", {
			value: HV++
		}), this.uuid = rs(), this.data = e, this.dataReady = !0, this.version = 0
	}
	set needsUpdate(e) {
		e === !0 && this.version++
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == "string";
		if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
		const i = {
				uuid: this.uuid,
				url: ""
			},
			r = this.data;
		if (r !== null) {
			let s;
			if (Array.isArray(r)) {
				s = [];
				for (let o = 0, a = r.length; o < a; o++) r[o].isDataTexture ? s.push(mg(r[o].image)) : s.push(mg(r[o]))
			} else s = mg(r);
			i.url = s
		}
		return t || (e.images[this.uuid] = i), i
	}
}

function mg(n) {
	return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? DD.getDataURL(n) : n.data ? {
		data: Array.from(n.data),
		width: n.width,
		height: n.height,
		type: n.data.constructor.name
	} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let GV = 0;
class Kn extends Ol {
	constructor(e = Kn.DEFAULT_IMAGE, t = Kn.DEFAULT_MAPPING, i = Nr, r = Nr, s = jn, o = Qs, a = vr, l = fa, c = Kn.DEFAULT_ANISOTROPY, u = jo) {
		super(), this.isTexture = !0, Object.defineProperty(this, "id", {
			value: GV++
		}), this.uuid = rs(), this.name = "", this.source = new PD(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Oe(0, 0), this.repeat = new Oe(1, 1), this.center = new Oe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new gt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
	}
	get image() {
		return this.source.data
	}
	set image(e = null) {
		this.source.data = e
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == "string";
		if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
		const i = {
			metadata: {
				version: 4.6,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(e).uuid,
			mapping: this.mapping,
			channel: this.channel,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	transformUv(e) {
		if (this.mapping !== pD) return e;
		if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
			case ya:
				e.x = e.x - Math.floor(e.x);
				break;
			case Nr:
				e.x = e.x < 0 ? 0 : 1;
				break;
			case nm:
				Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
				break
		}
		if (e.y < 0 || e.y > 1) switch (this.wrapT) {
			case ya:
				e.y = e.y - Math.floor(e.y);
				break;
			case Nr:
				e.y = e.y < 0 ? 0 : 1;
				break;
			case nm:
				Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
				break
		}
		return this.flipY && (e.y = 1 - e.y), e
	}
	set needsUpdate(e) {
		e === !0 && (this.version++, this.source.needsUpdate = !0)
	}
}
Kn.DEFAULT_IMAGE = null;
Kn.DEFAULT_MAPPING = pD;
Kn.DEFAULT_ANISOTROPY = 1;
class kt {
	constructor(e = 0, t = 0, i = 0, r = 1) {
		kt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r
	}
	get width() {
		return this.z
	}
	set width(e) {
		this.z = e
	}
	get height() {
		return this.w
	}
	set height(e) {
		this.w = e
	}
	set(e, t, i, r) {
		return this.x = e, this.y = t, this.z = i, this.w = r, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this.z = e, this.w = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setZ(e) {
		return this.z = e, this
	}
	setW(e) {
		return this.w = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			case 3:
				this.w = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
	}
	add(e) {
		return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
	}
	addScalar(e) {
		return this.x += e, this.y += e, this.z += e, this.w += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
	}
	sub(e) {
		return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
	}
	multiply(e) {
		return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
	}
	applyMatrix4(e) {
		const t = this.x,
			i = this.y,
			r = this.z,
			s = this.w,
			o = e.elements;
		return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	setAxisAngleFromQuaternion(e) {
		this.w = 2 * Math.acos(e.w);
		const t = Math.sqrt(1 - e.w * e.w);
		return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
	}
	setAxisAngleFromRotationMatrix(e) {
		let t, i, r, s;
		const l = e.elements,
			c = l[0],
			u = l[4],
			h = l[8],
			d = l[1],
			f = l[5],
			p = l[9],
			_ = l[2],
			g = l[6],
			m = l[10];
		if (Math.abs(u - d) < .01 && Math.abs(h - _) < .01 && Math.abs(p - g) < .01) {
			if (Math.abs(u + d) < .1 && Math.abs(h + _) < .1 && Math.abs(p + g) < .1 && Math.abs(c + f + m - 3) < .1) return this.set(1, 0, 0, 0), this;
			t = Math.PI;
			const v = (c + 1) / 2,
				y = (f + 1) / 2,
				x = (m + 1) / 2,
				S = (u + d) / 4,
				E = (h + _) / 4,
				C = (p + g) / 4;
			return v > y && v > x ? v < .01 ? (i = 0, r = .707106781, s = .707106781) : (i = Math.sqrt(v), r = S / i, s = E / i) : y > x ? y < .01 ? (i = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(y), i = S / r, s = C / r) : x < .01 ? (i = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(x), i = E / s, r = C / s), this.set(i, r, s, t), this
		}
		let b = Math.sqrt((g - p) * (g - p) + (h - _) * (h - _) + (d - u) * (d - u));
		return Math.abs(b) < .001 && (b = 1), this.x = (g - p) / b, this.y = (h - _) / b, this.z = (d - u) / b, this.w = Math.acos((c + f + m - 1) / 2), this
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
	}
	lerpVectors(e, t, i) {
		return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
	}
	fromBufferAttribute(e, t) {
		return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w
	}
}
class WV extends Ol {
	constructor(e = 1, t = 1, i = {}) {
		super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new kt(0, 0, e, t);
		const r = {
			width: e,
			height: t,
			depth: 1
		};
		i = Object.assign({
			generateMipmaps: !1,
			internalFormat: null,
			minFilter: jn,
			depthBuffer: !0,
			stencilBuffer: !1,
			depthTexture: null,
			samples: 0,
			count: 1
		}, i);
		const s = new Kn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
		s.flipY = !1, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
		const o = i.count;
		for (let a = 0; a < o; a++) this.textures[a] = s.clone(), this.textures[a].isRenderTargetTexture = !0;
		this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples
	}
	get texture() {
		return this.textures[0]
	}
	set texture(e) {
		this.textures[0] = e
	}
	setSize(e, t, i = 1) {
		if (this.width !== e || this.height !== t || this.depth !== i) {
			this.width = e, this.height = t, this.depth = i;
			for (let r = 0, s = this.textures.length; r < s; r++) this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = i;
			this.dispose()
		}
		this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
		for (let i = 0, r = e.textures.length; i < r; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
		const t = Object.assign({}, e.texture.image);
		return this.texture.source = new PD(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
class xa extends WV {
	constructor(e = 1, t = 1, i = {}) {
		super(e, t, i), this.isWebGLRenderTarget = !0
	}
}
class RD extends Kn {
	constructor(e = null, t = 1, i = 1, r = 1) {
		super(null), this.isDataArrayTexture = !0, this.image = {
			data: e,
			width: t,
			height: i,
			depth: r
		}, this.magFilter = $n, this.minFilter = $n, this.wrapR = Nr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
class jV extends Kn {
	constructor(e = null, t = 1, i = 1, r = 1) {
		super(null), this.isData3DTexture = !0, this.image = {
			data: e,
			width: t,
			height: i,
			depth: r
		}, this.magFilter = $n, this.minFilter = $n, this.wrapR = Nr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
class qr {
	constructor(e = 0, t = 0, i = 0, r = 1) {
		this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r
	}
	static slerpFlat(e, t, i, r, s, o, a) {
		let l = i[r + 0],
			c = i[r + 1],
			u = i[r + 2],
			h = i[r + 3];
		const d = s[o + 0],
			f = s[o + 1],
			p = s[o + 2],
			_ = s[o + 3];
		if (a === 0) {
			e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
			return
		}
		if (a === 1) {
			e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = _;
			return
		}
		if (h !== _ || l !== d || c !== f || u !== p) {
			let g = 1 - a;
			const m = l * d + c * f + u * p + h * _,
				b = m >= 0 ? 1 : -1,
				v = 1 - m * m;
			if (v > Number.EPSILON) {
				const x = Math.sqrt(v),
					S = Math.atan2(x, m * b);
				g = Math.sin(g * S) / x, a = Math.sin(a * S) / x
			}
			const y = a * b;
			if (l = l * g + d * y, c = c * g + f * y, u = u * g + p * y, h = h * g + _ * y, g === 1 - a) {
				const x = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
				l *= x, c *= x, u *= x, h *= x
			}
		}
		e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h
	}
	static multiplyQuaternionsFlat(e, t, i, r, s, o) {
		const a = i[r],
			l = i[r + 1],
			c = i[r + 2],
			u = i[r + 3],
			h = s[o],
			d = s[o + 1],
			f = s[o + 2],
			p = s[o + 3];
		return e[t] = a * p + u * h + l * f - c * d, e[t + 1] = l * p + u * d + c * h - a * f, e[t + 2] = c * p + u * f + a * d - l * h, e[t + 3] = u * p - a * h - l * d - c * f, e
	}
	get x() {
		return this._x
	}
	set x(e) {
		this._x = e, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(e) {
		this._y = e, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(e) {
		this._z = e, this._onChangeCallback()
	}
	get w() {
		return this._w
	}
	set w(e) {
		this._w = e, this._onChangeCallback()
	}
	set(e, t, i, r) {
		return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w)
	}
	copy(e) {
		return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
	}
	setFromEuler(e, t = !0) {
		const i = e._x,
			r = e._y,
			s = e._z,
			o = e._order,
			a = Math.cos,
			l = Math.sin,
			c = a(i / 2),
			u = a(r / 2),
			h = a(s / 2),
			d = l(i / 2),
			f = l(r / 2),
			p = l(s / 2);
		switch (o) {
			case "XYZ":
				this._x = d * u * h + c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h - d * f * p;
				break;
			case "YXZ":
				this._x = d * u * h + c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h + d * f * p;
				break;
			case "ZXY":
				this._x = d * u * h - c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h - d * f * p;
				break;
			case "ZYX":
				this._x = d * u * h - c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h + d * f * p;
				break;
			case "YZX":
				this._x = d * u * h + c * f * p, this._y = c * f * h + d * u * p, this._z = c * u * p - d * f * h, this._w = c * u * h - d * f * p;
				break;
			case "XZY":
				this._x = d * u * h - c * f * p, this._y = c * f * h - d * u * p, this._z = c * u * p + d * f * h, this._w = c * u * h + d * f * p;
				break;
			default:
				console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
		}
		return t === !0 && this._onChangeCallback(), this
	}
	setFromAxisAngle(e, t) {
		const i = t / 2,
			r = Math.sin(i);
		return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this
	}
	setFromRotationMatrix(e) {
		const t = e.elements,
			i = t[0],
			r = t[4],
			s = t[8],
			o = t[1],
			a = t[5],
			l = t[9],
			c = t[2],
			u = t[6],
			h = t[10],
			d = i + a + h;
		if (d > 0) {
			const f = .5 / Math.sqrt(d + 1);
			this._w = .25 / f, this._x = (u - l) * f, this._y = (s - c) * f, this._z = (o - r) * f
		} else if (i > a && i > h) {
			const f = 2 * Math.sqrt(1 + i - a - h);
			this._w = (u - l) / f, this._x = .25 * f, this._y = (r + o) / f, this._z = (s + c) / f
		} else if (a > h) {
			const f = 2 * Math.sqrt(1 + a - i - h);
			this._w = (s - c) / f, this._x = (r + o) / f, this._y = .25 * f, this._z = (l + u) / f
		} else {
			const f = 2 * Math.sqrt(1 + h - i - a);
			this._w = (o - r) / f, this._x = (s + c) / f, this._y = (l + u) / f, this._z = .25 * f
		}
		return this._onChangeCallback(), this
	}
	setFromUnitVectors(e, t) {
		let i = e.dot(t) + 1;
		return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
	}
	angleTo(e) {
		return 2 * Math.acos(Math.abs(ti(this.dot(e), -1, 1)))
	}
	rotateTowards(e, t) {
		const i = this.angleTo(e);
		if (i === 0) return this;
		const r = Math.min(1, t / i);
		return this.slerp(e, r), this
	}
	identity() {
		return this.set(0, 0, 0, 1)
	}
	invert() {
		return this.conjugate()
	}
	conjugate() {
		return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
	}
	dot(e) {
		return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
	}
	normalize() {
		let e = this.length();
		return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
	}
	multiply(e) {
		return this.multiplyQuaternions(this, e)
	}
	premultiply(e) {
		return this.multiplyQuaternions(e, this)
	}
	multiplyQuaternions(e, t) {
		const i = e._x,
			r = e._y,
			s = e._z,
			o = e._w,
			a = t._x,
			l = t._y,
			c = t._z,
			u = t._w;
		return this._x = i * u + o * a + r * c - s * l, this._y = r * u + o * l + s * a - i * c, this._z = s * u + o * c + i * l - r * a, this._w = o * u - i * a - r * l - s * c, this._onChangeCallback(), this
	}
	slerp(e, t) {
		if (t === 0) return this;
		if (t === 1) return this.copy(e);
		const i = this._x,
			r = this._y,
			s = this._z,
			o = this._w;
		let a = o * e._w + i * e._x + r * e._y + s * e._z;
		if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this;
		const l = 1 - a * a;
		if (l <= Number.EPSILON) {
			const f = 1 - t;
			return this._w = f * o + t * this._w, this._x = f * i + t * this._x, this._y = f * r + t * this._y, this._z = f * s + t * this._z, this.normalize(), this
		}
		const c = Math.sqrt(l),
			u = Math.atan2(c, a),
			h = Math.sin((1 - t) * u) / c,
			d = Math.sin(t * u) / c;
		return this._w = o * h + this._w * d, this._x = i * h + this._x * d, this._y = r * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this
	}
	slerpQuaternions(e, t, i) {
		return this.copy(e).slerp(t, i)
	}
	random() {
		const e = 2 * Math.PI * Math.random(),
			t = 2 * Math.PI * Math.random(),
			i = Math.random(),
			r = Math.sqrt(1 - i),
			s = Math.sqrt(i);
		return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
	}
	fromArray(e, t = 0) {
		return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
	}
	toArray(e = [], t = 0) {
		return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
	}
	fromBufferAttribute(e, t) {
		return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
	}
	toJSON() {
		return this.toArray()
	}
	_onChange(e) {
		return this._onChangeCallback = e, this
	}
	_onChangeCallback() {}*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._w
	}
}
class X {
	constructor(e = 0, t = 0, i = 0) {
		X.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
	}
	set(e, t, i) {
		return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this.z = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setZ(e) {
		return this.z = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this.z = e.z, this
	}
	add(e) {
		return this.x += e.x, this.y += e.y, this.z += e.z, this
	}
	addScalar(e) {
		return this.x += e, this.y += e, this.z += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
	}
	sub(e) {
		return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this.z -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
	}
	multiply(e) {
		return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this.z *= e, this
	}
	multiplyVectors(e, t) {
		return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
	}
	applyEuler(e) {
		return this.applyQuaternion(z2.setFromEuler(e))
	}
	applyAxisAngle(e, t) {
		return this.applyQuaternion(z2.setFromAxisAngle(e, t))
	}
	applyMatrix3(e) {
		const t = this.x,
			i = this.y,
			r = this.z,
			s = e.elements;
		return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this
	}
	applyNormalMatrix(e) {
		return this.applyMatrix3(e).normalize()
	}
	applyMatrix4(e) {
		const t = this.x,
			i = this.y,
			r = this.z,
			s = e.elements,
			o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
		return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this
	}
	applyQuaternion(e) {
		const t = this.x,
			i = this.y,
			r = this.z,
			s = e.x,
			o = e.y,
			a = e.z,
			l = e.w,
			c = 2 * (o * r - a * i),
			u = 2 * (a * t - s * r),
			h = 2 * (s * i - o * t);
		return this.x = t + l * c + o * h - a * u, this.y = i + l * u + a * c - s * h, this.z = r + l * h + s * u - o * c, this
	}
	project(e) {
		return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
	}
	unproject(e) {
		return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
	}
	transformDirection(e) {
		const t = this.x,
			i = this.y,
			r = this.z,
			s = e.elements;
		return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize()
	}
	divide(e) {
		return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
	}
	clampLength(e, t) {
		const i = this.length();
		return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
	}
	lerpVectors(e, t, i) {
		return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
	}
	cross(e) {
		return this.crossVectors(this, e)
	}
	crossVectors(e, t) {
		const i = e.x,
			r = e.y,
			s = e.z,
			o = t.x,
			a = t.y,
			l = t.z;
		return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this
	}
	projectOnVector(e) {
		const t = e.lengthSq();
		if (t === 0) return this.set(0, 0, 0);
		const i = e.dot(this) / t;
		return this.copy(e).multiplyScalar(i)
	}
	projectOnPlane(e) {
		return gg.copy(this).projectOnVector(e), this.sub(gg)
	}
	reflect(e) {
		return this.sub(gg.copy(e).multiplyScalar(2 * this.dot(e)))
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (t === 0) return Math.PI / 2;
		const i = this.dot(e) / t;
		return Math.acos(ti(i, -1, 1))
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e))
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			i = this.y - e.y,
			r = this.z - e.z;
		return t * t + i * i + r * r
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
	}
	setFromSpherical(e) {
		return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
	}
	setFromSphericalCoords(e, t, i) {
		const r = Math.sin(t) * e;
		return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this
	}
	setFromCylindrical(e) {
		return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
	}
	setFromCylindricalCoords(e, t, i) {
		return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
	}
	setFromMatrixPosition(e) {
		const t = e.elements;
		return this.x = t[12], this.y = t[13], this.z = t[14], this
	}
	setFromMatrixScale(e) {
		const t = this.setFromMatrixColumn(e, 0).length(),
			i = this.setFromMatrixColumn(e, 1).length(),
			r = this.setFromMatrixColumn(e, 2).length();
		return this.x = t, this.y = i, this.z = r, this
	}
	setFromMatrixColumn(e, t) {
		return this.fromArray(e.elements, t * 4)
	}
	setFromMatrix3Column(e, t) {
		return this.fromArray(e.elements, t * 3)
	}
	setFromEuler(e) {
		return this.x = e._x, this.y = e._y, this.z = e._z, this
	}
	setFromColor(e) {
		return this.x = e.r, this.y = e.g, this.z = e.b, this
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
	}
	fromBufferAttribute(e, t) {
		return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
	}
	randomDirection() {
		const e = Math.random() * Math.PI * 2,
			t = Math.random() * 2 - 1,
			i = Math.sqrt(1 - t * t);
		return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z
	}
}
const gg = new X,
	z2 = new qr;
class ks {
	constructor(e = new X(1 / 0, 1 / 0, 1 / 0), t = new X(-1 / 0, -1 / 0, -1 / 0)) {
		this.isBox3 = !0, this.min = e, this.max = t
	}
	set(e, t) {
		return this.min.copy(e), this.max.copy(t), this
	}
	setFromArray(e) {
		this.makeEmpty();
		for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Yr.fromArray(e, t));
		return this
	}
	setFromBufferAttribute(e) {
		this.makeEmpty();
		for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Yr.fromBufferAttribute(e, t));
		return this
	}
	setFromPoints(e) {
		this.makeEmpty();
		for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
		return this
	}
	setFromCenterAndSize(e, t) {
		const i = Yr.copy(t).multiplyScalar(.5);
		return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
	}
	setFromObject(e, t = !1) {
		return this.makeEmpty(), this.expandByObject(e, t)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		return this.min.copy(e.min), this.max.copy(e.max), this
	}
	makeEmpty() {
		return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	}
	getCenter(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
	}
	getSize(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
	}
	expandByPoint(e) {
		return this.min.min(e), this.max.max(e), this
	}
	expandByVector(e) {
		return this.min.sub(e), this.max.add(e), this
	}
	expandByScalar(e) {
		return this.min.addScalar(-e), this.max.addScalar(e), this
	}
	expandByObject(e, t = !1) {
		e.updateWorldMatrix(!1, !1);
		const i = e.geometry;
		if (i !== void 0) {
			const s = i.getAttribute("position");
			if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
				for (let o = 0, a = s.count; o < a; o++) e.isMesh === !0 ? e.getVertexPosition(o, Yr) : Yr.fromBufferAttribute(s, o), Yr.applyMatrix4(e.matrixWorld), this.expandByPoint(Yr);
			else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), xf.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), xf.copy(i.boundingBox)), xf.applyMatrix4(e.matrixWorld), this.union(xf)
		}
		const r = e.children;
		for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
		return this
	}
	containsPoint(e) {
		return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
	}
	containsBox(e) {
		return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
	}
	getParameter(e, t) {
		return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
	}
	intersectsBox(e) {
		return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
	}
	intersectsSphere(e) {
		return this.clampPoint(e.center, Yr), Yr.distanceToSquared(e.center) <= e.radius * e.radius
	}
	intersectsPlane(e) {
		let t, i;
		return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
	}
	intersectsTriangle(e) {
		if (this.isEmpty()) return !1;
		this.getCenter(Bu), wf.subVectors(this.max, Bu), Yl.subVectors(e.a, Bu), Kl.subVectors(e.b, Bu), Zl.subVectors(e.c, Bu), To.subVectors(Kl, Yl), Mo.subVectors(Zl, Kl), Ua.subVectors(Yl, Zl);
		let t = [0, -To.z, To.y, 0, -Mo.z, Mo.y, 0, -Ua.z, Ua.y, To.z, 0, -To.x, Mo.z, 0, -Mo.x, Ua.z, 0, -Ua.x, -To.y, To.x, 0, -Mo.y, Mo.x, 0, -Ua.y, Ua.x, 0];
		return !_g(t, Yl, Kl, Zl, wf) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !_g(t, Yl, Kl, Zl, wf)) ? !1 : (Ef.crossVectors(To, Mo), t = [Ef.x, Ef.y, Ef.z], _g(t, Yl, Kl, Zl, wf))
	}
	clampPoint(e, t) {
		return t.copy(e).clamp(this.min, this.max)
	}
	distanceToPoint(e) {
		return this.clampPoint(e, Yr).distanceTo(e)
	}
	getBoundingSphere(e) {
		return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Yr).length() * .5), e
	}
	intersect(e) {
		return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
	}
	union(e) {
		return this.min.min(e.min), this.max.max(e.max), this
	}
	applyMatrix4(e) {
		return this.isEmpty() ? this : (Bs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Bs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Bs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Bs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Bs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Bs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Bs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Bs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Bs), this)
	}
	translate(e) {
		return this.min.add(e), this.max.add(e), this
	}
	equals(e) {
		return e.min.equals(this.min) && e.max.equals(this.max)
	}
}
const Bs = [new X, new X, new X, new X, new X, new X, new X, new X],
	Yr = new X,
	xf = new ks,
	Yl = new X,
	Kl = new X,
	Zl = new X,
	To = new X,
	Mo = new X,
	Ua = new X,
	Bu = new X,
	wf = new X,
	Ef = new X,
	Ba = new X;

function _g(n, e, t, i, r) {
	for (let s = 0, o = n.length - 3; s <= o; s += 3) {
		Ba.fromArray(n, s);
		const a = r.x * Math.abs(Ba.x) + r.y * Math.abs(Ba.y) + r.z * Math.abs(Ba.z),
			l = e.dot(Ba),
			c = t.dot(Ba),
			u = i.dot(Ba);
		if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
	}
	return !0
}
const $V = new ks,
	zu = new X,
	vg = new X;
class Is {
	constructor(e = new X, t = -1) {
		this.isSphere = !0, this.center = e, this.radius = t
	}
	set(e, t) {
		return this.center.copy(e), this.radius = t, this
	}
	setFromPoints(e, t) {
		const i = this.center;
		t !== void 0 ? i.copy(t) : $V.setFromPoints(e).getCenter(i);
		let r = 0;
		for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
		return this.radius = Math.sqrt(r), this
	}
	copy(e) {
		return this.center.copy(e.center), this.radius = e.radius, this
	}
	isEmpty() {
		return this.radius < 0
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), this.radius = -1, this
	}
	containsPoint(e) {
		return e.distanceToSquared(this.center) <= this.radius * this.radius
	}
	distanceToPoint(e) {
		return e.distanceTo(this.center) - this.radius
	}
	intersectsSphere(e) {
		const t = this.radius + e.radius;
		return e.center.distanceToSquared(this.center) <= t * t
	}
	intersectsBox(e) {
		return e.intersectsSphere(this)
	}
	intersectsPlane(e) {
		return Math.abs(e.distanceToPoint(this.center)) <= this.radius
	}
	clampPoint(e, t) {
		const i = this.center.distanceToSquared(e);
		return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
	}
	getBoundingBox(e) {
		return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
	}
	applyMatrix4(e) {
		return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
	}
	translate(e) {
		return this.center.add(e), this
	}
	expandByPoint(e) {
		if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
		zu.subVectors(e, this.center);
		const t = zu.lengthSq();
		if (t > this.radius * this.radius) {
			const i = Math.sqrt(t),
				r = (i - this.radius) * .5;
			this.center.addScaledVector(zu, r / i), this.radius += r
		}
		return this
	}
	union(e) {
		return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (vg.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(zu.copy(e.center).add(vg)), this.expandByPoint(zu.copy(e.center).sub(vg))), this)
	}
	equals(e) {
		return e.center.equals(this.center) && e.radius === this.radius
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const zs = new X,
	bg = new X,
	Sf = new X,
	Co = new X,
	yg = new X,
	Tf = new X,
	xg = new X;
class Su {
	constructor(e = new X, t = new X(0, 0, -1)) {
		this.origin = e, this.direction = t
	}
	set(e, t) {
		return this.origin.copy(e), this.direction.copy(t), this
	}
	copy(e) {
		return this.origin.copy(e.origin), this.direction.copy(e.direction), this
	}
	at(e, t) {
		return t.copy(this.origin).addScaledVector(this.direction, e)
	}
	lookAt(e) {
		return this.direction.copy(e).sub(this.origin).normalize(), this
	}
	recast(e) {
		return this.origin.copy(this.at(e, zs)), this
	}
	closestPointToPoint(e, t) {
		t.subVectors(e, this.origin);
		const i = t.dot(this.direction);
		return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
	}
	distanceToPoint(e) {
		return Math.sqrt(this.distanceSqToPoint(e))
	}
	distanceSqToPoint(e) {
		const t = zs.subVectors(e, this.origin).dot(this.direction);
		return t < 0 ? this.origin.distanceToSquared(e) : (zs.copy(this.origin).addScaledVector(this.direction, t), zs.distanceToSquared(e))
	}
	distanceSqToSegment(e, t, i, r) {
		bg.copy(e).add(t).multiplyScalar(.5), Sf.copy(t).sub(e).normalize(), Co.copy(this.origin).sub(bg);
		const s = e.distanceTo(t) * .5,
			o = -this.direction.dot(Sf),
			a = Co.dot(this.direction),
			l = -Co.dot(Sf),
			c = Co.lengthSq(),
			u = Math.abs(1 - o * o);
		let h, d, f, p;
		if (u > 0)
			if (h = o * l - a, d = o * a - l, p = s * u, h >= 0)
				if (d >= -p)
					if (d <= p) {
						const _ = 1 / u;
						h *= _, d *= _, f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * l) + c
					} else d = s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
		else d = -s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
		else d <= -p ? (h = Math.max(0, -(-o * s + a)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), f = -h * h + d * (d + 2 * l) + c) : d <= p ? (h = 0, d = Math.min(Math.max(-s, -l), s), f = d * (d + 2 * l) + c) : (h = Math.max(0, -(o * s + a)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), f = -h * h + d * (d + 2 * l) + c);
		else d = o > 0 ? -s : s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + c;
		return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(bg).addScaledVector(Sf, d), f
	}
	intersectSphere(e, t) {
		zs.subVectors(e.center, this.origin);
		const i = zs.dot(this.direction),
			r = zs.dot(zs) - i * i,
			s = e.radius * e.radius;
		if (r > s) return null;
		const o = Math.sqrt(s - r),
			a = i - o,
			l = i + o;
		return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
	}
	intersectsSphere(e) {
		return this.distanceSqToPoint(e.center) <= e.radius * e.radius
	}
	distanceToPlane(e) {
		const t = e.normal.dot(this.direction);
		if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
		const i = -(this.origin.dot(e.normal) + e.constant) / t;
		return i >= 0 ? i : null
	}
	intersectPlane(e, t) {
		const i = this.distanceToPlane(e);
		return i === null ? null : this.at(i, t)
	}
	intersectsPlane(e) {
		const t = e.distanceToPoint(this.origin);
		return t === 0 || e.normal.dot(this.direction) * t < 0
	}
	intersectBox(e, t) {
		let i, r, s, o, a, l;
		const c = 1 / this.direction.x,
			u = 1 / this.direction.y,
			h = 1 / this.direction.z,
			d = this.origin;
		return c >= 0 ? (i = (e.min.x - d.x) * c, r = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, r = (e.min.x - d.x) * c), u >= 0 ? (s = (e.min.y - d.y) * u, o = (e.max.y - d.y) * u) : (s = (e.max.y - d.y) * u, o = (e.min.y - d.y) * u), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), h >= 0 ? (a = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (a = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t)
	}
	intersectsBox(e) {
		return this.intersectBox(e, zs) !== null
	}
	intersectTriangle(e, t, i, r, s) {
		yg.subVectors(t, e), Tf.subVectors(i, e), xg.crossVectors(yg, Tf);
		let o = this.direction.dot(xg),
			a;
		if (o > 0) {
			if (r) return null;
			a = 1
		} else if (o < 0) a = -1, o = -o;
		else return null;
		Co.subVectors(this.origin, e);
		const l = a * this.direction.dot(Tf.crossVectors(Co, Tf));
		if (l < 0) return null;
		const c = a * this.direction.dot(yg.cross(Co));
		if (c < 0 || l + c > o) return null;
		const u = -a * Co.dot(xg);
		return u < 0 ? null : this.at(u / o, s)
	}
	applyMatrix4(e) {
		return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
	}
	equals(e) {
		return e.origin.equals(this.origin) && e.direction.equals(this.direction)
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class pt {
	constructor(e, t, i, r, s, o, a, l, c, u, h, d, f, p, _, g) {
		pt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, h, d, f, p, _, g)
	}
	set(e, t, i, r, s, o, a, l, c, u, h, d, f, p, _, g) {
		const m = this.elements;
		return m[0] = e, m[4] = t, m[8] = i, m[12] = r, m[1] = s, m[5] = o, m[9] = a, m[13] = l, m[2] = c, m[6] = u, m[10] = h, m[14] = d, m[3] = f, m[7] = p, m[11] = _, m[15] = g, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	clone() {
		return new pt().fromArray(this.elements)
	}
	copy(e) {
		const t = this.elements,
			i = e.elements;
		return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
	}
	copyPosition(e) {
		const t = this.elements,
			i = e.elements;
		return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
	}
	setFromMatrix3(e) {
		const t = e.elements;
		return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
	}
	extractBasis(e, t, i) {
		return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
	}
	makeBasis(e, t, i) {
		return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
	}
	extractRotation(e) {
		const t = this.elements,
			i = e.elements,
			r = 1 / Jl.setFromMatrixColumn(e, 0).length(),
			s = 1 / Jl.setFromMatrixColumn(e, 1).length(),
			o = 1 / Jl.setFromMatrixColumn(e, 2).length();
		return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
	}
	makeRotationFromEuler(e) {
		const t = this.elements,
			i = e.x,
			r = e.y,
			s = e.z,
			o = Math.cos(i),
			a = Math.sin(i),
			l = Math.cos(r),
			c = Math.sin(r),
			u = Math.cos(s),
			h = Math.sin(s);
		if (e.order === "XYZ") {
			const d = o * u,
				f = o * h,
				p = a * u,
				_ = a * h;
			t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = f + p * c, t[5] = d - _ * c, t[9] = -a * l, t[2] = _ - d * c, t[6] = p + f * c, t[10] = o * l
		} else if (e.order === "YXZ") {
			const d = l * u,
				f = l * h,
				p = c * u,
				_ = c * h;
			t[0] = d + _ * a, t[4] = p * a - f, t[8] = o * c, t[1] = o * h, t[5] = o * u, t[9] = -a, t[2] = f * a - p, t[6] = _ + d * a, t[10] = o * l
		} else if (e.order === "ZXY") {
			const d = l * u,
				f = l * h,
				p = c * u,
				_ = c * h;
			t[0] = d - _ * a, t[4] = -o * h, t[8] = p + f * a, t[1] = f + p * a, t[5] = o * u, t[9] = _ - d * a, t[2] = -o * c, t[6] = a, t[10] = o * l
		} else if (e.order === "ZYX") {
			const d = o * u,
				f = o * h,
				p = a * u,
				_ = a * h;
			t[0] = l * u, t[4] = p * c - f, t[8] = d * c + _, t[1] = l * h, t[5] = _ * c + d, t[9] = f * c - p, t[2] = -c, t[6] = a * l, t[10] = o * l
		} else if (e.order === "YZX") {
			const d = o * l,
				f = o * c,
				p = a * l,
				_ = a * c;
			t[0] = l * u, t[4] = _ - d * h, t[8] = p * h + f, t[1] = h, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = f * h + p, t[10] = d - _ * h
		} else if (e.order === "XZY") {
			const d = o * l,
				f = o * c,
				p = a * l,
				_ = a * c;
			t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = d * h + _, t[5] = o * u, t[9] = f * h - p, t[2] = p * h - f, t[6] = a * u, t[10] = _ * h + d
		}
		return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
	}
	makeRotationFromQuaternion(e) {
		return this.compose(qV, e, XV)
	}
	lookAt(e, t, i) {
		const r = this.elements;
		return lr.subVectors(e, t), lr.lengthSq() === 0 && (lr.z = 1), lr.normalize(), Ao.crossVectors(i, lr), Ao.lengthSq() === 0 && (Math.abs(i.z) === 1 ? lr.x += 1e-4 : lr.z += 1e-4, lr.normalize(), Ao.crossVectors(i, lr)), Ao.normalize(), Mf.crossVectors(lr, Ao), r[0] = Ao.x, r[4] = Mf.x, r[8] = lr.x, r[1] = Ao.y, r[5] = Mf.y, r[9] = lr.y, r[2] = Ao.z, r[6] = Mf.z, r[10] = lr.z, this
	}
	multiply(e) {
		return this.multiplyMatrices(this, e)
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this)
	}
	multiplyMatrices(e, t) {
		const i = e.elements,
			r = t.elements,
			s = this.elements,
			o = i[0],
			a = i[4],
			l = i[8],
			c = i[12],
			u = i[1],
			h = i[5],
			d = i[9],
			f = i[13],
			p = i[2],
			_ = i[6],
			g = i[10],
			m = i[14],
			b = i[3],
			v = i[7],
			y = i[11],
			x = i[15],
			S = r[0],
			E = r[4],
			C = r[8],
			P = r[12],
			w = r[1],
			D = r[5],
			U = r[9],
			j = r[13],
			z = r[2],
			H = r[6],
			F = r[10],
			G = r[14],
			R = r[3],
			Q = r[7],
			B = r[11],
			ge = r[15];
		return s[0] = o * S + a * w + l * z + c * R, s[4] = o * E + a * D + l * H + c * Q, s[8] = o * C + a * U + l * F + c * B, s[12] = o * P + a * j + l * G + c * ge, s[1] = u * S + h * w + d * z + f * R, s[5] = u * E + h * D + d * H + f * Q, s[9] = u * C + h * U + d * F + f * B, s[13] = u * P + h * j + d * G + f * ge, s[2] = p * S + _ * w + g * z + m * R, s[6] = p * E + _ * D + g * H + m * Q, s[10] = p * C + _ * U + g * F + m * B, s[14] = p * P + _ * j + g * G + m * ge, s[3] = b * S + v * w + y * z + x * R, s[7] = b * E + v * D + y * H + x * Q, s[11] = b * C + v * U + y * F + x * B, s[15] = b * P + v * j + y * G + x * ge, this
	}
	multiplyScalar(e) {
		const t = this.elements;
		return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			i = e[4],
			r = e[8],
			s = e[12],
			o = e[1],
			a = e[5],
			l = e[9],
			c = e[13],
			u = e[2],
			h = e[6],
			d = e[10],
			f = e[14],
			p = e[3],
			_ = e[7],
			g = e[11],
			m = e[15];
		return p * (+s * l * h - r * c * h - s * a * d + i * c * d + r * a * f - i * l * f) + _ * (+t * l * f - t * c * d + s * o * d - r * o * f + r * c * u - s * l * u) + g * (+t * c * h - t * a * f - s * o * h + i * o * f + s * a * u - i * c * u) + m * (-r * a * u - t * l * h + t * a * d + r * o * h - i * o * d + i * l * u)
	}
	transpose() {
		const e = this.elements;
		let t;
		return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
	}
	setPosition(e, t, i) {
		const r = this.elements;
		return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this
	}
	invert() {
		const e = this.elements,
			t = e[0],
			i = e[1],
			r = e[2],
			s = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			u = e[8],
			h = e[9],
			d = e[10],
			f = e[11],
			p = e[12],
			_ = e[13],
			g = e[14],
			m = e[15],
			b = h * g * c - _ * d * c + _ * l * f - a * g * f - h * l * m + a * d * m,
			v = p * d * c - u * g * c - p * l * f + o * g * f + u * l * m - o * d * m,
			y = u * _ * c - p * h * c + p * a * f - o * _ * f - u * a * m + o * h * m,
			x = p * h * l - u * _ * l - p * a * d + o * _ * d + u * a * g - o * h * g,
			S = t * b + i * v + r * y + s * x;
		if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const E = 1 / S;
		return e[0] = b * E, e[1] = (_ * d * s - h * g * s - _ * r * f + i * g * f + h * r * m - i * d * m) * E, e[2] = (a * g * s - _ * l * s + _ * r * c - i * g * c - a * r * m + i * l * m) * E, e[3] = (h * l * s - a * d * s - h * r * c + i * d * c + a * r * f - i * l * f) * E, e[4] = v * E, e[5] = (u * g * s - p * d * s + p * r * f - t * g * f - u * r * m + t * d * m) * E, e[6] = (p * l * s - o * g * s - p * r * c + t * g * c + o * r * m - t * l * m) * E, e[7] = (o * d * s - u * l * s + u * r * c - t * d * c - o * r * f + t * l * f) * E, e[8] = y * E, e[9] = (p * h * s - u * _ * s - p * i * f + t * _ * f + u * i * m - t * h * m) * E, e[10] = (o * _ * s - p * a * s + p * i * c - t * _ * c - o * i * m + t * a * m) * E, e[11] = (u * a * s - o * h * s - u * i * c + t * h * c + o * i * f - t * a * f) * E, e[12] = x * E, e[13] = (u * _ * r - p * h * r + p * i * d - t * _ * d - u * i * g + t * h * g) * E, e[14] = (p * a * r - o * _ * r - p * i * l + t * _ * l + o * i * g - t * a * g) * E, e[15] = (o * h * r - u * a * r + u * i * l - t * h * l - o * i * d + t * a * d) * E, this
	}
	scale(e) {
		const t = this.elements,
			i = e.x,
			r = e.y,
			s = e.z;
		return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this
	}
	getMaxScaleOnAxis() {
		const e = this.elements,
			t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
			i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
			r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
		return Math.sqrt(Math.max(t, i, r))
	}
	makeTranslation(e, t, i) {
		return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
	}
	makeRotationX(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
	}
	makeRotationY(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
	}
	makeRotationZ(e) {
		const t = Math.cos(e),
			i = Math.sin(e);
		return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	makeRotationAxis(e, t) {
		const i = Math.cos(t),
			r = Math.sin(t),
			s = 1 - i,
			o = e.x,
			a = e.y,
			l = e.z,
			c = s * o,
			u = s * a;
		return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + i, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this
	}
	makeScale(e, t, i) {
		return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
	}
	makeShear(e, t, i, r, s, o) {
		return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
	}
	compose(e, t, i) {
		const r = this.elements,
			s = t._x,
			o = t._y,
			a = t._z,
			l = t._w,
			c = s + s,
			u = o + o,
			h = a + a,
			d = s * c,
			f = s * u,
			p = s * h,
			_ = o * u,
			g = o * h,
			m = a * h,
			b = l * c,
			v = l * u,
			y = l * h,
			x = i.x,
			S = i.y,
			E = i.z;
		return r[0] = (1 - (_ + m)) * x, r[1] = (f + y) * x, r[2] = (p - v) * x, r[3] = 0, r[4] = (f - y) * S, r[5] = (1 - (d + m)) * S, r[6] = (g + b) * S, r[7] = 0, r[8] = (p + v) * E, r[9] = (g - b) * E, r[10] = (1 - (d + _)) * E, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
	}
	decompose(e, t, i) {
		const r = this.elements;
		let s = Jl.set(r[0], r[1], r[2]).length();
		const o = Jl.set(r[4], r[5], r[6]).length(),
			a = Jl.set(r[8], r[9], r[10]).length();
		this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Kr.copy(this);
		const c = 1 / s,
			u = 1 / o,
			h = 1 / a;
		return Kr.elements[0] *= c, Kr.elements[1] *= c, Kr.elements[2] *= c, Kr.elements[4] *= u, Kr.elements[5] *= u, Kr.elements[6] *= u, Kr.elements[8] *= h, Kr.elements[9] *= h, Kr.elements[10] *= h, t.setFromRotationMatrix(Kr), i.x = s, i.y = o, i.z = a, this
	}
	makePerspective(e, t, i, r, s, o, a = eo) {
		const l = this.elements,
			c = 2 * s / (t - e),
			u = 2 * s / (i - r),
			h = (t + e) / (t - e),
			d = (i + r) / (i - r);
		let f, p;
		if (a === eo) f = -(o + s) / (o - s), p = -2 * o * s / (o - s);
		else if (a === am) f = -o / (o - s), p = -o * s / (o - s);
		else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
		return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = p, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
	}
	makeOrthographic(e, t, i, r, s, o, a = eo) {
		const l = this.elements,
			c = 1 / (t - e),
			u = 1 / (i - r),
			h = 1 / (o - s),
			d = (t + e) * c,
			f = (i + r) * u;
		let p, _;
		if (a === eo) p = (o + s) * h, _ = -2 * h;
		else if (a === am) p = s * h, _ = -1 * h;
		else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
		return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -p, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
	}
	equals(e) {
		const t = this.elements,
			i = e.elements;
		for (let r = 0; r < 16; r++)
			if (t[r] !== i[r]) return !1;
		return !0
	}
	fromArray(e, t = 0) {
		for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
		return this
	}
	toArray(e = [], t = 0) {
		const i = this.elements;
		return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
	}
}
const Jl = new X,
	Kr = new pt,
	qV = new X(0, 0, 0),
	XV = new X(1, 1, 1),
	Ao = new X,
	Mf = new X,
	lr = new X,
	V2 = new pt,
	H2 = new qr;
class Er {
	constructor(e = 0, t = 0, i = 0, r = Er.DEFAULT_ORDER) {
		this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r
	}
	get x() {
		return this._x
	}
	set x(e) {
		this._x = e, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(e) {
		this._y = e, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(e) {
		this._z = e, this._onChangeCallback()
	}
	get order() {
		return this._order
	}
	set order(e) {
		this._order = e, this._onChangeCallback()
	}
	set(e, t, i, r = this._order) {
		return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order)
	}
	copy(e) {
		return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
	}
	setFromRotationMatrix(e, t = this._order, i = !0) {
		const r = e.elements,
			s = r[0],
			o = r[4],
			a = r[8],
			l = r[1],
			c = r[5],
			u = r[9],
			h = r[2],
			d = r[6],
			f = r[10];
		switch (t) {
			case "XYZ":
				this._y = Math.asin(ti(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, c), this._z = 0);
				break;
			case "YXZ":
				this._x = Math.asin(-ti(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
				break;
			case "ZXY":
				this._x = Math.asin(ti(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
				break;
			case "ZYX":
				this._y = Math.asin(-ti(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
				break;
			case "YZX":
				this._z = Math.asin(ti(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, f));
				break;
			case "XZY":
				this._z = Math.asin(-ti(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, f), this._y = 0);
				break;
			default:
				console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
		}
		return this._order = t, i === !0 && this._onChangeCallback(), this
	}
	setFromQuaternion(e, t, i) {
		return V2.makeRotationFromQuaternion(e), this.setFromRotationMatrix(V2, t, i)
	}
	setFromVector3(e, t = this._order) {
		return this.set(e.x, e.y, e.z, t)
	}
	reorder(e) {
		return H2.setFromEuler(this), this.setFromQuaternion(H2, e)
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
	}
	fromArray(e) {
		return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
	}
	toArray(e = [], t = 0) {
		return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
	}
	_onChange(e) {
		return this._onChangeCallback = e, this
	}
	_onChangeCallback() {}*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._order
	}
}
Er.DEFAULT_ORDER = "XYZ";
class Pb {
	constructor() {
		this.mask = 1
	}
	set(e) {
		this.mask = (1 << e | 0) >>> 0
	}
	enable(e) {
		this.mask |= 1 << e | 0
	}
	enableAll() {
		this.mask = -1
	}
	toggle(e) {
		this.mask ^= 1 << e | 0
	}
	disable(e) {
		this.mask &= ~(1 << e | 0)
	}
	disableAll() {
		this.mask = 0
	}
	test(e) {
		return (this.mask & e.mask) !== 0
	}
	isEnabled(e) {
		return (this.mask & (1 << e | 0)) !== 0
	}
}
let YV = 0;
const G2 = new X,
	Ql = new qr,
	Vs = new pt,
	Cf = new X,
	Vu = new X,
	KV = new X,
	ZV = new qr,
	W2 = new X(1, 0, 0),
	j2 = new X(0, 1, 0),
	$2 = new X(0, 0, 1),
	JV = {
		type: "added"
	},
	QV = {
		type: "removed"
	},
	wg = {
		type: "childadded",
		child: null
	},
	Eg = {
		type: "childremoved",
		child: null
	};
class ht extends Ol {
	constructor() {
		super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
			value: YV++
		}), this.uuid = rs(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ht.DEFAULT_UP.clone();
		const e = new X,
			t = new Er,
			i = new qr,
			r = new X(1, 1, 1);

		function s() {
			i.setFromEuler(t, !1)
		}

		function o() {
			t.setFromQuaternion(i, void 0, !1)
		}
		t._onChange(s), i._onChange(o), Object.defineProperties(this, {
			position: {
				configurable: !0,
				enumerable: !0,
				value: e
			},
			rotation: {
				configurable: !0,
				enumerable: !0,
				value: t
			},
			quaternion: {
				configurable: !0,
				enumerable: !0,
				value: i
			},
			scale: {
				configurable: !0,
				enumerable: !0,
				value: r
			},
			modelViewMatrix: {
				value: new pt
			},
			normalMatrix: {
				value: new gt
			}
		}), this.matrix = new pt, this.matrixWorld = new pt, this.matrixAutoUpdate = ht.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Pb, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
	}
	onBeforeShadow() {}
	onAfterShadow() {}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(e) {
		this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
	}
	applyQuaternion(e) {
		return this.quaternion.premultiply(e), this
	}
	setRotationFromAxisAngle(e, t) {
		this.quaternion.setFromAxisAngle(e, t)
	}
	setRotationFromEuler(e) {
		this.quaternion.setFromEuler(e, !0)
	}
	setRotationFromMatrix(e) {
		this.quaternion.setFromRotationMatrix(e)
	}
	setRotationFromQuaternion(e) {
		this.quaternion.copy(e)
	}
	rotateOnAxis(e, t) {
		return Ql.setFromAxisAngle(e, t), this.quaternion.multiply(Ql), this
	}
	rotateOnWorldAxis(e, t) {
		return Ql.setFromAxisAngle(e, t), this.quaternion.premultiply(Ql), this
	}
	rotateX(e) {
		return this.rotateOnAxis(W2, e)
	}
	rotateY(e) {
		return this.rotateOnAxis(j2, e)
	}
	rotateZ(e) {
		return this.rotateOnAxis($2, e)
	}
	translateOnAxis(e, t) {
		return G2.copy(e).applyQuaternion(this.quaternion), this.position.add(G2.multiplyScalar(t)), this
	}
	translateX(e) {
		return this.translateOnAxis(W2, e)
	}
	translateY(e) {
		return this.translateOnAxis(j2, e)
	}
	translateZ(e) {
		return this.translateOnAxis($2, e)
	}
	localToWorld(e) {
		return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
	}
	worldToLocal(e) {
		return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Vs.copy(this.matrixWorld).invert())
	}
	lookAt(e, t, i) {
		e.isVector3 ? Cf.copy(e) : Cf.set(e, t, i);
		const r = this.parent;
		this.updateWorldMatrix(!0, !1), Vu.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Vs.lookAt(Vu, Cf, this.up) : Vs.lookAt(Cf, Vu, this.up), this.quaternion.setFromRotationMatrix(Vs), r && (Vs.extractRotation(r.matrixWorld), Ql.setFromRotationMatrix(Vs), this.quaternion.premultiply(Ql.invert()))
	}
	add(e) {
		if (arguments.length > 1) {
			for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
			return this
		}
		return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(JV), wg.child = e, this.dispatchEvent(wg), wg.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
	}
	remove(e) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
			return this
		}
		const t = this.children.indexOf(e);
		return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(QV), Eg.child = e, this.dispatchEvent(Eg), Eg.child = null), this
	}
	removeFromParent() {
		const e = this.parent;
		return e !== null && e.remove(this), this
	}
	clear() {
		return this.remove(...this.children)
	}
	attach(e) {
		return this.updateWorldMatrix(!0, !1), Vs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Vs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Vs), this.add(e), e.updateWorldMatrix(!1, !0), this
	}
	getObjectById(e) {
		return this.getObjectByProperty("id", e)
	}
	getObjectByName(e) {
		return this.getObjectByProperty("name", e)
	}
	getObjectByProperty(e, t) {
		if (this[e] === t) return this;
		for (let i = 0, r = this.children.length; i < r; i++) {
			const o = this.children[i].getObjectByProperty(e, t);
			if (o !== void 0) return o
		}
	}
	getObjectsByProperty(e, t, i = []) {
		this[e] === t && i.push(this);
		const r = this.children;
		for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i);
		return i
	}
	getWorldPosition(e) {
		return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
	}
	getWorldQuaternion(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Vu, e, KV), e
	}
	getWorldScale(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Vu, ZV, e), e
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(t[8], t[9], t[10]).normalize()
	}
	raycast() {}
	traverse(e) {
		e(this);
		const t = this.children;
		for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
	}
	traverseVisible(e) {
		if (this.visible === !1) return;
		e(this);
		const t = this.children;
		for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
	}
	traverseAncestors(e) {
		const t = this.parent;
		t !== null && (e(t), t.traverseAncestors(e))
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}
	updateMatrixWorld(e) {
		this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
		const t = this.children;
		for (let i = 0, r = t.length; i < r; i++) {
			const s = t[i];
			(s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
		}
	}
	updateWorldMatrix(e, t) {
		const i = this.parent;
		if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
			const r = this.children;
			for (let s = 0, o = r.length; s < o; s++) {
				const a = r[s];
				a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
			}
		}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == "string",
			i = {};
		t && (e = {
			geometries: {},
			materials: {},
			textures: {},
			images: {},
			shapes: {},
			skeletons: {},
			animations: {},
			nodes: {}
		}, i.metadata = {
			version: 4.6,
			type: "Object",
			generator: "Object3D.toJSON"
		});
		const r = {};
		r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map(a => ({
			boxInitialized: a.boxInitialized,
			boxMin: a.box.min.toArray(),
			boxMax: a.box.max.toArray(),
			sphereInitialized: a.sphereInitialized,
			sphereRadius: a.sphere.radius,
			sphereCenter: a.sphere.center.toArray()
		})), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = {
			center: r.boundingSphere.center.toArray(),
			radius: r.boundingSphere.radius
		}), this.boundingBox !== null && (r.boundingBox = {
			min: r.boundingBox.min.toArray(),
			max: r.boundingBox.max.toArray()
		}));

		function s(a, l) {
			return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
		}
		if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			r.geometry = s(e.geometries, this.geometry);
			const a = this.geometry.parameters;
			if (a !== void 0 && a.shapes !== void 0) {
				const l = a.shapes;
				if (Array.isArray(l))
					for (let c = 0, u = l.length; c < u; c++) {
						const h = l[c];
						s(e.shapes, h)
					} else s(e.shapes, l)
			}
		}
		if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
			if (Array.isArray(this.material)) {
				const a = [];
				for (let l = 0, c = this.material.length; l < c; l++) a.push(s(e.materials, this.material[l]));
				r.material = a
			} else r.material = s(e.materials, this.material);
		if (this.children.length > 0) {
			r.children = [];
			for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(e).object)
		}
		if (this.animations.length > 0) {
			r.animations = [];
			for (let a = 0; a < this.animations.length; a++) {
				const l = this.animations[a];
				r.animations.push(s(e.animations, l))
			}
		}
		if (t) {
			const a = o(e.geometries),
				l = o(e.materials),
				c = o(e.textures),
				u = o(e.images),
				h = o(e.shapes),
				d = o(e.skeletons),
				f = o(e.animations),
				p = o(e.nodes);
			a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), p.length > 0 && (i.nodes = p)
		}
		return i.object = r, i;

		function o(a) {
			const l = [];
			for (const c in a) {
				const u = a[c];
				delete u.metadata, l.push(u)
			}
			return l
		}
	}
	clone(e) {
		return new this.constructor().copy(this, e)
	}
	copy(e, t = !0) {
		if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
			for (let i = 0; i < e.children.length; i++) {
				const r = e.children[i];
				this.add(r.clone())
			}
		return this
	}
}
ht.DEFAULT_UP = new X(0, 1, 0);
ht.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Zr = new X,
	Hs = new X,
	Sg = new X,
	Gs = new X,
	ec = new X,
	tc = new X,
	q2 = new X,
	Tg = new X,
	Mg = new X,
	Cg = new X;
class vs {
	constructor(e = new X, t = new X, i = new X) {
		this.a = e, this.b = t, this.c = i
	}
	static getNormal(e, t, i, r) {
		r.subVectors(i, t), Zr.subVectors(e, t), r.cross(Zr);
		const s = r.lengthSq();
		return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
	}
	static getBarycoord(e, t, i, r, s) {
		Zr.subVectors(r, t), Hs.subVectors(i, t), Sg.subVectors(e, t);
		const o = Zr.dot(Zr),
			a = Zr.dot(Hs),
			l = Zr.dot(Sg),
			c = Hs.dot(Hs),
			u = Hs.dot(Sg),
			h = o * c - a * a;
		if (h === 0) return s.set(0, 0, 0), null;
		const d = 1 / h,
			f = (c * l - a * u) * d,
			p = (o * u - a * l) * d;
		return s.set(1 - f - p, p, f)
	}
	static containsPoint(e, t, i, r) {
		return this.getBarycoord(e, t, i, r, Gs) === null ? !1 : Gs.x >= 0 && Gs.y >= 0 && Gs.x + Gs.y <= 1
	}
	static getInterpolation(e, t, i, r, s, o, a, l) {
		return this.getBarycoord(e, t, i, r, Gs) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, Gs.x), l.addScaledVector(o, Gs.y), l.addScaledVector(a, Gs.z), l)
	}
	static isFrontFacing(e, t, i, r) {
		return Zr.subVectors(i, t), Hs.subVectors(e, t), Zr.cross(Hs).dot(r) < 0
	}
	set(e, t, i) {
		return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
	}
	setFromPointsAndIndices(e, t, i, r) {
		return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
	}
	setFromAttributeAndIndices(e, t, i, r) {
		return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
	}
	getArea() {
		return Zr.subVectors(this.c, this.b), Hs.subVectors(this.a, this.b), Zr.cross(Hs).length() * .5
	}
	getMidpoint(e) {
		return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	}
	getNormal(e) {
		return vs.getNormal(this.a, this.b, this.c, e)
	}
	getPlane(e) {
		return e.setFromCoplanarPoints(this.a, this.b, this.c)
	}
	getBarycoord(e, t) {
		return vs.getBarycoord(e, this.a, this.b, this.c, t)
	}
	getInterpolation(e, t, i, r, s) {
		return vs.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
	}
	containsPoint(e) {
		return vs.containsPoint(e, this.a, this.b, this.c)
	}
	isFrontFacing(e) {
		return vs.isFrontFacing(this.a, this.b, this.c, e)
	}
	intersectsBox(e) {
		return e.intersectsTriangle(this)
	}
	closestPointToPoint(e, t) {
		const i = this.a,
			r = this.b,
			s = this.c;
		let o, a;
		ec.subVectors(r, i), tc.subVectors(s, i), Tg.subVectors(e, i);
		const l = ec.dot(Tg),
			c = tc.dot(Tg);
		if (l <= 0 && c <= 0) return t.copy(i);
		Mg.subVectors(e, r);
		const u = ec.dot(Mg),
			h = tc.dot(Mg);
		if (u >= 0 && h <= u) return t.copy(r);
		const d = l * h - u * c;
		if (d <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(i).addScaledVector(ec, o);
		Cg.subVectors(e, s);
		const f = ec.dot(Cg),
			p = tc.dot(Cg);
		if (p >= 0 && f <= p) return t.copy(s);
		const _ = f * c - l * p;
		if (_ <= 0 && c >= 0 && p <= 0) return a = c / (c - p), t.copy(i).addScaledVector(tc, a);
		const g = u * p - f * h;
		if (g <= 0 && h - u >= 0 && f - p >= 0) return q2.subVectors(s, r), a = (h - u) / (h - u + (f - p)), t.copy(r).addScaledVector(q2, a);
		const m = 1 / (g + _ + d);
		return o = _ * m, a = d * m, t.copy(i).addScaledVector(ec, o).addScaledVector(tc, a)
	}
	equals(e) {
		return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
	}
}
const LD = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	},
	Do = {
		h: 0,
		s: 0,
		l: 0
	},
	Af = {
		h: 0,
		s: 0,
		l: 0
	};

function Ag(n, e, t) {
	return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class et {
	constructor(e, t, i) {
		return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i)
	}
	set(e, t, i) {
		if (t === void 0 && i === void 0) {
			const r = e;
			r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
		} else this.setRGB(e, t, i);
		return this
	}
	setScalar(e) {
		return this.r = e, this.g = e, this.b = e, this
	}
	setHex(e, t = qn) {
		return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Lt.toWorkingColorSpace(this, t), this
	}
	setRGB(e, t, i, r = Lt.workingColorSpace) {
		return this.r = e, this.g = t, this.b = i, Lt.toWorkingColorSpace(this, r), this
	}
	setHSL(e, t, i, r = Lt.workingColorSpace) {
		if (e = Db(e, 1), t = ti(t, 0, 1), i = ti(i, 0, 1), t === 0) this.r = this.g = this.b = i;
		else {
			const s = i <= .5 ? i * (1 + t) : i + t - i * t,
				o = 2 * i - s;
			this.r = Ag(o, s, e + 1 / 3), this.g = Ag(o, s, e), this.b = Ag(o, s, e - 1 / 3)
		}
		return Lt.toWorkingColorSpace(this, r), this
	}
	setStyle(e, t = qn) {
		function i(s) {
			s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
		}
		let r;
		if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
			let s;
			const o = r[1],
				a = r[2];
			switch (o) {
				case "rgb":
				case "rgba":
					if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
					if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
					break;
				case "hsl":
				case "hsla":
					if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
					break;
				default:
					console.warn("THREE.Color: Unknown color model " + e)
			}
		} else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
			const s = r[1],
				o = s.length;
			if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
			if (o === 6) return this.setHex(parseInt(s, 16), t);
			console.warn("THREE.Color: Invalid hex color " + e)
		} else if (e && e.length > 0) return this.setColorName(e, t);
		return this
	}
	setColorName(e, t = qn) {
		const i = LD[e.toLowerCase()];
		return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b)
	}
	copy(e) {
		return this.r = e.r, this.g = e.g, this.b = e.b, this
	}
	copySRGBToLinear(e) {
		return this.r = Bc(e.r), this.g = Bc(e.g), this.b = Bc(e.b), this
	}
	copyLinearToSRGB(e) {
		return this.r = pg(e.r), this.g = pg(e.g), this.b = pg(e.b), this
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this
	}
	getHex(e = qn) {
		return Lt.fromWorkingColorSpace(li.copy(this), e), Math.round(ti(li.r * 255, 0, 255)) * 65536 + Math.round(ti(li.g * 255, 0, 255)) * 256 + Math.round(ti(li.b * 255, 0, 255))
	}
	getHexString(e = qn) {
		return ("000000" + this.getHex(e).toString(16)).slice(-6)
	}
	getHSL(e, t = Lt.workingColorSpace) {
		Lt.fromWorkingColorSpace(li.copy(this), t);
		const i = li.r,
			r = li.g,
			s = li.b,
			o = Math.max(i, r, s),
			a = Math.min(i, r, s);
		let l, c;
		const u = (a + o) / 2;
		if (a === o) l = 0, c = 0;
		else {
			const h = o - a;
			switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a), o) {
				case i:
					l = (r - s) / h + (r < s ? 6 : 0);
					break;
				case r:
					l = (s - i) / h + 2;
					break;
				case s:
					l = (i - r) / h + 4;
					break
			}
			l /= 6
		}
		return e.h = l, e.s = c, e.l = u, e
	}
	getRGB(e, t = Lt.workingColorSpace) {
		return Lt.fromWorkingColorSpace(li.copy(this), t), e.r = li.r, e.g = li.g, e.b = li.b, e
	}
	getStyle(e = qn) {
		Lt.fromWorkingColorSpace(li.copy(this), e);
		const t = li.r,
			i = li.g,
			r = li.b;
		return e !== qn ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(r*255)})`
	}
	offsetHSL(e, t, i) {
		return this.getHSL(Do), this.setHSL(Do.h + e, Do.s + t, Do.l + i)
	}
	add(e) {
		return this.r += e.r, this.g += e.g, this.b += e.b, this
	}
	addColors(e, t) {
		return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
	}
	addScalar(e) {
		return this.r += e, this.g += e, this.b += e, this
	}
	sub(e) {
		return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
	}
	multiply(e) {
		return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
	}
	multiplyScalar(e) {
		return this.r *= e, this.g *= e, this.b *= e, this
	}
	lerp(e, t) {
		return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
	}
	lerpColors(e, t, i) {
		return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
	}
	lerpHSL(e, t) {
		this.getHSL(Do), e.getHSL(Af);
		const i = Ih(Do.h, Af.h, t),
			r = Ih(Do.s, Af.s, t),
			s = Ih(Do.l, Af.l, t);
		return this.setHSL(i, r, s), this
	}
	setFromVector3(e) {
		return this.r = e.x, this.g = e.y, this.b = e.z, this
	}
	applyMatrix3(e) {
		const t = this.r,
			i = this.g,
			r = this.b,
			s = e.elements;
		return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this
	}
	equals(e) {
		return e.r === this.r && e.g === this.g && e.b === this.b
	}
	fromArray(e, t = 0) {
		return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
	}
	fromBufferAttribute(e, t) {
		return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
	}
	toJSON() {
		return this.getHex()
	}*[Symbol.iterator]() {
		yield this.r, yield this.g, yield this.b
	}
}
const li = new et;
et.NAMES = LD;
let eH = 0;
class Cs extends Ol {
	constructor() {
		super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
			value: eH++
		}), this.uuid = rs(), this.name = "", this.type = "Material", this.blending = ha, this.side = fo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Cv, this.blendDst = Av, this.blendEquation = Ja, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new et(0, 0, 0), this.blendAlpha = 0, this.depthFunc = tm, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = I2, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ql, this.stencilZFail = ql, this.stencilZPass = ql, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
	}
	get alphaTest() {
		return this._alphaTest
	}
	set alphaTest(e) {
		this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString()
	}
	setValues(e) {
		if (e !== void 0)
			for (const t in e) {
				const i = e[t];
				if (i === void 0) {
					console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
					continue
				}
				const r = this[t];
				if (r === void 0) {
					console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
					continue
				}
				r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
			}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == "string";
		t && (e = {
			textures: {},
			images: {}
		});
		const i = {
			metadata: {
				version: 4.6,
				type: "Material",
				generator: "Material.toJSON"
			}
		};
		i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ha && (i.blending = this.blending), this.side !== fo && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Cv && (i.blendSrc = this.blendSrc), this.blendDst !== Av && (i.blendDst = this.blendDst), this.blendEquation !== Ja && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== tm && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== I2 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ql && (i.stencilFail = this.stencilFail), this.stencilZFail !== ql && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== ql && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);

		function r(s) {
			const o = [];
			for (const a in s) {
				const l = s[a];
				delete l.metadata, o.push(l)
			}
			return o
		}
		if (t) {
			const s = r(e.textures),
				o = r(e.images);
			s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o)
		}
		return i
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
		const t = e.clippingPlanes;
		let i = null;
		if (t !== null) {
			const r = t.length;
			i = new Array(r);
			for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
		}
		return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	set needsUpdate(e) {
		e === !0 && this.version++
	}
}
class yr extends Cs {
	constructor(e) {
		super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new et(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Er, this.combine = fD, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
	}
}
const Sn = new X,
	Df = new Oe;
class Cn {
	constructor(e, t, i = !1) {
		if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = om, this._updateRange = {
			offset: 0,
			count: -1
		}, this.updateRanges = [], this.gpuType = ns, this.version = 0
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++
	}
	get updateRange() {
		return AD("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
	}
	setUsage(e) {
		return this.usage = e, this
	}
	addUpdateRange(e, t) {
		this.updateRanges.push({
			start: e,
			count: t
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(e) {
		return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
	}
	copyAt(e, t, i) {
		e *= this.itemSize, i *= t.itemSize;
		for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
		return this
	}
	copyArray(e) {
		return this.array.set(e), this
	}
	applyMatrix3(e) {
		if (this.itemSize === 2)
			for (let t = 0, i = this.count; t < i; t++) Df.fromBufferAttribute(this, t), Df.applyMatrix3(e), this.setXY(t, Df.x, Df.y);
		else if (this.itemSize === 3)
			for (let t = 0, i = this.count; t < i; t++) Sn.fromBufferAttribute(this, t), Sn.applyMatrix3(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
		return this
	}
	applyMatrix4(e) {
		for (let t = 0, i = this.count; t < i; t++) Sn.fromBufferAttribute(this, t), Sn.applyMatrix4(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
		return this
	}
	applyNormalMatrix(e) {
		for (let t = 0, i = this.count; t < i; t++) Sn.fromBufferAttribute(this, t), Sn.applyNormalMatrix(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
		return this
	}
	transformDirection(e) {
		for (let t = 0, i = this.count; t < i; t++) Sn.fromBufferAttribute(this, t), Sn.transformDirection(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
		return this
	}
	set(e, t = 0) {
		return this.array.set(e, t), this
	}
	getComponent(e, t) {
		let i = this.array[e * this.itemSize + t];
		return this.normalized && (i = is(i, this.array)), i
	}
	setComponent(e, t, i) {
		return this.normalized && (i = Bt(i, this.array)), this.array[e * this.itemSize + t] = i, this
	}
	getX(e) {
		let t = this.array[e * this.itemSize];
		return this.normalized && (t = is(t, this.array)), t
	}
	setX(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.array[e * this.itemSize] = t, this
	}
	getY(e) {
		let t = this.array[e * this.itemSize + 1];
		return this.normalized && (t = is(t, this.array)), t
	}
	setY(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.array[e * this.itemSize + 1] = t, this
	}
	getZ(e) {
		let t = this.array[e * this.itemSize + 2];
		return this.normalized && (t = is(t, this.array)), t
	}
	setZ(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.array[e * this.itemSize + 2] = t, this
	}
	getW(e) {
		let t = this.array[e * this.itemSize + 3];
		return this.normalized && (t = is(t, this.array)), t
	}
	setW(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.array[e * this.itemSize + 3] = t, this
	}
	setXY(e, t, i) {
		return e *= this.itemSize, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
	}
	setXYZ(e, t, i, r) {
		return e *= this.itemSize, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array), r = Bt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this
	}
	setXYZW(e, t, i, r, s) {
		return e *= this.itemSize, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array), r = Bt(r, this.array), s = Bt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this
	}
	onUpload(e) {
		return this.onUploadCallback = e, this
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this)
	}
	toJSON() {
		const e = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		return this.name !== "" && (e.name = this.name), this.usage !== om && (e.usage = this.usage), e
	}
}
class kD extends Cn {
	constructor(e, t, i) {
		super(new Uint16Array(e), t, i)
	}
}
class ID extends Cn {
	constructor(e, t, i) {
		super(new Uint32Array(e), t, i)
	}
}
class $i extends Cn {
	constructor(e, t, i) {
		super(new Float32Array(e), t, i)
	}
}
let tH = 0;
const Pr = new pt,
	Dg = new ht,
	nc = new X,
	cr = new ks,
	Hu = new ks,
	Hn = new X;
class gi extends Ol {
	constructor() {
		super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
			value: tH++
		}), this.uuid = rs(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
			start: 0,
			count: 1 / 0
		}, this.userData = {}
	}
	getIndex() {
		return this.index
	}
	setIndex(e) {
		return Array.isArray(e) ? this.index = new(CD(e) ? ID : kD)(e, 1) : this.index = e, this
	}
	getAttribute(e) {
		return this.attributes[e]
	}
	setAttribute(e, t) {
		return this.attributes[e] = t, this
	}
	deleteAttribute(e) {
		return delete this.attributes[e], this
	}
	hasAttribute(e) {
		return this.attributes[e] !== void 0
	}
	addGroup(e, t, i = 0) {
		this.groups.push({
			start: e,
			count: t,
			materialIndex: i
		})
	}
	clearGroups() {
		this.groups = []
	}
	setDrawRange(e, t) {
		this.drawRange.start = e, this.drawRange.count = t
	}
	applyMatrix4(e) {
		const t = this.attributes.position;
		t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
		const i = this.attributes.normal;
		if (i !== void 0) {
			const s = new gt().getNormalMatrix(e);
			i.applyNormalMatrix(s), i.needsUpdate = !0
		}
		const r = this.attributes.tangent;
		return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
	}
	applyQuaternion(e) {
		return Pr.makeRotationFromQuaternion(e), this.applyMatrix4(Pr), this
	}
	rotateX(e) {
		return Pr.makeRotationX(e), this.applyMatrix4(Pr), this
	}
	rotateY(e) {
		return Pr.makeRotationY(e), this.applyMatrix4(Pr), this
	}
	rotateZ(e) {
		return Pr.makeRotationZ(e), this.applyMatrix4(Pr), this
	}
	translate(e, t, i) {
		return Pr.makeTranslation(e, t, i), this.applyMatrix4(Pr), this
	}
	scale(e, t, i) {
		return Pr.makeScale(e, t, i), this.applyMatrix4(Pr), this
	}
	lookAt(e) {
		return Dg.lookAt(e), Dg.updateMatrix(), this.applyMatrix4(Dg.matrix), this
	}
	center() {
		return this.computeBoundingBox(), this.boundingBox.getCenter(nc).negate(), this.translate(nc.x, nc.y, nc.z), this
	}
	setFromPoints(e) {
		const t = [];
		for (let i = 0, r = e.length; i < r; i++) {
			const s = e[i];
			t.push(s.x, s.y, s.z || 0)
		}
		return this.setAttribute("position", new $i(t, 3)), this
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new ks);
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new X(-1 / 0, -1 / 0, -1 / 0), new X(1 / 0, 1 / 0, 1 / 0));
			return
		}
		if (e !== void 0) {
			if (this.boundingBox.setFromBufferAttribute(e), t)
				for (let i = 0, r = t.length; i < r; i++) {
					const s = t[i];
					cr.setFromBufferAttribute(s), this.morphTargetsRelative ? (Hn.addVectors(this.boundingBox.min, cr.min), this.boundingBox.expandByPoint(Hn), Hn.addVectors(this.boundingBox.max, cr.max), this.boundingBox.expandByPoint(Hn)) : (this.boundingBox.expandByPoint(cr.min), this.boundingBox.expandByPoint(cr.max))
				}
		} else this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new Is);
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new X, 1 / 0);
			return
		}
		if (e) {
			const i = this.boundingSphere.center;
			if (cr.setFromBufferAttribute(e), t)
				for (let s = 0, o = t.length; s < o; s++) {
					const a = t[s];
					Hu.setFromBufferAttribute(a), this.morphTargetsRelative ? (Hn.addVectors(cr.min, Hu.min), cr.expandByPoint(Hn), Hn.addVectors(cr.max, Hu.max), cr.expandByPoint(Hn)) : (cr.expandByPoint(Hu.min), cr.expandByPoint(Hu.max))
				}
			cr.getCenter(i);
			let r = 0;
			for (let s = 0, o = e.count; s < o; s++) Hn.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(Hn));
			if (t)
				for (let s = 0, o = t.length; s < o; s++) {
					const a = t[s],
						l = this.morphTargetsRelative;
					for (let c = 0, u = a.count; c < u; c++) Hn.fromBufferAttribute(a, c), l && (nc.fromBufferAttribute(e, c), Hn.add(nc)), r = Math.max(r, i.distanceToSquared(Hn))
				}
			this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
		}
	}
	computeTangents() {
		const e = this.index,
			t = this.attributes;
		if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
			console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
			return
		}
		const i = t.position,
			r = t.normal,
			s = t.uv;
		this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Cn(new Float32Array(4 * i.count), 4));
		const o = this.getAttribute("tangent"),
			a = [],
			l = [];
		for (let C = 0; C < i.count; C++) a[C] = new X, l[C] = new X;
		const c = new X,
			u = new X,
			h = new X,
			d = new Oe,
			f = new Oe,
			p = new Oe,
			_ = new X,
			g = new X;

		function m(C, P, w) {
			c.fromBufferAttribute(i, C), u.fromBufferAttribute(i, P), h.fromBufferAttribute(i, w), d.fromBufferAttribute(s, C), f.fromBufferAttribute(s, P), p.fromBufferAttribute(s, w), u.sub(c), h.sub(c), f.sub(d), p.sub(d);
			const D = 1 / (f.x * p.y - p.x * f.y);
			isFinite(D) && (_.copy(u).multiplyScalar(p.y).addScaledVector(h, -f.y).multiplyScalar(D), g.copy(h).multiplyScalar(f.x).addScaledVector(u, -p.x).multiplyScalar(D), a[C].add(_), a[P].add(_), a[w].add(_), l[C].add(g), l[P].add(g), l[w].add(g))
		}
		let b = this.groups;
		b.length === 0 && (b = [{
			start: 0,
			count: e.count
		}]);
		for (let C = 0, P = b.length; C < P; ++C) {
			const w = b[C],
				D = w.start,
				U = w.count;
			for (let j = D, z = D + U; j < z; j += 3) m(e.getX(j + 0), e.getX(j + 1), e.getX(j + 2))
		}
		const v = new X,
			y = new X,
			x = new X,
			S = new X;

		function E(C) {
			x.fromBufferAttribute(r, C), S.copy(x);
			const P = a[C];
			v.copy(P), v.sub(x.multiplyScalar(x.dot(P))).normalize(), y.crossVectors(S, P);
			const D = y.dot(l[C]) < 0 ? -1 : 1;
			o.setXYZW(C, v.x, v.y, v.z, D)
		}
		for (let C = 0, P = b.length; C < P; ++C) {
			const w = b[C],
				D = w.start,
				U = w.count;
			for (let j = D, z = D + U; j < z; j += 3) E(e.getX(j + 0)), E(e.getX(j + 1)), E(e.getX(j + 2))
		}
	}
	computeVertexNormals() {
		const e = this.index,
			t = this.getAttribute("position");
		if (t !== void 0) {
			let i = this.getAttribute("normal");
			if (i === void 0) i = new Cn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
			else
				for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
			const r = new X,
				s = new X,
				o = new X,
				a = new X,
				l = new X,
				c = new X,
				u = new X,
				h = new X;
			if (e)
				for (let d = 0, f = e.count; d < f; d += 3) {
					const p = e.getX(d + 0),
						_ = e.getX(d + 1),
						g = e.getX(d + 2);
					r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, _), o.fromBufferAttribute(t, g), u.subVectors(o, s), h.subVectors(r, s), u.cross(h), a.fromBufferAttribute(i, p), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, g), a.add(u), l.add(u), c.add(u), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(g, c.x, c.y, c.z)
				} else
					for (let d = 0, f = t.count; d < f; d += 3) r.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), h.subVectors(r, s), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
			this.normalizeNormals(), i.needsUpdate = !0
		}
	}
	normalizeNormals() {
		const e = this.attributes.normal;
		for (let t = 0, i = e.count; t < i; t++) Hn.fromBufferAttribute(e, t), Hn.normalize(), e.setXYZ(t, Hn.x, Hn.y, Hn.z)
	}
	toNonIndexed() {
		function e(a, l) {
			const c = a.array,
				u = a.itemSize,
				h = a.normalized,
				d = new c.constructor(l.length * u);
			let f = 0,
				p = 0;
			for (let _ = 0, g = l.length; _ < g; _++) {
				a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * u;
				for (let m = 0; m < u; m++) d[p++] = c[f++]
			}
			return new Cn(d, u, h)
		}
		if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
		const t = new gi,
			i = this.index.array,
			r = this.attributes;
		for (const a in r) {
			const l = r[a],
				c = e(l, i);
			t.setAttribute(a, c)
		}
		const s = this.morphAttributes;
		for (const a in s) {
			const l = [],
				c = s[a];
			for (let u = 0, h = c.length; u < h; u++) {
				const d = c[u],
					f = e(d, i);
				l.push(f)
			}
			t.morphAttributes[a] = l
		}
		t.morphTargetsRelative = this.morphTargetsRelative;
		const o = this.groups;
		for (let a = 0, l = o.length; a < l; a++) {
			const c = o[a];
			t.addGroup(c.start, c.count, c.materialIndex)
		}
		return t
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.6,
				type: "BufferGeometry",
				generator: "BufferGeometry.toJSON"
			}
		};
		if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
			const l = this.parameters;
			for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
			return e
		}
		e.data = {
			attributes: {}
		};
		const t = this.index;
		t !== null && (e.data.index = {
			type: t.array.constructor.name,
			array: Array.prototype.slice.call(t.array)
		});
		const i = this.attributes;
		for (const l in i) {
			const c = i[l];
			e.data.attributes[l] = c.toJSON(e.data)
		}
		const r = {};
		let s = !1;
		for (const l in this.morphAttributes) {
			const c = this.morphAttributes[l],
				u = [];
			for (let h = 0, d = c.length; h < d; h++) {
				const f = c[h];
				u.push(f.toJSON(e.data))
			}
			u.length > 0 && (r[l] = u, s = !0)
		}
		s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
		const o = this.groups;
		o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
		const a = this.boundingSphere;
		return a !== null && (e.data.boundingSphere = {
			center: a.center.toArray(),
			radius: a.radius
		}), e
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(e) {
		this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
		const t = {};
		this.name = e.name;
		const i = e.index;
		i !== null && this.setIndex(i.clone(t));
		const r = e.attributes;
		for (const c in r) {
			const u = r[c];
			this.setAttribute(c, u.clone(t))
		}
		const s = e.morphAttributes;
		for (const c in s) {
			const u = [],
				h = s[c];
			for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
			this.morphAttributes[c] = u
		}
		this.morphTargetsRelative = e.morphTargetsRelative;
		const o = e.groups;
		for (let c = 0, u = o.length; c < u; c++) {
			const h = o[c];
			this.addGroup(h.start, h.count, h.materialIndex)
		}
		const a = e.boundingBox;
		a !== null && (this.boundingBox = a.clone());
		const l = e.boundingSphere;
		return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
const X2 = new pt,
	za = new Su,
	Pf = new Is,
	Y2 = new X,
	ic = new X,
	rc = new X,
	sc = new X,
	Pg = new X,
	Rf = new X,
	Lf = new Oe,
	kf = new Oe,
	If = new Oe,
	K2 = new X,
	Z2 = new X,
	J2 = new X,
	Of = new X,
	Ff = new X;
class an extends ht {
	constructor(e = new gi, t = new yr) {
		super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e, t) {
		return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			i = Object.keys(t);
		if (i.length > 0) {
			const r = t[i[0]];
			if (r !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let s = 0, o = r.length; s < o; s++) {
					const a = r[s].name || String(s);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
				}
			}
		}
	}
	getVertexPosition(e, t) {
		const i = this.geometry,
			r = i.attributes.position,
			s = i.morphAttributes.position,
			o = i.morphTargetsRelative;
		t.fromBufferAttribute(r, e);
		const a = this.morphTargetInfluences;
		if (s && a) {
			Rf.set(0, 0, 0);
			for (let l = 0, c = s.length; l < c; l++) {
				const u = a[l],
					h = s[l];
				u !== 0 && (Pg.fromBufferAttribute(h, e), o ? Rf.addScaledVector(Pg, u) : Rf.addScaledVector(Pg.sub(t), u))
			}
			t.add(Rf)
		}
		return t
	}
	raycast(e, t) {
		const i = this.geometry,
			r = this.material,
			s = this.matrixWorld;
		r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Pf.copy(i.boundingSphere), Pf.applyMatrix4(s), za.copy(e.ray).recast(e.near), !(Pf.containsPoint(za.origin) === !1 && (za.intersectSphere(Pf, Y2) === null || za.origin.distanceToSquared(Y2) > (e.far - e.near) ** 2)) && (X2.copy(s).invert(), za.copy(e.ray).applyMatrix4(X2), !(i.boundingBox !== null && za.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, za)))
	}
	_computeIntersections(e, t, i) {
		let r;
		const s = this.geometry,
			o = this.material,
			a = s.index,
			l = s.attributes.position,
			c = s.attributes.uv,
			u = s.attributes.uv1,
			h = s.attributes.normal,
			d = s.groups,
			f = s.drawRange;
		if (a !== null)
			if (Array.isArray(o))
				for (let p = 0, _ = d.length; p < _; p++) {
					const g = d[p],
						m = o[g.materialIndex],
						b = Math.max(g.start, f.start),
						v = Math.min(a.count, Math.min(g.start + g.count, f.start + f.count));
					for (let y = b, x = v; y < x; y += 3) {
						const S = a.getX(y),
							E = a.getX(y + 1),
							C = a.getX(y + 2);
						r = Nf(this, m, e, i, c, u, h, S, E, C), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = g.materialIndex, t.push(r))
					}
				} else {
					const p = Math.max(0, f.start),
						_ = Math.min(a.count, f.start + f.count);
					for (let g = p, m = _; g < m; g += 3) {
						const b = a.getX(g),
							v = a.getX(g + 1),
							y = a.getX(g + 2);
						r = Nf(this, o, e, i, c, u, h, b, v, y), r && (r.faceIndex = Math.floor(g / 3), t.push(r))
					}
				} else if (l !== void 0)
					if (Array.isArray(o))
						for (let p = 0, _ = d.length; p < _; p++) {
							const g = d[p],
								m = o[g.materialIndex],
								b = Math.max(g.start, f.start),
								v = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
							for (let y = b, x = v; y < x; y += 3) {
								const S = y,
									E = y + 1,
									C = y + 2;
								r = Nf(this, m, e, i, c, u, h, S, E, C), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = g.materialIndex, t.push(r))
							}
						} else {
							const p = Math.max(0, f.start),
								_ = Math.min(l.count, f.start + f.count);
							for (let g = p, m = _; g < m; g += 3) {
								const b = g,
									v = g + 1,
									y = g + 2;
								r = Nf(this, o, e, i, c, u, h, b, v, y), r && (r.faceIndex = Math.floor(g / 3), t.push(r))
							}
						}
	}
}

function nH(n, e, t, i, r, s, o, a) {
	let l;
	if (e.side === ji ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === fo, a), l === null) return null;
	Ff.copy(a), Ff.applyMatrix4(n.matrixWorld);
	const c = t.ray.origin.distanceTo(Ff);
	return c < t.near || c > t.far ? null : {
		distance: c,
		point: Ff.clone(),
		object: n
	}
}

function Nf(n, e, t, i, r, s, o, a, l, c) {
	n.getVertexPosition(a, ic), n.getVertexPosition(l, rc), n.getVertexPosition(c, sc);
	const u = nH(n, e, t, i, ic, rc, sc, Of);
	if (u) {
		r && (Lf.fromBufferAttribute(r, a), kf.fromBufferAttribute(r, l), If.fromBufferAttribute(r, c), u.uv = vs.getInterpolation(Of, ic, rc, sc, Lf, kf, If, new Oe)), s && (Lf.fromBufferAttribute(s, a), kf.fromBufferAttribute(s, l), If.fromBufferAttribute(s, c), u.uv1 = vs.getInterpolation(Of, ic, rc, sc, Lf, kf, If, new Oe)), o && (K2.fromBufferAttribute(o, a), Z2.fromBufferAttribute(o, l), J2.fromBufferAttribute(o, c), u.normal = vs.getInterpolation(Of, ic, rc, sc, K2, Z2, J2, new X), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
		const h = {
			a,
			b: l,
			c,
			normal: new X,
			materialIndex: 0
		};
		vs.getNormal(ic, rc, sc, h.normal), u.face = h
	}
	return u
}
class Tu extends gi {
	constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
		super(), this.type = "BoxGeometry", this.parameters = {
			width: e,
			height: t,
			depth: i,
			widthSegments: r,
			heightSegments: s,
			depthSegments: o
		};
		const a = this;
		r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
		const l = [],
			c = [],
			u = [],
			h = [];
		let d = 0,
			f = 0;
		p("z", "y", "x", -1, -1, i, t, e, o, s, 0), p("z", "y", "x", 1, -1, i, t, -e, o, s, 1), p("x", "z", "y", 1, 1, e, i, t, r, o, 2), p("x", "z", "y", 1, -1, e, i, -t, r, o, 3), p("x", "y", "z", 1, -1, e, t, i, r, s, 4), p("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new $i(c, 3)), this.setAttribute("normal", new $i(u, 3)), this.setAttribute("uv", new $i(h, 2));

		function p(_, g, m, b, v, y, x, S, E, C, P) {
			const w = y / E,
				D = x / C,
				U = y / 2,
				j = x / 2,
				z = S / 2,
				H = E + 1,
				F = C + 1;
			let G = 0,
				R = 0;
			const Q = new X;
			for (let B = 0; B < F; B++) {
				const ge = B * D - j;
				for (let Ae = 0; Ae < H; Ae++) {
					const ze = Ae * w - U;
					Q[_] = ze * b, Q[g] = ge * v, Q[m] = z, c.push(Q.x, Q.y, Q.z), Q[_] = 0, Q[g] = 0, Q[m] = S > 0 ? 1 : -1, u.push(Q.x, Q.y, Q.z), h.push(Ae / E), h.push(1 - B / C), G += 1
				}
			}
			for (let B = 0; B < C; B++)
				for (let ge = 0; ge < E; ge++) {
					const Ae = d + ge + H * B,
						ze = d + ge + H * (B + 1),
						K = d + (ge + 1) + H * (B + 1),
						ye = d + (ge + 1) + H * B;
					l.push(Ae, ze, ye), l.push(ze, K, ye), R += 6
				}
			a.addGroup(f, R, P), f += R, d += G
		}
	}
	copy(e) {
		return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
	}
	static fromJSON(e) {
		return new Tu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
	}
}

function hu(n) {
	const e = {};
	for (const t in n) {
		e[t] = {};
		for (const i in n[t]) {
			const r = n[t][i];
			r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
		}
	}
	return e
}

function Si(n) {
	const e = {};
	for (let t = 0; t < n.length; t++) {
		const i = hu(n[t]);
		for (const r in i) e[r] = i[r]
	}
	return e
}

function iH(n) {
	const e = [];
	for (let t = 0; t < n.length; t++) e.push(n[t].clone());
	return e
}

function OD(n) {
	return n.getRenderTarget() === null ? n.outputColorSpace : Lt.workingColorSpace
}
const Rb = {
	clone: hu,
	merge: Si
};
var rH = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
	sH = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Dn extends Cs {
	constructor(e) {
		super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = rH, this.fragmentShader = sH, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1,
			clipCullDistance: !1,
			multiDraw: !1
		}, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv1: [0, 0]
		}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = hu(e.uniforms), this.uniformsGroups = iH(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		t.glslVersion = this.glslVersion, t.uniforms = {};
		for (const r in this.uniforms) {
			const o = this.uniforms[r].value;
			o && o.isTexture ? t.uniforms[r] = {
				type: "t",
				value: o.toJSON(e).uuid
			} : o && o.isColor ? t.uniforms[r] = {
				type: "c",
				value: o.getHex()
			} : o && o.isVector2 ? t.uniforms[r] = {
				type: "v2",
				value: o.toArray()
			} : o && o.isVector3 ? t.uniforms[r] = {
				type: "v3",
				value: o.toArray()
			} : o && o.isVector4 ? t.uniforms[r] = {
				type: "v4",
				value: o.toArray()
			} : o && o.isMatrix3 ? t.uniforms[r] = {
				type: "m3",
				value: o.toArray()
			} : o && o.isMatrix4 ? t.uniforms[r] = {
				type: "m4",
				value: o.toArray()
			} : t.uniforms[r] = {
				value: o
			}
		}
		Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
		const i = {};
		for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
		return Object.keys(i).length > 0 && (t.extensions = i), t
	}
}
class Lb extends ht {
	constructor() {
		super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new pt, this.projectionMatrix = new pt, this.projectionMatrixInverse = new pt, this.coordinateSystem = eo
	}
	copy(e, t) {
		return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
	}
	getWorldDirection(e) {
		return super.getWorldDirection(e).negate()
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	updateWorldMatrix(e, t) {
		super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const Po = new X,
	Q2 = new Oe,
	eE = new Oe;
class Yn extends Lb {
	constructor(e = 50, t = 1, i = .1, r = 2e3) {
		super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
	}
	copy(e, t) {
		return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
	}
	setFocalLength(e) {
		const t = .5 * this.getFilmHeight() / e;
		this.fov = uu * 2 * Math.atan(t), this.updateProjectionMatrix()
	}
	getFocalLength() {
		const e = Math.tan(kh * .5 * this.fov);
		return .5 * this.getFilmHeight() / e
	}
	getEffectiveFOV() {
		return uu * 2 * Math.atan(Math.tan(kh * .5 * this.fov) / this.zoom)
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1)
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1)
	}
	getViewBounds(e, t, i) {
		Po.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Po.x, Po.y).multiplyScalar(-e / Po.z), Po.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(Po.x, Po.y).multiplyScalar(-e / Po.z)
	}
	getViewSize(e, t) {
		return this.getViewBounds(e, Q2, eE), t.subVectors(eE, Q2)
	}
	setViewOffset(e, t, i, r, s, o) {
		this.aspect = e / t, this.view === null && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const e = this.near;
		let t = e * Math.tan(kh * .5 * this.fov) / this.zoom,
			i = 2 * t,
			r = this.aspect * i,
			s = -.5 * r;
		const o = this.view;
		if (this.view !== null && this.view.enabled) {
			const l = o.fullWidth,
				c = o.fullHeight;
			s += o.offsetX * r / l, t -= o.offsetY * i / c, r *= o.width / l, i *= o.height / c
		}
		const a = this.filmOffset;
		a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
	}
}
const oc = -90,
	ac = 1;
class oH extends ht {
	constructor(e, t, i) {
		super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
		const r = new Yn(oc, ac, e, t);
		r.layers = this.layers, this.add(r);
		const s = new Yn(oc, ac, e, t);
		s.layers = this.layers, this.add(s);
		const o = new Yn(oc, ac, e, t);
		o.layers = this.layers, this.add(o);
		const a = new Yn(oc, ac, e, t);
		a.layers = this.layers, this.add(a);
		const l = new Yn(oc, ac, e, t);
		l.layers = this.layers, this.add(l);
		const c = new Yn(oc, ac, e, t);
		c.layers = this.layers, this.add(c)
	}
	updateCoordinateSystem() {
		const e = this.coordinateSystem,
			t = this.children.concat(),
			[i, r, s, o, a, l] = t;
		for (const c of t) this.remove(c);
		if (e === eo) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
		else if (e === am) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
		else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
		for (const c of t) this.add(c), c.updateMatrixWorld()
	}
	update(e, t) {
		this.parent === null && this.updateMatrixWorld();
		const {
			renderTarget: i,
			activeMipmapLevel: r
		} = this;
		this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
		const [s, o, a, l, c, u] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), p = e.xr.enabled;
		e.xr.enabled = !1;
		const _ = i.texture.generateMipmaps;
		i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, o), e.setRenderTarget(i, 2, r), e.render(t, a), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, c), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, r), e.render(t, u), e.setRenderTarget(h, d, f), e.xr.enabled = p, i.texture.needsPMREMUpdate = !0
	}
}
class FD extends Kn {
	constructor(e, t, i, r, s, o, a, l, c, u) {
		e = e !== void 0 ? e : [], t = t !== void 0 ? t : su, super(e, t, i, r, s, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
	}
	get images() {
		return this.image
	}
	set images(e) {
		this.image = e
	}
}
class aH extends xa {
	constructor(e = 1, t = {}) {
		super(e, e, t), this.isWebGLCubeRenderTarget = !0;
		const i = {
				width: e,
				height: e,
				depth: 1
			},
			r = [i, i, i, i, i, i];
		this.texture = new FD(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : jn
	}
	fromEquirectangularTexture(e, t) {
		this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
		const i = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			},
			r = new Tu(5, 5, 5),
			s = new Dn({
				name: "CubemapFromEquirect",
				uniforms: hu(i.uniforms),
				vertexShader: i.vertexShader,
				fragmentShader: i.fragmentShader,
				side: ji,
				blending: ua
			});
		s.uniforms.tEquirect.value = t;
		const o = new an(r, s),
			a = t.minFilter;
		return t.minFilter === Qs && (t.minFilter = jn), new oH(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
	}
	clear(e, t, i, r) {
		const s = e.getRenderTarget();
		for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
		e.setRenderTarget(s)
	}
}
const Rg = new X,
	lH = new X,
	cH = new gt;
let Ho = class {
	constructor(e = new X(1, 0, 0), t = 0) {
		this.isPlane = !0, this.normal = e, this.constant = t
	}
	set(e, t) {
		return this.normal.copy(e), this.constant = t, this
	}
	setComponents(e, t, i, r) {
		return this.normal.set(e, t, i), this.constant = r, this
	}
	setFromNormalAndCoplanarPoint(e, t) {
		return this.normal.copy(e), this.constant = -t.dot(this.normal), this
	}
	setFromCoplanarPoints(e, t, i) {
		const r = Rg.subVectors(i, t).cross(lH.subVectors(e, t)).normalize();
		return this.setFromNormalAndCoplanarPoint(r, e), this
	}
	copy(e) {
		return this.normal.copy(e.normal), this.constant = e.constant, this
	}
	normalize() {
		const e = 1 / this.normal.length();
		return this.normal.multiplyScalar(e), this.constant *= e, this
	}
	negate() {
		return this.constant *= -1, this.normal.negate(), this
	}
	distanceToPoint(e) {
		return this.normal.dot(e) + this.constant
	}
	distanceToSphere(e) {
		return this.distanceToPoint(e.center) - e.radius
	}
	projectPoint(e, t) {
		return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
	}
	intersectLine(e, t) {
		const i = e.delta(Rg),
			r = this.normal.dot(i);
		if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
		const s = -(e.start.dot(this.normal) + this.constant) / r;
		return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
	}
	intersectsLine(e) {
		const t = this.distanceToPoint(e.start),
			i = this.distanceToPoint(e.end);
		return t < 0 && i > 0 || i < 0 && t > 0
	}
	intersectsBox(e) {
		return e.intersectsPlane(this)
	}
	intersectsSphere(e) {
		return e.intersectsPlane(this)
	}
	coplanarPoint(e) {
		return e.copy(this.normal).multiplyScalar(-this.constant)
	}
	applyMatrix4(e, t) {
		const i = t || cH.getNormalMatrix(e),
			r = this.coplanarPoint(Rg).applyMatrix4(e),
			s = this.normal.applyMatrix3(i).normalize();
		return this.constant = -r.dot(s), this
	}
	translate(e) {
		return this.constant -= e.dot(this.normal), this
	}
	equals(e) {
		return e.normal.equals(this.normal) && e.constant === this.constant
	}
	clone() {
		return new this.constructor().copy(this)
	}
};
const Va = new Is,
	Uf = new X;
class kb {
	constructor(e = new Ho, t = new Ho, i = new Ho, r = new Ho, s = new Ho, o = new Ho) {
		this.planes = [e, t, i, r, s, o]
	}
	set(e, t, i, r, s, o) {
		const a = this.planes;
		return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this
	}
	copy(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
		return this
	}
	setFromProjectionMatrix(e, t = eo) {
		const i = this.planes,
			r = e.elements,
			s = r[0],
			o = r[1],
			a = r[2],
			l = r[3],
			c = r[4],
			u = r[5],
			h = r[6],
			d = r[7],
			f = r[8],
			p = r[9],
			_ = r[10],
			g = r[11],
			m = r[12],
			b = r[13],
			v = r[14],
			y = r[15];
		if (i[0].setComponents(l - s, d - c, g - f, y - m).normalize(), i[1].setComponents(l + s, d + c, g + f, y + m).normalize(), i[2].setComponents(l + o, d + u, g + p, y + b).normalize(), i[3].setComponents(l - o, d - u, g - p, y - b).normalize(), i[4].setComponents(l - a, d - h, g - _, y - v).normalize(), t === eo) i[5].setComponents(l + a, d + h, g + _, y + v).normalize();
		else if (t === am) i[5].setComponents(a, h, _, v).normalize();
		else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
		return this
	}
	intersectsObject(e) {
		if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Va.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
		else {
			const t = e.geometry;
			t.boundingSphere === null && t.computeBoundingSphere(), Va.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
		}
		return this.intersectsSphere(Va)
	}
	intersectsSprite(e) {
		return Va.center.set(0, 0, 0), Va.radius = .7071067811865476, Va.applyMatrix4(e.matrixWorld), this.intersectsSphere(Va)
	}
	intersectsSphere(e) {
		const t = this.planes,
			i = e.center,
			r = -e.radius;
		for (let s = 0; s < 6; s++)
			if (t[s].distanceToPoint(i) < r) return !1;
		return !0
	}
	intersectsBox(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++) {
			const r = t[i];
			if (Uf.x = r.normal.x > 0 ? e.max.x : e.min.x, Uf.y = r.normal.y > 0 ? e.max.y : e.min.y, Uf.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Uf) < 0) return !1
		}
		return !0
	}
	containsPoint(e) {
		const t = this.planes;
		for (let i = 0; i < 6; i++)
			if (t[i].distanceToPoint(e) < 0) return !1;
		return !0
	}
	clone() {
		return new this.constructor().copy(this)
	}
}

function ND() {
	let n = null,
		e = !1,
		t = null,
		i = null;

	function r(s, o) {
		t(s, o), i = n.requestAnimationFrame(r)
	}
	return {
		start: function () {
			e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0)
		},
		stop: function () {
			n.cancelAnimationFrame(i), e = !1
		},
		setAnimationLoop: function (s) {
			t = s
		},
		setContext: function (s) {
			n = s
		}
	}
}

function uH(n, e) {
	const t = e.isWebGL2,
		i = new WeakMap;

	function r(c, u) {
		const h = c.array,
			d = c.usage,
			f = h.byteLength,
			p = n.createBuffer();
		n.bindBuffer(u, p), n.bufferData(u, h, d), c.onUploadCallback();
		let _;
		if (h instanceof Float32Array) _ = n.FLOAT;
		else if (h instanceof Uint16Array)
			if (c.isFloat16BufferAttribute)
				if (t) _ = n.HALF_FLOAT;
				else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
		else _ = n.UNSIGNED_SHORT;
		else if (h instanceof Int16Array) _ = n.SHORT;
		else if (h instanceof Uint32Array) _ = n.UNSIGNED_INT;
		else if (h instanceof Int32Array) _ = n.INT;
		else if (h instanceof Int8Array) _ = n.BYTE;
		else if (h instanceof Uint8Array) _ = n.UNSIGNED_BYTE;
		else if (h instanceof Uint8ClampedArray) _ = n.UNSIGNED_BYTE;
		else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
		return {
			buffer: p,
			type: _,
			bytesPerElement: h.BYTES_PER_ELEMENT,
			version: c.version,
			size: f
		}
	}

	function s(c, u, h) {
		const d = u.array,
			f = u._updateRange,
			p = u.updateRanges;
		if (n.bindBuffer(h, c), f.count === -1 && p.length === 0 && n.bufferSubData(h, 0, d), p.length !== 0) {
			for (let _ = 0, g = p.length; _ < g; _++) {
				const m = p[_];
				t ? n.bufferSubData(h, m.start * d.BYTES_PER_ELEMENT, d, m.start, m.count) : n.bufferSubData(h, m.start * d.BYTES_PER_ELEMENT, d.subarray(m.start, m.start + m.count))
			}
			u.clearUpdateRanges()
		}
		f.count !== -1 && (t ? n.bufferSubData(h, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : n.bufferSubData(h, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)), f.count = -1), u.onUploadCallback()
	}

	function o(c) {
		return c.isInterleavedBufferAttribute && (c = c.data), i.get(c)
	}

	function a(c) {
		c.isInterleavedBufferAttribute && (c = c.data);
		const u = i.get(c);
		u && (n.deleteBuffer(u.buffer), i.delete(c))
	}

	function l(c, u) {
		if (c.isGLBufferAttribute) {
			const d = i.get(c);
			(!d || d.version < c.version) && i.set(c, {
				buffer: c.buffer,
				type: c.type,
				bytesPerElement: c.elementSize,
				version: c.version
			});
			return
		}
		c.isInterleavedBufferAttribute && (c = c.data);
		const h = i.get(c);
		if (h === void 0) i.set(c, r(c, u));
		else if (h.version < c.version) {
			if (h.size !== c.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
			s(h.buffer, c, u), h.version = c.version
		}
	}
	return {
		get: o,
		remove: a,
		update: l
	}
}
class os extends gi {
	constructor(e = 1, t = 1, i = 1, r = 1) {
		super(), this.type = "PlaneGeometry", this.parameters = {
			width: e,
			height: t,
			widthSegments: i,
			heightSegments: r
		};
		const s = e / 2,
			o = t / 2,
			a = Math.floor(i),
			l = Math.floor(r),
			c = a + 1,
			u = l + 1,
			h = e / a,
			d = t / l,
			f = [],
			p = [],
			_ = [],
			g = [];
		for (let m = 0; m < u; m++) {
			const b = m * d - o;
			for (let v = 0; v < c; v++) {
				const y = v * h - s;
				p.push(y, -b, 0), _.push(0, 0, 1), g.push(v / a), g.push(1 - m / l)
			}
		}
		for (let m = 0; m < l; m++)
			for (let b = 0; b < a; b++) {
				const v = b + c * m,
					y = b + c * (m + 1),
					x = b + 1 + c * (m + 1),
					S = b + 1 + c * m;
				f.push(v, y, S), f.push(y, x, S)
			}
		this.setIndex(f), this.setAttribute("position", new $i(p, 3)), this.setAttribute("normal", new $i(_, 3)), this.setAttribute("uv", new $i(g, 2))
	}
	copy(e) {
		return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
	}
	static fromJSON(e) {
		return new os(e.width, e.height, e.widthSegments, e.heightSegments)
	}
}
var hH = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
	dH = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
	fH = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
	pH = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	mH = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
	gH = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
	_H = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
	vH = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
	bH = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
	yH = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
	xH = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
	wH = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
	EH = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
	SH = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
	TH = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
	MH = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
	CH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
	AH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
	DH = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
	PH = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
	RH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
	LH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
	kH = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
	IH = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
	OH = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
	FH = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
	NH = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
	UH = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
	BH = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
	zH = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
	VH = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
	HH = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
	GH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
	WH = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
	jH = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
	$H = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
	qH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
	XH = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
	YH = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
	KH = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
	ZH = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
	JH = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
	QH = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
	eG = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
	tG = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
	nG = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
	iG = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
	rG = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
	sG = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
	oG = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
	aG = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
	lG = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
	cG = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
	uG = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
	hG = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
	dG = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
	fG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
	pG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
	mG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
	gG = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
	_G = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
	vG = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
	bG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
	yG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
	xG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
	wG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
	EG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
	SG = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
	TG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
	MG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
	CG = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
	AG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
	DG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
	PG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
	RG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	LG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
	kG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
	IG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
	OG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
	FG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
	NG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
	UG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
	BG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
	zG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
	VG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
	HG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
	GG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
	WG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
	jG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
	$G = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
	qG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
	XG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
	YG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
	KG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
	ZG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
	JG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
	QG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
	eW = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
	tW = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
	nW = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
	iW = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
	rW = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
	sW = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
	oW = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
	aW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
	lW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
	cW = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
	uW = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const hW = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
	dW = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	fW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
	pW = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	mW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
	gW = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	_W = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
	vW = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
	bW = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
	yW = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
	xW = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
	wW = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	EW = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	SW = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	TW = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
	MW = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	CW = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	AW = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	DW = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
	PW = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	RW = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
	LW = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
	kW = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	IW = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	OW = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
	FW = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	NW = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	UW = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
	BW = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
	zW = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
	VW = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
	HW = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	GW = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
	WW = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	mt = {
		alphahash_fragment: hH,
		alphahash_pars_fragment: dH,
		alphamap_fragment: fH,
		alphamap_pars_fragment: pH,
		alphatest_fragment: mH,
		alphatest_pars_fragment: gH,
		aomap_fragment: _H,
		aomap_pars_fragment: vH,
		batching_pars_vertex: bH,
		batching_vertex: yH,
		begin_vertex: xH,
		beginnormal_vertex: wH,
		bsdfs: EH,
		iridescence_fragment: SH,
		bumpmap_pars_fragment: TH,
		clipping_planes_fragment: MH,
		clipping_planes_pars_fragment: CH,
		clipping_planes_pars_vertex: AH,
		clipping_planes_vertex: DH,
		color_fragment: PH,
		color_pars_fragment: RH,
		color_pars_vertex: LH,
		color_vertex: kH,
		common: IH,
		cube_uv_reflection_fragment: OH,
		defaultnormal_vertex: FH,
		displacementmap_pars_vertex: NH,
		displacementmap_vertex: UH,
		emissivemap_fragment: BH,
		emissivemap_pars_fragment: zH,
		colorspace_fragment: VH,
		colorspace_pars_fragment: HH,
		envmap_fragment: GH,
		envmap_common_pars_fragment: WH,
		envmap_pars_fragment: jH,
		envmap_pars_vertex: $H,
		envmap_physical_pars_fragment: rG,
		envmap_vertex: qH,
		fog_vertex: XH,
		fog_pars_vertex: YH,
		fog_fragment: KH,
		fog_pars_fragment: ZH,
		gradientmap_pars_fragment: JH,
		lightmap_fragment: QH,
		lightmap_pars_fragment: eG,
		lights_lambert_fragment: tG,
		lights_lambert_pars_fragment: nG,
		lights_pars_begin: iG,
		lights_toon_fragment: sG,
		lights_toon_pars_fragment: oG,
		lights_phong_fragment: aG,
		lights_phong_pars_fragment: lG,
		lights_physical_fragment: cG,
		lights_physical_pars_fragment: uG,
		lights_fragment_begin: hG,
		lights_fragment_maps: dG,
		lights_fragment_end: fG,
		logdepthbuf_fragment: pG,
		logdepthbuf_pars_fragment: mG,
		logdepthbuf_pars_vertex: gG,
		logdepthbuf_vertex: _G,
		map_fragment: vG,
		map_pars_fragment: bG,
		map_particle_fragment: yG,
		map_particle_pars_fragment: xG,
		metalnessmap_fragment: wG,
		metalnessmap_pars_fragment: EG,
		morphinstance_vertex: SG,
		morphcolor_vertex: TG,
		morphnormal_vertex: MG,
		morphtarget_pars_vertex: CG,
		morphtarget_vertex: AG,
		normal_fragment_begin: DG,
		normal_fragment_maps: PG,
		normal_pars_fragment: RG,
		normal_pars_vertex: LG,
		normal_vertex: kG,
		normalmap_pars_fragment: IG,
		clearcoat_normal_fragment_begin: OG,
		clearcoat_normal_fragment_maps: FG,
		clearcoat_pars_fragment: NG,
		iridescence_pars_fragment: UG,
		opaque_fragment: BG,
		packing: zG,
		premultiplied_alpha_fragment: VG,
		project_vertex: HG,
		dithering_fragment: GG,
		dithering_pars_fragment: WG,
		roughnessmap_fragment: jG,
		roughnessmap_pars_fragment: $G,
		shadowmap_pars_fragment: qG,
		shadowmap_pars_vertex: XG,
		shadowmap_vertex: YG,
		shadowmask_pars_fragment: KG,
		skinbase_vertex: ZG,
		skinning_pars_vertex: JG,
		skinning_vertex: QG,
		skinnormal_vertex: eW,
		specularmap_fragment: tW,
		specularmap_pars_fragment: nW,
		tonemapping_fragment: iW,
		tonemapping_pars_fragment: rW,
		transmission_fragment: sW,
		transmission_pars_fragment: oW,
		uv_pars_fragment: aW,
		uv_pars_vertex: lW,
		uv_vertex: cW,
		worldpos_vertex: uW,
		background_vert: hW,
		background_frag: dW,
		backgroundCube_vert: fW,
		backgroundCube_frag: pW,
		cube_vert: mW,
		cube_frag: gW,
		depth_vert: _W,
		depth_frag: vW,
		distanceRGBA_vert: bW,
		distanceRGBA_frag: yW,
		equirect_vert: xW,
		equirect_frag: wW,
		linedashed_vert: EW,
		linedashed_frag: SW,
		meshbasic_vert: TW,
		meshbasic_frag: MW,
		meshlambert_vert: CW,
		meshlambert_frag: AW,
		meshmatcap_vert: DW,
		meshmatcap_frag: PW,
		meshnormal_vert: RW,
		meshnormal_frag: LW,
		meshphong_vert: kW,
		meshphong_frag: IW,
		meshphysical_vert: OW,
		meshphysical_frag: FW,
		meshtoon_vert: NW,
		meshtoon_frag: UW,
		points_vert: BW,
		points_frag: zW,
		shadow_vert: VW,
		shadow_frag: HW,
		sprite_vert: GW,
		sprite_frag: WW
	},
	Ue = {
		common: {
			diffuse: {
				value: new et(16777215)
			},
			opacity: {
				value: 1
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new gt
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new gt
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			},
			specularMapTransform: {
				value: new gt
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			envMapRotation: {
				value: new gt
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1
			},
			ior: {
				value: 1.5
			},
			refractionRatio: {
				value: .98
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			},
			aoMapTransform: {
				value: new gt
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			},
			lightMapTransform: {
				value: new gt
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpMapTransform: {
				value: new gt
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalMapTransform: {
				value: new gt
			},
			normalScale: {
				value: new Oe(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementMapTransform: {
				value: new gt
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			},
			emissiveMapTransform: {
				value: new gt
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			},
			metalnessMapTransform: {
				value: new gt
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			},
			roughnessMapTransform: {
				value: new gt
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 25e-5
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2e3
			},
			fogColor: {
				value: new et(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotLightMap: {
				value: []
			},
			spotShadowMap: {
				value: []
			},
			spotLightMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new et(16777215)
			},
			opacity: {
				value: 1
			},
			size: {
				value: 1
			},
			scale: {
				value: 1
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new gt
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new gt
			}
		},
		sprite: {
			diffuse: {
				value: new et(16777215)
			},
			opacity: {
				value: 1
			},
			center: {
				value: new Oe(.5, .5)
			},
			rotation: {
				value: 0
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new gt
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new gt
			},
			alphaTest: {
				value: 0
			}
		}
	},
	ni = {
		basic: {
			uniforms: Si([Ue.common, Ue.specularmap, Ue.envmap, Ue.aomap, Ue.lightmap, Ue.fog]),
			vertexShader: mt.meshbasic_vert,
			fragmentShader: mt.meshbasic_frag
		},
		lambert: {
			uniforms: Si([Ue.common, Ue.specularmap, Ue.envmap, Ue.aomap, Ue.lightmap, Ue.emissivemap, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, Ue.fog, Ue.lights, {
				emissive: {
					value: new et(0)
				}
			}]),
			vertexShader: mt.meshlambert_vert,
			fragmentShader: mt.meshlambert_frag
		},
		phong: {
			uniforms: Si([Ue.common, Ue.specularmap, Ue.envmap, Ue.aomap, Ue.lightmap, Ue.emissivemap, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, Ue.fog, Ue.lights, {
				emissive: {
					value: new et(0)
				},
				specular: {
					value: new et(1118481)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: mt.meshphong_vert,
			fragmentShader: mt.meshphong_frag
		},
		standard: {
			uniforms: Si([Ue.common, Ue.envmap, Ue.aomap, Ue.lightmap, Ue.emissivemap, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, Ue.roughnessmap, Ue.metalnessmap, Ue.fog, Ue.lights, {
				emissive: {
					value: new et(0)
				},
				roughness: {
					value: 1
				},
				metalness: {
					value: 0
				},
				envMapIntensity: {
					value: 1
				}
			}]),
			vertexShader: mt.meshphysical_vert,
			fragmentShader: mt.meshphysical_frag
		},
		toon: {
			uniforms: Si([Ue.common, Ue.aomap, Ue.lightmap, Ue.emissivemap, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, Ue.gradientmap, Ue.fog, Ue.lights, {
				emissive: {
					value: new et(0)
				}
			}]),
			vertexShader: mt.meshtoon_vert,
			fragmentShader: mt.meshtoon_frag
		},
		matcap: {
			uniforms: Si([Ue.common, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, Ue.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: mt.meshmatcap_vert,
			fragmentShader: mt.meshmatcap_frag
		},
		points: {
			uniforms: Si([Ue.points, Ue.fog]),
			vertexShader: mt.points_vert,
			fragmentShader: mt.points_frag
		},
		dashed: {
			uniforms: Si([Ue.common, Ue.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: mt.linedashed_vert,
			fragmentShader: mt.linedashed_frag
		},
		depth: {
			uniforms: Si([Ue.common, Ue.displacementmap]),
			vertexShader: mt.depth_vert,
			fragmentShader: mt.depth_frag
		},
		normal: {
			uniforms: Si([Ue.common, Ue.bumpmap, Ue.normalmap, Ue.displacementmap, {
				opacity: {
					value: 1
				}
			}]),
			vertexShader: mt.meshnormal_vert,
			fragmentShader: mt.meshnormal_frag
		},
		sprite: {
			uniforms: Si([Ue.sprite, Ue.fog]),
			vertexShader: mt.sprite_vert,
			fragmentShader: mt.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new gt
				},
				t2D: {
					value: null
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: mt.background_vert,
			fragmentShader: mt.background_frag
		},
		backgroundCube: {
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				backgroundBlurriness: {
					value: 0
				},
				backgroundIntensity: {
					value: 1
				},
				backgroundRotation: {
					value: new gt
				}
			},
			vertexShader: mt.backgroundCube_vert,
			fragmentShader: mt.backgroundCube_frag
		},
		cube: {
			uniforms: {
				tCube: {
					value: null
				},
				tFlip: {
					value: -1
				},
				opacity: {
					value: 1
				}
			},
			vertexShader: mt.cube_vert,
			fragmentShader: mt.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: mt.equirect_vert,
			fragmentShader: mt.equirect_frag
		},
		distanceRGBA: {
			uniforms: Si([Ue.common, Ue.displacementmap, {
				referencePosition: {
					value: new X
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1e3
				}
			}]),
			vertexShader: mt.distanceRGBA_vert,
			fragmentShader: mt.distanceRGBA_frag
		},
		shadow: {
			uniforms: Si([Ue.lights, Ue.fog, {
				color: {
					value: new et(0)
				},
				opacity: {
					value: 1
				}
			}]),
			vertexShader: mt.shadow_vert,
			fragmentShader: mt.shadow_frag
		}
	};
ni.physical = {
	uniforms: Si([ni.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatMapTransform: {
			value: new gt
		},
		clearcoatNormalMap: {
			value: null
		},
		clearcoatNormalMapTransform: {
			value: new gt
		},
		clearcoatNormalScale: {
			value: new Oe(1, 1)
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatRoughnessMapTransform: {
			value: new gt
		},
		iridescence: {
			value: 0
		},
		iridescenceMap: {
			value: null
		},
		iridescenceMapTransform: {
			value: new gt
		},
		iridescenceIOR: {
			value: 1.3
		},
		iridescenceThicknessMinimum: {
			value: 100
		},
		iridescenceThicknessMaximum: {
			value: 400
		},
		iridescenceThicknessMap: {
			value: null
		},
		iridescenceThicknessMapTransform: {
			value: new gt
		},
		sheen: {
			value: 0
		},
		sheenColor: {
			value: new et(0)
		},
		sheenColorMap: {
			value: null
		},
		sheenColorMapTransform: {
			value: new gt
		},
		sheenRoughness: {
			value: 1
		},
		sheenRoughnessMap: {
			value: null
		},
		sheenRoughnessMapTransform: {
			value: new gt
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionMapTransform: {
			value: new gt
		},
		transmissionSamplerSize: {
			value: new Oe
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		thicknessMapTransform: {
			value: new gt
		},
		attenuationDistance: {
			value: 0
		},
		attenuationColor: {
			value: new et(0)
		},
		specularColor: {
			value: new et(1, 1, 1)
		},
		specularColorMap: {
			value: null
		},
		specularColorMapTransform: {
			value: new gt
		},
		specularIntensity: {
			value: 1
		},
		specularIntensityMap: {
			value: null
		},
		specularIntensityMapTransform: {
			value: new gt
		},
		anisotropyVector: {
			value: new Oe
		},
		anisotropyMap: {
			value: null
		},
		anisotropyMapTransform: {
			value: new gt
		}
	}]),
	vertexShader: mt.meshphysical_vert,
	fragmentShader: mt.meshphysical_frag
};
const Bf = {
		r: 0,
		b: 0,
		g: 0
	},
	Ha = new Er,
	jW = new pt;

function $W(n, e, t, i, r, s, o) {
	const a = new et(0);
	let l = s === !0 ? 0 : 1,
		c, u, h = null,
		d = 0,
		f = null;

	function p(g, m) {
		let b = !1,
			v = m.isScene === !0 ? m.background : null;
		v && v.isTexture && (v = (m.backgroundBlurriness > 0 ? t : e).get(v)), v === null ? _(a, l) : v && v.isColor && (_(v, 1), b = !0);
		const y = n.xr.getEnvironmentBlendMode();
		y === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : y === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n.autoClear || b) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), v && (v.isCubeTexture || v.mapping === Km) ? (u === void 0 && (u = new an(new Tu(1, 1, 1), new Dn({
			name: "BackgroundCubeMaterial",
			uniforms: hu(ni.backgroundCube.uniforms),
			vertexShader: ni.backgroundCube.vertexShader,
			fragmentShader: ni.backgroundCube.fragmentShader,
			side: ji,
			depthTest: !1,
			depthWrite: !1,
			fog: !1
		})), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (x, S, E) {
			this.matrixWorld.copyPosition(E.matrixWorld)
		}, Object.defineProperty(u.material, "envMap", {
			get: function () {
				return this.uniforms.envMap.value
			}
		}), r.update(u)), Ha.copy(m.backgroundRotation), Ha.x *= -1, Ha.y *= -1, Ha.z *= -1, v.isCubeTexture && v.isRenderTargetTexture === !1 && (Ha.y *= -1, Ha.z *= -1), u.material.uniforms.envMap.value = v, u.material.uniforms.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(jW.makeRotationFromEuler(Ha)), u.material.toneMapped = Lt.getTransfer(v.colorSpace) !== Qt, (h !== v || d !== v.version || f !== n.toneMapping) && (u.material.needsUpdate = !0, h = v, d = v.version, f = n.toneMapping), u.layers.enableAll(), g.unshift(u, u.geometry, u.material, 0, 0, null)) : v && v.isTexture && (c === void 0 && (c = new an(new os(2, 2), new Dn({
			name: "BackgroundMaterial",
			uniforms: hu(ni.background.uniforms),
			vertexShader: ni.background.vertexShader,
			fragmentShader: ni.background.fragmentShader,
			side: fo,
			depthTest: !1,
			depthWrite: !1,
			fog: !1
		})), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
			get: function () {
				return this.uniforms.t2D.value
			}
		}), r.update(c)), c.material.uniforms.t2D.value = v, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.toneMapped = Lt.getTransfer(v.colorSpace) !== Qt, v.matrixAutoUpdate === !0 && v.updateMatrix(), c.material.uniforms.uvTransform.value.copy(v.matrix), (h !== v || d !== v.version || f !== n.toneMapping) && (c.material.needsUpdate = !0, h = v, d = v.version, f = n.toneMapping), c.layers.enableAll(), g.unshift(c, c.geometry, c.material, 0, 0, null))
	}

	function _(g, m) {
		g.getRGB(Bf, OD(n)), i.buffers.color.setClear(Bf.r, Bf.g, Bf.b, m, o)
	}
	return {
		getClearColor: function () {
			return a
		},
		setClearColor: function (g, m = 1) {
			a.set(g), l = m, _(a, l)
		},
		getClearAlpha: function () {
			return l
		},
		setClearAlpha: function (g) {
			l = g, _(a, l)
		},
		render: p
	}
}

function qW(n, e, t, i) {
	const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
		s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
		o = i.isWebGL2 || s !== null,
		a = {},
		l = g(null);
	let c = l,
		u = !1;

	function h(z, H, F, G, R) {
		let Q = !1;
		if (o) {
			const B = _(G, F, H);
			c !== B && (c = B, f(c.object)), Q = m(z, G, F, R), Q && b(z, G, F, R)
		} else {
			const B = H.wireframe === !0;
			(c.geometry !== G.id || c.program !== F.id || c.wireframe !== B) && (c.geometry = G.id, c.program = F.id, c.wireframe = B, Q = !0)
		}
		R !== null && t.update(R, n.ELEMENT_ARRAY_BUFFER), (Q || u) && (u = !1, C(z, H, F, G), R !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(R).buffer))
	}

	function d() {
		return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
	}

	function f(z) {
		return i.isWebGL2 ? n.bindVertexArray(z) : s.bindVertexArrayOES(z)
	}

	function p(z) {
		return i.isWebGL2 ? n.deleteVertexArray(z) : s.deleteVertexArrayOES(z)
	}

	function _(z, H, F) {
		const G = F.wireframe === !0;
		let R = a[z.id];
		R === void 0 && (R = {}, a[z.id] = R);
		let Q = R[H.id];
		Q === void 0 && (Q = {}, R[H.id] = Q);
		let B = Q[G];
		return B === void 0 && (B = g(d()), Q[G] = B), B
	}

	function g(z) {
		const H = [],
			F = [],
			G = [];
		for (let R = 0; R < r; R++) H[R] = 0, F[R] = 0, G[R] = 0;
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: H,
			enabledAttributes: F,
			attributeDivisors: G,
			object: z,
			attributes: {},
			index: null
		}
	}

	function m(z, H, F, G) {
		const R = c.attributes,
			Q = H.attributes;
		let B = 0;
		const ge = F.getAttributes();
		for (const Ae in ge)
			if (ge[Ae].location >= 0) {
				const K = R[Ae];
				let ye = Q[Ae];
				if (ye === void 0 && (Ae === "instanceMatrix" && z.instanceMatrix && (ye = z.instanceMatrix), Ae === "instanceColor" && z.instanceColor && (ye = z.instanceColor)), K === void 0 || K.attribute !== ye || ye && K.data !== ye.data) return !0;
				B++
			} return c.attributesNum !== B || c.index !== G
	}

	function b(z, H, F, G) {
		const R = {},
			Q = H.attributes;
		let B = 0;
		const ge = F.getAttributes();
		for (const Ae in ge)
			if (ge[Ae].location >= 0) {
				let K = Q[Ae];
				K === void 0 && (Ae === "instanceMatrix" && z.instanceMatrix && (K = z.instanceMatrix), Ae === "instanceColor" && z.instanceColor && (K = z.instanceColor));
				const ye = {};
				ye.attribute = K, K && K.data && (ye.data = K.data), R[Ae] = ye, B++
			} c.attributes = R, c.attributesNum = B, c.index = G
	}

	function v() {
		const z = c.newAttributes;
		for (let H = 0, F = z.length; H < F; H++) z[H] = 0
	}

	function y(z) {
		x(z, 0)
	}

	function x(z, H) {
		const F = c.newAttributes,
			G = c.enabledAttributes,
			R = c.attributeDivisors;
		F[z] = 1, G[z] === 0 && (n.enableVertexAttribArray(z), G[z] = 1), R[z] !== H && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](z, H), R[z] = H)
	}

	function S() {
		const z = c.newAttributes,
			H = c.enabledAttributes;
		for (let F = 0, G = H.length; F < G; F++) H[F] !== z[F] && (n.disableVertexAttribArray(F), H[F] = 0)
	}

	function E(z, H, F, G, R, Q, B) {
		B === !0 ? n.vertexAttribIPointer(z, H, F, R, Q) : n.vertexAttribPointer(z, H, F, G, R, Q)
	}

	function C(z, H, F, G) {
		if (i.isWebGL2 === !1 && (z.isInstancedMesh || G.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
		v();
		const R = G.attributes,
			Q = F.getAttributes(),
			B = H.defaultAttributeValues;
		for (const ge in Q) {
			const Ae = Q[ge];
			if (Ae.location >= 0) {
				let ze = R[ge];
				if (ze === void 0 && (ge === "instanceMatrix" && z.instanceMatrix && (ze = z.instanceMatrix), ge === "instanceColor" && z.instanceColor && (ze = z.instanceColor)), ze !== void 0) {
					const K = ze.normalized,
						ye = ze.itemSize,
						Se = t.get(ze);
					if (Se === void 0) continue;
					const Z = Se.buffer,
						pe = Se.type,
						ce = Se.bytesPerElement,
						Ce = i.isWebGL2 === !0 && (pe === n.INT || pe === n.UNSIGNED_INT || ze.gpuType === mD);
					if (ze.isInterleavedBufferAttribute) {
						const Re = ze.data,
							Y = Re.stride,
							k = ze.offset;
						if (Re.isInstancedInterleavedBuffer) {
							for (let O = 0; O < Ae.locationSize; O++) x(Ae.location + O, Re.meshPerAttribute);
							z.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = Re.meshPerAttribute * Re.count)
						} else
							for (let O = 0; O < Ae.locationSize; O++) y(Ae.location + O);
						n.bindBuffer(n.ARRAY_BUFFER, Z);
						for (let O = 0; O < Ae.locationSize; O++) E(Ae.location + O, ye / Ae.locationSize, pe, K, Y * ce, (k + ye / Ae.locationSize * O) * ce, Ce)
					} else {
						if (ze.isInstancedBufferAttribute) {
							for (let Re = 0; Re < Ae.locationSize; Re++) x(Ae.location + Re, ze.meshPerAttribute);
							z.isInstancedMesh !== !0 && G._maxInstanceCount === void 0 && (G._maxInstanceCount = ze.meshPerAttribute * ze.count)
						} else
							for (let Re = 0; Re < Ae.locationSize; Re++) y(Ae.location + Re);
						n.bindBuffer(n.ARRAY_BUFFER, Z);
						for (let Re = 0; Re < Ae.locationSize; Re++) E(Ae.location + Re, ye / Ae.locationSize, pe, K, ye * ce, ye / Ae.locationSize * Re * ce, Ce)
					}
				} else if (B !== void 0) {
					const K = B[ge];
					if (K !== void 0) switch (K.length) {
						case 2:
							n.vertexAttrib2fv(Ae.location, K);
							break;
						case 3:
							n.vertexAttrib3fv(Ae.location, K);
							break;
						case 4:
							n.vertexAttrib4fv(Ae.location, K);
							break;
						default:
							n.vertexAttrib1fv(Ae.location, K)
					}
				}
			}
		}
		S()
	}

	function P() {
		U();
		for (const z in a) {
			const H = a[z];
			for (const F in H) {
				const G = H[F];
				for (const R in G) p(G[R].object), delete G[R];
				delete H[F]
			}
			delete a[z]
		}
	}

	function w(z) {
		if (a[z.id] === void 0) return;
		const H = a[z.id];
		for (const F in H) {
			const G = H[F];
			for (const R in G) p(G[R].object), delete G[R];
			delete H[F]
		}
		delete a[z.id]
	}

	function D(z) {
		for (const H in a) {
			const F = a[H];
			if (F[z.id] === void 0) continue;
			const G = F[z.id];
			for (const R in G) p(G[R].object), delete G[R];
			delete F[z.id]
		}
	}

	function U() {
		j(), u = !0, c !== l && (c = l, f(c.object))
	}

	function j() {
		l.geometry = null, l.program = null, l.wireframe = !1
	}
	return {
		setup: h,
		reset: U,
		resetDefaultState: j,
		dispose: P,
		releaseStatesOfGeometry: w,
		releaseStatesOfProgram: D,
		initAttributes: v,
		enableAttribute: y,
		disableUnusedAttributes: S
	}
}

function XW(n, e, t, i) {
	const r = i.isWebGL2;
	let s;

	function o(u) {
		s = u
	}

	function a(u, h) {
		n.drawArrays(s, u, h), t.update(h, s, 1)
	}

	function l(u, h, d) {
		if (d === 0) return;
		let f, p;
		if (r) f = n, p = "drawArraysInstanced";
		else if (f = e.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", f === null) {
			console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			return
		}
		f[p](s, u, h, d), t.update(h, s, d)
	}

	function c(u, h, d) {
		if (d === 0) return;
		const f = e.get("WEBGL_multi_draw");
		if (f === null)
			for (let p = 0; p < d; p++) this.render(u[p], h[p]);
		else {
			f.multiDrawArraysWEBGL(s, u, 0, h, 0, d);
			let p = 0;
			for (let _ = 0; _ < d; _++) p += h[_];
			t.update(p, s, 1)
		}
	}
	this.setMode = o, this.render = a, this.renderInstances = l, this.renderMultiDraw = c
}

function YW(n, e, t) {
	let i;

	function r() {
		if (i !== void 0) return i;
		if (e.has("EXT_texture_filter_anisotropic") === !0) {
			const E = e.get("EXT_texture_filter_anisotropic");
			i = n.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
		} else i = 0;
		return i
	}

	function s(E) {
		if (E === "highp") {
			if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
			E = "mediump"
		}
		return E === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
	}
	const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
	let a = t.precision !== void 0 ? t.precision : "highp";
	const l = s(a);
	l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
	const c = o || e.has("WEBGL_draw_buffers"),
		u = t.logarithmicDepthBuffer === !0,
		h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
		d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
		f = n.getParameter(n.MAX_TEXTURE_SIZE),
		p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
		_ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
		g = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
		m = n.getParameter(n.MAX_VARYING_VECTORS),
		b = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
		v = d > 0,
		y = o || e.has("OES_texture_float"),
		x = v && y,
		S = o ? n.getParameter(n.MAX_SAMPLES) : 0;
	return {
		isWebGL2: o,
		drawBuffers: c,
		getMaxAnisotropy: r,
		getMaxPrecision: s,
		precision: a,
		logarithmicDepthBuffer: u,
		maxTextures: h,
		maxVertexTextures: d,
		maxTextureSize: f,
		maxCubemapSize: p,
		maxAttributes: _,
		maxVertexUniforms: g,
		maxVaryings: m,
		maxFragmentUniforms: b,
		vertexTextures: v,
		floatFragmentTextures: y,
		floatVertexTextures: x,
		maxSamples: S
	}
}

function KW(n) {
	const e = this;
	let t = null,
		i = 0,
		r = !1,
		s = !1;
	const o = new Ho,
		a = new gt,
		l = {
			value: null,
			needsUpdate: !1
		};
	this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (h, d) {
		const f = h.length !== 0 || d || i !== 0 || r;
		return r = d, i = h.length, f
	}, this.beginShadows = function () {
		s = !0, u(null)
	}, this.endShadows = function () {
		s = !1
	}, this.setGlobalState = function (h, d) {
		t = u(h, d, 0)
	}, this.setState = function (h, d, f) {
		const p = h.clippingPlanes,
			_ = h.clipIntersection,
			g = h.clipShadows,
			m = n.get(h);
		if (!r || p === null || p.length === 0 || s && !g) s ? u(null) : c();
		else {
			const b = s ? 0 : i,
				v = b * 4;
			let y = m.clippingState || null;
			l.value = y, y = u(p, d, v, f);
			for (let x = 0; x !== v; ++x) y[x] = t[x];
			m.clippingState = y, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += b
		}
	};

	function c() {
		l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
	}

	function u(h, d, f, p) {
		const _ = h !== null ? h.length : 0;
		let g = null;
		if (_ !== 0) {
			if (g = l.value, p !== !0 || g === null) {
				const m = f + _ * 4,
					b = d.matrixWorldInverse;
				a.getNormalMatrix(b), (g === null || g.length < m) && (g = new Float32Array(m));
				for (let v = 0, y = f; v !== _; ++v, y += 4) o.copy(h[v]).applyMatrix4(b, a), o.normal.toArray(g, y), g[y + 3] = o.constant
			}
			l.value = g, l.needsUpdate = !0
		}
		return e.numPlanes = _, e.numIntersection = 0, g
	}
}

function ZW(n) {
	let e = new WeakMap;

	function t(o, a) {
		return a === cd ? o.mapping = su : a === Dv && (o.mapping = ou), o
	}

	function i(o) {
		if (o && o.isTexture) {
			const a = o.mapping;
			if (a === cd || a === Dv)
				if (e.has(o)) {
					const l = e.get(o).texture;
					return t(l, o.mapping)
				} else {
					const l = o.image;
					if (l && l.height > 0) {
						const c = new aH(l.height);
						return c.fromEquirectangularTexture(n, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping)
					} else return null
				}
		}
		return o
	}

	function r(o) {
		const a = o.target;
		a.removeEventListener("dispose", r);
		const l = e.get(a);
		l !== void 0 && (e.delete(a), l.dispose())
	}

	function s() {
		e = new WeakMap
	}
	return {
		get: i,
		dispose: s
	}
}
class Jm extends Lb {
	constructor(e = -1, t = 1, i = 1, r = -1, s = .1, o = 2e3) {
		super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix()
	}
	copy(e, t) {
		return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
	}
	setViewOffset(e, t, i, r, s, o) {
		this.view === null && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const e = (this.right - this.left) / (2 * this.zoom),
			t = (this.top - this.bottom) / (2 * this.zoom),
			i = (this.right + this.left) / 2,
			r = (this.top + this.bottom) / 2;
		let s = i - e,
			o = i + e,
			a = r + t,
			l = r - t;
		if (this.view !== null && this.view.enabled) {
			const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
				u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			s += c * this.view.offsetX, o = s + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height
		}
		this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
	}
}
const Ec = 4,
	tE = [.125, .215, .35, .446, .526, .582],
	Qa = 20,
	Lg = new Jm,
	nE = new et;
let kg = null,
	Ig = 0,
	Og = 0;
const Ya = (1 + Math.sqrt(5)) / 2,
	lc = 1 / Ya,
	iE = [new X(1, 1, 1), new X(-1, 1, 1), new X(1, 1, -1), new X(-1, 1, -1), new X(0, Ya, lc), new X(0, Ya, -lc), new X(lc, 0, Ya), new X(-lc, 0, Ya), new X(Ya, lc, 0), new X(-Ya, lc, 0)];
class rE {
	constructor(e) {
		this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
	}
	fromScene(e, t = 0, i = .1, r = 100) {
		kg = this._renderer.getRenderTarget(), Ig = this._renderer.getActiveCubeFace(), Og = this._renderer.getActiveMipmapLevel(), this._setSize(256);
		const s = this._allocateTargets();
		return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
	}
	fromEquirectangular(e, t = null) {
		return this._fromTexture(e, t)
	}
	fromCubemap(e, t = null) {
		return this._fromTexture(e, t)
	}
	compileCubemapShader() {
		this._cubemapMaterial === null && (this._cubemapMaterial = aE(), this._compileMaterial(this._cubemapMaterial))
	}
	compileEquirectangularShader() {
		this._equirectMaterial === null && (this._equirectMaterial = oE(), this._compileMaterial(this._equirectMaterial))
	}
	dispose() {
		this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
	}
	_setSize(e) {
		this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
	}
	_dispose() {
		this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
		for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
	}
	_cleanup(e) {
		this._renderer.setRenderTarget(kg, Ig, Og), e.scissorTest = !1, zf(e, 0, 0, e.width, e.height)
	}
	_fromTexture(e, t) {
		e.mapping === su || e.mapping === ou ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), kg = this._renderer.getRenderTarget(), Ig = this._renderer.getActiveCubeFace(), Og = this._renderer.getActiveMipmapLevel();
		const i = t || this._allocateTargets();
		return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
	}
	_allocateTargets() {
		const e = 3 * Math.max(this._cubeSize, 112),
			t = 4 * this._cubeSize,
			i = {
				magFilter: jn,
				minFilter: jn,
				generateMipmaps: !1,
				type: au,
				format: vr,
				colorSpace: Jn,
				depthBuffer: !1
			},
			r = sE(e, t, i);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
			this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = sE(e, t, i);
			const {
				_lodMax: s
			} = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = JW(s)), this._blurMaterial = QW(s, e, t)
		}
		return r
	}
	_compileMaterial(e) {
		const t = new an(this._lodPlanes[0], e);
		this._renderer.compile(t, Lg)
	}
	_sceneToCubeUV(e, t, i, r) {
		const a = new Yn(90, 1, t, i),
			l = [1, -1, 1, 1, 1, 1],
			c = [1, 1, 1, -1, -1, -1],
			u = this._renderer,
			h = u.autoClear,
			d = u.toneMapping;
		u.getClearColor(nE), u.toneMapping = da, u.autoClear = !1;
		const f = new yr({
				name: "PMREM.Background",
				side: ji,
				depthWrite: !1,
				depthTest: !1
			}),
			p = new an(new Tu, f);
		let _ = !1;
		const g = e.background;
		g ? g.isColor && (f.color.copy(g), e.background = null, _ = !0) : (f.color.copy(nE), _ = !0);
		for (let m = 0; m < 6; m++) {
			const b = m % 3;
			b === 0 ? (a.up.set(0, l[m], 0), a.lookAt(c[m], 0, 0)) : b === 1 ? (a.up.set(0, 0, l[m]), a.lookAt(0, c[m], 0)) : (a.up.set(0, l[m], 0), a.lookAt(0, 0, c[m]));
			const v = this._cubeSize;
			zf(r, b * v, m > 2 ? v : 0, v, v), u.setRenderTarget(r), _ && u.render(p, a), u.render(e, a)
		}
		p.geometry.dispose(), p.material.dispose(), u.toneMapping = d, u.autoClear = h, e.background = g
	}
	_textureToCubeUV(e, t) {
		const i = this._renderer,
			r = e.mapping === su || e.mapping === ou;
		r ? (this._cubemapMaterial === null && (this._cubemapMaterial = aE()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = oE());
		const s = r ? this._cubemapMaterial : this._equirectMaterial,
			o = new an(this._lodPlanes[0], s),
			a = s.uniforms;
		a.envMap.value = e;
		const l = this._cubeSize;
		zf(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Lg)
	}
	_applyPMREM(e) {
		const t = this._renderer,
			i = t.autoClear;
		t.autoClear = !1;
		for (let r = 1; r < this._lodPlanes.length; r++) {
			const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
				o = iE[(r - 1) % iE.length];
			this._blur(e, r - 1, r, s, o)
		}
		t.autoClear = i
	}
	_blur(e, t, i, r, s) {
		const o = this._pingPongRenderTarget;
		this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s)
	}
	_halfBlur(e, t, i, r, s, o, a) {
		const l = this._renderer,
			c = this._blurMaterial;
		o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
		const u = 3,
			h = new an(this._lodPlanes[r], c),
			d = c.uniforms,
			f = this._sizeLods[i] - 1,
			p = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Qa - 1),
			_ = s / p,
			g = isFinite(s) ? 1 + Math.floor(u * _) : Qa;
		g > Qa && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Qa}`);
		const m = [];
		let b = 0;
		for (let E = 0; E < Qa; ++E) {
			const C = E / _,
				P = Math.exp(-C * C / 2);
			m.push(P), E === 0 ? b += P : E < g && (b += 2 * P)
		}
		for (let E = 0; E < m.length; E++) m[E] = m[E] / b;
		d.envMap.value = e.texture, d.samples.value = g, d.weights.value = m, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
		const {
			_lodMax: v
		} = this;
		d.dTheta.value = p, d.mipInt.value = v - i;
		const y = this._sizeLods[r],
			x = 3 * y * (r > v - Ec ? r - v + Ec : 0),
			S = 4 * (this._cubeSize - y);
		zf(t, x, S, 3 * y, 2 * y), l.setRenderTarget(t), l.render(h, Lg)
	}
}

function JW(n) {
	const e = [],
		t = [],
		i = [];
	let r = n;
	const s = n - Ec + 1 + tE.length;
	for (let o = 0; o < s; o++) {
		const a = Math.pow(2, r);
		t.push(a);
		let l = 1 / a;
		o > n - Ec ? l = tE[o - n + Ec - 1] : o === 0 && (l = 0), i.push(l);
		const c = 1 / (a - 2),
			u = -c,
			h = 1 + c,
			d = [u, u, h, u, h, h, u, u, h, h, u, h],
			f = 6,
			p = 6,
			_ = 3,
			g = 2,
			m = 1,
			b = new Float32Array(_ * p * f),
			v = new Float32Array(g * p * f),
			y = new Float32Array(m * p * f);
		for (let S = 0; S < f; S++) {
			const E = S % 3 * 2 / 3 - 1,
				C = S > 2 ? 0 : -1,
				P = [E, C, 0, E + 2 / 3, C, 0, E + 2 / 3, C + 1, 0, E, C, 0, E + 2 / 3, C + 1, 0, E, C + 1, 0];
			b.set(P, _ * p * S), v.set(d, g * p * S);
			const w = [S, S, S, S, S, S];
			y.set(w, m * p * S)
		}
		const x = new gi;
		x.setAttribute("position", new Cn(b, _)), x.setAttribute("uv", new Cn(v, g)), x.setAttribute("faceIndex", new Cn(y, m)), e.push(x), r > Ec && r--
	}
	return {
		lodPlanes: e,
		sizeLods: t,
		sigmas: i
	}
}

function sE(n, e, t) {
	const i = new xa(n, e, t);
	return i.texture.mapping = Km, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function zf(n, e, t, i, r) {
	n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r)
}

function QW(n, e, t) {
	const i = new Float32Array(Qa),
		r = new X(0, 1, 0);
	return new Dn({
		name: "SphericalGaussianBlur",
		defines: {
			n: Qa,
			CUBEUV_TEXEL_WIDTH: 1 / e,
			CUBEUV_TEXEL_HEIGHT: 1 / t,
			CUBEUV_MAX_MIP: `${n}.0`
		},
		uniforms: {
			envMap: {
				value: null
			},
			samples: {
				value: 1
			},
			weights: {
				value: i
			},
			latitudinal: {
				value: !1
			},
			dTheta: {
				value: 0
			},
			mipInt: {
				value: 0
			},
			poleAxis: {
				value: r
			}
		},
		vertexShader: Ib(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
		blending: ua,
		depthTest: !1,
		depthWrite: !1
	})
}

function oE() {
	return new Dn({
		name: "EquirectangularToCubeUV",
		uniforms: {
			envMap: {
				value: null
			}
		},
		vertexShader: Ib(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: ua,
		depthTest: !1,
		depthWrite: !1
	})
}

function aE() {
	return new Dn({
		name: "CubemapToCubeUV",
		uniforms: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			}
		},
		vertexShader: Ib(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: ua,
		depthTest: !1,
		depthWrite: !1
	})
}

function Ib() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function ej(n) {
	let e = new WeakMap,
		t = null;

	function i(a) {
		if (a && a.isTexture) {
			const l = a.mapping,
				c = l === cd || l === Dv,
				u = l === su || l === ou;
			if (c || u)
				if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
					a.needsPMREMUpdate = !1;
					let h = e.get(a);
					return t === null && (t = new rE(n)), h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture
				} else {
					if (e.has(a)) return e.get(a).texture; {
						const h = a.image;
						if (c && h && h.height > 0 || u && h && r(h)) {
							t === null && (t = new rE(n));
							const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
							return e.set(a, d), a.addEventListener("dispose", s), d.texture
						} else return null
					}
				}
		}
		return a
	}

	function r(a) {
		let l = 0;
		const c = 6;
		for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
		return l === c
	}

	function s(a) {
		const l = a.target;
		l.removeEventListener("dispose", s);
		const c = e.get(l);
		c !== void 0 && (e.delete(l), c.dispose())
	}

	function o() {
		e = new WeakMap, t !== null && (t.dispose(), t = null)
	}
	return {
		get: i,
		dispose: o
	}
}

function tj(n) {
	const e = {};

	function t(i) {
		if (e[i] !== void 0) return e[i];
		let r;
		switch (i) {
			case "WEBGL_depth_texture":
				r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
				break;
			case "EXT_texture_filter_anisotropic":
				r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				break;
			case "WEBGL_compressed_texture_s3tc":
				r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
				break;
			case "WEBGL_compressed_texture_pvrtc":
				r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
				break;
			default:
				r = n.getExtension(i)
		}
		return e[i] = r, r
	}
	return {
		has: function (i) {
			return t(i) !== null
		},
		init: function (i) {
			i.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
		},
		get: function (i) {
			const r = t(i);
			return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r
		}
	}
}

function nj(n, e, t, i) {
	const r = {},
		s = new WeakMap;

	function o(h) {
		const d = h.target;
		d.index !== null && e.remove(d.index);
		for (const p in d.attributes) e.remove(d.attributes[p]);
		for (const p in d.morphAttributes) {
			const _ = d.morphAttributes[p];
			for (let g = 0, m = _.length; g < m; g++) e.remove(_[g])
		}
		d.removeEventListener("dispose", o), delete r[d.id];
		const f = s.get(d);
		f && (e.remove(f), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--
	}

	function a(h, d) {
		return r[d.id] === !0 || (d.addEventListener("dispose", o), r[d.id] = !0, t.memory.geometries++), d
	}

	function l(h) {
		const d = h.attributes;
		for (const p in d) e.update(d[p], n.ARRAY_BUFFER);
		const f = h.morphAttributes;
		for (const p in f) {
			const _ = f[p];
			for (let g = 0, m = _.length; g < m; g++) e.update(_[g], n.ARRAY_BUFFER)
		}
	}

	function c(h) {
		const d = [],
			f = h.index,
			p = h.attributes.position;
		let _ = 0;
		if (f !== null) {
			const b = f.array;
			_ = f.version;
			for (let v = 0, y = b.length; v < y; v += 3) {
				const x = b[v + 0],
					S = b[v + 1],
					E = b[v + 2];
				d.push(x, S, S, E, E, x)
			}
		} else if (p !== void 0) {
			const b = p.array;
			_ = p.version;
			for (let v = 0, y = b.length / 3 - 1; v < y; v += 3) {
				const x = v + 0,
					S = v + 1,
					E = v + 2;
				d.push(x, S, S, E, E, x)
			}
		} else return;
		const g = new(CD(d) ? ID : kD)(d, 1);
		g.version = _;
		const m = s.get(h);
		m && e.remove(m), s.set(h, g)
	}

	function u(h) {
		const d = s.get(h);
		if (d) {
			const f = h.index;
			f !== null && d.version < f.version && c(h)
		} else c(h);
		return s.get(h)
	}
	return {
		get: a,
		update: l,
		getWireframeAttribute: u
	}
}

function ij(n, e, t, i) {
	const r = i.isWebGL2;
	let s;

	function o(f) {
		s = f
	}
	let a, l;

	function c(f) {
		a = f.type, l = f.bytesPerElement
	}

	function u(f, p) {
		n.drawElements(s, p, a, f * l), t.update(p, s, 1)
	}

	function h(f, p, _) {
		if (_ === 0) return;
		let g, m;
		if (r) g = n, m = "drawElementsInstanced";
		else if (g = e.get("ANGLE_instanced_arrays"), m = "drawElementsInstancedANGLE", g === null) {
			console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			return
		}
		g[m](s, p, a, f * l, _), t.update(p, s, _)
	}

	function d(f, p, _) {
		if (_ === 0) return;
		const g = e.get("WEBGL_multi_draw");
		if (g === null)
			for (let m = 0; m < _; m++) this.render(f[m] / l, p[m]);
		else {
			g.multiDrawElementsWEBGL(s, p, 0, a, f, 0, _);
			let m = 0;
			for (let b = 0; b < _; b++) m += p[b];
			t.update(m, s, 1)
		}
	}
	this.setMode = o, this.setIndex = c, this.render = u, this.renderInstances = h, this.renderMultiDraw = d
}

function rj(n) {
	const e = {
			geometries: 0,
			textures: 0
		},
		t = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

	function i(s, o, a) {
		switch (t.calls++, o) {
			case n.TRIANGLES:
				t.triangles += a * (s / 3);
				break;
			case n.LINES:
				t.lines += a * (s / 2);
				break;
			case n.LINE_STRIP:
				t.lines += a * (s - 1);
				break;
			case n.LINE_LOOP:
				t.lines += a * s;
				break;
			case n.POINTS:
				t.points += a * s;
				break;
			default:
				console.error("THREE.WebGLInfo: Unknown draw mode:", o);
				break
		}
	}

	function r() {
		t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
	}
	return {
		memory: e,
		render: t,
		programs: null,
		autoReset: !0,
		reset: r,
		update: i
	}
}

function sj(n, e) {
	return n[0] - e[0]
}

function oj(n, e) {
	return Math.abs(e[1]) - Math.abs(n[1])
}

function aj(n, e, t) {
	const i = {},
		r = new Float32Array(8),
		s = new WeakMap,
		o = new kt,
		a = [];
	for (let c = 0; c < 8; c++) a[c] = [c, 0];

	function l(c, u, h) {
		const d = c.morphTargetInfluences;
		if (e.isWebGL2 === !0) {
			const f = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
				p = f !== void 0 ? f.length : 0;
			let _ = s.get(u);
			if (_ === void 0 || _.count !== p) {
				let U = function () {
					w.dispose(), s.delete(u), u.removeEventListener("dispose", U)
				};
				_ !== void 0 && _.texture.dispose();
				const g = u.morphAttributes.position !== void 0,
					m = u.morphAttributes.normal !== void 0,
					b = u.morphAttributes.color !== void 0,
					v = u.morphAttributes.position || [],
					y = u.morphAttributes.normal || [],
					x = u.morphAttributes.color || [];
				let S = 0;
				g === !0 && (S = 1), m === !0 && (S = 2), b === !0 && (S = 3);
				let E = u.attributes.position.count * S,
					C = 1;
				E > e.maxTextureSize && (C = Math.ceil(E / e.maxTextureSize), E = e.maxTextureSize);
				const P = new Float32Array(E * C * 4 * p),
					w = new RD(P, E, C, p);
				w.type = ns, w.needsUpdate = !0;
				const D = S * 4;
				for (let j = 0; j < p; j++) {
					const z = v[j],
						H = y[j],
						F = x[j],
						G = E * C * 4 * j;
					for (let R = 0; R < z.count; R++) {
						const Q = R * D;
						g === !0 && (o.fromBufferAttribute(z, R), P[G + Q + 0] = o.x, P[G + Q + 1] = o.y, P[G + Q + 2] = o.z, P[G + Q + 3] = 0), m === !0 && (o.fromBufferAttribute(H, R), P[G + Q + 4] = o.x, P[G + Q + 5] = o.y, P[G + Q + 6] = o.z, P[G + Q + 7] = 0), b === !0 && (o.fromBufferAttribute(F, R), P[G + Q + 8] = o.x, P[G + Q + 9] = o.y, P[G + Q + 10] = o.z, P[G + Q + 11] = F.itemSize === 4 ? o.w : 1)
					}
				}
				_ = {
					count: p,
					texture: w,
					size: new Oe(E, C)
				}, s.set(u, _), u.addEventListener("dispose", U)
			}
			if (c.isInstancedMesh === !0 && c.morphTexture !== null) h.getUniforms().setValue(n, "morphTexture", c.morphTexture, t);
			else {
				let g = 0;
				for (let b = 0; b < d.length; b++) g += d[b];
				const m = u.morphTargetsRelative ? 1 : 1 - g;
				h.getUniforms().setValue(n, "morphTargetBaseInfluence", m), h.getUniforms().setValue(n, "morphTargetInfluences", d)
			}
			h.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t), h.getUniforms().setValue(n, "morphTargetsTextureSize", _.size)
		} else {
			const f = d === void 0 ? 0 : d.length;
			let p = i[u.id];
			if (p === void 0 || p.length !== f) {
				p = [];
				for (let v = 0; v < f; v++) p[v] = [v, 0];
				i[u.id] = p
			}
			for (let v = 0; v < f; v++) {
				const y = p[v];
				y[0] = v, y[1] = d[v]
			}
			p.sort(oj);
			for (let v = 0; v < 8; v++) v < f && p[v][1] ? (a[v][0] = p[v][0], a[v][1] = p[v][1]) : (a[v][0] = Number.MAX_SAFE_INTEGER, a[v][1] = 0);
			a.sort(sj);
			const _ = u.morphAttributes.position,
				g = u.morphAttributes.normal;
			let m = 0;
			for (let v = 0; v < 8; v++) {
				const y = a[v],
					x = y[0],
					S = y[1];
				x !== Number.MAX_SAFE_INTEGER && S ? (_ && u.getAttribute("morphTarget" + v) !== _[x] && u.setAttribute("morphTarget" + v, _[x]), g && u.getAttribute("morphNormal" + v) !== g[x] && u.setAttribute("morphNormal" + v, g[x]), r[v] = S, m += S) : (_ && u.hasAttribute("morphTarget" + v) === !0 && u.deleteAttribute("morphTarget" + v), g && u.hasAttribute("morphNormal" + v) === !0 && u.deleteAttribute("morphNormal" + v), r[v] = 0)
			}
			const b = u.morphTargetsRelative ? 1 : 1 - m;
			h.getUniforms().setValue(n, "morphTargetBaseInfluence", b), h.getUniforms().setValue(n, "morphTargetInfluences", r)
		}
	}
	return {
		update: l
	}
}

function lj(n, e, t, i) {
	let r = new WeakMap;

	function s(l) {
		const c = i.render.frame,
			u = l.geometry,
			h = e.get(l, u);
		if (r.get(h) !== c && (e.update(h), r.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh) {
			const d = l.skeleton;
			r.get(d) !== c && (d.update(), r.set(d, c))
		}
		return h
	}

	function o() {
		r = new WeakMap
	}

	function a(l) {
		const c = l.target;
		c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
	}
	return {
		update: s,
		dispose: o
	}
}
class Ob extends Kn {
	constructor(e, t, i, r, s, o, a, l, c, u) {
		if (u = u !== void 0 ? u : bl, u !== bl && u !== lu) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		i === void 0 && u === bl && (i = Qo), i === void 0 && u === lu && (i = vl), super(null, r, s, o, a, l, u, i, c), this.isDepthTexture = !0, this.image = {
			width: e,
			height: t
		}, this.magFilter = a !== void 0 ? a : $n, this.minFilter = l !== void 0 ? l : $n, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
	}
	copy(e) {
		return super.copy(e), this.compareFunction = e.compareFunction, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
	}
}
const UD = new Kn,
	BD = new Ob(1, 1);
BD.compareFunction = TD;
const zD = new RD,
	VD = new jV,
	HD = new FD,
	lE = [],
	cE = [],
	uE = new Float32Array(16),
	hE = new Float32Array(9),
	dE = new Float32Array(4);

function Mu(n, e, t) {
	const i = n[0];
	if (i <= 0 || i > 0) return n;
	const r = e * t;
	let s = lE[r];
	if (s === void 0 && (s = new Float32Array(r), lE[r] = s), e !== 0) {
		i.toArray(s, 0);
		for (let o = 1, a = 0; o !== e; ++o) a += t, n[o].toArray(s, a)
	}
	return s
}

function Bn(n, e) {
	if (n.length !== e.length) return !1;
	for (let t = 0, i = n.length; t < i; t++)
		if (n[t] !== e[t]) return !1;
	return !0
}

function zn(n, e) {
	for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}

function Qm(n, e) {
	let t = cE[e];
	t === void 0 && (t = new Int32Array(e), cE[e] = t);
	for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
	return t
}

function cj(n, e) {
	const t = this.cache;
	t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e)
}

function uj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
	else {
		if (Bn(t, e)) return;
		n.uniform2fv(this.addr, e), zn(t, e)
	}
}

function hj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
	else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
	else {
		if (Bn(t, e)) return;
		n.uniform3fv(this.addr, e), zn(t, e)
	}
}

function dj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
	else {
		if (Bn(t, e)) return;
		n.uniform4fv(this.addr, e), zn(t, e)
	}
}

function fj(n, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Bn(t, e)) return;
		n.uniformMatrix2fv(this.addr, !1, e), zn(t, e)
	} else {
		if (Bn(t, i)) return;
		dE.set(i), n.uniformMatrix2fv(this.addr, !1, dE), zn(t, i)
	}
}

function pj(n, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Bn(t, e)) return;
		n.uniformMatrix3fv(this.addr, !1, e), zn(t, e)
	} else {
		if (Bn(t, i)) return;
		hE.set(i), n.uniformMatrix3fv(this.addr, !1, hE), zn(t, i)
	}
}

function mj(n, e) {
	const t = this.cache,
		i = e.elements;
	if (i === void 0) {
		if (Bn(t, e)) return;
		n.uniformMatrix4fv(this.addr, !1, e), zn(t, e)
	} else {
		if (Bn(t, i)) return;
		uE.set(i), n.uniformMatrix4fv(this.addr, !1, uE), zn(t, i)
	}
}

function gj(n, e) {
	const t = this.cache;
	t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e)
}

function _j(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
	else {
		if (Bn(t, e)) return;
		n.uniform2iv(this.addr, e), zn(t, e)
	}
}

function vj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
	else {
		if (Bn(t, e)) return;
		n.uniform3iv(this.addr, e), zn(t, e)
	}
}

function bj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
	else {
		if (Bn(t, e)) return;
		n.uniform4iv(this.addr, e), zn(t, e)
	}
}

function yj(n, e) {
	const t = this.cache;
	t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e)
}

function xj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
	else {
		if (Bn(t, e)) return;
		n.uniform2uiv(this.addr, e), zn(t, e)
	}
}

function wj(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
	else {
		if (Bn(t, e)) return;
		n.uniform3uiv(this.addr, e), zn(t, e)
	}
}

function Ej(n, e) {
	const t = this.cache;
	if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
	else {
		if (Bn(t, e)) return;
		n.uniform4uiv(this.addr, e), zn(t, e)
	}
}

function Sj(n, e, t) {
	const i = this.cache,
		r = t.allocateTextureUnit();
	i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r);
	const s = this.type === n.SAMPLER_2D_SHADOW ? BD : UD;
	t.setTexture2D(e || s, r)
}

function Tj(n, e, t) {
	const i = this.cache,
		r = t.allocateTextureUnit();
	i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || VD, r)
}

function Mj(n, e, t) {
	const i = this.cache,
		r = t.allocateTextureUnit();
	i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || HD, r)
}

function Cj(n, e, t) {
	const i = this.cache,
		r = t.allocateTextureUnit();
	i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || zD, r)
}

function Aj(n) {
	switch (n) {
		case 5126:
			return cj;
		case 35664:
			return uj;
		case 35665:
			return hj;
		case 35666:
			return dj;
		case 35674:
			return fj;
		case 35675:
			return pj;
		case 35676:
			return mj;
		case 5124:
		case 35670:
			return gj;
		case 35667:
		case 35671:
			return _j;
		case 35668:
		case 35672:
			return vj;
		case 35669:
		case 35673:
			return bj;
		case 5125:
			return yj;
		case 36294:
			return xj;
		case 36295:
			return wj;
		case 36296:
			return Ej;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return Sj;
		case 35679:
		case 36299:
		case 36307:
			return Tj;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return Mj;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return Cj
	}
}

function Dj(n, e) {
	n.uniform1fv(this.addr, e)
}

function Pj(n, e) {
	const t = Mu(e, this.size, 2);
	n.uniform2fv(this.addr, t)
}

function Rj(n, e) {
	const t = Mu(e, this.size, 3);
	n.uniform3fv(this.addr, t)
}

function Lj(n, e) {
	const t = Mu(e, this.size, 4);
	n.uniform4fv(this.addr, t)
}

function kj(n, e) {
	const t = Mu(e, this.size, 4);
	n.uniformMatrix2fv(this.addr, !1, t)
}

function Ij(n, e) {
	const t = Mu(e, this.size, 9);
	n.uniformMatrix3fv(this.addr, !1, t)
}

function Oj(n, e) {
	const t = Mu(e, this.size, 16);
	n.uniformMatrix4fv(this.addr, !1, t)
}

function Fj(n, e) {
	n.uniform1iv(this.addr, e)
}

function Nj(n, e) {
	n.uniform2iv(this.addr, e)
}

function Uj(n, e) {
	n.uniform3iv(this.addr, e)
}

function Bj(n, e) {
	n.uniform4iv(this.addr, e)
}

function zj(n, e) {
	n.uniform1uiv(this.addr, e)
}

function Vj(n, e) {
	n.uniform2uiv(this.addr, e)
}

function Hj(n, e) {
	n.uniform3uiv(this.addr, e)
}

function Gj(n, e) {
	n.uniform4uiv(this.addr, e)
}

function Wj(n, e, t) {
	const i = this.cache,
		r = e.length,
		s = Qm(t, r);
	Bn(i, s) || (n.uniform1iv(this.addr, s), zn(i, s));
	for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || UD, s[o])
}

function jj(n, e, t) {
	const i = this.cache,
		r = e.length,
		s = Qm(t, r);
	Bn(i, s) || (n.uniform1iv(this.addr, s), zn(i, s));
	for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || VD, s[o])
}

function $j(n, e, t) {
	const i = this.cache,
		r = e.length,
		s = Qm(t, r);
	Bn(i, s) || (n.uniform1iv(this.addr, s), zn(i, s));
	for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || HD, s[o])
}

function qj(n, e, t) {
	const i = this.cache,
		r = e.length,
		s = Qm(t, r);
	Bn(i, s) || (n.uniform1iv(this.addr, s), zn(i, s));
	for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || zD, s[o])
}

function Xj(n) {
	switch (n) {
		case 5126:
			return Dj;
		case 35664:
			return Pj;
		case 35665:
			return Rj;
		case 35666:
			return Lj;
		case 35674:
			return kj;
		case 35675:
			return Ij;
		case 35676:
			return Oj;
		case 5124:
		case 35670:
			return Fj;
		case 35667:
		case 35671:
			return Nj;
		case 35668:
		case 35672:
			return Uj;
		case 35669:
		case 35673:
			return Bj;
		case 5125:
			return zj;
		case 36294:
			return Vj;
		case 36295:
			return Hj;
		case 36296:
			return Gj;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return Wj;
		case 35679:
		case 36299:
		case 36307:
			return jj;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return $j;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return qj
	}
}
class Yj {
	constructor(e, t, i) {
		this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = Aj(t.type)
	}
}
class Kj {
	constructor(e, t, i) {
		this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Xj(t.type)
	}
}
class Zj {
	constructor(e) {
		this.id = e, this.seq = [], this.map = {}
	}
	setValue(e, t, i) {
		const r = this.seq;
		for (let s = 0, o = r.length; s !== o; ++s) {
			const a = r[s];
			a.setValue(e, t[a.id], i)
		}
	}
}
const Fg = /(\w+)(\])?(\[|\.)?/g;

function fE(n, e) {
	n.seq.push(e), n.map[e.id] = e
}

function Jj(n, e, t) {
	const i = n.name,
		r = i.length;
	for (Fg.lastIndex = 0;;) {
		const s = Fg.exec(i),
			o = Fg.lastIndex;
		let a = s[1];
		const l = s[2] === "]",
			c = s[3];
		if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) {
			fE(t, c === void 0 ? new Yj(a, n, e) : new Kj(a, n, e));
			break
		} else {
			let h = t.map[a];
			h === void 0 && (h = new Zj(a), fE(t, h)), t = h
		}
	}
}
class bp {
	constructor(e, t) {
		this.seq = [], this.map = {};
		const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
		for (let r = 0; r < i; ++r) {
			const s = e.getActiveUniform(t, r),
				o = e.getUniformLocation(t, s.name);
			Jj(s, o, this)
		}
	}
	setValue(e, t, i, r) {
		const s = this.map[t];
		s !== void 0 && s.setValue(e, i, r)
	}
	setOptional(e, t, i) {
		const r = t[i];
		r !== void 0 && this.setValue(e, i, r)
	}
	static upload(e, t, i, r) {
		for (let s = 0, o = t.length; s !== o; ++s) {
			const a = t[s],
				l = i[a.id];
			l.needsUpdate !== !1 && a.setValue(e, l.value, r)
		}
	}
	static seqWithValue(e, t) {
		const i = [];
		for (let r = 0, s = e.length; r !== s; ++r) {
			const o = e[r];
			o.id in t && i.push(o)
		}
		return i
	}
}

function pE(n, e, t) {
	const i = n.createShader(e);
	return n.shaderSource(i, t), n.compileShader(i), i
}
const Qj = 37297;
let e$ = 0;

function t$(n, e) {
	const t = n.split(`
`),
		i = [],
		r = Math.max(e - 6, 0),
		s = Math.min(e + 6, t.length);
	for (let o = r; o < s; o++) {
		const a = o + 1;
		i.push(`${a===e?">":" "} ${a}: ${t[o]}`)
	}
	return i.join(`
`)
}

function n$(n) {
	const e = Lt.getPrimaries(Lt.workingColorSpace),
		t = Lt.getPrimaries(n);
	let i;
	switch (e === t ? i = "" : e === sm && t === rm ? i = "LinearDisplayP3ToLinearSRGB" : e === rm && t === sm && (i = "LinearSRGBToLinearDisplayP3"), n) {
		case Jn:
		case Zm:
			return [i, "LinearTransferOETF"];
		case qn:
		case Ab:
			return [i, "sRGBTransferOETF"];
		default:
			return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [i, "LinearTransferOETF"]
	}
}

function mE(n, e, t) {
	const i = n.getShaderParameter(e, n.COMPILE_STATUS),
		r = n.getShaderInfoLog(e).trim();
	if (i && r === "") return "";
	const s = /ERROR: 0:(\d+)/.exec(r);
	if (s) {
		const o = parseInt(s[1]);
		return t.toUpperCase() + `

` + r + `

` + t$(n.getShaderSource(e), o)
	} else return r
}

function i$(n, e) {
	const t = n$(e);
	return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}

function r$(n, e) {
	let t;
	switch (e) {
		case Qz:
			t = "Linear";
			break;
		case eV:
			t = "Reinhard";
			break;
		case tV:
			t = "OptimizedCineon";
			break;
		case nV:
			t = "ACESFilmic";
			break;
		case rV:
			t = "AgX";
			break;
		case sV:
			t = "Neutral";
			break;
		case iV:
			t = "Custom";
			break;
		default:
			console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
	}
	return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}

function s$(n) {
	return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.alphaToCoverage || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Sc).join(`
`)
}

function o$(n) {
	return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Sc).join(`
`)
}

function a$(n) {
	const e = [];
	for (const t in n) {
		const i = n[t];
		i !== !1 && e.push("#define " + t + " " + i)
	}
	return e.join(`
`)
}

function l$(n, e) {
	const t = {},
		i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
	for (let r = 0; r < i; r++) {
		const s = n.getActiveAttrib(e, r),
			o = s.name;
		let a = 1;
		s.type === n.FLOAT_MAT2 && (a = 2), s.type === n.FLOAT_MAT3 && (a = 3), s.type === n.FLOAT_MAT4 && (a = 4), t[o] = {
			type: s.type,
			location: n.getAttribLocation(e, o),
			locationSize: a
		}
	}
	return t
}

function Sc(n) {
	return n !== ""
}

function gE(n, e) {
	const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
	return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function _E(n, e) {
	return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const c$ = /^[ \t]*#include +<([\w\d./]+)>/gm;

function Iv(n) {
	return n.replace(c$, h$)
}
const u$ = new Map([
	["encodings_fragment", "colorspace_fragment"],
	["encodings_pars_fragment", "colorspace_pars_fragment"],
	["output_fragment", "opaque_fragment"]
]);

function h$(n, e) {
	let t = mt[e];
	if (t === void 0) {
		const i = u$.get(e);
		if (i !== void 0) t = mt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
		else throw new Error("Can not resolve #include <" + e + ">")
	}
	return Iv(t)
}
const d$ = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function vE(n) {
	return n.replace(d$, f$)
}

function f$(n, e, t, i) {
	let r = "";
	for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
	return r
}

function bE(n) {
	let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	`;
	return n.isWebGL2 && (e += `precision ${n.precision} sampler3D;
		precision ${n.precision} sampler2DArray;
		precision ${n.precision} sampler2DShadow;
		precision ${n.precision} samplerCubeShadow;
		precision ${n.precision} sampler2DArrayShadow;
		precision ${n.precision} isampler2D;
		precision ${n.precision} isampler3D;
		precision ${n.precision} isamplerCube;
		precision ${n.precision} isampler2DArray;
		precision ${n.precision} usampler2D;
		precision ${n.precision} usampler3D;
		precision ${n.precision} usamplerCube;
		precision ${n.precision} usampler2DArray;
		`), n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function p$(n) {
	let e = "SHADOWMAP_TYPE_BASIC";
	return n.shadowMapType === dD ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Cz ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === js && (e = "SHADOWMAP_TYPE_VSM"), e
}

function m$(n) {
	let e = "ENVMAP_TYPE_CUBE";
	if (n.envMap) switch (n.envMapMode) {
		case su:
		case ou:
			e = "ENVMAP_TYPE_CUBE";
			break;
		case Km:
			e = "ENVMAP_TYPE_CUBE_UV";
			break
	}
	return e
}

function g$(n) {
	let e = "ENVMAP_MODE_REFLECTION";
	if (n.envMap) switch (n.envMapMode) {
		case ou:
			e = "ENVMAP_MODE_REFRACTION";
			break
	}
	return e
}

function _$(n) {
	let e = "ENVMAP_BLENDING_NONE";
	if (n.envMap) switch (n.combine) {
		case fD:
			e = "ENVMAP_BLENDING_MULTIPLY";
			break;
		case Zz:
			e = "ENVMAP_BLENDING_MIX";
			break;
		case Jz:
			e = "ENVMAP_BLENDING_ADD";
			break
	}
	return e
}

function v$(n) {
	const e = n.envMapCubeUVHeight;
	if (e === null) return null;
	const t = Math.log2(e) - 2,
		i = 1 / e;
	return {
		texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
		texelHeight: i,
		maxMip: t
	}
}

function b$(n, e, t, i) {
	const r = n.getContext(),
		s = t.defines;
	let o = t.vertexShader,
		a = t.fragmentShader;
	const l = p$(t),
		c = m$(t),
		u = g$(t),
		h = _$(t),
		d = v$(t),
		f = t.isWebGL2 ? "" : s$(t),
		p = o$(t),
		_ = a$(s),
		g = r.createProgram();
	let m, b, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
	t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Sc).join(`
`), m.length > 0 && (m += `
`), b = [f, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(Sc).join(`
`), b.length > 0 && (b += `
`)) : (m = [bE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Sc).join(`
`), b = [f, bE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== da ? "#define TONE_MAPPING" : "", t.toneMapping !== da ? mt.tonemapping_pars_fragment : "", t.toneMapping !== da ? r$("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", mt.colorspace_pars_fragment, i$("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Sc).join(`
`)), o = Iv(o), o = gE(o, t), o = _E(o, t), a = Iv(a), a = gE(a, t), a = _E(a, t), o = vE(o), a = vE(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, m = [p, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, b = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === O2 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === O2 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + b);
	const y = v + m + o,
		x = v + b + a,
		S = pE(r, r.VERTEX_SHADER, y),
		E = pE(r, r.FRAGMENT_SHADER, x);
	r.attachShader(g, S), r.attachShader(g, E), t.index0AttributeName !== void 0 ? r.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g);

	function C(U) {
		if (n.debug.checkShaderErrors) {
			const j = r.getProgramInfoLog(g).trim(),
				z = r.getShaderInfoLog(S).trim(),
				H = r.getShaderInfoLog(E).trim();
			let F = !0,
				G = !0;
			if (r.getProgramParameter(g, r.LINK_STATUS) === !1)
				if (F = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(r, g, S, E);
				else {
					const R = mE(r, S, "vertex"),
						Q = mE(r, E, "fragment");
					console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + `

Material Name: ` + U.name + `
Material Type: ` + U.type + `

Program Info Log: ` + j + `
` + R + `
` + Q)
				}
			else j !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", j) : (z === "" || H === "") && (G = !1);
			G && (U.diagnostics = {
				runnable: F,
				programLog: j,
				vertexShader: {
					log: z,
					prefix: m
				},
				fragmentShader: {
					log: H,
					prefix: b
				}
			})
		}
		r.deleteShader(S), r.deleteShader(E), P = new bp(r, g), w = l$(r, g)
	}
	let P;
	this.getUniforms = function () {
		return P === void 0 && C(this), P
	};
	let w;
	this.getAttributes = function () {
		return w === void 0 && C(this), w
	};
	let D = t.rendererExtensionParallelShaderCompile === !1;
	return this.isReady = function () {
		return D === !1 && (D = r.getProgramParameter(g, Qj)), D
	}, this.destroy = function () {
		i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0
	}, this.type = t.shaderType, this.name = t.shaderName, this.id = e$++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = E, this
}
let y$ = 0;
class x$ {
	constructor() {
		this.shaderCache = new Map, this.materialCache = new Map
	}
	update(e) {
		const t = e.vertexShader,
			i = e.fragmentShader,
			r = this._getShaderStage(t),
			s = this._getShaderStage(i),
			o = this._getShaderCacheForMaterial(e);
		return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
	}
	remove(e) {
		const t = this.materialCache.get(e);
		for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
		return this.materialCache.delete(e), this
	}
	getVertexShaderID(e) {
		return this._getShaderStage(e.vertexShader).id
	}
	getFragmentShaderID(e) {
		return this._getShaderStage(e.fragmentShader).id
	}
	dispose() {
		this.shaderCache.clear(), this.materialCache.clear()
	}
	_getShaderCacheForMaterial(e) {
		const t = this.materialCache;
		let i = t.get(e);
		return i === void 0 && (i = new Set, t.set(e, i)), i
	}
	_getShaderStage(e) {
		const t = this.shaderCache;
		let i = t.get(e);
		return i === void 0 && (i = new w$(e), t.set(e, i)), i
	}
}
class w$ {
	constructor(e) {
		this.id = y$++, this.code = e, this.usedTimes = 0
	}
}

function E$(n, e, t, i, r, s, o) {
	const a = new Pb,
		l = new x$,
		c = new Set,
		u = [],
		h = r.isWebGL2,
		d = r.logarithmicDepthBuffer,
		f = r.vertexTextures;
	let p = r.precision;
	const _ = {
		MeshDepthMaterial: "depth",
		MeshDistanceMaterial: "distanceRGBA",
		MeshNormalMaterial: "normal",
		MeshBasicMaterial: "basic",
		MeshLambertMaterial: "lambert",
		MeshPhongMaterial: "phong",
		MeshToonMaterial: "toon",
		MeshStandardMaterial: "physical",
		MeshPhysicalMaterial: "physical",
		MeshMatcapMaterial: "matcap",
		LineBasicMaterial: "basic",
		LineDashedMaterial: "dashed",
		PointsMaterial: "points",
		ShadowMaterial: "shadow",
		SpriteMaterial: "sprite"
	};

	function g(w) {
		return c.add(w), w === 0 ? "uv" : `uv${w}`
	}

	function m(w, D, U, j, z) {
		const H = j.fog,
			F = z.geometry,
			G = w.isMeshStandardMaterial ? j.environment : null,
			R = (w.isMeshStandardMaterial ? t : e).get(w.envMap || G),
			Q = R && R.mapping === Km ? R.image.height : null,
			B = _[w.type];
		w.precision !== null && (p = r.getMaxPrecision(w.precision), p !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", p, "instead."));
		const ge = F.morphAttributes.position || F.morphAttributes.normal || F.morphAttributes.color,
			Ae = ge !== void 0 ? ge.length : 0;
		let ze = 0;
		F.morphAttributes.position !== void 0 && (ze = 1), F.morphAttributes.normal !== void 0 && (ze = 2), F.morphAttributes.color !== void 0 && (ze = 3);
		let K, ye, Se, Z;
		if (B) {
			const Et = ni[B];
			K = Et.vertexShader, ye = Et.fragmentShader
		} else K = w.vertexShader, ye = w.fragmentShader, l.update(w), Se = l.getVertexShaderID(w), Z = l.getFragmentShaderID(w);
		const pe = n.getRenderTarget(),
			ce = z.isInstancedMesh === !0,
			Ce = z.isBatchedMesh === !0,
			Re = !!w.map,
			Y = !!w.matcap,
			k = !!R,
			O = !!w.aoMap,
			q = !!w.lightMap,
			ie = !!w.bumpMap,
			N = !!w.normalMap,
			me = !!w.displacementMap,
			ve = !!w.emissiveMap,
			xe = !!w.metalnessMap,
			A = !!w.roughnessMap,
			T = w.anisotropy > 0,
			$ = w.clearcoat > 0,
			re = w.iridescence > 0,
			se = w.sheen > 0,
			ue = w.transmission > 0,
			Me = T && !!w.anisotropyMap,
			Le = $ && !!w.clearcoatMap,
			we = $ && !!w.clearcoatNormalMap,
			Te = $ && !!w.clearcoatRoughnessMap,
			je = re && !!w.iridescenceMap,
			M = re && !!w.iridescenceThicknessMap,
			W = se && !!w.sheenColorMap,
			le = se && !!w.sheenRoughnessMap,
			J = !!w.specularMap,
			oe = !!w.specularColorMap,
			_e = !!w.specularIntensityMap,
			I = ue && !!w.transmissionMap,
			ee = ue && !!w.thicknessMap,
			De = !!w.gradientMap,
			V = !!w.alphaMap,
			be = w.alphaTest > 0,
			te = !!w.alphaHash,
			Ee = !!w.extensions;
		let Ie = da;
		w.toneMapped && (pe === null || pe.isXRRenderTarget === !0) && (Ie = n.toneMapping);
		const st = {
			isWebGL2: h,
			shaderID: B,
			shaderType: w.type,
			shaderName: w.name,
			vertexShader: K,
			fragmentShader: ye,
			defines: w.defines,
			customVertexShaderID: Se,
			customFragmentShaderID: Z,
			isRawShaderMaterial: w.isRawShaderMaterial === !0,
			glslVersion: w.glslVersion,
			precision: p,
			batching: Ce,
			instancing: ce,
			instancingColor: ce && z.instanceColor !== null,
			instancingMorph: ce && z.morphTexture !== null,
			supportsVertexTextures: f,
			outputColorSpace: pe === null ? n.outputColorSpace : pe.isXRRenderTarget === !0 ? pe.texture.colorSpace : Jn,
			alphaToCoverage: !!w.alphaToCoverage,
			map: Re,
			matcap: Y,
			envMap: k,
			envMapMode: k && R.mapping,
			envMapCubeUVHeight: Q,
			aoMap: O,
			lightMap: q,
			bumpMap: ie,
			normalMap: N,
			displacementMap: f && me,
			emissiveMap: ve,
			normalMapObjectSpace: N && w.normalMapType === _V,
			normalMapTangentSpace: N && w.normalMapType === SD,
			metalnessMap: xe,
			roughnessMap: A,
			anisotropy: T,
			anisotropyMap: Me,
			clearcoat: $,
			clearcoatMap: Le,
			clearcoatNormalMap: we,
			clearcoatRoughnessMap: Te,
			iridescence: re,
			iridescenceMap: je,
			iridescenceThicknessMap: M,
			sheen: se,
			sheenColorMap: W,
			sheenRoughnessMap: le,
			specularMap: J,
			specularColorMap: oe,
			specularIntensityMap: _e,
			transmission: ue,
			transmissionMap: I,
			thicknessMap: ee,
			gradientMap: De,
			opaque: w.transparent === !1 && w.blending === ha && w.alphaToCoverage === !1,
			alphaMap: V,
			alphaTest: be,
			alphaHash: te,
			combine: w.combine,
			mapUv: Re && g(w.map.channel),
			aoMapUv: O && g(w.aoMap.channel),
			lightMapUv: q && g(w.lightMap.channel),
			bumpMapUv: ie && g(w.bumpMap.channel),
			normalMapUv: N && g(w.normalMap.channel),
			displacementMapUv: me && g(w.displacementMap.channel),
			emissiveMapUv: ve && g(w.emissiveMap.channel),
			metalnessMapUv: xe && g(w.metalnessMap.channel),
			roughnessMapUv: A && g(w.roughnessMap.channel),
			anisotropyMapUv: Me && g(w.anisotropyMap.channel),
			clearcoatMapUv: Le && g(w.clearcoatMap.channel),
			clearcoatNormalMapUv: we && g(w.clearcoatNormalMap.channel),
			clearcoatRoughnessMapUv: Te && g(w.clearcoatRoughnessMap.channel),
			iridescenceMapUv: je && g(w.iridescenceMap.channel),
			iridescenceThicknessMapUv: M && g(w.iridescenceThicknessMap.channel),
			sheenColorMapUv: W && g(w.sheenColorMap.channel),
			sheenRoughnessMapUv: le && g(w.sheenRoughnessMap.channel),
			specularMapUv: J && g(w.specularMap.channel),
			specularColorMapUv: oe && g(w.specularColorMap.channel),
			specularIntensityMapUv: _e && g(w.specularIntensityMap.channel),
			transmissionMapUv: I && g(w.transmissionMap.channel),
			thicknessMapUv: ee && g(w.thicknessMap.channel),
			alphaMapUv: V && g(w.alphaMap.channel),
			vertexTangents: !!F.attributes.tangent && (N || T),
			vertexColors: w.vertexColors,
			vertexAlphas: w.vertexColors === !0 && !!F.attributes.color && F.attributes.color.itemSize === 4,
			pointsUvs: z.isPoints === !0 && !!F.attributes.uv && (Re || V),
			fog: !!H,
			useFog: w.fog === !0,
			fogExp2: !!H && H.isFogExp2,
			flatShading: w.flatShading === !0,
			sizeAttenuation: w.sizeAttenuation === !0,
			logarithmicDepthBuffer: d,
			skinning: z.isSkinnedMesh === !0,
			morphTargets: F.morphAttributes.position !== void 0,
			morphNormals: F.morphAttributes.normal !== void 0,
			morphColors: F.morphAttributes.color !== void 0,
			morphTargetsCount: Ae,
			morphTextureStride: ze,
			numDirLights: D.directional.length,
			numPointLights: D.point.length,
			numSpotLights: D.spot.length,
			numSpotLightMaps: D.spotLightMap.length,
			numRectAreaLights: D.rectArea.length,
			numHemiLights: D.hemi.length,
			numDirLightShadows: D.directionalShadowMap.length,
			numPointLightShadows: D.pointShadowMap.length,
			numSpotLightShadows: D.spotShadowMap.length,
			numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps,
			numLightProbes: D.numLightProbes,
			numClippingPlanes: o.numPlanes,
			numClipIntersection: o.numIntersection,
			dithering: w.dithering,
			shadowMapEnabled: n.shadowMap.enabled && U.length > 0,
			shadowMapType: n.shadowMap.type,
			toneMapping: Ie,
			useLegacyLights: n._useLegacyLights,
			decodeVideoTexture: Re && w.map.isVideoTexture === !0 && Lt.getTransfer(w.map.colorSpace) === Qt,
			premultipliedAlpha: w.premultipliedAlpha,
			doubleSided: w.side === _r,
			flipSided: w.side === ji,
			useDepthPacking: w.depthPacking >= 0,
			depthPacking: w.depthPacking || 0,
			index0AttributeName: w.index0AttributeName,
			extensionDerivatives: Ee && w.extensions.derivatives === !0,
			extensionFragDepth: Ee && w.extensions.fragDepth === !0,
			extensionDrawBuffers: Ee && w.extensions.drawBuffers === !0,
			extensionShaderTextureLOD: Ee && w.extensions.shaderTextureLOD === !0,
			extensionClipCullDistance: Ee && w.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
			extensionMultiDraw: Ee && w.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"),
			rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
			rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
			rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
			rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
			customProgramCacheKey: w.customProgramCacheKey()
		};
		return st.vertexUv1s = c.has(1), st.vertexUv2s = c.has(2), st.vertexUv3s = c.has(3), c.clear(), st
	}

	function b(w) {
		const D = [];
		if (w.shaderID ? D.push(w.shaderID) : (D.push(w.customVertexShaderID), D.push(w.customFragmentShaderID)), w.defines !== void 0)
			for (const U in w.defines) D.push(U), D.push(w.defines[U]);
		return w.isRawShaderMaterial === !1 && (v(D, w), y(D, w), D.push(n.outputColorSpace)), D.push(w.customProgramCacheKey), D.join()
	}

	function v(w, D) {
		w.push(D.precision), w.push(D.outputColorSpace), w.push(D.envMapMode), w.push(D.envMapCubeUVHeight), w.push(D.mapUv), w.push(D.alphaMapUv), w.push(D.lightMapUv), w.push(D.aoMapUv), w.push(D.bumpMapUv), w.push(D.normalMapUv), w.push(D.displacementMapUv), w.push(D.emissiveMapUv), w.push(D.metalnessMapUv), w.push(D.roughnessMapUv), w.push(D.anisotropyMapUv), w.push(D.clearcoatMapUv), w.push(D.clearcoatNormalMapUv), w.push(D.clearcoatRoughnessMapUv), w.push(D.iridescenceMapUv), w.push(D.iridescenceThicknessMapUv), w.push(D.sheenColorMapUv), w.push(D.sheenRoughnessMapUv), w.push(D.specularMapUv), w.push(D.specularColorMapUv), w.push(D.specularIntensityMapUv), w.push(D.transmissionMapUv), w.push(D.thicknessMapUv), w.push(D.combine), w.push(D.fogExp2), w.push(D.sizeAttenuation), w.push(D.morphTargetsCount), w.push(D.morphAttributeCount), w.push(D.numDirLights), w.push(D.numPointLights), w.push(D.numSpotLights), w.push(D.numSpotLightMaps), w.push(D.numHemiLights), w.push(D.numRectAreaLights), w.push(D.numDirLightShadows), w.push(D.numPointLightShadows), w.push(D.numSpotLightShadows), w.push(D.numSpotLightShadowsWithMaps), w.push(D.numLightProbes), w.push(D.shadowMapType), w.push(D.toneMapping), w.push(D.numClippingPlanes), w.push(D.numClipIntersection), w.push(D.depthPacking)
	}

	function y(w, D) {
		a.disableAll(), D.isWebGL2 && a.enable(0), D.supportsVertexTextures && a.enable(1), D.instancing && a.enable(2), D.instancingColor && a.enable(3), D.instancingMorph && a.enable(4), D.matcap && a.enable(5), D.envMap && a.enable(6), D.normalMapObjectSpace && a.enable(7), D.normalMapTangentSpace && a.enable(8), D.clearcoat && a.enable(9), D.iridescence && a.enable(10), D.alphaTest && a.enable(11), D.vertexColors && a.enable(12), D.vertexAlphas && a.enable(13), D.vertexUv1s && a.enable(14), D.vertexUv2s && a.enable(15), D.vertexUv3s && a.enable(16), D.vertexTangents && a.enable(17), D.anisotropy && a.enable(18), D.alphaHash && a.enable(19), D.batching && a.enable(20), w.push(a.mask), a.disableAll(), D.fog && a.enable(0), D.useFog && a.enable(1), D.flatShading && a.enable(2), D.logarithmicDepthBuffer && a.enable(3), D.skinning && a.enable(4), D.morphTargets && a.enable(5), D.morphNormals && a.enable(6), D.morphColors && a.enable(7), D.premultipliedAlpha && a.enable(8), D.shadowMapEnabled && a.enable(9), D.useLegacyLights && a.enable(10), D.doubleSided && a.enable(11), D.flipSided && a.enable(12), D.useDepthPacking && a.enable(13), D.dithering && a.enable(14), D.transmission && a.enable(15), D.sheen && a.enable(16), D.opaque && a.enable(17), D.pointsUvs && a.enable(18), D.decodeVideoTexture && a.enable(19), D.alphaToCoverage && a.enable(20), w.push(a.mask)
	}

	function x(w) {
		const D = _[w.type];
		let U;
		if (D) {
			const j = ni[D];
			U = Rb.clone(j.uniforms)
		} else U = w.uniforms;
		return U
	}

	function S(w, D) {
		let U;
		for (let j = 0, z = u.length; j < z; j++) {
			const H = u[j];
			if (H.cacheKey === D) {
				U = H, ++U.usedTimes;
				break
			}
		}
		return U === void 0 && (U = new b$(n, D, w, s), u.push(U)), U
	}

	function E(w) {
		if (--w.usedTimes === 0) {
			const D = u.indexOf(w);
			u[D] = u[u.length - 1], u.pop(), w.destroy()
		}
	}

	function C(w) {
		l.remove(w)
	}

	function P() {
		l.dispose()
	}
	return {
		getParameters: m,
		getProgramCacheKey: b,
		getUniforms: x,
		acquireProgram: S,
		releaseProgram: E,
		releaseShaderCache: C,
		programs: u,
		dispose: P
	}
}

function S$() {
	let n = new WeakMap;

	function e(s) {
		let o = n.get(s);
		return o === void 0 && (o = {}, n.set(s, o)), o
	}

	function t(s) {
		n.delete(s)
	}

	function i(s, o, a) {
		n.get(s)[o] = a
	}

	function r() {
		n = new WeakMap
	}
	return {
		get: e,
		remove: t,
		update: i,
		dispose: r
	}
}

function T$(n, e) {
	return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}

function yE(n, e) {
	return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}

function xE() {
	const n = [];
	let e = 0;
	const t = [],
		i = [],
		r = [];

	function s() {
		e = 0, t.length = 0, i.length = 0, r.length = 0
	}

	function o(h, d, f, p, _, g) {
		let m = n[e];
		return m === void 0 ? (m = {
			id: h.id,
			object: h,
			geometry: d,
			material: f,
			groupOrder: p,
			renderOrder: h.renderOrder,
			z: _,
			group: g
		}, n[e] = m) : (m.id = h.id, m.object = h, m.geometry = d, m.material = f, m.groupOrder = p, m.renderOrder = h.renderOrder, m.z = _, m.group = g), e++, m
	}

	function a(h, d, f, p, _, g) {
		const m = o(h, d, f, p, _, g);
		f.transmission > 0 ? i.push(m) : f.transparent === !0 ? r.push(m) : t.push(m)
	}

	function l(h, d, f, p, _, g) {
		const m = o(h, d, f, p, _, g);
		f.transmission > 0 ? i.unshift(m) : f.transparent === !0 ? r.unshift(m) : t.unshift(m)
	}

	function c(h, d) {
		t.length > 1 && t.sort(h || T$), i.length > 1 && i.sort(d || yE), r.length > 1 && r.sort(d || yE)
	}

	function u() {
		for (let h = e, d = n.length; h < d; h++) {
			const f = n[h];
			if (f.id === null) break;
			f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null
		}
	}
	return {
		opaque: t,
		transmissive: i,
		transparent: r,
		init: s,
		push: a,
		unshift: l,
		finish: u,
		sort: c
	}
}

function M$() {
	let n = new WeakMap;

	function e(i, r) {
		const s = n.get(i);
		let o;
		return s === void 0 ? (o = new xE, n.set(i, [o])) : r >= s.length ? (o = new xE, s.push(o)) : o = s[r], o
	}

	function t() {
		n = new WeakMap
	}
	return {
		get: e,
		dispose: t
	}
}

function C$() {
	const n = {};
	return {
		get: function (e) {
			if (n[e.id] !== void 0) return n[e.id];
			let t;
			switch (e.type) {
				case "DirectionalLight":
					t = {
						direction: new X,
						color: new et
					};
					break;
				case "SpotLight":
					t = {
						position: new X,
						direction: new X,
						color: new et,
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case "PointLight":
					t = {
						position: new X,
						color: new et,
						distance: 0,
						decay: 0
					};
					break;
				case "HemisphereLight":
					t = {
						direction: new X,
						skyColor: new et,
						groundColor: new et
					};
					break;
				case "RectAreaLight":
					t = {
						color: new et,
						position: new X,
						halfWidth: new X,
						halfHeight: new X
					};
					break
			}
			return n[e.id] = t, t
		}
	}
}

function A$() {
	const n = {};
	return {
		get: function (e) {
			if (n[e.id] !== void 0) return n[e.id];
			let t;
			switch (e.type) {
				case "DirectionalLight":
					t = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Oe
					};
					break;
				case "SpotLight":
					t = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Oe
					};
					break;
				case "PointLight":
					t = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Oe,
						shadowCameraNear: 1,
						shadowCameraFar: 1e3
					};
					break
			}
			return n[e.id] = t, t
		}
	}
}
let D$ = 0;

function P$(n, e) {
	return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}

function R$(n, e) {
	const t = new C$,
		i = A$(),
		r = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1,
				numLightProbes: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0,
			numLightProbes: 0
		};
	for (let u = 0; u < 9; u++) r.probe.push(new X);
	const s = new X,
		o = new pt,
		a = new pt;

	function l(u, h) {
		let d = 0,
			f = 0,
			p = 0;
		for (let U = 0; U < 9; U++) r.probe[U].set(0, 0, 0);
		let _ = 0,
			g = 0,
			m = 0,
			b = 0,
			v = 0,
			y = 0,
			x = 0,
			S = 0,
			E = 0,
			C = 0,
			P = 0;
		u.sort(P$);
		const w = h === !0 ? Math.PI : 1;
		for (let U = 0, j = u.length; U < j; U++) {
			const z = u[U],
				H = z.color,
				F = z.intensity,
				G = z.distance,
				R = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
			if (z.isAmbientLight) d += H.r * F * w, f += H.g * F * w, p += H.b * F * w;
			else if (z.isLightProbe) {
				for (let Q = 0; Q < 9; Q++) r.probe[Q].addScaledVector(z.sh.coefficients[Q], F);
				P++
			} else if (z.isDirectionalLight) {
				const Q = t.get(z);
				if (Q.color.copy(z.color).multiplyScalar(z.intensity * w), z.castShadow) {
					const B = z.shadow,
						ge = i.get(z);
					ge.shadowBias = B.bias, ge.shadowNormalBias = B.normalBias, ge.shadowRadius = B.radius, ge.shadowMapSize = B.mapSize, r.directionalShadow[_] = ge, r.directionalShadowMap[_] = R, r.directionalShadowMatrix[_] = z.shadow.matrix, y++
				}
				r.directional[_] = Q, _++
			} else if (z.isSpotLight) {
				const Q = t.get(z);
				Q.position.setFromMatrixPosition(z.matrixWorld), Q.color.copy(H).multiplyScalar(F * w), Q.distance = G, Q.coneCos = Math.cos(z.angle), Q.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)), Q.decay = z.decay, r.spot[m] = Q;
				const B = z.shadow;
				if (z.map && (r.spotLightMap[E] = z.map, E++, B.updateMatrices(z), z.castShadow && C++), r.spotLightMatrix[m] = B.matrix, z.castShadow) {
					const ge = i.get(z);
					ge.shadowBias = B.bias, ge.shadowNormalBias = B.normalBias, ge.shadowRadius = B.radius, ge.shadowMapSize = B.mapSize, r.spotShadow[m] = ge, r.spotShadowMap[m] = R, S++
				}
				m++
			} else if (z.isRectAreaLight) {
				const Q = t.get(z);
				Q.color.copy(H).multiplyScalar(F), Q.halfWidth.set(z.width * .5, 0, 0), Q.halfHeight.set(0, z.height * .5, 0), r.rectArea[b] = Q, b++
			} else if (z.isPointLight) {
				const Q = t.get(z);
				if (Q.color.copy(z.color).multiplyScalar(z.intensity * w), Q.distance = z.distance, Q.decay = z.decay, z.castShadow) {
					const B = z.shadow,
						ge = i.get(z);
					ge.shadowBias = B.bias, ge.shadowNormalBias = B.normalBias, ge.shadowRadius = B.radius, ge.shadowMapSize = B.mapSize, ge.shadowCameraNear = B.camera.near, ge.shadowCameraFar = B.camera.far, r.pointShadow[g] = ge, r.pointShadowMap[g] = R, r.pointShadowMatrix[g] = z.shadow.matrix, x++
				}
				r.point[g] = Q, g++
			} else if (z.isHemisphereLight) {
				const Q = t.get(z);
				Q.skyColor.copy(z.color).multiplyScalar(F * w), Q.groundColor.copy(z.groundColor).multiplyScalar(F * w), r.hemi[v] = Q, v++
			}
		}
		b > 0 && (e.isWebGL2 ? n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ue.LTC_FLOAT_1, r.rectAreaLTC2 = Ue.LTC_FLOAT_2) : (r.rectAreaLTC1 = Ue.LTC_HALF_1, r.rectAreaLTC2 = Ue.LTC_HALF_2) : n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ue.LTC_FLOAT_1, r.rectAreaLTC2 = Ue.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ue.LTC_HALF_1, r.rectAreaLTC2 = Ue.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = d, r.ambient[1] = f, r.ambient[2] = p;
		const D = r.hash;
		(D.directionalLength !== _ || D.pointLength !== g || D.spotLength !== m || D.rectAreaLength !== b || D.hemiLength !== v || D.numDirectionalShadows !== y || D.numPointShadows !== x || D.numSpotShadows !== S || D.numSpotMaps !== E || D.numLightProbes !== P) && (r.directional.length = _, r.spot.length = m, r.rectArea.length = b, r.point.length = g, r.hemi.length = v, r.directionalShadow.length = y, r.directionalShadowMap.length = y, r.pointShadow.length = x, r.pointShadowMap.length = x, r.spotShadow.length = S, r.spotShadowMap.length = S, r.directionalShadowMatrix.length = y, r.pointShadowMatrix.length = x, r.spotLightMatrix.length = S + E - C, r.spotLightMap.length = E, r.numSpotLightShadowsWithMaps = C, r.numLightProbes = P, D.directionalLength = _, D.pointLength = g, D.spotLength = m, D.rectAreaLength = b, D.hemiLength = v, D.numDirectionalShadows = y, D.numPointShadows = x, D.numSpotShadows = S, D.numSpotMaps = E, D.numLightProbes = P, r.version = D$++)
	}

	function c(u, h) {
		let d = 0,
			f = 0,
			p = 0,
			_ = 0,
			g = 0;
		const m = h.matrixWorldInverse;
		for (let b = 0, v = u.length; b < v; b++) {
			const y = u[b];
			if (y.isDirectionalLight) {
				const x = r.directional[d];
				x.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(m), d++
			} else if (y.isSpotLight) {
				const x = r.spot[p];
				x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(m), x.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(m), p++
			} else if (y.isRectAreaLight) {
				const x = r.rectArea[_];
				x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(m), a.identity(), o.copy(y.matrixWorld), o.premultiply(m), a.extractRotation(o), x.halfWidth.set(y.width * .5, 0, 0), x.halfHeight.set(0, y.height * .5, 0), x.halfWidth.applyMatrix4(a), x.halfHeight.applyMatrix4(a), _++
			} else if (y.isPointLight) {
				const x = r.point[f];
				x.position.setFromMatrixPosition(y.matrixWorld), x.position.applyMatrix4(m), f++
			} else if (y.isHemisphereLight) {
				const x = r.hemi[g];
				x.direction.setFromMatrixPosition(y.matrixWorld), x.direction.transformDirection(m), g++
			}
		}
	}
	return {
		setup: l,
		setupView: c,
		state: r
	}
}

function wE(n, e) {
	const t = new R$(n, e),
		i = [],
		r = [];

	function s() {
		i.length = 0, r.length = 0
	}

	function o(h) {
		i.push(h)
	}

	function a(h) {
		r.push(h)
	}

	function l(h) {
		t.setup(i, h)
	}

	function c(h) {
		t.setupView(i, h)
	}
	return {
		init: s,
		state: {
			lightsArray: i,
			shadowsArray: r,
			lights: t
		},
		setupLights: l,
		setupLightsView: c,
		pushLight: o,
		pushShadow: a
	}
}

function L$(n, e) {
	let t = new WeakMap;

	function i(s, o = 0) {
		const a = t.get(s);
		let l;
		return a === void 0 ? (l = new wE(n, e), t.set(s, [l])) : o >= a.length ? (l = new wE(n, e), a.push(l)) : l = a[o], l
	}

	function r() {
		t = new WeakMap
	}
	return {
		get: i,
		dispose: r
	}
}
class GD extends Cs {
	constructor(e) {
		super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = mV, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
	}
}
class k$ extends Cs {
	constructor(e) {
		super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
	}
}
const I$ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
	O$ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function F$(n, e, t) {
	let i = new kb;
	const r = new Oe,
		s = new Oe,
		o = new kt,
		a = new GD({
			depthPacking: gV
		}),
		l = new k$,
		c = {},
		u = t.maxTextureSize,
		h = {
			[fo]: ji,
			[ji]: fo,
			[_r]: _r
		},
		d = new Dn({
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Oe
				},
				radius: {
					value: 4
				}
			},
			vertexShader: I$,
			fragmentShader: O$
		}),
		f = d.clone();
	f.defines.HORIZONTAL_PASS = 1;
	const p = new gi;
	p.setAttribute("position", new Cn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
	const _ = new an(p, d),
		g = this;
	this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = dD;
	let m = this.type;
	this.render = function (S, E, C) {
		if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || S.length === 0) return;
		const P = n.getRenderTarget(),
			w = n.getActiveCubeFace(),
			D = n.getActiveMipmapLevel(),
			U = n.state;
		U.setBlending(ua), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
		const j = m !== js && this.type === js,
			z = m === js && this.type !== js;
		for (let H = 0, F = S.length; H < F; H++) {
			const G = S[H],
				R = G.shadow;
			if (R === void 0) {
				console.warn("THREE.WebGLShadowMap:", G, "has no shadow.");
				continue
			}
			if (R.autoUpdate === !1 && R.needsUpdate === !1) continue;
			r.copy(R.mapSize);
			const Q = R.getFrameExtents();
			if (r.multiply(Q), s.copy(R.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / Q.x), r.x = s.x * Q.x, R.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / Q.y), r.y = s.y * Q.y, R.mapSize.y = s.y)), R.map === null || j === !0 || z === !0) {
				const ge = this.type !== js ? {
					minFilter: $n,
					magFilter: $n
				} : {};
				R.map !== null && R.map.dispose(), R.map = new xa(r.x, r.y, ge), R.map.texture.name = G.name + ".shadowMap", R.camera.updateProjectionMatrix()
			}
			n.setRenderTarget(R.map), n.clear();
			const B = R.getViewportCount();
			for (let ge = 0; ge < B; ge++) {
				const Ae = R.getViewport(ge);
				o.set(s.x * Ae.x, s.y * Ae.y, s.x * Ae.z, s.y * Ae.w), U.viewport(o), R.updateMatrices(G, ge), i = R.getFrustum(), y(E, C, R.camera, G, this.type)
			}
			R.isPointLightShadow !== !0 && this.type === js && b(R, C), R.needsUpdate = !1
		}
		m = this.type, g.needsUpdate = !1, n.setRenderTarget(P, w, D)
	};

	function b(S, E) {
		const C = e.update(_);
		d.defines.VSM_SAMPLES !== S.blurSamples && (d.defines.VSM_SAMPLES = S.blurSamples, f.defines.VSM_SAMPLES = S.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), S.mapPass === null && (S.mapPass = new xa(r.x, r.y)), d.uniforms.shadow_pass.value = S.map.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, n.setRenderTarget(S.mapPass), n.clear(), n.renderBufferDirect(E, null, C, d, _, null), f.uniforms.shadow_pass.value = S.mapPass.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, n.setRenderTarget(S.map), n.clear(), n.renderBufferDirect(E, null, C, f, _, null)
	}

	function v(S, E, C, P) {
		let w = null;
		const D = C.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
		if (D !== void 0) w = D;
		else if (w = C.isPointLight === !0 ? l : a, n.localClippingEnabled && E.clipShadows === !0 && Array.isArray(E.clippingPlanes) && E.clippingPlanes.length !== 0 || E.displacementMap && E.displacementScale !== 0 || E.alphaMap && E.alphaTest > 0 || E.map && E.alphaTest > 0) {
			const U = w.uuid,
				j = E.uuid;
			let z = c[U];
			z === void 0 && (z = {}, c[U] = z);
			let H = z[j];
			H === void 0 && (H = w.clone(), z[j] = H, E.addEventListener("dispose", x)), w = H
		}
		if (w.visible = E.visible, w.wireframe = E.wireframe, P === js ? w.side = E.shadowSide !== null ? E.shadowSide : E.side : w.side = E.shadowSide !== null ? E.shadowSide : h[E.side], w.alphaMap = E.alphaMap, w.alphaTest = E.alphaTest, w.map = E.map, w.clipShadows = E.clipShadows, w.clippingPlanes = E.clippingPlanes, w.clipIntersection = E.clipIntersection, w.displacementMap = E.displacementMap, w.displacementScale = E.displacementScale, w.displacementBias = E.displacementBias, w.wireframeLinewidth = E.wireframeLinewidth, w.linewidth = E.linewidth, C.isPointLight === !0 && w.isMeshDistanceMaterial === !0) {
			const U = n.properties.get(w);
			U.light = C
		}
		return w
	}

	function y(S, E, C, P, w) {
		if (S.visible === !1) return;
		if (S.layers.test(E.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && w === js) && (!S.frustumCulled || i.intersectsObject(S))) {
			S.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, S.matrixWorld);
			const j = e.update(S),
				z = S.material;
			if (Array.isArray(z)) {
				const H = j.groups;
				for (let F = 0, G = H.length; F < G; F++) {
					const R = H[F],
						Q = z[R.materialIndex];
					if (Q && Q.visible) {
						const B = v(S, Q, P, w);
						S.onBeforeShadow(n, S, E, C, j, B, R), n.renderBufferDirect(C, null, j, B, S, R), S.onAfterShadow(n, S, E, C, j, B, R)
					}
				}
			} else if (z.visible) {
				const H = v(S, z, P, w);
				S.onBeforeShadow(n, S, E, C, j, H, null), n.renderBufferDirect(C, null, j, H, S, null), S.onAfterShadow(n, S, E, C, j, H, null)
			}
		}
		const U = S.children;
		for (let j = 0, z = U.length; j < z; j++) y(U[j], E, C, P, w)
	}

	function x(S) {
		S.target.removeEventListener("dispose", x);
		for (const C in c) {
			const P = c[C],
				w = S.target.uuid;
			w in P && (P[w].dispose(), delete P[w])
		}
	}
}

function N$(n, e, t) {
	const i = t.isWebGL2;

	function r() {
		let V = !1;
		const be = new kt;
		let te = null;
		const Ee = new kt(0, 0, 0, 0);
		return {
			setMask: function (Ie) {
				te !== Ie && !V && (n.colorMask(Ie, Ie, Ie, Ie), te = Ie)
			},
			setLocked: function (Ie) {
				V = Ie
			},
			setClear: function (Ie, st, Et, He, Ve) {
				Ve === !0 && (Ie *= He, st *= He, Et *= He), be.set(Ie, st, Et, He), Ee.equals(be) === !1 && (n.clearColor(Ie, st, Et, He), Ee.copy(be))
			},
			reset: function () {
				V = !1, te = null, Ee.set(-1, 0, 0, 0)
			}
		}
	}

	function s() {
		let V = !1,
			be = null,
			te = null,
			Ee = null;
		return {
			setTest: function (Ie) {
				Ie ? ce(n.DEPTH_TEST) : Ce(n.DEPTH_TEST)
			},
			setMask: function (Ie) {
				be !== Ie && !V && (n.depthMask(Ie), be = Ie)
			},
			setFunc: function (Ie) {
				if (te !== Ie) {
					switch (Ie) {
						case Wz:
							n.depthFunc(n.NEVER);
							break;
						case jz:
							n.depthFunc(n.ALWAYS);
							break;
						case $z:
							n.depthFunc(n.LESS);
							break;
						case tm:
							n.depthFunc(n.LEQUAL);
							break;
						case qz:
							n.depthFunc(n.EQUAL);
							break;
						case Xz:
							n.depthFunc(n.GEQUAL);
							break;
						case Yz:
							n.depthFunc(n.GREATER);
							break;
						case Kz:
							n.depthFunc(n.NOTEQUAL);
							break;
						default:
							n.depthFunc(n.LEQUAL)
					}
					te = Ie
				}
			},
			setLocked: function (Ie) {
				V = Ie
			},
			setClear: function (Ie) {
				Ee !== Ie && (n.clearDepth(Ie), Ee = Ie)
			},
			reset: function () {
				V = !1, be = null, te = null, Ee = null
			}
		}
	}

	function o() {
		let V = !1,
			be = null,
			te = null,
			Ee = null,
			Ie = null,
			st = null,
			Et = null,
			He = null,
			Ve = null;
		return {
			setTest: function ($e) {
				V || ($e ? ce(n.STENCIL_TEST) : Ce(n.STENCIL_TEST))
			},
			setMask: function ($e) {
				be !== $e && !V && (n.stencilMask($e), be = $e)
			},
			setFunc: function ($e, Pe, Ze) {
				(te !== $e || Ee !== Pe || Ie !== Ze) && (n.stencilFunc($e, Pe, Ze), te = $e, Ee = Pe, Ie = Ze)
			},
			setOp: function ($e, Pe, Ze) {
				(st !== $e || Et !== Pe || He !== Ze) && (n.stencilOp($e, Pe, Ze), st = $e, Et = Pe, He = Ze)
			},
			setLocked: function ($e) {
				V = $e
			},
			setClear: function ($e) {
				Ve !== $e && (n.clearStencil($e), Ve = $e)
			},
			reset: function () {
				V = !1, be = null, te = null, Ee = null, Ie = null, st = null, Et = null, He = null, Ve = null
			}
		}
	}
	const a = new r,
		l = new s,
		c = new o,
		u = new WeakMap,
		h = new WeakMap;
	let d = {},
		f = {},
		p = new WeakMap,
		_ = [],
		g = null,
		m = !1,
		b = null,
		v = null,
		y = null,
		x = null,
		S = null,
		E = null,
		C = null,
		P = new et(0, 0, 0),
		w = 0,
		D = !1,
		U = null,
		j = null,
		z = null,
		H = null,
		F = null;
	const G = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let R = !1,
		Q = 0;
	const B = n.getParameter(n.VERSION);
	B.indexOf("WebGL") !== -1 ? (Q = parseFloat(/^WebGL (\d)/.exec(B)[1]), R = Q >= 1) : B.indexOf("OpenGL ES") !== -1 && (Q = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), R = Q >= 2);
	let ge = null,
		Ae = {};
	const ze = n.getParameter(n.SCISSOR_BOX),
		K = n.getParameter(n.VIEWPORT),
		ye = new kt().fromArray(ze),
		Se = new kt().fromArray(K);

	function Z(V, be, te, Ee) {
		const Ie = new Uint8Array(4),
			st = n.createTexture();
		n.bindTexture(V, st), n.texParameteri(V, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(V, n.TEXTURE_MAG_FILTER, n.NEAREST);
		for (let Et = 0; Et < te; Et++) i && (V === n.TEXTURE_3D || V === n.TEXTURE_2D_ARRAY) ? n.texImage3D(be, 0, n.RGBA, 1, 1, Ee, 0, n.RGBA, n.UNSIGNED_BYTE, Ie) : n.texImage2D(be + Et, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Ie);
		return st
	}
	const pe = {};
	pe[n.TEXTURE_2D] = Z(n.TEXTURE_2D, n.TEXTURE_2D, 1), pe[n.TEXTURE_CUBE_MAP] = Z(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (pe[n.TEXTURE_2D_ARRAY] = Z(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), pe[n.TEXTURE_3D] = Z(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ce(n.DEPTH_TEST), l.setFunc(tm), me(!1), ve(Qw), ce(n.CULL_FACE), ie(ua);

	function ce(V) {
		d[V] !== !0 && (n.enable(V), d[V] = !0)
	}

	function Ce(V) {
		d[V] !== !1 && (n.disable(V), d[V] = !1)
	}

	function Re(V, be) {
		return f[V] !== be ? (n.bindFramebuffer(V, be), f[V] = be, i && (V === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = be), V === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = be)), !0) : !1
	}

	function Y(V, be) {
		let te = _,
			Ee = !1;
		if (V) {
			te = p.get(be), te === void 0 && (te = [], p.set(be, te));
			const Ie = V.textures;
			if (te.length !== Ie.length || te[0] !== n.COLOR_ATTACHMENT0) {
				for (let st = 0, Et = Ie.length; st < Et; st++) te[st] = n.COLOR_ATTACHMENT0 + st;
				te.length = Ie.length, Ee = !0
			}
		} else te[0] !== n.BACK && (te[0] = n.BACK, Ee = !0);
		if (Ee)
			if (t.isWebGL2) n.drawBuffers(te);
			else if (e.has("WEBGL_draw_buffers") === !0) e.get("WEBGL_draw_buffers").drawBuffersWEBGL(te);
		else throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension")
	}

	function k(V) {
		return g !== V ? (n.useProgram(V), g = V, !0) : !1
	}
	const O = {
		[Ja]: n.FUNC_ADD,
		[Dz]: n.FUNC_SUBTRACT,
		[Pz]: n.FUNC_REVERSE_SUBTRACT
	};
	if (i) O[i2] = n.MIN, O[r2] = n.MAX;
	else {
		const V = e.get("EXT_blend_minmax");
		V !== null && (O[i2] = V.MIN_EXT, O[r2] = V.MAX_EXT)
	}
	const q = {
		[Rz]: n.ZERO,
		[Lz]: n.ONE,
		[kz]: n.SRC_COLOR,
		[Cv]: n.SRC_ALPHA,
		[Bz]: n.SRC_ALPHA_SATURATE,
		[Nz]: n.DST_COLOR,
		[Oz]: n.DST_ALPHA,
		[Iz]: n.ONE_MINUS_SRC_COLOR,
		[Av]: n.ONE_MINUS_SRC_ALPHA,
		[Uz]: n.ONE_MINUS_DST_COLOR,
		[Fz]: n.ONE_MINUS_DST_ALPHA,
		[zz]: n.CONSTANT_COLOR,
		[Vz]: n.ONE_MINUS_CONSTANT_COLOR,
		[Hz]: n.CONSTANT_ALPHA,
		[Gz]: n.ONE_MINUS_CONSTANT_ALPHA
	};

	function ie(V, be, te, Ee, Ie, st, Et, He, Ve, $e) {
		if (V === ua) {
			m === !0 && (Ce(n.BLEND), m = !1);
			return
		}
		if (m === !1 && (ce(n.BLEND), m = !0), V !== Az) {
			if (V !== b || $e !== D) {
				if ((v !== Ja || S !== Ja) && (n.blendEquation(n.FUNC_ADD), v = Ja, S = Ja), $e) switch (V) {
					case ha:
						n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
						break;
					case e2:
						n.blendFunc(n.ONE, n.ONE);
						break;
					case t2:
						n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
						break;
					case n2:
						n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", V);
						break
				} else switch (V) {
					case ha:
						n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
						break;
					case e2:
						n.blendFunc(n.SRC_ALPHA, n.ONE);
						break;
					case t2:
						n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
						break;
					case n2:
						n.blendFunc(n.ZERO, n.SRC_COLOR);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", V);
						break
				}
				y = null, x = null, E = null, C = null, P.set(0, 0, 0), w = 0, b = V, D = $e
			}
			return
		}
		Ie = Ie || be, st = st || te, Et = Et || Ee, (be !== v || Ie !== S) && (n.blendEquationSeparate(O[be], O[Ie]), v = be, S = Ie), (te !== y || Ee !== x || st !== E || Et !== C) && (n.blendFuncSeparate(q[te], q[Ee], q[st], q[Et]), y = te, x = Ee, E = st, C = Et), (He.equals(P) === !1 || Ve !== w) && (n.blendColor(He.r, He.g, He.b, Ve), P.copy(He), w = Ve), b = V, D = !1
	}

	function N(V, be) {
		V.side === _r ? Ce(n.CULL_FACE) : ce(n.CULL_FACE);
		let te = V.side === ji;
		be && (te = !te), me(te), V.blending === ha && V.transparent === !1 ? ie(ua) : ie(V.blending, V.blendEquation, V.blendSrc, V.blendDst, V.blendEquationAlpha, V.blendSrcAlpha, V.blendDstAlpha, V.blendColor, V.blendAlpha, V.premultipliedAlpha), l.setFunc(V.depthFunc), l.setTest(V.depthTest), l.setMask(V.depthWrite), a.setMask(V.colorWrite);
		const Ee = V.stencilWrite;
		c.setTest(Ee), Ee && (c.setMask(V.stencilWriteMask), c.setFunc(V.stencilFunc, V.stencilRef, V.stencilFuncMask), c.setOp(V.stencilFail, V.stencilZFail, V.stencilZPass)), A(V.polygonOffset, V.polygonOffsetFactor, V.polygonOffsetUnits), V.alphaToCoverage === !0 ? ce(n.SAMPLE_ALPHA_TO_COVERAGE) : Ce(n.SAMPLE_ALPHA_TO_COVERAGE)
	}

	function me(V) {
		U !== V && (V ? n.frontFace(n.CW) : n.frontFace(n.CCW), U = V)
	}

	function ve(V) {
		V !== Tz ? (ce(n.CULL_FACE), V !== j && (V === Qw ? n.cullFace(n.BACK) : V === Mz ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Ce(n.CULL_FACE), j = V
	}

	function xe(V) {
		V !== z && (R && n.lineWidth(V), z = V)
	}

	function A(V, be, te) {
		V ? (ce(n.POLYGON_OFFSET_FILL), (H !== be || F !== te) && (n.polygonOffset(be, te), H = be, F = te)) : Ce(n.POLYGON_OFFSET_FILL)
	}

	function T(V) {
		V ? ce(n.SCISSOR_TEST) : Ce(n.SCISSOR_TEST)
	}

	function $(V) {
		V === void 0 && (V = n.TEXTURE0 + G - 1), ge !== V && (n.activeTexture(V), ge = V)
	}

	function re(V, be, te) {
		te === void 0 && (ge === null ? te = n.TEXTURE0 + G - 1 : te = ge);
		let Ee = Ae[te];
		Ee === void 0 && (Ee = {
			type: void 0,
			texture: void 0
		}, Ae[te] = Ee), (Ee.type !== V || Ee.texture !== be) && (ge !== te && (n.activeTexture(te), ge = te), n.bindTexture(V, be || pe[V]), Ee.type = V, Ee.texture = be)
	}

	function se() {
		const V = Ae[ge];
		V !== void 0 && V.type !== void 0 && (n.bindTexture(V.type, null), V.type = void 0, V.texture = void 0)
	}

	function ue() {
		try {
			n.compressedTexImage2D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function Me() {
		try {
			n.compressedTexImage3D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function Le() {
		try {
			n.texSubImage2D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function we() {
		try {
			n.texSubImage3D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function Te() {
		try {
			n.compressedTexSubImage2D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function je() {
		try {
			n.compressedTexSubImage3D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function M() {
		try {
			n.texStorage2D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function W() {
		try {
			n.texStorage3D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function le() {
		try {
			n.texImage2D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function J() {
		try {
			n.texImage3D.apply(n, arguments)
		} catch (V) {
			console.error("THREE.WebGLState:", V)
		}
	}

	function oe(V) {
		ye.equals(V) === !1 && (n.scissor(V.x, V.y, V.z, V.w), ye.copy(V))
	}

	function _e(V) {
		Se.equals(V) === !1 && (n.viewport(V.x, V.y, V.z, V.w), Se.copy(V))
	}

	function I(V, be) {
		let te = h.get(be);
		te === void 0 && (te = new WeakMap, h.set(be, te));
		let Ee = te.get(V);
		Ee === void 0 && (Ee = n.getUniformBlockIndex(be, V.name), te.set(V, Ee))
	}

	function ee(V, be) {
		const Ee = h.get(be).get(V);
		u.get(be) !== Ee && (n.uniformBlockBinding(be, Ee, V.__bindingPointIndex), u.set(be, Ee))
	}

	function De() {
		n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), d = {}, ge = null, Ae = {}, f = {}, p = new WeakMap, _ = [], g = null, m = !1, b = null, v = null, y = null, x = null, S = null, E = null, C = null, P = new et(0, 0, 0), w = 0, D = !1, U = null, j = null, z = null, H = null, F = null, ye.set(0, 0, n.canvas.width, n.canvas.height), Se.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), c.reset()
	}
	return {
		buffers: {
			color: a,
			depth: l,
			stencil: c
		},
		enable: ce,
		disable: Ce,
		bindFramebuffer: Re,
		drawBuffers: Y,
		useProgram: k,
		setBlending: ie,
		setMaterial: N,
		setFlipSided: me,
		setCullFace: ve,
		setLineWidth: xe,
		setPolygonOffset: A,
		setScissorTest: T,
		activeTexture: $,
		bindTexture: re,
		unbindTexture: se,
		compressedTexImage2D: ue,
		compressedTexImage3D: Me,
		texImage2D: le,
		texImage3D: J,
		updateUBOMapping: I,
		uniformBlockBinding: ee,
		texStorage2D: M,
		texStorage3D: W,
		texSubImage2D: Le,
		texSubImage3D: we,
		compressedTexSubImage2D: Te,
		compressedTexSubImage3D: je,
		scissor: oe,
		viewport: _e,
		reset: De
	}
}

function U$(n, e, t, i, r, s, o) {
	const a = r.isWebGL2,
		l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
		c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
		u = new Oe,
		h = new WeakMap;
	let d;
	const f = new WeakMap;
	let p = !1;
	try {
		p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
	} catch {}

	function _(A, T) {
		return p ? new OffscreenCanvas(A, T) : hd("canvas")
	}

	function g(A, T, $, re) {
		let se = 1;
		const ue = xe(A);
		if ((ue.width > re || ue.height > re) && (se = re / Math.max(ue.width, ue.height)), se < 1 || T === !0)
			if (typeof HTMLImageElement < "u" && A instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && A instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && A instanceof ImageBitmap || typeof VideoFrame < "u" && A instanceof VideoFrame) {
				const Me = T ? lm : Math.floor,
					Le = Me(se * ue.width),
					we = Me(se * ue.height);
				d === void 0 && (d = _(Le, we));
				const Te = $ ? _(Le, we) : d;
				return Te.width = Le, Te.height = we, Te.getContext("2d").drawImage(A, 0, 0, Le, we), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ue.width + "x" + ue.height + ") to (" + Le + "x" + we + ")."), Te
			} else return "data" in A && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ue.width + "x" + ue.height + ")."), A;
		return A
	}

	function m(A) {
		const T = xe(A);
		return kv(T.width) && kv(T.height)
	}

	function b(A) {
		return a ? !1 : A.wrapS !== Nr || A.wrapT !== Nr || A.minFilter !== $n && A.minFilter !== jn
	}

	function v(A, T) {
		return A.generateMipmaps && T && A.minFilter !== $n && A.minFilter !== jn
	}

	function y(A) {
		n.generateMipmap(A)
	}

	function x(A, T, $, re, se = !1) {
		if (a === !1) return T;
		if (A !== null) {
			if (n[A] !== void 0) return n[A];
			console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + A + "'")
		}
		let ue = T;
		if (T === n.RED && ($ === n.FLOAT && (ue = n.R32F), $ === n.HALF_FLOAT && (ue = n.R16F), $ === n.UNSIGNED_BYTE && (ue = n.R8)), T === n.RED_INTEGER && ($ === n.UNSIGNED_BYTE && (ue = n.R8UI), $ === n.UNSIGNED_SHORT && (ue = n.R16UI), $ === n.UNSIGNED_INT && (ue = n.R32UI), $ === n.BYTE && (ue = n.R8I), $ === n.SHORT && (ue = n.R16I), $ === n.INT && (ue = n.R32I)), T === n.RG && ($ === n.FLOAT && (ue = n.RG32F), $ === n.HALF_FLOAT && (ue = n.RG16F), $ === n.UNSIGNED_BYTE && (ue = n.RG8)), T === n.RG_INTEGER && ($ === n.UNSIGNED_BYTE && (ue = n.RG8UI), $ === n.UNSIGNED_SHORT && (ue = n.RG16UI), $ === n.UNSIGNED_INT && (ue = n.RG32UI), $ === n.BYTE && (ue = n.RG8I), $ === n.SHORT && (ue = n.RG16I), $ === n.INT && (ue = n.RG32I)), T === n.RGBA) {
			const Me = se ? im : Lt.getTransfer(re);
			$ === n.FLOAT && (ue = n.RGBA32F), $ === n.HALF_FLOAT && (ue = n.RGBA16F), $ === n.UNSIGNED_BYTE && (ue = Me === Qt ? n.SRGB8_ALPHA8 : n.RGBA8), $ === n.UNSIGNED_SHORT_4_4_4_4 && (ue = n.RGBA4), $ === n.UNSIGNED_SHORT_5_5_5_1 && (ue = n.RGB5_A1)
		}
		return (ue === n.R16F || ue === n.R32F || ue === n.RG16F || ue === n.RG32F || ue === n.RGBA16F || ue === n.RGBA32F) && e.get("EXT_color_buffer_float"), ue
	}

	function S(A, T, $) {
		return v(A, $) === !0 || A.isFramebufferTexture && A.minFilter !== $n && A.minFilter !== jn ? Math.log2(Math.max(T.width, T.height)) + 1 : A.mipmaps !== void 0 && A.mipmaps.length > 0 ? A.mipmaps.length : A.isCompressedTexture && Array.isArray(A.image) ? T.mipmaps.length : 1
	}

	function E(A) {
		return A === $n || A === Pv || A === mc ? n.NEAREST : n.LINEAR
	}

	function C(A) {
		const T = A.target;
		T.removeEventListener("dispose", C), w(T), T.isVideoTexture && h.delete(T)
	}

	function P(A) {
		const T = A.target;
		T.removeEventListener("dispose", P), U(T)
	}

	function w(A) {
		const T = i.get(A);
		if (T.__webglInit === void 0) return;
		const $ = A.source,
			re = f.get($);
		if (re) {
			const se = re[T.__cacheKey];
			se.usedTimes--, se.usedTimes === 0 && D(A), Object.keys(re).length === 0 && f.delete($)
		}
		i.remove(A)
	}

	function D(A) {
		const T = i.get(A);
		n.deleteTexture(T.__webglTexture);
		const $ = A.source,
			re = f.get($);
		delete re[T.__cacheKey], o.memory.textures--
	}

	function U(A) {
		const T = i.get(A);
		if (A.depthTexture && A.depthTexture.dispose(), A.isWebGLCubeRenderTarget)
			for (let re = 0; re < 6; re++) {
				if (Array.isArray(T.__webglFramebuffer[re]))
					for (let se = 0; se < T.__webglFramebuffer[re].length; se++) n.deleteFramebuffer(T.__webglFramebuffer[re][se]);
				else n.deleteFramebuffer(T.__webglFramebuffer[re]);
				T.__webglDepthbuffer && n.deleteRenderbuffer(T.__webglDepthbuffer[re])
			} else {
				if (Array.isArray(T.__webglFramebuffer))
					for (let re = 0; re < T.__webglFramebuffer.length; re++) n.deleteFramebuffer(T.__webglFramebuffer[re]);
				else n.deleteFramebuffer(T.__webglFramebuffer);
				if (T.__webglDepthbuffer && n.deleteRenderbuffer(T.__webglDepthbuffer), T.__webglMultisampledFramebuffer && n.deleteFramebuffer(T.__webglMultisampledFramebuffer), T.__webglColorRenderbuffer)
					for (let re = 0; re < T.__webglColorRenderbuffer.length; re++) T.__webglColorRenderbuffer[re] && n.deleteRenderbuffer(T.__webglColorRenderbuffer[re]);
				T.__webglDepthRenderbuffer && n.deleteRenderbuffer(T.__webglDepthRenderbuffer)
			}
		const $ = A.textures;
		for (let re = 0, se = $.length; re < se; re++) {
			const ue = i.get($[re]);
			ue.__webglTexture && (n.deleteTexture(ue.__webglTexture), o.memory.textures--), i.remove($[re])
		}
		i.remove(A)
	}
	let j = 0;

	function z() {
		j = 0
	}

	function H() {
		const A = j;
		return A >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + A + " texture units while this GPU supports only " + r.maxTextures), j += 1, A
	}

	function F(A) {
		const T = [];
		return T.push(A.wrapS), T.push(A.wrapT), T.push(A.wrapR || 0), T.push(A.magFilter), T.push(A.minFilter), T.push(A.anisotropy), T.push(A.internalFormat), T.push(A.format), T.push(A.type), T.push(A.generateMipmaps), T.push(A.premultiplyAlpha), T.push(A.flipY), T.push(A.unpackAlignment), T.push(A.colorSpace), T.join()
	}

	function G(A, T) {
		const $ = i.get(A);
		if (A.isVideoTexture && me(A), A.isRenderTargetTexture === !1 && A.version > 0 && $.__version !== A.version) {
			const re = A.image;
			if (re === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
			else if (re.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
			else {
				Se($, A, T);
				return
			}
		}
		t.bindTexture(n.TEXTURE_2D, $.__webglTexture, n.TEXTURE0 + T)
	}

	function R(A, T) {
		const $ = i.get(A);
		if (A.version > 0 && $.__version !== A.version) {
			Se($, A, T);
			return
		}
		t.bindTexture(n.TEXTURE_2D_ARRAY, $.__webglTexture, n.TEXTURE0 + T)
	}

	function Q(A, T) {
		const $ = i.get(A);
		if (A.version > 0 && $.__version !== A.version) {
			Se($, A, T);
			return
		}
		t.bindTexture(n.TEXTURE_3D, $.__webglTexture, n.TEXTURE0 + T)
	}

	function B(A, T) {
		const $ = i.get(A);
		if (A.version > 0 && $.__version !== A.version) {
			Z($, A, T);
			return
		}
		t.bindTexture(n.TEXTURE_CUBE_MAP, $.__webglTexture, n.TEXTURE0 + T)
	}
	const ge = {
			[ya]: n.REPEAT,
			[Nr]: n.CLAMP_TO_EDGE,
			[nm]: n.MIRRORED_REPEAT
		},
		Ae = {
			[$n]: n.NEAREST,
			[Pv]: n.NEAREST_MIPMAP_NEAREST,
			[mc]: n.NEAREST_MIPMAP_LINEAR,
			[jn]: n.LINEAR,
			[vp]: n.LINEAR_MIPMAP_NEAREST,
			[Qs]: n.LINEAR_MIPMAP_LINEAR
		},
		ze = {
			[vV]: n.NEVER,
			[SV]: n.ALWAYS,
			[bV]: n.LESS,
			[TD]: n.LEQUAL,
			[yV]: n.EQUAL,
			[EV]: n.GEQUAL,
			[xV]: n.GREATER,
			[wV]: n.NOTEQUAL
		};

	function K(A, T, $) {
		if (T.type === ns && e.has("OES_texture_float_linear") === !1 && (T.magFilter === jn || T.magFilter === vp || T.magFilter === mc || T.magFilter === Qs || T.minFilter === jn || T.minFilter === vp || T.minFilter === mc || T.minFilter === Qs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), $ ? (n.texParameteri(A, n.TEXTURE_WRAP_S, ge[T.wrapS]), n.texParameteri(A, n.TEXTURE_WRAP_T, ge[T.wrapT]), (A === n.TEXTURE_3D || A === n.TEXTURE_2D_ARRAY) && n.texParameteri(A, n.TEXTURE_WRAP_R, ge[T.wrapR]), n.texParameteri(A, n.TEXTURE_MAG_FILTER, Ae[T.magFilter]), n.texParameteri(A, n.TEXTURE_MIN_FILTER, Ae[T.minFilter])) : (n.texParameteri(A, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(A, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (A === n.TEXTURE_3D || A === n.TEXTURE_2D_ARRAY) && n.texParameteri(A, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (T.wrapS !== Nr || T.wrapT !== Nr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(A, n.TEXTURE_MAG_FILTER, E(T.magFilter)), n.texParameteri(A, n.TEXTURE_MIN_FILTER, E(T.minFilter)), T.minFilter !== $n && T.minFilter !== jn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), T.compareFunction && (n.texParameteri(A, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(A, n.TEXTURE_COMPARE_FUNC, ze[T.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
			if (T.magFilter === $n || T.minFilter !== mc && T.minFilter !== Qs || T.type === ns && e.has("OES_texture_float_linear") === !1 || a === !1 && T.type === au && e.has("OES_texture_half_float_linear") === !1) return;
			if (T.anisotropy > 1 || i.get(T).__currentAnisotropy) {
				const re = e.get("EXT_texture_filter_anisotropic");
				n.texParameterf(A, re.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(T.anisotropy, r.getMaxAnisotropy())), i.get(T).__currentAnisotropy = T.anisotropy
			}
		}
	}

	function ye(A, T) {
		let $ = !1;
		A.__webglInit === void 0 && (A.__webglInit = !0, T.addEventListener("dispose", C));
		const re = T.source;
		let se = f.get(re);
		se === void 0 && (se = {}, f.set(re, se));
		const ue = F(T);
		if (ue !== A.__cacheKey) {
			se[ue] === void 0 && (se[ue] = {
				texture: n.createTexture(),
				usedTimes: 0
			}, o.memory.textures++, $ = !0), se[ue].usedTimes++;
			const Me = se[A.__cacheKey];
			Me !== void 0 && (se[A.__cacheKey].usedTimes--, Me.usedTimes === 0 && D(T)), A.__cacheKey = ue, A.__webglTexture = se[ue].texture
		}
		return $
	}

	function Se(A, T, $) {
		let re = n.TEXTURE_2D;
		(T.isDataArrayTexture || T.isCompressedArrayTexture) && (re = n.TEXTURE_2D_ARRAY), T.isData3DTexture && (re = n.TEXTURE_3D);
		const se = ye(A, T),
			ue = T.source;
		t.bindTexture(re, A.__webglTexture, n.TEXTURE0 + $);
		const Me = i.get(ue);
		if (ue.version !== Me.__version || se === !0) {
			t.activeTexture(n.TEXTURE0 + $);
			const Le = Lt.getPrimaries(Lt.workingColorSpace),
				we = T.colorSpace === jo ? null : Lt.getPrimaries(T.colorSpace),
				Te = T.colorSpace === jo || Le === we ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
			n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Te);
			const je = b(T) && m(T.image) === !1;
			let M = g(T.image, je, !1, r.maxTextureSize);
			M = ve(T, M);
			const W = m(M) || a,
				le = s.convert(T.format, T.colorSpace);
			let J = s.convert(T.type),
				oe = x(T.internalFormat, le, J, T.colorSpace, T.isVideoTexture);
			K(re, T, W);
			let _e;
			const I = T.mipmaps,
				ee = a && T.isVideoTexture !== !0 && oe !== wD,
				De = Me.__version === void 0 || se === !0,
				V = ue.dataReady,
				be = S(T, M, W);
			if (T.isDepthTexture) oe = n.DEPTH_COMPONENT, a ? T.type === ns ? oe = n.DEPTH_COMPONENT32F : T.type === Qo ? oe = n.DEPTH_COMPONENT24 : T.type === vl ? oe = n.DEPTH24_STENCIL8 : oe = n.DEPTH_COMPONENT16 : T.type === ns && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), T.format === bl && oe === n.DEPTH_COMPONENT && T.type !== Cb && T.type !== Qo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), T.type = Qo, J = s.convert(T.type)), T.format === lu && oe === n.DEPTH_COMPONENT && (oe = n.DEPTH_STENCIL, T.type !== vl && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), T.type = vl, J = s.convert(T.type))), De && (ee ? t.texStorage2D(n.TEXTURE_2D, 1, oe, M.width, M.height) : t.texImage2D(n.TEXTURE_2D, 0, oe, M.width, M.height, 0, le, J, null));
			else if (T.isDataTexture)
				if (I.length > 0 && W) {
					ee && De && t.texStorage2D(n.TEXTURE_2D, be, oe, I[0].width, I[0].height);
					for (let te = 0, Ee = I.length; te < Ee; te++) _e = I[te], ee ? V && t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, _e.width, _e.height, le, J, _e.data) : t.texImage2D(n.TEXTURE_2D, te, oe, _e.width, _e.height, 0, le, J, _e.data);
					T.generateMipmaps = !1
				} else ee ? (De && t.texStorage2D(n.TEXTURE_2D, be, oe, M.width, M.height), V && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, M.width, M.height, le, J, M.data)) : t.texImage2D(n.TEXTURE_2D, 0, oe, M.width, M.height, 0, le, J, M.data);
			else if (T.isCompressedTexture)
				if (T.isCompressedArrayTexture) {
					ee && De && t.texStorage3D(n.TEXTURE_2D_ARRAY, be, oe, I[0].width, I[0].height, M.depth);
					for (let te = 0, Ee = I.length; te < Ee; te++) _e = I[te], T.format !== vr ? le !== null ? ee ? V && t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, te, 0, 0, 0, _e.width, _e.height, M.depth, le, _e.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, te, oe, _e.width, _e.height, M.depth, 0, _e.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ee ? V && t.texSubImage3D(n.TEXTURE_2D_ARRAY, te, 0, 0, 0, _e.width, _e.height, M.depth, le, J, _e.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, te, oe, _e.width, _e.height, M.depth, 0, le, J, _e.data)
				} else {
					ee && De && t.texStorage2D(n.TEXTURE_2D, be, oe, I[0].width, I[0].height);
					for (let te = 0, Ee = I.length; te < Ee; te++) _e = I[te], T.format !== vr ? le !== null ? ee ? V && t.compressedTexSubImage2D(n.TEXTURE_2D, te, 0, 0, _e.width, _e.height, le, _e.data) : t.compressedTexImage2D(n.TEXTURE_2D, te, oe, _e.width, _e.height, 0, _e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ee ? V && t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, _e.width, _e.height, le, J, _e.data) : t.texImage2D(n.TEXTURE_2D, te, oe, _e.width, _e.height, 0, le, J, _e.data)
				}
			else if (T.isDataArrayTexture) ee ? (De && t.texStorage3D(n.TEXTURE_2D_ARRAY, be, oe, M.width, M.height, M.depth), V && t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, M.width, M.height, M.depth, le, J, M.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, oe, M.width, M.height, M.depth, 0, le, J, M.data);
			else if (T.isData3DTexture) ee ? (De && t.texStorage3D(n.TEXTURE_3D, be, oe, M.width, M.height, M.depth), V && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, M.width, M.height, M.depth, le, J, M.data)) : t.texImage3D(n.TEXTURE_3D, 0, oe, M.width, M.height, M.depth, 0, le, J, M.data);
			else if (T.isFramebufferTexture) {
				if (De)
					if (ee) t.texStorage2D(n.TEXTURE_2D, be, oe, M.width, M.height);
					else {
						let te = M.width,
							Ee = M.height;
						for (let Ie = 0; Ie < be; Ie++) t.texImage2D(n.TEXTURE_2D, Ie, oe, te, Ee, 0, le, J, null), te >>= 1, Ee >>= 1
					}
			} else if (I.length > 0 && W) {
				if (ee && De) {
					const te = xe(I[0]);
					t.texStorage2D(n.TEXTURE_2D, be, oe, te.width, te.height)
				}
				for (let te = 0, Ee = I.length; te < Ee; te++) _e = I[te], ee ? V && t.texSubImage2D(n.TEXTURE_2D, te, 0, 0, le, J, _e) : t.texImage2D(n.TEXTURE_2D, te, oe, le, J, _e);
				T.generateMipmaps = !1
			} else if (ee) {
				if (De) {
					const te = xe(M);
					t.texStorage2D(n.TEXTURE_2D, be, oe, te.width, te.height)
				}
				V && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, le, J, M)
			} else t.texImage2D(n.TEXTURE_2D, 0, oe, le, J, M);
			v(T, W) && y(re), Me.__version = ue.version, T.onUpdate && T.onUpdate(T)
		}
		A.__version = T.version
	}

	function Z(A, T, $) {
		if (T.image.length !== 6) return;
		const re = ye(A, T),
			se = T.source;
		t.bindTexture(n.TEXTURE_CUBE_MAP, A.__webglTexture, n.TEXTURE0 + $);
		const ue = i.get(se);
		if (se.version !== ue.__version || re === !0) {
			t.activeTexture(n.TEXTURE0 + $);
			const Me = Lt.getPrimaries(Lt.workingColorSpace),
				Le = T.colorSpace === jo ? null : Lt.getPrimaries(T.colorSpace),
				we = T.colorSpace === jo || Me === Le ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
			n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
			const Te = T.isCompressedTexture || T.image[0].isCompressedTexture,
				je = T.image[0] && T.image[0].isDataTexture,
				M = [];
			for (let te = 0; te < 6; te++) !Te && !je ? M[te] = g(T.image[te], !1, !0, r.maxCubemapSize) : M[te] = je ? T.image[te].image : T.image[te], M[te] = ve(T, M[te]);
			const W = M[0],
				le = m(W) || a,
				J = s.convert(T.format, T.colorSpace),
				oe = s.convert(T.type),
				_e = x(T.internalFormat, J, oe, T.colorSpace),
				I = a && T.isVideoTexture !== !0,
				ee = ue.__version === void 0 || re === !0,
				De = se.dataReady;
			let V = S(T, W, le);
			K(n.TEXTURE_CUBE_MAP, T, le);
			let be;
			if (Te) {
				I && ee && t.texStorage2D(n.TEXTURE_CUBE_MAP, V, _e, W.width, W.height);
				for (let te = 0; te < 6; te++) {
					be = M[te].mipmaps;
					for (let Ee = 0; Ee < be.length; Ee++) {
						const Ie = be[Ee];
						T.format !== vr ? J !== null ? I ? De && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee, 0, 0, Ie.width, Ie.height, J, Ie.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee, _e, Ie.width, Ie.height, 0, Ie.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : I ? De && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee, 0, 0, Ie.width, Ie.height, J, oe, Ie.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee, _e, Ie.width, Ie.height, 0, J, oe, Ie.data)
					}
				}
			} else {
				if (be = T.mipmaps, I && ee) {
					be.length > 0 && V++;
					const te = xe(M[0]);
					t.texStorage2D(n.TEXTURE_CUBE_MAP, V, _e, te.width, te.height)
				}
				for (let te = 0; te < 6; te++)
					if (je) {
						I ? De && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, M[te].width, M[te].height, J, oe, M[te].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, _e, M[te].width, M[te].height, 0, J, oe, M[te].data);
						for (let Ee = 0; Ee < be.length; Ee++) {
							const st = be[Ee].image[te].image;
							I ? De && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee + 1, 0, 0, st.width, st.height, J, oe, st.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee + 1, _e, st.width, st.height, 0, J, oe, st.data)
						}
					} else {
						I ? De && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, 0, 0, J, oe, M[te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, 0, _e, J, oe, M[te]);
						for (let Ee = 0; Ee < be.length; Ee++) {
							const Ie = be[Ee];
							I ? De && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee + 1, 0, 0, J, oe, Ie.image[te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + te, Ee + 1, _e, J, oe, Ie.image[te])
						}
					}
			}
			v(T, le) && y(n.TEXTURE_CUBE_MAP), ue.__version = se.version, T.onUpdate && T.onUpdate(T)
		}
		A.__version = T.version
	}

	function pe(A, T, $, re, se, ue) {
		const Me = s.convert($.format, $.colorSpace),
			Le = s.convert($.type),
			we = x($.internalFormat, Me, Le, $.colorSpace);
		if (!i.get(T).__hasExternalTextures) {
			const je = Math.max(1, T.width >> ue),
				M = Math.max(1, T.height >> ue);
			se === n.TEXTURE_3D || se === n.TEXTURE_2D_ARRAY ? t.texImage3D(se, ue, we, je, M, T.depth, 0, Me, Le, null) : t.texImage2D(se, ue, we, je, M, 0, Me, Le, null)
		}
		t.bindFramebuffer(n.FRAMEBUFFER, A), N(T) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, re, se, i.get($).__webglTexture, 0, ie(T)) : (se === n.TEXTURE_2D || se >= n.TEXTURE_CUBE_MAP_POSITIVE_X && se <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, re, se, i.get($).__webglTexture, ue), t.bindFramebuffer(n.FRAMEBUFFER, null)
	}

	function ce(A, T, $) {
		if (n.bindRenderbuffer(n.RENDERBUFFER, A), T.depthBuffer && !T.stencilBuffer) {
			let re = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
			if ($ || N(T)) {
				const se = T.depthTexture;
				se && se.isDepthTexture && (se.type === ns ? re = n.DEPTH_COMPONENT32F : se.type === Qo && (re = n.DEPTH_COMPONENT24));
				const ue = ie(T);
				N(T) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ue, re, T.width, T.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, ue, re, T.width, T.height)
			} else n.renderbufferStorage(n.RENDERBUFFER, re, T.width, T.height);
			n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, A)
		} else if (T.depthBuffer && T.stencilBuffer) {
			const re = ie(T);
			$ && N(T) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, re, n.DEPTH24_STENCIL8, T.width, T.height) : N(T) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, re, n.DEPTH24_STENCIL8, T.width, T.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, T.width, T.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, A)
		} else {
			const re = T.textures;
			for (let se = 0; se < re.length; se++) {
				const ue = re[se],
					Me = s.convert(ue.format, ue.colorSpace),
					Le = s.convert(ue.type),
					we = x(ue.internalFormat, Me, Le, ue.colorSpace),
					Te = ie(T);
				$ && N(T) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Te, we, T.width, T.height) : N(T) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Te, we, T.width, T.height) : n.renderbufferStorage(n.RENDERBUFFER, we, T.width, T.height)
			}
		}
		n.bindRenderbuffer(n.RENDERBUFFER, null)
	}

	function Ce(A, T) {
		if (T && T.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
		if (t.bindFramebuffer(n.FRAMEBUFFER, A), !(T.depthTexture && T.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
		(!i.get(T.depthTexture).__webglTexture || T.depthTexture.image.width !== T.width || T.depthTexture.image.height !== T.height) && (T.depthTexture.image.width = T.width, T.depthTexture.image.height = T.height, T.depthTexture.needsUpdate = !0), G(T.depthTexture, 0);
		const re = i.get(T.depthTexture).__webglTexture,
			se = ie(T);
		if (T.depthTexture.format === bl) N(T) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, re, 0, se) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, re, 0);
		else if (T.depthTexture.format === lu) N(T) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, re, 0, se) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, re, 0);
		else throw new Error("Unknown depthTexture format")
	}

	function Re(A) {
		const T = i.get(A),
			$ = A.isWebGLCubeRenderTarget === !0;
		if (A.depthTexture && !T.__autoAllocateDepthBuffer) {
			if ($) throw new Error("target.depthTexture not supported in Cube render targets");
			Ce(T.__webglFramebuffer, A)
		} else if ($) {
			T.__webglDepthbuffer = [];
			for (let re = 0; re < 6; re++) t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer[re]), T.__webglDepthbuffer[re] = n.createRenderbuffer(), ce(T.__webglDepthbuffer[re], A, !1)
		} else t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer), T.__webglDepthbuffer = n.createRenderbuffer(), ce(T.__webglDepthbuffer, A, !1);
		t.bindFramebuffer(n.FRAMEBUFFER, null)
	}

	function Y(A, T, $) {
		const re = i.get(A);
		T !== void 0 && pe(re.__webglFramebuffer, A, A.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), $ !== void 0 && Re(A)
	}

	function k(A) {
		const T = A.texture,
			$ = i.get(A),
			re = i.get(T);
		A.addEventListener("dispose", P);
		const se = A.textures,
			ue = A.isWebGLCubeRenderTarget === !0,
			Me = se.length > 1,
			Le = m(A) || a;
		if (Me || (re.__webglTexture === void 0 && (re.__webglTexture = n.createTexture()), re.__version = T.version, o.memory.textures++), ue) {
			$.__webglFramebuffer = [];
			for (let we = 0; we < 6; we++)
				if (a && T.mipmaps && T.mipmaps.length > 0) {
					$.__webglFramebuffer[we] = [];
					for (let Te = 0; Te < T.mipmaps.length; Te++) $.__webglFramebuffer[we][Te] = n.createFramebuffer()
				} else $.__webglFramebuffer[we] = n.createFramebuffer()
		} else {
			if (a && T.mipmaps && T.mipmaps.length > 0) {
				$.__webglFramebuffer = [];
				for (let we = 0; we < T.mipmaps.length; we++) $.__webglFramebuffer[we] = n.createFramebuffer()
			} else $.__webglFramebuffer = n.createFramebuffer();
			if (Me)
				if (r.drawBuffers)
					for (let we = 0, Te = se.length; we < Te; we++) {
						const je = i.get(se[we]);
						je.__webglTexture === void 0 && (je.__webglTexture = n.createTexture(), o.memory.textures++)
					} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
			if (a && A.samples > 0 && N(A) === !1) {
				$.__webglMultisampledFramebuffer = n.createFramebuffer(), $.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
				for (let we = 0; we < se.length; we++) {
					const Te = se[we];
					$.__webglColorRenderbuffer[we] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, $.__webglColorRenderbuffer[we]);
					const je = s.convert(Te.format, Te.colorSpace),
						M = s.convert(Te.type),
						W = x(Te.internalFormat, je, M, Te.colorSpace, A.isXRRenderTarget === !0),
						le = ie(A);
					n.renderbufferStorageMultisample(n.RENDERBUFFER, le, W, A.width, A.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + we, n.RENDERBUFFER, $.__webglColorRenderbuffer[we])
				}
				n.bindRenderbuffer(n.RENDERBUFFER, null), A.depthBuffer && ($.__webglDepthRenderbuffer = n.createRenderbuffer(), ce($.__webglDepthRenderbuffer, A, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null)
			}
		}
		if (ue) {
			t.bindTexture(n.TEXTURE_CUBE_MAP, re.__webglTexture), K(n.TEXTURE_CUBE_MAP, T, Le);
			for (let we = 0; we < 6; we++)
				if (a && T.mipmaps && T.mipmaps.length > 0)
					for (let Te = 0; Te < T.mipmaps.length; Te++) pe($.__webglFramebuffer[we][Te], A, T, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + we, Te);
				else pe($.__webglFramebuffer[we], A, T, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0);
			v(T, Le) && y(n.TEXTURE_CUBE_MAP), t.unbindTexture()
		} else if (Me) {
			for (let we = 0, Te = se.length; we < Te; we++) {
				const je = se[we],
					M = i.get(je);
				t.bindTexture(n.TEXTURE_2D, M.__webglTexture), K(n.TEXTURE_2D, je, Le), pe($.__webglFramebuffer, A, je, n.COLOR_ATTACHMENT0 + we, n.TEXTURE_2D, 0), v(je, Le) && y(n.TEXTURE_2D)
			}
			t.unbindTexture()
		} else {
			let we = n.TEXTURE_2D;
			if ((A.isWebGL3DRenderTarget || A.isWebGLArrayRenderTarget) && (a ? we = A.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(we, re.__webglTexture), K(we, T, Le), a && T.mipmaps && T.mipmaps.length > 0)
				for (let Te = 0; Te < T.mipmaps.length; Te++) pe($.__webglFramebuffer[Te], A, T, n.COLOR_ATTACHMENT0, we, Te);
			else pe($.__webglFramebuffer, A, T, n.COLOR_ATTACHMENT0, we, 0);
			v(T, Le) && y(we), t.unbindTexture()
		}
		A.depthBuffer && Re(A)
	}

	function O(A) {
		const T = m(A) || a,
			$ = A.textures;
		for (let re = 0, se = $.length; re < se; re++) {
			const ue = $[re];
			if (v(ue, T)) {
				const Me = A.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D,
					Le = i.get(ue).__webglTexture;
				t.bindTexture(Me, Le), y(Me), t.unbindTexture()
			}
		}
	}

	function q(A) {
		if (a && A.samples > 0 && N(A) === !1) {
			const T = A.textures,
				$ = A.width,
				re = A.height;
			let se = n.COLOR_BUFFER_BIT;
			const ue = [],
				Me = A.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
				Le = i.get(A),
				we = T.length > 1;
			if (we)
				for (let Te = 0; Te < T.length; Te++) t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Te, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Te, n.TEXTURE_2D, null, 0);
			t.bindFramebuffer(n.READ_FRAMEBUFFER, Le.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Le.__webglFramebuffer);
			for (let Te = 0; Te < T.length; Te++) {
				ue.push(n.COLOR_ATTACHMENT0 + Te), A.depthBuffer && ue.push(Me);
				const je = Le.__ignoreDepthValues !== void 0 ? Le.__ignoreDepthValues : !1;
				if (je === !1 && (A.depthBuffer && (se |= n.DEPTH_BUFFER_BIT), A.stencilBuffer && (se |= n.STENCIL_BUFFER_BIT)), we && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Le.__webglColorRenderbuffer[Te]), je === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Me]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Me])), we) {
					const M = i.get(T[Te]).__webglTexture;
					n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, M, 0)
				}
				n.blitFramebuffer(0, 0, $, re, 0, 0, $, re, se, n.NEAREST), c && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ue)
			}
			if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), we)
				for (let Te = 0; Te < T.length; Te++) {
					t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Te, n.RENDERBUFFER, Le.__webglColorRenderbuffer[Te]);
					const je = i.get(T[Te]).__webglTexture;
					t.bindFramebuffer(n.FRAMEBUFFER, Le.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Te, n.TEXTURE_2D, je, 0)
				}
			t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Le.__webglMultisampledFramebuffer)
		}
	}

	function ie(A) {
		return Math.min(r.maxSamples, A.samples)
	}

	function N(A) {
		const T = i.get(A);
		return a && A.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && T.__useRenderToTexture !== !1
	}

	function me(A) {
		const T = o.render.frame;
		h.get(A) !== T && (h.set(A, T), A.update())
	}

	function ve(A, T) {
		const $ = A.colorSpace,
			re = A.format,
			se = A.type;
		return A.isCompressedTexture === !0 || A.isVideoTexture === !0 || A.format === Lv || $ !== Jn && $ !== jo && (Lt.getTransfer($) === Qt ? a === !1 ? e.has("EXT_sRGB") === !0 && re === vr ? (A.format = Lv, A.minFilter = jn, A.generateMipmaps = !1) : T = DD.sRGBToLinear(T) : (re !== vr || se !== fa) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $)), T
	}

	function xe(A) {
		return typeof HTMLImageElement < "u" && A instanceof HTMLImageElement ? (u.width = A.naturalWidth || A.width, u.height = A.naturalHeight || A.height) : typeof VideoFrame < "u" && A instanceof VideoFrame ? (u.width = A.displayWidth, u.height = A.displayHeight) : (u.width = A.width, u.height = A.height), u
	}
	this.allocateTextureUnit = H, this.resetTextureUnits = z, this.setTexture2D = G, this.setTexture2DArray = R, this.setTexture3D = Q, this.setTextureCube = B, this.rebindTextures = Y, this.setupRenderTarget = k, this.updateRenderTargetMipmap = O, this.updateMultisampleRenderTarget = q, this.setupDepthRenderbuffer = Re, this.setupFrameBufferTexture = pe, this.useMultisampledRTT = N
}

function B$(n, e, t) {
	const i = t.isWebGL2;

	function r(s, o = jo) {
		let a;
		const l = Lt.getTransfer(o);
		if (s === fa) return n.UNSIGNED_BYTE;
		if (s === gD) return n.UNSIGNED_SHORT_4_4_4_4;
		if (s === _D) return n.UNSIGNED_SHORT_5_5_5_1;
		if (s === aV) return n.BYTE;
		if (s === lV) return n.SHORT;
		if (s === Cb) return n.UNSIGNED_SHORT;
		if (s === mD) return n.INT;
		if (s === Qo) return n.UNSIGNED_INT;
		if (s === ns) return n.FLOAT;
		if (s === au) return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
		if (s === cV) return n.ALPHA;
		if (s === vr) return n.RGBA;
		if (s === uV) return n.LUMINANCE;
		if (s === hV) return n.LUMINANCE_ALPHA;
		if (s === bl) return n.DEPTH_COMPONENT;
		if (s === lu) return n.DEPTH_STENCIL;
		if (s === Lv) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
		if (s === Lh) return n.RED;
		if (s === vD) return n.RED_INTEGER;
		if (s === bD) return n.RG;
		if (s === yD) return n.RG_INTEGER;
		if (s === xD) return n.RGBA_INTEGER;
		if (s === ag || s === lg || s === cg || s === ug)
			if (l === Qt)
				if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
					if (s === ag) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (s === lg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (s === cg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (s === ug) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
				} else return null;
		else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
			if (s === ag) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if (s === lg) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if (s === cg) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if (s === ug) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
		} else return null;
		if (s === o2 || s === a2 || s === l2 || s === c2)
			if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
				if (s === o2) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (s === a2) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (s === l2) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (s === c2) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
			} else return null;
		if (s === wD) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
		if (s === u2 || s === h2)
			if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
				if (s === u2) return l === Qt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
				if (s === h2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
			} else return null;
		if (s === d2 || s === f2 || s === p2 || s === m2 || s === g2 || s === _2 || s === v2 || s === b2 || s === y2 || s === x2 || s === w2 || s === E2 || s === S2 || s === T2)
			if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
				if (s === d2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (s === f2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (s === p2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (s === m2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (s === g2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (s === _2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (s === v2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (s === b2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (s === y2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (s === x2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (s === w2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (s === E2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (s === S2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (s === T2) return l === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
			} else return null;
		if (s === hg || s === M2 || s === C2)
			if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
				if (s === hg) return l === Qt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if (s === M2) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if (s === C2) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
			} else return null;
		if (s === dV || s === A2 || s === D2 || s === P2)
			if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
				if (s === hg) return a.COMPRESSED_RED_RGTC1_EXT;
				if (s === A2) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (s === D2) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (s === P2) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
			} else return null;
		return s === vl ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
	}
	return {
		convert: r
	}
}
class z$ extends Yn {
	constructor(e = []) {
		super(), this.isArrayCamera = !0, this.cameras = e
	}
}
class il extends ht {
	constructor() {
		super(), this.isGroup = !0, this.type = "Group"
	}
}
const V$ = {
	type: "move"
};
class Ng {
	constructor() {
		this._targetRay = null, this._grip = null, this._hand = null
	}
	getHandSpace() {
		return this._hand === null && (this._hand = new il, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
			pinching: !1
		}), this._hand
	}
	getTargetRaySpace() {
		return this._targetRay === null && (this._targetRay = new il, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new X, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new X), this._targetRay
	}
	getGripSpace() {
		return this._grip === null && (this._grip = new il, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new X, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new X), this._grip
	}
	dispatchEvent(e) {
		return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
	}
	connect(e) {
		if (e && e.hand) {
			const t = this._hand;
			if (t)
				for (const i of e.hand.values()) this._getHandJoint(t, i)
		}
		return this.dispatchEvent({
			type: "connected",
			data: e
		}), this
	}
	disconnect(e) {
		return this.dispatchEvent({
			type: "disconnected",
			data: e
		}), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
	}
	update(e, t, i) {
		let r = null,
			s = null,
			o = null;
		const a = this._targetRay,
			l = this._grip,
			c = this._hand;
		if (e && t.session.visibilityState !== "visible-blurred") {
			if (c && e.hand) {
				o = !0;
				for (const _ of e.hand.values()) {
					const g = t.getJointPose(_, i),
						m = this._getHandJoint(c, _);
					g !== null && (m.matrix.fromArray(g.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = g.radius), m.visible = g !== null
				}
				const u = c.joints["index-finger-tip"],
					h = c.joints["thumb-tip"],
					d = u.position.distanceTo(h.position),
					f = .02,
					p = .005;
				c.inputState.pinching && d > f + p ? (c.inputState.pinching = !1, this.dispatchEvent({
					type: "pinchend",
					handedness: e.handedness,
					target: this
				})) : !c.inputState.pinching && d <= f - p && (c.inputState.pinching = !0, this.dispatchEvent({
					type: "pinchstart",
					handedness: e.handedness,
					target: this
				}))
			} else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
			a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(V$)))
		}
		return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
	}
	_getHandJoint(e, t) {
		if (e.joints[t.jointName] === void 0) {
			const i = new il;
			i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
		}
		return e.joints[t.jointName]
	}
}
const H$ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
	G$ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class W$ {
	constructor() {
		this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
	}
	init(e, t, i) {
		if (this.texture === null) {
			const r = new Kn,
				s = e.properties.get(r);
			s.__webglTexture = t.texture, (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r
		}
	}
	render(e, t) {
		if (this.texture !== null) {
			if (this.mesh === null) {
				const i = t.cameras[0].viewport,
					r = new Dn({
						extensions: {
							fragDepth: !0
						},
						vertexShader: H$,
						fragmentShader: G$,
						uniforms: {
							depthColor: {
								value: this.texture
							},
							depthWidth: {
								value: i.z
							},
							depthHeight: {
								value: i.w
							}
						}
					});
				this.mesh = new an(new os(20, 20), r)
			}
			e.render(this.mesh, t)
		}
	}
	reset() {
		this.texture = null, this.mesh = null
	}
}
class j$ extends Ol {
	constructor(e, t) {
		super();
		const i = this;
		let r = null,
			s = 1,
			o = null,
			a = "local-floor",
			l = 1,
			c = null,
			u = null,
			h = null,
			d = null,
			f = null,
			p = null;
		const _ = new W$,
			g = t.getContextAttributes();
		let m = null,
			b = null;
		const v = [],
			y = [],
			x = new Oe;
		let S = null;
		const E = new Yn;
		E.layers.enable(1), E.viewport = new kt;
		const C = new Yn;
		C.layers.enable(2), C.viewport = new kt;
		const P = [E, C],
			w = new z$;
		w.layers.enable(1), w.layers.enable(2);
		let D = null,
			U = null;
		this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (K) {
			let ye = v[K];
			return ye === void 0 && (ye = new Ng, v[K] = ye), ye.getTargetRaySpace()
		}, this.getControllerGrip = function (K) {
			let ye = v[K];
			return ye === void 0 && (ye = new Ng, v[K] = ye), ye.getGripSpace()
		}, this.getHand = function (K) {
			let ye = v[K];
			return ye === void 0 && (ye = new Ng, v[K] = ye), ye.getHandSpace()
		};

		function j(K) {
			const ye = y.indexOf(K.inputSource);
			if (ye === -1) return;
			const Se = v[ye];
			Se !== void 0 && (Se.update(K.inputSource, K.frame, c || o), Se.dispatchEvent({
				type: K.type,
				data: K.inputSource
			}))
		}

		function z() {
			r.removeEventListener("select", j), r.removeEventListener("selectstart", j), r.removeEventListener("selectend", j), r.removeEventListener("squeeze", j), r.removeEventListener("squeezestart", j), r.removeEventListener("squeezeend", j), r.removeEventListener("end", z), r.removeEventListener("inputsourceschange", H);
			for (let K = 0; K < v.length; K++) {
				const ye = y[K];
				ye !== null && (y[K] = null, v[K].disconnect(ye))
			}
			D = null, U = null, _.reset(), e.setRenderTarget(m), f = null, d = null, h = null, r = null, b = null, ze.stop(), i.isPresenting = !1, e.setPixelRatio(S), e.setSize(x.width, x.height, !1), i.dispatchEvent({
				type: "sessionend"
			})
		}
		this.setFramebufferScaleFactor = function (K) {
			s = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
		}, this.setReferenceSpaceType = function (K) {
			a = K, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
		}, this.getReferenceSpace = function () {
			return c || o
		}, this.setReferenceSpace = function (K) {
			c = K
		}, this.getBaseLayer = function () {
			return d !== null ? d : f
		}, this.getBinding = function () {
			return h
		}, this.getFrame = function () {
			return p
		}, this.getSession = function () {
			return r
		}, this.setSession = async function (K) {
			if (r = K, r !== null) {
				if (m = e.getRenderTarget(), r.addEventListener("select", j), r.addEventListener("selectstart", j), r.addEventListener("selectend", j), r.addEventListener("squeeze", j), r.addEventListener("squeezestart", j), r.addEventListener("squeezeend", j), r.addEventListener("end", z), r.addEventListener("inputsourceschange", H), g.xrCompatible !== !0 && await t.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(x), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
					const ye = {
						antialias: r.renderState.layers === void 0 ? g.antialias : !0,
						alpha: !0,
						depth: g.depth,
						stencil: g.stencil,
						framebufferScaleFactor: s
					};
					f = new XRWebGLLayer(r, t, ye), r.updateRenderState({
						baseLayer: f
					}), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), b = new xa(f.framebufferWidth, f.framebufferHeight, {
						format: vr,
						type: fa,
						colorSpace: e.outputColorSpace,
						stencilBuffer: g.stencil
					})
				} else {
					let ye = null,
						Se = null,
						Z = null;
					g.depth && (Z = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ye = g.stencil ? lu : bl, Se = g.stencil ? vl : Qo);
					const pe = {
						colorFormat: t.RGBA8,
						depthFormat: Z,
						scaleFactor: s
					};
					h = new XRWebGLBinding(r, t), d = h.createProjectionLayer(pe), r.updateRenderState({
						layers: [d]
					}), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), b = new xa(d.textureWidth, d.textureHeight, {
						format: vr,
						type: fa,
						depthTexture: new Ob(d.textureWidth, d.textureHeight, Se, void 0, void 0, void 0, void 0, void 0, void 0, ye),
						stencilBuffer: g.stencil,
						colorSpace: e.outputColorSpace,
						samples: g.antialias ? 4 : 0
					});
					const ce = e.properties.get(b);
					ce.__ignoreDepthValues = d.ignoreDepthValues
				}
				b.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await r.requestReferenceSpace(a), ze.setContext(r), ze.start(), i.isPresenting = !0, i.dispatchEvent({
					type: "sessionstart"
				})
			}
		}, this.getEnvironmentBlendMode = function () {
			if (r !== null) return r.environmentBlendMode
		};

		function H(K) {
			for (let ye = 0; ye < K.removed.length; ye++) {
				const Se = K.removed[ye],
					Z = y.indexOf(Se);
				Z >= 0 && (y[Z] = null, v[Z].disconnect(Se))
			}
			for (let ye = 0; ye < K.added.length; ye++) {
				const Se = K.added[ye];
				let Z = y.indexOf(Se);
				if (Z === -1) {
					for (let ce = 0; ce < v.length; ce++)
						if (ce >= y.length) {
							y.push(Se), Z = ce;
							break
						} else if (y[ce] === null) {
						y[ce] = Se, Z = ce;
						break
					}
					if (Z === -1) break
				}
				const pe = v[Z];
				pe && pe.connect(Se)
			}
		}
		const F = new X,
			G = new X;

		function R(K, ye, Se) {
			F.setFromMatrixPosition(ye.matrixWorld), G.setFromMatrixPosition(Se.matrixWorld);
			const Z = F.distanceTo(G),
				pe = ye.projectionMatrix.elements,
				ce = Se.projectionMatrix.elements,
				Ce = pe[14] / (pe[10] - 1),
				Re = pe[14] / (pe[10] + 1),
				Y = (pe[9] + 1) / pe[5],
				k = (pe[9] - 1) / pe[5],
				O = (pe[8] - 1) / pe[0],
				q = (ce[8] + 1) / ce[0],
				ie = Ce * O,
				N = Ce * q,
				me = Z / (-O + q),
				ve = me * -O;
			ye.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(ve), K.translateZ(me), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert();
			const xe = Ce + me,
				A = Re + me,
				T = ie - ve,
				$ = N + (Z - ve),
				re = Y * Re / A * xe,
				se = k * Re / A * xe;
			K.projectionMatrix.makePerspective(T, $, re, se, xe, A), K.projectionMatrixInverse.copy(K.projectionMatrix).invert()
		}

		function Q(K, ye) {
			ye === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(ye.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert()
		}
		this.updateCamera = function (K) {
			if (r === null) return;
			_.texture !== null && (K.near = _.depthNear, K.far = _.depthFar), w.near = C.near = E.near = K.near, w.far = C.far = E.far = K.far, (D !== w.near || U !== w.far) && (r.updateRenderState({
				depthNear: w.near,
				depthFar: w.far
			}), D = w.near, U = w.far, E.near = D, E.far = U, C.near = D, C.far = U, E.updateProjectionMatrix(), C.updateProjectionMatrix(), K.updateProjectionMatrix());
			const ye = K.parent,
				Se = w.cameras;
			Q(w, ye);
			for (let Z = 0; Z < Se.length; Z++) Q(Se[Z], ye);
			Se.length === 2 ? R(w, E, C) : w.projectionMatrix.copy(E.projectionMatrix), B(K, w, ye)
		};

		function B(K, ye, Se) {
			Se === null ? K.matrix.copy(ye.matrixWorld) : (K.matrix.copy(Se.matrixWorld), K.matrix.invert(), K.matrix.multiply(ye.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(!0), K.projectionMatrix.copy(ye.projectionMatrix), K.projectionMatrixInverse.copy(ye.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = uu * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1)
		}
		this.getCamera = function () {
			return w
		}, this.getFoveation = function () {
			if (!(d === null && f === null)) return l
		}, this.setFoveation = function (K) {
			l = K, d !== null && (d.fixedFoveation = K), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = K)
		}, this.hasDepthSensing = function () {
			return _.texture !== null
		};
		let ge = null;

		function Ae(K, ye) {
			if (u = ye.getViewerPose(c || o), p = ye, u !== null) {
				const Se = u.views;
				f !== null && (e.setRenderTargetFramebuffer(b, f.framebuffer), e.setRenderTarget(b));
				let Z = !1;
				Se.length !== w.cameras.length && (w.cameras.length = 0, Z = !0);
				for (let ce = 0; ce < Se.length; ce++) {
					const Ce = Se[ce];
					let Re = null;
					if (f !== null) Re = f.getViewport(Ce);
					else {
						const k = h.getViewSubImage(d, Ce);
						Re = k.viewport, ce === 0 && (e.setRenderTargetTextures(b, k.colorTexture, d.ignoreDepthValues ? void 0 : k.depthStencilTexture), e.setRenderTarget(b))
					}
					let Y = P[ce];
					Y === void 0 && (Y = new Yn, Y.layers.enable(ce), Y.viewport = new kt, P[ce] = Y), Y.matrix.fromArray(Ce.transform.matrix), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.projectionMatrix.fromArray(Ce.projectionMatrix), Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert(), Y.viewport.set(Re.x, Re.y, Re.width, Re.height), ce === 0 && (w.matrix.copy(Y.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), Z === !0 && w.cameras.push(Y)
				}
				const pe = r.enabledFeatures;
				if (pe && pe.includes("depth-sensing")) {
					const ce = h.getDepthInformation(Se[0]);
					ce && ce.isValid && ce.texture && _.init(e, ce, r.renderState)
				}
			}
			for (let Se = 0; Se < v.length; Se++) {
				const Z = y[Se],
					pe = v[Se];
				Z !== null && pe !== void 0 && pe.update(Z, ye, c || o)
			}
			_.render(e, w), ge && ge(K, ye), ye.detectedPlanes && i.dispatchEvent({
				type: "planesdetected",
				data: ye
			}), p = null
		}
		const ze = new ND;
		ze.setAnimationLoop(Ae), this.setAnimationLoop = function (K) {
			ge = K
		}, this.dispose = function () {}
	}
}
const Ga = new Er,
	$$ = new pt;

function q$(n, e) {
	function t(g, m) {
		g.matrixAutoUpdate === !0 && g.updateMatrix(), m.value.copy(g.matrix)
	}

	function i(g, m) {
		m.color.getRGB(g.fogColor.value, OD(n)), m.isFog ? (g.fogNear.value = m.near, g.fogFar.value = m.far) : m.isFogExp2 && (g.fogDensity.value = m.density)
	}

	function r(g, m, b, v, y) {
		m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(g, m) : m.isMeshToonMaterial ? (s(g, m), h(g, m)) : m.isMeshPhongMaterial ? (s(g, m), u(g, m)) : m.isMeshStandardMaterial ? (s(g, m), d(g, m), m.isMeshPhysicalMaterial && f(g, m, y)) : m.isMeshMatcapMaterial ? (s(g, m), p(g, m)) : m.isMeshDepthMaterial ? s(g, m) : m.isMeshDistanceMaterial ? (s(g, m), _(g, m)) : m.isMeshNormalMaterial ? s(g, m) : m.isLineBasicMaterial ? (o(g, m), m.isLineDashedMaterial && a(g, m)) : m.isPointsMaterial ? l(g, m, b, v) : m.isSpriteMaterial ? c(g, m) : m.isShadowMaterial ? (g.color.value.copy(m.color), g.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1)
	}

	function s(g, m) {
		g.opacity.value = m.opacity, m.color && g.diffuse.value.copy(m.color), m.emissive && g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.bumpMap && (g.bumpMap.value = m.bumpMap, t(m.bumpMap, g.bumpMapTransform), g.bumpScale.value = m.bumpScale, m.side === ji && (g.bumpScale.value *= -1)), m.normalMap && (g.normalMap.value = m.normalMap, t(m.normalMap, g.normalMapTransform), g.normalScale.value.copy(m.normalScale), m.side === ji && g.normalScale.value.negate()), m.displacementMap && (g.displacementMap.value = m.displacementMap, t(m.displacementMap, g.displacementMapTransform), g.displacementScale.value = m.displacementScale, g.displacementBias.value = m.displacementBias), m.emissiveMap && (g.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, g.emissiveMapTransform)), m.specularMap && (g.specularMap.value = m.specularMap, t(m.specularMap, g.specularMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
		const b = e.get(m),
			v = b.envMap,
			y = b.envMapRotation;
		if (v && (g.envMap.value = v, Ga.copy(y), Ga.x *= -1, Ga.y *= -1, Ga.z *= -1, v.isCubeTexture && v.isRenderTargetTexture === !1 && (Ga.y *= -1, Ga.z *= -1), g.envMapRotation.value.setFromMatrix4($$.makeRotationFromEuler(Ga)), g.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = m.reflectivity, g.ior.value = m.ior, g.refractionRatio.value = m.refractionRatio), m.lightMap) {
			g.lightMap.value = m.lightMap;
			const x = n._useLegacyLights === !0 ? Math.PI : 1;
			g.lightMapIntensity.value = m.lightMapIntensity * x, t(m.lightMap, g.lightMapTransform)
		}
		m.aoMap && (g.aoMap.value = m.aoMap, g.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, g.aoMapTransform))
	}

	function o(g, m) {
		g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, m.map && (g.map.value = m.map, t(m.map, g.mapTransform))
	}

	function a(g, m) {
		g.dashSize.value = m.dashSize, g.totalSize.value = m.dashSize + m.gapSize, g.scale.value = m.scale
	}

	function l(g, m, b, v) {
		g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.size.value = m.size * b, g.scale.value = v * .5, m.map && (g.map.value = m.map, t(m.map, g.uvTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
	}

	function c(g, m) {
		g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.rotation.value = m.rotation, m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
	}

	function u(g, m) {
		g.specular.value.copy(m.specular), g.shininess.value = Math.max(m.shininess, 1e-4)
	}

	function h(g, m) {
		m.gradientMap && (g.gradientMap.value = m.gradientMap)
	}

	function d(g, m) {
		g.metalness.value = m.metalness, m.metalnessMap && (g.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, g.metalnessMapTransform)), g.roughness.value = m.roughness, m.roughnessMap && (g.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, g.roughnessMapTransform)), e.get(m).envMap && (g.envMapIntensity.value = m.envMapIntensity)
	}

	function f(g, m, b) {
		g.ior.value = m.ior, m.sheen > 0 && (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), g.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (g.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, g.sheenColorMapTransform)), m.sheenRoughnessMap && (g.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))), m.clearcoat > 0 && (g.clearcoat.value = m.clearcoat, g.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (g.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, g.clearcoatMapTransform)), m.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (g.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === ji && g.clearcoatNormalScale.value.negate())), m.iridescence > 0 && (g.iridescence.value = m.iridescence, g.iridescenceIOR.value = m.iridescenceIOR, g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (g.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, g.iridescenceMapTransform)), m.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), m.transmission > 0 && (g.transmission.value = m.transmission, g.transmissionSamplerMap.value = b.texture, g.transmissionSamplerSize.value.set(b.width, b.height), m.transmissionMap && (g.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, g.transmissionMapTransform)), g.thickness.value = m.thickness, m.thicknessMap && (g.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = m.attenuationDistance, g.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (g.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (g.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = m.specularIntensity, g.specularColor.value.copy(m.specularColor), m.specularColorMap && (g.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, g.specularColorMapTransform)), m.specularIntensityMap && (g.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, g.specularIntensityMapTransform))
	}

	function p(g, m) {
		m.matcap && (g.matcap.value = m.matcap)
	}

	function _(g, m) {
		const b = e.get(m).light;
		g.referencePosition.value.setFromMatrixPosition(b.matrixWorld), g.nearDistance.value = b.shadow.camera.near, g.farDistance.value = b.shadow.camera.far
	}
	return {
		refreshFogUniforms: i,
		refreshMaterialUniforms: r
	}
}

function X$(n, e, t, i) {
	let r = {},
		s = {},
		o = [];
	const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

	function l(b, v) {
		const y = v.program;
		i.uniformBlockBinding(b, y)
	}

	function c(b, v) {
		let y = r[b.id];
		y === void 0 && (p(b), y = u(b), r[b.id] = y, b.addEventListener("dispose", g));
		const x = v.program;
		i.updateUBOMapping(b, x);
		const S = e.render.frame;
		s[b.id] !== S && (d(b), s[b.id] = S)
	}

	function u(b) {
		const v = h();
		b.__bindingPointIndex = v;
		const y = n.createBuffer(),
			x = b.__size,
			S = b.usage;
		return n.bindBuffer(n.UNIFORM_BUFFER, y), n.bufferData(n.UNIFORM_BUFFER, x, S), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, v, y), y
	}

	function h() {
		for (let b = 0; b < a; b++)
			if (o.indexOf(b) === -1) return o.push(b), b;
		return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
	}

	function d(b) {
		const v = r[b.id],
			y = b.uniforms,
			x = b.__cache;
		n.bindBuffer(n.UNIFORM_BUFFER, v);
		for (let S = 0, E = y.length; S < E; S++) {
			const C = Array.isArray(y[S]) ? y[S] : [y[S]];
			for (let P = 0, w = C.length; P < w; P++) {
				const D = C[P];
				if (f(D, S, P, x) === !0) {
					const U = D.__offset,
						j = Array.isArray(D.value) ? D.value : [D.value];
					let z = 0;
					for (let H = 0; H < j.length; H++) {
						const F = j[H],
							G = _(F);
						typeof F == "number" || typeof F == "boolean" ? (D.__data[0] = F, n.bufferSubData(n.UNIFORM_BUFFER, U + z, D.__data)) : F.isMatrix3 ? (D.__data[0] = F.elements[0], D.__data[1] = F.elements[1], D.__data[2] = F.elements[2], D.__data[3] = 0, D.__data[4] = F.elements[3], D.__data[5] = F.elements[4], D.__data[6] = F.elements[5], D.__data[7] = 0, D.__data[8] = F.elements[6], D.__data[9] = F.elements[7], D.__data[10] = F.elements[8], D.__data[11] = 0) : (F.toArray(D.__data, z), z += G.storage / Float32Array.BYTES_PER_ELEMENT)
					}
					n.bufferSubData(n.UNIFORM_BUFFER, U, D.__data)
				}
			}
		}
		n.bindBuffer(n.UNIFORM_BUFFER, null)
	}

	function f(b, v, y, x) {
		const S = b.value,
			E = v + "_" + y;
		if (x[E] === void 0) return typeof S == "number" || typeof S == "boolean" ? x[E] = S : x[E] = S.clone(), !0; {
			const C = x[E];
			if (typeof S == "number" || typeof S == "boolean") {
				if (C !== S) return x[E] = S, !0
			} else if (C.equals(S) === !1) return C.copy(S), !0
		}
		return !1
	}

	function p(b) {
		const v = b.uniforms;
		let y = 0;
		const x = 16;
		for (let E = 0, C = v.length; E < C; E++) {
			const P = Array.isArray(v[E]) ? v[E] : [v[E]];
			for (let w = 0, D = P.length; w < D; w++) {
				const U = P[w],
					j = Array.isArray(U.value) ? U.value : [U.value];
				for (let z = 0, H = j.length; z < H; z++) {
					const F = j[z],
						G = _(F),
						R = y % x;
					R !== 0 && x - R < G.boundary && (y += x - R), U.__data = new Float32Array(G.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = y, y += G.storage
				}
			}
		}
		const S = y % x;
		return S > 0 && (y += x - S), b.__size = y, b.__cache = {}, this
	}

	function _(b) {
		const v = {
			boundary: 0,
			storage: 0
		};
		return typeof b == "number" || typeof b == "boolean" ? (v.boundary = 4, v.storage = 4) : b.isVector2 ? (v.boundary = 8, v.storage = 8) : b.isVector3 || b.isColor ? (v.boundary = 16, v.storage = 12) : b.isVector4 ? (v.boundary = 16, v.storage = 16) : b.isMatrix3 ? (v.boundary = 48, v.storage = 48) : b.isMatrix4 ? (v.boundary = 64, v.storage = 64) : b.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", b), v
	}

	function g(b) {
		const v = b.target;
		v.removeEventListener("dispose", g);
		const y = o.indexOf(v.__bindingPointIndex);
		o.splice(y, 1), n.deleteBuffer(r[v.id]), delete r[v.id], delete s[v.id]
	}

	function m() {
		for (const b in r) n.deleteBuffer(r[b]);
		o = [], r = {}, s = {}
	}
	return {
		bind: l,
		update: c,
		dispose: m
	}
}
class Fb {
	constructor(e = {}) {
		const {
			canvas: t = zV(),
			context: i = null,
			depth: r = !0,
			stencil: s = !0,
			alpha: o = !1,
			antialias: a = !1,
			premultipliedAlpha: l = !0,
			preserveDrawingBuffer: c = !1,
			powerPreference: u = "default",
			failIfMajorPerformanceCaveat: h = !1
		} = e;
		this.isWebGLRenderer = !0;
		let d;
		i !== null ? d = i.getContextAttributes().alpha : d = o;
		const f = new Uint32Array(4),
			p = new Int32Array(4);
		let _ = null,
			g = null;
		const m = [],
			b = [];
		this.domElement = t, this.debug = {
			checkShaderErrors: !0,
			onShaderError: null
		}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = qn, this._useLegacyLights = !1, this.toneMapping = da, this.toneMappingExposure = 1;
		const v = this;
		let y = !1,
			x = 0,
			S = 0,
			E = null,
			C = -1,
			P = null;
		const w = new kt,
			D = new kt;
		let U = null;
		const j = new et(0);
		let z = 0,
			H = t.width,
			F = t.height,
			G = 1,
			R = null,
			Q = null;
		const B = new kt(0, 0, H, F),
			ge = new kt(0, 0, H, F);
		let Ae = !1;
		const ze = new kb;
		let K = !1,
			ye = !1,
			Se = null;
		const Z = new pt,
			pe = new Oe,
			ce = new X,
			Ce = {
				background: null,
				fog: null,
				environment: null,
				overrideMaterial: null,
				isScene: !0
			};

		function Re() {
			return E === null ? G : 1
		}
		let Y = i;

		function k(L, ne) {
			for (let de = 0; de < L.length; de++) {
				const he = L[de],
					ae = t.getContext(he, ne);
				if (ae !== null) return ae
			}
			return null
		}
		try {
			const L = {
				alpha: !0,
				depth: r,
				stencil: s,
				antialias: a,
				premultipliedAlpha: l,
				preserveDrawingBuffer: c,
				powerPreference: u,
				failIfMajorPerformanceCaveat: h
			};
			if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Mb}`), t.addEventListener("webglcontextlost", De, !1), t.addEventListener("webglcontextrestored", V, !1), t.addEventListener("webglcontextcreationerror", be, !1), Y === null) {
				const ne = ["webgl2", "webgl", "experimental-webgl"];
				if (v.isWebGL1Renderer === !0 && ne.shift(), Y = k(ne, L), Y === null) throw k(ne) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
			}
			typeof WebGLRenderingContext < "u" && Y instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), Y.getShaderPrecisionFormat === void 0 && (Y.getShaderPrecisionFormat = function () {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		} catch (L) {
			throw console.error("THREE.WebGLRenderer: " + L.message), L
		}
		let O, q, ie, N, me, ve, xe, A, T, $, re, se, ue, Me, Le, we, Te, je, M, W, le, J, oe, _e;

		function I() {
			O = new tj(Y), q = new YW(Y, O, e), O.init(q), J = new B$(Y, O, q), ie = new N$(Y, O, q), N = new rj(Y), me = new S$, ve = new U$(Y, O, ie, me, q, J, N), xe = new ZW(v), A = new ej(v), T = new uH(Y, q), oe = new qW(Y, O, T, q), $ = new nj(Y, T, N, oe), re = new lj(Y, $, T, N), M = new aj(Y, q, ve), we = new KW(me), se = new E$(v, xe, A, O, q, oe, we), ue = new q$(v, me), Me = new M$, Le = new L$(O, q), je = new $W(v, xe, A, ie, re, d, l), Te = new F$(v, re, q), _e = new X$(Y, N, q, ie), W = new XW(Y, O, N, q), le = new ij(Y, O, N, q), N.programs = se.programs, v.capabilities = q, v.extensions = O, v.properties = me, v.renderLists = Me, v.shadowMap = Te, v.state = ie, v.info = N
		}
		I();
		const ee = new j$(v, Y);
		this.xr = ee, this.getContext = function () {
			return Y
		}, this.getContextAttributes = function () {
			return Y.getContextAttributes()
		}, this.forceContextLoss = function () {
			const L = O.get("WEBGL_lose_context");
			L && L.loseContext()
		}, this.forceContextRestore = function () {
			const L = O.get("WEBGL_lose_context");
			L && L.restoreContext()
		}, this.getPixelRatio = function () {
			return G
		}, this.setPixelRatio = function (L) {
			L !== void 0 && (G = L, this.setSize(H, F, !1))
		}, this.getSize = function (L) {
			return L.set(H, F)
		}, this.setSize = function (L, ne, de = !0) {
			if (ee.isPresenting) {
				console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
				return
			}
			H = L, F = ne, t.width = Math.floor(L * G), t.height = Math.floor(ne * G), de === !0 && (t.style.width = L + "px", t.style.height = ne + "px"), this.setViewport(0, 0, L, ne)
		}, this.getDrawingBufferSize = function (L) {
			return L.set(H * G, F * G).floor()
		}, this.setDrawingBufferSize = function (L, ne, de) {
			H = L, F = ne, G = de, t.width = Math.floor(L * de), t.height = Math.floor(ne * de), this.setViewport(0, 0, L, ne)
		}, this.getCurrentViewport = function (L) {
			return L.copy(w)
		}, this.getViewport = function (L) {
			return L.copy(B)
		}, this.setViewport = function (L, ne, de, he) {
			L.isVector4 ? B.set(L.x, L.y, L.z, L.w) : B.set(L, ne, de, he), ie.viewport(w.copy(B).multiplyScalar(G).round())
		}, this.getScissor = function (L) {
			return L.copy(ge)
		}, this.setScissor = function (L, ne, de, he) {
			L.isVector4 ? ge.set(L.x, L.y, L.z, L.w) : ge.set(L, ne, de, he), ie.scissor(D.copy(ge).multiplyScalar(G).round())
		}, this.getScissorTest = function () {
			return Ae
		}, this.setScissorTest = function (L) {
			ie.setScissorTest(Ae = L)
		}, this.setOpaqueSort = function (L) {
			R = L
		}, this.setTransparentSort = function (L) {
			Q = L
		}, this.getClearColor = function (L) {
			return L.copy(je.getClearColor())
		}, this.setClearColor = function () {
			je.setClearColor.apply(je, arguments)
		}, this.getClearAlpha = function () {
			return je.getClearAlpha()
		}, this.setClearAlpha = function () {
			je.setClearAlpha.apply(je, arguments)
		}, this.clear = function (L = !0, ne = !0, de = !0) {
			let he = 0;
			if (L) {
				let ae = !1;
				if (E !== null) {
					const Ne = E.texture.format;
					ae = Ne === xD || Ne === yD || Ne === vD
				}
				if (ae) {
					const Ne = E.texture.type,
						qe = Ne === fa || Ne === Qo || Ne === Cb || Ne === vl || Ne === gD || Ne === _D,
						nt = je.getClearColor(),
						Xe = je.getClearAlpha(),
						Qe = nt.r,
						it = nt.g,
						dt = nt.b;
					qe ? (f[0] = Qe, f[1] = it, f[2] = dt, f[3] = Xe, Y.clearBufferuiv(Y.COLOR, 0, f)) : (p[0] = Qe, p[1] = it, p[2] = dt, p[3] = Xe, Y.clearBufferiv(Y.COLOR, 0, p))
				} else he |= Y.COLOR_BUFFER_BIT
			}
			ne && (he |= Y.DEPTH_BUFFER_BIT), de && (he |= Y.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Y.clear(he)
		}, this.clearColor = function () {
			this.clear(!0, !1, !1)
		}, this.clearDepth = function () {
			this.clear(!1, !0, !1)
		}, this.clearStencil = function () {
			this.clear(!1, !1, !0)
		}, this.dispose = function () {
			t.removeEventListener("webglcontextlost", De, !1), t.removeEventListener("webglcontextrestored", V, !1), t.removeEventListener("webglcontextcreationerror", be, !1), Me.dispose(), Le.dispose(), me.dispose(), xe.dispose(), A.dispose(), re.dispose(), oe.dispose(), _e.dispose(), se.dispose(), ee.dispose(), ee.removeEventListener("sessionstart", Ve), ee.removeEventListener("sessionend", $e), Se && (Se.dispose(), Se = null), Pe.stop()
		};

		function De(L) {
			L.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0
		}

		function V() {
			console.log("THREE.WebGLRenderer: Context Restored."), y = !1;
			const L = N.autoReset,
				ne = Te.enabled,
				de = Te.autoUpdate,
				he = Te.needsUpdate,
				ae = Te.type;
			I(), N.autoReset = L, Te.enabled = ne, Te.autoUpdate = de, Te.needsUpdate = he, Te.type = ae
		}

		function be(L) {
			console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", L.statusMessage)
		}

		function te(L) {
			const ne = L.target;
			ne.removeEventListener("dispose", te), Ee(ne)
		}

		function Ee(L) {
			Ie(L), me.remove(L)
		}

		function Ie(L) {
			const ne = me.get(L).programs;
			ne !== void 0 && (ne.forEach(function (de) {
				se.releaseProgram(de)
			}), L.isShaderMaterial && se.releaseShaderCache(L))
		}
		this.renderBufferDirect = function (L, ne, de, he, ae, Ne) {
			ne === null && (ne = Ce);
			const qe = ae.isMesh && ae.matrixWorld.determinant() < 0,
				nt = Xt(L, ne, de, he, ae);
			ie.setMaterial(he, qe);
			let Xe = de.index,
				Qe = 1;
			if (he.wireframe === !0) {
				if (Xe = $.getWireframeAttribute(de), Xe === void 0) return;
				Qe = 2
			}
			const it = de.drawRange,
				dt = de.attributes.position;
			let tn = it.start * Qe,
				Ln = (it.start + it.count) * Qe;
			Ne !== null && (tn = Math.max(tn, Ne.start * Qe), Ln = Math.min(Ln, (Ne.start + Ne.count) * Qe)), Xe !== null ? (tn = Math.max(tn, 0), Ln = Math.min(Ln, Xe.count)) : dt != null && (tn = Math.max(tn, 0), Ln = Math.min(Ln, dt.count));
			const Nt = Ln - tn;
			if (Nt < 0 || Nt === 1 / 0) return;
			oe.setup(ae, he, nt, de, Xe);
			let vi, Ht = W;
			if (Xe !== null && (vi = T.get(Xe), Ht = le, Ht.setIndex(vi)), ae.isMesh) he.wireframe === !0 ? (ie.setLineWidth(he.wireframeLinewidth * Re()), Ht.setMode(Y.LINES)) : Ht.setMode(Y.TRIANGLES);
			else if (ae.isLine) {
				let ct = he.linewidth;
				ct === void 0 && (ct = 1), ie.setLineWidth(ct * Re()), ae.isLineSegments ? Ht.setMode(Y.LINES) : ae.isLineLoop ? Ht.setMode(Y.LINE_LOOP) : Ht.setMode(Y.LINE_STRIP)
			} else ae.isPoints ? Ht.setMode(Y.POINTS) : ae.isSprite && Ht.setMode(Y.TRIANGLES);
			if (ae.isBatchedMesh) Ht.renderMultiDraw(ae._multiDrawStarts, ae._multiDrawCounts, ae._multiDrawCount);
			else if (ae.isInstancedMesh) Ht.renderInstances(tn, Nt, ae.count);
			else if (de.isInstancedBufferGeometry) {
				const ct = de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0,
					a0 = Math.min(de.instanceCount, ct);
				Ht.renderInstances(tn, Nt, a0)
			} else Ht.render(tn, Nt)
		};

		function st(L, ne, de) {
			L.transparent === !0 && L.side === _r && L.forceSinglePass === !1 ? (L.side = ji, L.needsUpdate = !0, qt(L, ne, de), L.side = fo, L.needsUpdate = !0, qt(L, ne, de), L.side = _r) : qt(L, ne, de)
		}
		this.compile = function (L, ne, de = null) {
			de === null && (de = L), g = Le.get(de), g.init(), b.push(g), de.traverseVisible(function (ae) {
				ae.isLight && ae.layers.test(ne.layers) && (g.pushLight(ae), ae.castShadow && g.pushShadow(ae))
			}), L !== de && L.traverseVisible(function (ae) {
				ae.isLight && ae.layers.test(ne.layers) && (g.pushLight(ae), ae.castShadow && g.pushShadow(ae))
			}), g.setupLights(v._useLegacyLights);
			const he = new Set;
			return L.traverse(function (ae) {
				const Ne = ae.material;
				if (Ne)
					if (Array.isArray(Ne))
						for (let qe = 0; qe < Ne.length; qe++) {
							const nt = Ne[qe];
							st(nt, de, ae), he.add(nt)
						} else st(Ne, de, ae), he.add(Ne)
			}), b.pop(), g = null, he
		}, this.compileAsync = function (L, ne, de = null) {
			const he = this.compile(L, ne, de);
			return new Promise(ae => {
				function Ne() {
					if (he.forEach(function (qe) {
							me.get(qe).currentProgram.isReady() && he.delete(qe)
						}), he.size === 0) {
						ae(L);
						return
					}
					setTimeout(Ne, 10)
				}
				O.get("KHR_parallel_shader_compile") !== null ? Ne() : setTimeout(Ne, 10)
			})
		};
		let Et = null;

		function He(L) {
			Et && Et(L)
		}

		function Ve() {
			Pe.stop()
		}

		function $e() {
			Pe.start()
		}
		const Pe = new ND;
		Pe.setAnimationLoop(He), typeof self < "u" && Pe.setContext(self), this.setAnimationLoop = function (L) {
			Et = L, ee.setAnimationLoop(L), L === null ? Pe.stop() : Pe.start()
		}, ee.addEventListener("sessionstart", Ve), ee.addEventListener("sessionend", $e), this.render = function (L, ne) {
			if (ne !== void 0 && ne.isCamera !== !0) {
				console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
				return
			}
			if (y === !0) return;
			L.matrixWorldAutoUpdate === !0 && L.updateMatrixWorld(), ne.parent === null && ne.matrixWorldAutoUpdate === !0 && ne.updateMatrixWorld(), ee.enabled === !0 && ee.isPresenting === !0 && (ee.cameraAutoUpdate === !0 && ee.updateCamera(ne), ne = ee.getCamera()), L.isScene === !0 && L.onBeforeRender(v, L, ne, E), g = Le.get(L, b.length), g.init(), b.push(g), Z.multiplyMatrices(ne.projectionMatrix, ne.matrixWorldInverse), ze.setFromProjectionMatrix(Z), ye = this.localClippingEnabled, K = we.init(this.clippingPlanes, ye), _ = Me.get(L, m.length), _.init(), m.push(_), Ze(L, ne, 0, v.sortObjects), _.finish(), v.sortObjects === !0 && _.sort(R, Q), this.info.render.frame++, K === !0 && we.beginShadows();
			const de = g.state.shadowsArray;
			if (Te.render(de, L, ne), K === !0 && we.endShadows(), this.info.autoReset === !0 && this.info.reset(), (ee.enabled === !1 || ee.isPresenting === !1 || ee.hasDepthSensing() === !1) && je.render(_, L), g.setupLights(v._useLegacyLights), ne.isArrayCamera) {
				const he = ne.cameras;
				for (let ae = 0, Ne = he.length; ae < Ne; ae++) {
					const qe = he[ae];
					Je(_, L, qe, qe.viewport)
				}
			} else Je(_, L, ne);
			E !== null && (ve.updateMultisampleRenderTarget(E), ve.updateRenderTargetMipmap(E)), L.isScene === !0 && L.onAfterRender(v, L, ne), oe.resetDefaultState(), C = -1, P = null, b.pop(), b.length > 0 ? g = b[b.length - 1] : g = null, m.pop(), m.length > 0 ? _ = m[m.length - 1] : _ = null
		};

		function Ze(L, ne, de, he) {
			if (L.visible === !1) return;
			if (L.layers.test(ne.layers)) {
				if (L.isGroup) de = L.renderOrder;
				else if (L.isLOD) L.autoUpdate === !0 && L.update(ne);
				else if (L.isLight) g.pushLight(L), L.castShadow && g.pushShadow(L);
				else if (L.isSprite) {
					if (!L.frustumCulled || ze.intersectsSprite(L)) {
						he && ce.setFromMatrixPosition(L.matrixWorld).applyMatrix4(Z);
						const qe = re.update(L),
							nt = L.material;
						nt.visible && _.push(L, qe, nt, de, ce.z, null)
					}
				} else if ((L.isMesh || L.isLine || L.isPoints) && (!L.frustumCulled || ze.intersectsObject(L))) {
					const qe = re.update(L),
						nt = L.material;
					if (he && (L.boundingSphere !== void 0 ? (L.boundingSphere === null && L.computeBoundingSphere(), ce.copy(L.boundingSphere.center)) : (qe.boundingSphere === null && qe.computeBoundingSphere(), ce.copy(qe.boundingSphere.center)), ce.applyMatrix4(L.matrixWorld).applyMatrix4(Z)), Array.isArray(nt)) {
						const Xe = qe.groups;
						for (let Qe = 0, it = Xe.length; Qe < it; Qe++) {
							const dt = Xe[Qe],
								tn = nt[dt.materialIndex];
							tn && tn.visible && _.push(L, qe, tn, de, ce.z, dt)
						}
					} else nt.visible && _.push(L, qe, nt, de, ce.z, null)
				}
			}
			const Ne = L.children;
			for (let qe = 0, nt = Ne.length; qe < nt; qe++) Ze(Ne[qe], ne, de, he)
		}

		function Je(L, ne, de, he) {
			const ae = L.opaque,
				Ne = L.transmissive,
				qe = L.transparent;
			g.setupLightsView(de), K === !0 && we.setGlobalState(v.clippingPlanes, de), Ne.length > 0 && ot(ae, Ne, ne, de), he && ie.viewport(w.copy(he)), ae.length > 0 && hn(ae, ne, de), Ne.length > 0 && hn(Ne, ne, de), qe.length > 0 && hn(qe, ne, de), ie.buffers.depth.setTest(!0), ie.buffers.depth.setMask(!0), ie.buffers.color.setMask(!0), ie.setPolygonOffset(!1)
		}

		function ot(L, ne, de, he) {
			if ((de.isScene === !0 ? de.overrideMaterial : null) !== null) return;
			const Ne = q.isWebGL2;
			Se === null && (Se = new xa(1, 1, {
				generateMipmaps: !0,
				type: O.has("EXT_color_buffer_half_float") ? au : fa,
				minFilter: Qs,
				samples: Ne ? 4 : 0
			})), v.getDrawingBufferSize(pe), Ne ? Se.setSize(pe.x, pe.y) : Se.setSize(lm(pe.x), lm(pe.y));
			const qe = v.getRenderTarget();
			v.setRenderTarget(Se), v.getClearColor(j), z = v.getClearAlpha(), z < 1 && v.setClearColor(16777215, .5), v.clear();
			const nt = v.toneMapping;
			v.toneMapping = da, hn(L, de, he), ve.updateMultisampleRenderTarget(Se), ve.updateRenderTargetMipmap(Se);
			let Xe = !1;
			for (let Qe = 0, it = ne.length; Qe < it; Qe++) {
				const dt = ne[Qe],
					tn = dt.object,
					Ln = dt.geometry,
					Nt = dt.material,
					vi = dt.group;
				if (Nt.side === _r && tn.layers.test(he.layers)) {
					const Ht = Nt.side;
					Nt.side = ji, Nt.needsUpdate = !0, vt(tn, de, he, Ln, Nt, vi), Nt.side = Ht, Nt.needsUpdate = !0, Xe = !0
				}
			}
			Xe === !0 && (ve.updateMultisampleRenderTarget(Se), ve.updateRenderTargetMipmap(Se)), v.setRenderTarget(qe), v.setClearColor(j, z), v.toneMapping = nt
		}

		function hn(L, ne, de) {
			const he = ne.isScene === !0 ? ne.overrideMaterial : null;
			for (let ae = 0, Ne = L.length; ae < Ne; ae++) {
				const qe = L[ae],
					nt = qe.object,
					Xe = qe.geometry,
					Qe = he === null ? qe.material : he,
					it = qe.group;
				nt.layers.test(de.layers) && vt(nt, ne, de, Xe, Qe, it)
			}
		}

		function vt(L, ne, de, he, ae, Ne) {
			L.onBeforeRender(v, ne, de, he, ae, Ne), L.modelViewMatrix.multiplyMatrices(de.matrixWorldInverse, L.matrixWorld), L.normalMatrix.getNormalMatrix(L.modelViewMatrix), ae.onBeforeRender(v, ne, de, he, L, Ne), ae.transparent === !0 && ae.side === _r && ae.forceSinglePass === !1 ? (ae.side = ji, ae.needsUpdate = !0, v.renderBufferDirect(de, ne, he, ae, L, Ne), ae.side = fo, ae.needsUpdate = !0, v.renderBufferDirect(de, ne, he, ae, L, Ne), ae.side = _r) : v.renderBufferDirect(de, ne, he, ae, L, Ne), L.onAfterRender(v, ne, de, he, ae, Ne)
		}

		function qt(L, ne, de) {
			ne.isScene !== !0 && (ne = Ce);
			const he = me.get(L),
				ae = g.state.lights,
				Ne = g.state.shadowsArray,
				qe = ae.state.version,
				nt = se.getParameters(L, ae.state, Ne, ne, de),
				Xe = se.getProgramCacheKey(nt);
			let Qe = he.programs;
			he.environment = L.isMeshStandardMaterial ? ne.environment : null, he.fog = ne.fog, he.envMap = (L.isMeshStandardMaterial ? A : xe).get(L.envMap || he.environment), he.envMapRotation = he.environment !== null && L.envMap === null ? ne.environmentRotation : L.envMapRotation, Qe === void 0 && (L.addEventListener("dispose", te), Qe = new Map, he.programs = Qe);
			let it = Qe.get(Xe);
			if (it !== void 0) {
				if (he.currentProgram === it && he.lightsStateVersion === qe) return Jt(L, nt), it
			} else nt.uniforms = se.getUniforms(L), L.onBuild(de, nt, v), L.onBeforeCompile(nt, v), it = se.acquireProgram(nt, Xe), Qe.set(Xe, it), he.uniforms = nt.uniforms;
			const dt = he.uniforms;
			return (!L.isShaderMaterial && !L.isRawShaderMaterial || L.clipping === !0) && (dt.clippingPlanes = we.uniform), Jt(L, nt), he.needsLights = tr(L), he.lightsStateVersion = qe, he.needsLights && (dt.ambientLightColor.value = ae.state.ambient, dt.lightProbe.value = ae.state.probe, dt.directionalLights.value = ae.state.directional, dt.directionalLightShadows.value = ae.state.directionalShadow, dt.spotLights.value = ae.state.spot, dt.spotLightShadows.value = ae.state.spotShadow, dt.rectAreaLights.value = ae.state.rectArea, dt.ltc_1.value = ae.state.rectAreaLTC1, dt.ltc_2.value = ae.state.rectAreaLTC2, dt.pointLights.value = ae.state.point, dt.pointLightShadows.value = ae.state.pointShadow, dt.hemisphereLights.value = ae.state.hemi, dt.directionalShadowMap.value = ae.state.directionalShadowMap, dt.directionalShadowMatrix.value = ae.state.directionalShadowMatrix, dt.spotShadowMap.value = ae.state.spotShadowMap, dt.spotLightMatrix.value = ae.state.spotLightMatrix, dt.spotLightMap.value = ae.state.spotLightMap, dt.pointShadowMap.value = ae.state.pointShadowMap, dt.pointShadowMatrix.value = ae.state.pointShadowMatrix), he.currentProgram = it, he.uniformsList = null, it
		}

		function Rn(L) {
			if (L.uniformsList === null) {
				const ne = L.currentProgram.getUniforms();
				L.uniformsList = bp.seqWithValue(ne.seq, L.uniforms)
			}
			return L.uniformsList
		}

		function Jt(L, ne) {
			const de = me.get(L);
			de.outputColorSpace = ne.outputColorSpace, de.batching = ne.batching, de.instancing = ne.instancing, de.instancingColor = ne.instancingColor, de.instancingMorph = ne.instancingMorph, de.skinning = ne.skinning, de.morphTargets = ne.morphTargets, de.morphNormals = ne.morphNormals, de.morphColors = ne.morphColors, de.morphTargetsCount = ne.morphTargetsCount, de.numClippingPlanes = ne.numClippingPlanes, de.numIntersection = ne.numClipIntersection, de.vertexAlphas = ne.vertexAlphas, de.vertexTangents = ne.vertexTangents, de.toneMapping = ne.toneMapping
		}

		function Xt(L, ne, de, he, ae) {
			ne.isScene !== !0 && (ne = Ce), ve.resetTextureUnits();
			const Ne = ne.fog,
				qe = he.isMeshStandardMaterial ? ne.environment : null,
				nt = E === null ? v.outputColorSpace : E.isXRRenderTarget === !0 ? E.texture.colorSpace : Jn,
				Xe = (he.isMeshStandardMaterial ? A : xe).get(he.envMap || qe),
				Qe = he.vertexColors === !0 && !!de.attributes.color && de.attributes.color.itemSize === 4,
				it = !!de.attributes.tangent && (!!he.normalMap || he.anisotropy > 0),
				dt = !!de.morphAttributes.position,
				tn = !!de.morphAttributes.normal,
				Ln = !!de.morphAttributes.color;
			let Nt = da;
			he.toneMapped && (E === null || E.isXRRenderTarget === !0) && (Nt = v.toneMapping);
			const vi = de.morphAttributes.position || de.morphAttributes.normal || de.morphAttributes.color,
				Ht = vi !== void 0 ? vi.length : 0,
				ct = me.get(he),
				a0 = g.state.lights;
			if (K === !0 && (ye === !0 || L !== P)) {
				const Cr = L === P && he.id === C;
				we.setState(he, L, Cr)
			}
			let nn = !1;
			he.version === ct.__version ? (ct.needsLights && ct.lightsStateVersion !== a0.state.version || ct.outputColorSpace !== nt || ae.isBatchedMesh && ct.batching === !1 || !ae.isBatchedMesh && ct.batching === !0 || ae.isInstancedMesh && ct.instancing === !1 || !ae.isInstancedMesh && ct.instancing === !0 || ae.isSkinnedMesh && ct.skinning === !1 || !ae.isSkinnedMesh && ct.skinning === !0 || ae.isInstancedMesh && ct.instancingColor === !0 && ae.instanceColor === null || ae.isInstancedMesh && ct.instancingColor === !1 && ae.instanceColor !== null || ae.isInstancedMesh && ct.instancingMorph === !0 && ae.morphTexture === null || ae.isInstancedMesh && ct.instancingMorph === !1 && ae.morphTexture !== null || ct.envMap !== Xe || he.fog === !0 && ct.fog !== Ne || ct.numClippingPlanes !== void 0 && (ct.numClippingPlanes !== we.numPlanes || ct.numIntersection !== we.numIntersection) || ct.vertexAlphas !== Qe || ct.vertexTangents !== it || ct.morphTargets !== dt || ct.morphNormals !== tn || ct.morphColors !== Ln || ct.toneMapping !== Nt || q.isWebGL2 === !0 && ct.morphTargetsCount !== Ht) && (nn = !0) : (nn = !0, ct.__version = he.version);
			let Pa = ct.currentProgram;
			nn === !0 && (Pa = qt(he, ne, ae));
			let $b = !1,
				Du = !1,
				l0 = !1;
			const oi = Pa.getUniforms(),
				Ra = ct.uniforms;
			if (ie.useProgram(Pa.program) && ($b = !0, Du = !0, l0 = !0), he.id !== C && (C = he.id, Du = !0), $b || P !== L) {
				oi.setValue(Y, "projectionMatrix", L.projectionMatrix), oi.setValue(Y, "viewMatrix", L.matrixWorldInverse);
				const Cr = oi.map.cameraPosition;
				Cr !== void 0 && Cr.setValue(Y, ce.setFromMatrixPosition(L.matrixWorld)), q.logarithmicDepthBuffer && oi.setValue(Y, "logDepthBufFC", 2 / (Math.log(L.far + 1) / Math.LN2)), (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial) && oi.setValue(Y, "isOrthographic", L.isOrthographicCamera === !0), P !== L && (P = L, Du = !0, l0 = !0)
			}
			if (ae.isSkinnedMesh) {
				oi.setOptional(Y, ae, "bindMatrix"), oi.setOptional(Y, ae, "bindMatrixInverse");
				const Cr = ae.skeleton;
				Cr && (q.floatVertexTextures ? (Cr.boneTexture === null && Cr.computeBoneTexture(), oi.setValue(Y, "boneTexture", Cr.boneTexture, ve)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
			}
			ae.isBatchedMesh && (oi.setOptional(Y, ae, "batchingTexture"), oi.setValue(Y, "batchingTexture", ae._matricesTexture, ve));
			const c0 = de.morphAttributes;
			if ((c0.position !== void 0 || c0.normal !== void 0 || c0.color !== void 0 && q.isWebGL2 === !0) && M.update(ae, de, Pa), (Du || ct.receiveShadow !== ae.receiveShadow) && (ct.receiveShadow = ae.receiveShadow, oi.setValue(Y, "receiveShadow", ae.receiveShadow)), he.isMeshGouraudMaterial && he.envMap !== null && (Ra.envMap.value = Xe, Ra.flipEnvMap.value = Xe.isCubeTexture && Xe.isRenderTargetTexture === !1 ? -1 : 1), Du && (oi.setValue(Y, "toneMappingExposure", v.toneMappingExposure), ct.needsLights && Ft(Ra, l0), Ne && he.fog === !0 && ue.refreshFogUniforms(Ra, Ne), ue.refreshMaterialUniforms(Ra, he, G, F, Se), bp.upload(Y, Rn(ct), Ra, ve)), he.isShaderMaterial && he.uniformsNeedUpdate === !0 && (bp.upload(Y, Rn(ct), Ra, ve), he.uniformsNeedUpdate = !1), he.isSpriteMaterial && oi.setValue(Y, "center", ae.center), oi.setValue(Y, "modelViewMatrix", ae.modelViewMatrix), oi.setValue(Y, "normalMatrix", ae.normalMatrix), oi.setValue(Y, "modelMatrix", ae.matrixWorld), he.isShaderMaterial || he.isRawShaderMaterial) {
				const Cr = he.uniformsGroups;
				for (let u0 = 0, LP = Cr.length; u0 < LP; u0++)
					if (q.isWebGL2) {
						const qb = Cr[u0];
						_e.update(qb, Pa), _e.bind(qb, Pa)
					} else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
			}
			return Pa
		}

		function Ft(L, ne) {
			L.ambientLightColor.needsUpdate = ne, L.lightProbe.needsUpdate = ne, L.directionalLights.needsUpdate = ne, L.directionalLightShadows.needsUpdate = ne, L.pointLights.needsUpdate = ne, L.pointLightShadows.needsUpdate = ne, L.spotLights.needsUpdate = ne, L.spotLightShadows.needsUpdate = ne, L.rectAreaLights.needsUpdate = ne, L.hemisphereLights.needsUpdate = ne
		}

		function tr(L) {
			return L.isMeshLambertMaterial || L.isMeshToonMaterial || L.isMeshPhongMaterial || L.isMeshStandardMaterial || L.isShadowMaterial || L.isShaderMaterial && L.lights === !0
		}
		this.getActiveCubeFace = function () {
			return x
		}, this.getActiveMipmapLevel = function () {
			return S
		}, this.getRenderTarget = function () {
			return E
		}, this.setRenderTargetTextures = function (L, ne, de) {
			me.get(L.texture).__webglTexture = ne, me.get(L.depthTexture).__webglTexture = de;
			const he = me.get(L);
			he.__hasExternalTextures = !0, he.__autoAllocateDepthBuffer = de === void 0, he.__autoAllocateDepthBuffer || O.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), he.__useRenderToTexture = !1)
		}, this.setRenderTargetFramebuffer = function (L, ne) {
			const de = me.get(L);
			de.__webglFramebuffer = ne, de.__useDefaultFramebuffer = ne === void 0
		}, this.setRenderTarget = function (L, ne = 0, de = 0) {
			E = L, x = ne, S = de;
			let he = !0,
				ae = null,
				Ne = !1,
				qe = !1;
			if (L) {
				const Xe = me.get(L);
				Xe.__useDefaultFramebuffer !== void 0 ? (ie.bindFramebuffer(Y.FRAMEBUFFER, null), he = !1) : Xe.__webglFramebuffer === void 0 ? ve.setupRenderTarget(L) : Xe.__hasExternalTextures && ve.rebindTextures(L, me.get(L.texture).__webglTexture, me.get(L.depthTexture).__webglTexture);
				const Qe = L.texture;
				(Qe.isData3DTexture || Qe.isDataArrayTexture || Qe.isCompressedArrayTexture) && (qe = !0);
				const it = me.get(L).__webglFramebuffer;
				L.isWebGLCubeRenderTarget ? (Array.isArray(it[ne]) ? ae = it[ne][de] : ae = it[ne], Ne = !0) : q.isWebGL2 && L.samples > 0 && ve.useMultisampledRTT(L) === !1 ? ae = me.get(L).__webglMultisampledFramebuffer : Array.isArray(it) ? ae = it[de] : ae = it, w.copy(L.viewport), D.copy(L.scissor), U = L.scissorTest
			} else w.copy(B).multiplyScalar(G).floor(), D.copy(ge).multiplyScalar(G).floor(), U = Ae;
			if (ie.bindFramebuffer(Y.FRAMEBUFFER, ae) && q.drawBuffers && he && ie.drawBuffers(L, ae), ie.viewport(w), ie.scissor(D), ie.setScissorTest(U), Ne) {
				const Xe = me.get(L.texture);
				Y.framebufferTexture2D(Y.FRAMEBUFFER, Y.COLOR_ATTACHMENT0, Y.TEXTURE_CUBE_MAP_POSITIVE_X + ne, Xe.__webglTexture, de)
			} else if (qe) {
				const Xe = me.get(L.texture),
					Qe = ne || 0;
				Y.framebufferTextureLayer(Y.FRAMEBUFFER, Y.COLOR_ATTACHMENT0, Xe.__webglTexture, de || 0, Qe)
			}
			C = -1
		}, this.readRenderTargetPixels = function (L, ne, de, he, ae, Ne, qe) {
			if (!(L && L.isWebGLRenderTarget)) {
				console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
				return
			}
			let nt = me.get(L).__webglFramebuffer;
			if (L.isWebGLCubeRenderTarget && qe !== void 0 && (nt = nt[qe]), nt) {
				ie.bindFramebuffer(Y.FRAMEBUFFER, nt);
				try {
					const Xe = L.texture,
						Qe = Xe.format,
						it = Xe.type;
					if (Qe !== vr && J.convert(Qe) !== Y.getParameter(Y.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
						return
					}
					const dt = it === au && (O.has("EXT_color_buffer_half_float") || q.isWebGL2 && O.has("EXT_color_buffer_float"));
					if (it !== fa && J.convert(it) !== Y.getParameter(Y.IMPLEMENTATION_COLOR_READ_TYPE) && !(it === ns && (q.isWebGL2 || O.has("OES_texture_float") || O.has("WEBGL_color_buffer_float"))) && !dt) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
						return
					}
					ne >= 0 && ne <= L.width - he && de >= 0 && de <= L.height - ae && Y.readPixels(ne, de, he, ae, J.convert(Qe), J.convert(it), Ne)
				} finally {
					const Xe = E !== null ? me.get(E).__webglFramebuffer : null;
					ie.bindFramebuffer(Y.FRAMEBUFFER, Xe)
				}
			}
		}, this.copyFramebufferToTexture = function (L, ne, de = 0) {
			const he = Math.pow(2, -de),
				ae = Math.floor(ne.image.width * he),
				Ne = Math.floor(ne.image.height * he);
			ve.setTexture2D(ne, 0), Y.copyTexSubImage2D(Y.TEXTURE_2D, de, 0, 0, L.x, L.y, ae, Ne), ie.unbindTexture()
		}, this.copyTextureToTexture = function (L, ne, de, he = 0) {
			const ae = ne.image.width,
				Ne = ne.image.height,
				qe = J.convert(de.format),
				nt = J.convert(de.type);
			ve.setTexture2D(de, 0), Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, de.flipY), Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, de.premultiplyAlpha), Y.pixelStorei(Y.UNPACK_ALIGNMENT, de.unpackAlignment), ne.isDataTexture ? Y.texSubImage2D(Y.TEXTURE_2D, he, L.x, L.y, ae, Ne, qe, nt, ne.image.data) : ne.isCompressedTexture ? Y.compressedTexSubImage2D(Y.TEXTURE_2D, he, L.x, L.y, ne.mipmaps[0].width, ne.mipmaps[0].height, qe, ne.mipmaps[0].data) : Y.texSubImage2D(Y.TEXTURE_2D, he, L.x, L.y, qe, nt, ne.image), he === 0 && de.generateMipmaps && Y.generateMipmap(Y.TEXTURE_2D), ie.unbindTexture()
		}, this.copyTextureToTexture3D = function (L, ne, de, he, ae = 0) {
			if (v.isWebGL1Renderer) {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
				return
			}
			const Ne = Math.round(L.max.x - L.min.x),
				qe = Math.round(L.max.y - L.min.y),
				nt = L.max.z - L.min.z + 1,
				Xe = J.convert(he.format),
				Qe = J.convert(he.type);
			let it;
			if (he.isData3DTexture) ve.setTexture3D(he, 0), it = Y.TEXTURE_3D;
			else if (he.isDataArrayTexture || he.isCompressedArrayTexture) ve.setTexture2DArray(he, 0), it = Y.TEXTURE_2D_ARRAY;
			else {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
				return
			}
			Y.pixelStorei(Y.UNPACK_FLIP_Y_WEBGL, he.flipY), Y.pixelStorei(Y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, he.premultiplyAlpha), Y.pixelStorei(Y.UNPACK_ALIGNMENT, he.unpackAlignment);
			const dt = Y.getParameter(Y.UNPACK_ROW_LENGTH),
				tn = Y.getParameter(Y.UNPACK_IMAGE_HEIGHT),
				Ln = Y.getParameter(Y.UNPACK_SKIP_PIXELS),
				Nt = Y.getParameter(Y.UNPACK_SKIP_ROWS),
				vi = Y.getParameter(Y.UNPACK_SKIP_IMAGES),
				Ht = de.isCompressedTexture ? de.mipmaps[ae] : de.image;
			Y.pixelStorei(Y.UNPACK_ROW_LENGTH, Ht.width), Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, Ht.height), Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, L.min.x), Y.pixelStorei(Y.UNPACK_SKIP_ROWS, L.min.y), Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, L.min.z), de.isDataTexture || de.isData3DTexture ? Y.texSubImage3D(it, ae, ne.x, ne.y, ne.z, Ne, qe, nt, Xe, Qe, Ht.data) : he.isCompressedArrayTexture ? Y.compressedTexSubImage3D(it, ae, ne.x, ne.y, ne.z, Ne, qe, nt, Xe, Ht.data) : Y.texSubImage3D(it, ae, ne.x, ne.y, ne.z, Ne, qe, nt, Xe, Qe, Ht), Y.pixelStorei(Y.UNPACK_ROW_LENGTH, dt), Y.pixelStorei(Y.UNPACK_IMAGE_HEIGHT, tn), Y.pixelStorei(Y.UNPACK_SKIP_PIXELS, Ln), Y.pixelStorei(Y.UNPACK_SKIP_ROWS, Nt), Y.pixelStorei(Y.UNPACK_SKIP_IMAGES, vi), ae === 0 && he.generateMipmaps && Y.generateMipmap(it), ie.unbindTexture()
		}, this.initTexture = function (L) {
			L.isCubeTexture ? ve.setTextureCube(L, 0) : L.isData3DTexture ? ve.setTexture3D(L, 0) : L.isDataArrayTexture || L.isCompressedArrayTexture ? ve.setTexture2DArray(L, 0) : ve.setTexture2D(L, 0), ie.unbindTexture()
		}, this.resetState = function () {
			x = 0, S = 0, E = null, ie.reset(), oe.reset()
		}, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	get coordinateSystem() {
		return eo
	}
	get outputColorSpace() {
		return this._outputColorSpace
	}
	set outputColorSpace(e) {
		this._outputColorSpace = e;
		const t = this.getContext();
		t.drawingBufferColorSpace = e === Ab ? "display-p3" : "srgb", t.unpackColorSpace = Lt.workingColorSpace === Zm ? "display-p3" : "srgb"
	}
	get useLegacyLights() {
		return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
	}
	set useLegacyLights(e) {
		console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
	}
}
class Y$ extends Fb {}
Y$.prototype.isWebGL1Renderer = !0;
class Nb {
	constructor(e, t = 1, i = 1e3) {
		this.isFog = !0, this.name = "", this.color = new et(e), this.near = t, this.far = i
	}
	clone() {
		return new Nb(this.color, this.near, this.far)
	}
	toJSON() {
		return {
			type: "Fog",
			name: this.name,
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		}
	}
}
class K$ extends ht {
	constructor() {
		super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Er, this.environmentRotation = new Er, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	copy(e, t) {
		return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), t.object.environmentRotation = this.environmentRotation.toArray(), t
	}
}
class WD {
	constructor(e, t) {
		this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = om, this._updateRange = {
			offset: 0,
			count: -1
		}, this.updateRanges = [], this.version = 0, this.uuid = rs()
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++
	}
	get updateRange() {
		return AD("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
	}
	setUsage(e) {
		return this.usage = e, this
	}
	addUpdateRange(e, t) {
		this.updateRanges.push({
			start: e,
			count: t
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(e) {
		return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
	}
	copyAt(e, t, i) {
		e *= this.stride, i *= t.stride;
		for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
		return this
	}
	set(e, t = 0) {
		return this.array.set(e, t), this
	}
	clone(e) {
		e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = rs()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
		const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
			i = new this.constructor(t, this.stride);
		return i.setUsage(this.usage), i
	}
	onUpload(e) {
		return this.onUploadCallback = e, this
	}
	toJSON(e) {
		return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = rs()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		}
	}
}
const xi = new X;
class pr {
	constructor(e, t, i, r = !1) {
		this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r
	}
	get count() {
		return this.data.count
	}
	get array() {
		return this.data.array
	}
	set needsUpdate(e) {
		this.data.needsUpdate = e
	}
	applyMatrix4(e) {
		for (let t = 0, i = this.data.count; t < i; t++) xi.fromBufferAttribute(this, t), xi.applyMatrix4(e), this.setXYZ(t, xi.x, xi.y, xi.z);
		return this
	}
	applyNormalMatrix(e) {
		for (let t = 0, i = this.count; t < i; t++) xi.fromBufferAttribute(this, t), xi.applyNormalMatrix(e), this.setXYZ(t, xi.x, xi.y, xi.z);
		return this
	}
	transformDirection(e) {
		for (let t = 0, i = this.count; t < i; t++) xi.fromBufferAttribute(this, t), xi.transformDirection(e), this.setXYZ(t, xi.x, xi.y, xi.z);
		return this
	}
	getComponent(e, t) {
		let i = this.array[e * this.data.stride + this.offset + t];
		return this.normalized && (i = is(i, this.array)), i
	}
	setComponent(e, t, i) {
		return this.normalized && (i = Bt(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this
	}
	setX(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
	}
	setY(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
	}
	setZ(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
	}
	setW(e, t) {
		return this.normalized && (t = Bt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
	}
	getX(e) {
		let t = this.data.array[e * this.data.stride + this.offset];
		return this.normalized && (t = is(t, this.array)), t
	}
	getY(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 1];
		return this.normalized && (t = is(t, this.array)), t
	}
	getZ(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 2];
		return this.normalized && (t = is(t, this.array)), t
	}
	getW(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 3];
		return this.normalized && (t = is(t, this.array)), t
	}
	setXY(e, t, i) {
		return e = e * this.data.stride + this.offset, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
	}
	setXYZ(e, t, i, r) {
		return e = e * this.data.stride + this.offset, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array), r = Bt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this
	}
	setXYZW(e, t, i, r, s) {
		return e = e * this.data.stride + this.offset, this.normalized && (t = Bt(t, this.array), i = Bt(i, this.array), r = Bt(r, this.array), s = Bt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this
	}
	clone(e) {
		if (e === void 0) {
			console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
			const t = [];
			for (let i = 0; i < this.count; i++) {
				const r = i * this.data.stride + this.offset;
				for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
			}
			return new Cn(new this.array.constructor(t), this.itemSize, this.normalized)
		} else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new pr(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
	}
	toJSON(e) {
		if (e === void 0) {
			console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
			const t = [];
			for (let i = 0; i < this.count; i++) {
				const r = i * this.data.stride + this.offset;
				for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: t,
				normalized: this.normalized
			}
		} else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
			isInterleavedBufferAttribute: !0,
			itemSize: this.itemSize,
			data: this.data.uuid,
			offset: this.offset,
			normalized: this.normalized
		}
	}
}
const EE = new X,
	SE = new kt,
	TE = new kt,
	Z$ = new X,
	ME = new pt,
	Vf = new X,
	Ug = new Is,
	CE = new pt,
	Bg = new Su;
class J$ extends an {
	constructor(e, t) {
		super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = s2, this.bindMatrix = new pt, this.bindMatrixInverse = new pt, this.boundingBox = null, this.boundingSphere = null
	}
	computeBoundingBox() {
		const e = this.geometry;
		this.boundingBox === null && (this.boundingBox = new ks), this.boundingBox.makeEmpty();
		const t = e.getAttribute("position");
		for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Vf), this.boundingBox.expandByPoint(Vf)
	}
	computeBoundingSphere() {
		const e = this.geometry;
		this.boundingSphere === null && (this.boundingSphere = new Is), this.boundingSphere.makeEmpty();
		const t = e.getAttribute("position");
		for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Vf), this.boundingSphere.expandByPoint(Vf)
	}
	copy(e, t) {
		return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
	}
	raycast(e, t) {
		const i = this.material,
			r = this.matrixWorld;
		i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ug.copy(this.boundingSphere), Ug.applyMatrix4(r), e.ray.intersectsSphere(Ug) !== !1 && (CE.copy(r).invert(), Bg.copy(e.ray).applyMatrix4(CE), !(this.boundingBox !== null && Bg.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Bg)))
	}
	getVertexPosition(e, t) {
		return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
	}
	bind(e, t) {
		this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
	}
	pose() {
		this.skeleton.pose()
	}
	normalizeSkinWeights() {
		const e = new kt,
			t = this.geometry.attributes.skinWeight;
		for (let i = 0, r = t.count; i < r; i++) {
			e.fromBufferAttribute(t, i);
			const s = 1 / e.manhattanLength();
			s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
		}
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e), this.bindMode === s2 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === oV ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
	}
	applyBoneTransform(e, t) {
		const i = this.skeleton,
			r = this.geometry;
		SE.fromBufferAttribute(r.attributes.skinIndex, e), TE.fromBufferAttribute(r.attributes.skinWeight, e), EE.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
		for (let s = 0; s < 4; s++) {
			const o = TE.getComponent(s);
			if (o !== 0) {
				const a = SE.getComponent(s);
				ME.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(Z$.copy(EE).applyMatrix4(ME), o)
			}
		}
		return t.applyMatrix4(this.bindMatrixInverse)
	}
}
class jD extends ht {
	constructor() {
		super(), this.isBone = !0, this.type = "Bone"
	}
}
class $D extends Kn {
	constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = $n, u = $n, h, d) {
		super(null, o, a, l, c, u, r, s, h, d), this.isDataTexture = !0, this.image = {
			data: e,
			width: t,
			height: i
		}, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
const AE = new pt,
	Q$ = new pt;
class Ub {
	constructor(e = [], t = []) {
		this.uuid = rs(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
	}
	init() {
		const e = this.bones,
			t = this.boneInverses;
		if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
		else if (e.length !== t.length) {
			console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
			for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new pt)
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = new pt;
			this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
		}
	}
	pose() {
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = this.bones[e];
			i && i.matrixWorld.copy(this.boneInverses[e]).invert()
		}
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const i = this.bones[e];
			i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale))
		}
	}
	update() {
		const e = this.bones,
			t = this.boneInverses,
			i = this.boneMatrices,
			r = this.boneTexture;
		for (let s = 0, o = e.length; s < o; s++) {
			const a = e[s] ? e[s].matrixWorld : Q$;
			AE.multiplyMatrices(a, t[s]), AE.toArray(i, s * 16)
		}
		r !== null && (r.needsUpdate = !0)
	}
	clone() {
		return new Ub(this.bones, this.boneInverses)
	}
	computeBoneTexture() {
		let e = Math.sqrt(this.bones.length * 4);
		e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
		const t = new Float32Array(e * e * 4);
		t.set(this.boneMatrices);
		const i = new $D(t, e, e, vr, ns);
		return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this
	}
	getBoneByName(e) {
		for (let t = 0, i = this.bones.length; t < i; t++) {
			const r = this.bones[t];
			if (r.name === e) return r
		}
	}
	dispose() {
		this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
	}
	fromJSON(e, t) {
		this.uuid = e.uuid;
		for (let i = 0, r = e.bones.length; i < r; i++) {
			const s = e.bones[i];
			let o = t[s];
			o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new jD), this.bones.push(o), this.boneInverses.push(new pt().fromArray(e.boneInverses[i]))
		}
		return this.init(), this
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.6,
				type: "Skeleton",
				generator: "Skeleton.toJSON"
			},
			bones: [],
			boneInverses: []
		};
		e.uuid = this.uuid;
		const t = this.bones,
			i = this.boneInverses;
		for (let r = 0, s = t.length; r < s; r++) {
			const o = t[r];
			e.bones.push(o.uuid);
			const a = i[r];
			e.boneInverses.push(a.toArray())
		}
		return e
	}
}
class cm extends Cn {
	constructor(e, t, i, r = 1) {
		super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
	}
	copy(e) {
		return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
	}
	toJSON() {
		const e = super.toJSON();
		return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
	}
}
const cc = new pt,
	DE = new pt,
	Hf = [],
	PE = new ks,
	eq = new pt,
	Gu = new an,
	Wu = new Is;
class tq extends an {
	constructor(e, t, i) {
		super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new cm(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
		for (let r = 0; r < i; r++) this.setMatrixAt(r, eq)
	}
	computeBoundingBox() {
		const e = this.geometry,
			t = this.count;
		this.boundingBox === null && (this.boundingBox = new ks), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
		for (let i = 0; i < t; i++) this.getMatrixAt(i, cc), PE.copy(e.boundingBox).applyMatrix4(cc), this.boundingBox.union(PE)
	}
	computeBoundingSphere() {
		const e = this.geometry,
			t = this.count;
		this.boundingSphere === null && (this.boundingSphere = new Is), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
		for (let i = 0; i < t; i++) this.getMatrixAt(i, cc), Wu.copy(e.boundingSphere).applyMatrix4(cc), this.boundingSphere.union(Wu)
	}
	copy(e, t) {
		return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
	}
	getColorAt(e, t) {
		t.fromArray(this.instanceColor.array, e * 3)
	}
	getMatrixAt(e, t) {
		t.fromArray(this.instanceMatrix.array, e * 16)
	}
	getMorphAt(e, t) {
		const i = t.morphTargetInfluences,
			r = this.morphTexture.source.data.data,
			s = i.length + 1,
			o = e * s + 1;
		for (let a = 0; a < i.length; a++) i[a] = r[o + a]
	}
	raycast(e, t) {
		const i = this.matrixWorld,
			r = this.count;
		if (Gu.geometry = this.geometry, Gu.material = this.material, Gu.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Wu.copy(this.boundingSphere), Wu.applyMatrix4(i), e.ray.intersectsSphere(Wu) !== !1))
			for (let s = 0; s < r; s++) {
				this.getMatrixAt(s, cc), DE.multiplyMatrices(i, cc), Gu.matrixWorld = DE, Gu.raycast(e, Hf);
				for (let o = 0, a = Hf.length; o < a; o++) {
					const l = Hf[o];
					l.instanceId = s, l.object = this, t.push(l)
				}
				Hf.length = 0
			}
	}
	setColorAt(e, t) {
		this.instanceColor === null && (this.instanceColor = new cm(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3)
	}
	setMatrixAt(e, t) {
		t.toArray(this.instanceMatrix.array, e * 16)
	}
	setMorphAt(e, t) {
		const i = t.morphTargetInfluences,
			r = i.length + 1;
		this.morphTexture === null && (this.morphTexture = new $D(new Float32Array(r * this.count), r, this.count, Lh, ns));
		const s = this.morphTexture.source.data.data;
		let o = 0;
		for (let c = 0; c < i.length; c++) o += i[c];
		const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
			l = r * e;
		s[l] = a, s.set(i, l + 1)
	}
	updateMorphTargets() {}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
class Bb extends Cs {
	constructor(e) {
		super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new et(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
	}
}
const RE = new X,
	LE = new X,
	kE = new pt,
	zg = new Su,
	Gf = new Is;
class zb extends ht {
	constructor(e = new gi, t = new Bb) {
		super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e, t) {
		return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.index === null) {
			const t = e.attributes.position,
				i = [0];
			for (let r = 1, s = t.count; r < s; r++) RE.fromBufferAttribute(t, r - 1), LE.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += RE.distanceTo(LE);
			e.setAttribute("lineDistance", new $i(i, 1))
		} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
		return this
	}
	raycast(e, t) {
		const i = this.geometry,
			r = this.matrixWorld,
			s = e.params.Line.threshold,
			o = i.drawRange;
		if (i.boundingSphere === null && i.computeBoundingSphere(), Gf.copy(i.boundingSphere), Gf.applyMatrix4(r), Gf.radius += s, e.ray.intersectsSphere(Gf) === !1) return;
		kE.copy(r).invert(), zg.copy(e.ray).applyMatrix4(kE);
		const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = a * a,
			c = new X,
			u = new X,
			h = new X,
			d = new X,
			f = this.isLineSegments ? 2 : 1,
			p = i.index,
			g = i.attributes.position;
		if (p !== null) {
			const m = Math.max(0, o.start),
				b = Math.min(p.count, o.start + o.count);
			for (let v = m, y = b - 1; v < y; v += f) {
				const x = p.getX(v),
					S = p.getX(v + 1);
				if (c.fromBufferAttribute(g, x), u.fromBufferAttribute(g, S), zg.distanceSqToSegment(c, u, d, h) > l) continue;
				d.applyMatrix4(this.matrixWorld);
				const C = e.ray.origin.distanceTo(d);
				C < e.near || C > e.far || t.push({
					distance: C,
					point: h.clone().applyMatrix4(this.matrixWorld),
					index: v,
					face: null,
					faceIndex: null,
					object: this
				})
			}
		} else {
			const m = Math.max(0, o.start),
				b = Math.min(g.count, o.start + o.count);
			for (let v = m, y = b - 1; v < y; v += f) {
				if (c.fromBufferAttribute(g, v), u.fromBufferAttribute(g, v + 1), zg.distanceSqToSegment(c, u, d, h) > l) continue;
				d.applyMatrix4(this.matrixWorld);
				const S = e.ray.origin.distanceTo(d);
				S < e.near || S > e.far || t.push({
					distance: S,
					point: h.clone().applyMatrix4(this.matrixWorld),
					index: v,
					face: null,
					faceIndex: null,
					object: this
				})
			}
		}
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			i = Object.keys(t);
		if (i.length > 0) {
			const r = t[i[0]];
			if (r !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let s = 0, o = r.length; s < o; s++) {
					const a = r[s].name || String(s);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
				}
			}
		}
	}
}
const IE = new X,
	OE = new X;
class qD extends zb {
	constructor(e, t) {
		super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.index === null) {
			const t = e.attributes.position,
				i = [];
			for (let r = 0, s = t.count; r < s; r += 2) IE.fromBufferAttribute(t, r), OE.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + IE.distanceTo(OE);
			e.setAttribute("lineDistance", new $i(i, 1))
		} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
		return this
	}
}
class nq extends zb {
	constructor(e, t) {
		super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
	}
}
class XD extends Cs {
	constructor(e) {
		super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new et(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
	}
}
const FE = new pt,
	Ov = new Su,
	Wf = new Is,
	jf = new X;
class iq extends ht {
	constructor(e = new gi, t = new XD) {
		super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e, t) {
		return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
	}
	raycast(e, t) {
		const i = this.geometry,
			r = this.matrixWorld,
			s = e.params.Points.threshold,
			o = i.drawRange;
		if (i.boundingSphere === null && i.computeBoundingSphere(), Wf.copy(i.boundingSphere), Wf.applyMatrix4(r), Wf.radius += s, e.ray.intersectsSphere(Wf) === !1) return;
		FE.copy(r).invert(), Ov.copy(e.ray).applyMatrix4(FE);
		const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = a * a,
			c = i.index,
			h = i.attributes.position;
		if (c !== null) {
			const d = Math.max(0, o.start),
				f = Math.min(c.count, o.start + o.count);
			for (let p = d, _ = f; p < _; p++) {
				const g = c.getX(p);
				jf.fromBufferAttribute(h, g), NE(jf, g, l, r, e, t, this)
			}
		} else {
			const d = Math.max(0, o.start),
				f = Math.min(h.count, o.start + o.count);
			for (let p = d, _ = f; p < _; p++) jf.fromBufferAttribute(h, p), NE(jf, p, l, r, e, t, this)
		}
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			i = Object.keys(t);
		if (i.length > 0) {
			const r = t[i[0]];
			if (r !== void 0) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let s = 0, o = r.length; s < o; s++) {
					const a = r[s].name || String(s);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
				}
			}
		}
	}
}

function NE(n, e, t, i, r, s, o) {
	const a = Ov.distanceSqToPoint(n);
	if (a < t) {
		const l = new X;
		Ov.closestPointToPoint(n, l), l.applyMatrix4(i);
		const c = r.ray.origin.distanceTo(l);
		if (c < r.near || c > r.far) return;
		s.push({
			distance: c,
			distanceToRay: Math.sqrt(a),
			point: l,
			index: e,
			face: null,
			object: o
		})
	}
}
class e0 extends gi {
	constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
		super(), this.type = "SphereGeometry", this.parameters = {
			radius: e,
			widthSegments: t,
			heightSegments: i,
			phiStart: r,
			phiLength: s,
			thetaStart: o,
			thetaLength: a
		}, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
		const l = Math.min(o + a, Math.PI);
		let c = 0;
		const u = [],
			h = new X,
			d = new X,
			f = [],
			p = [],
			_ = [],
			g = [];
		for (let m = 0; m <= i; m++) {
			const b = [],
				v = m / i;
			let y = 0;
			m === 0 && o === 0 ? y = .5 / t : m === i && l === Math.PI && (y = -.5 / t);
			for (let x = 0; x <= t; x++) {
				const S = x / t;
				h.x = -e * Math.cos(r + S * s) * Math.sin(o + v * a), h.y = e * Math.cos(o + v * a), h.z = e * Math.sin(r + S * s) * Math.sin(o + v * a), p.push(h.x, h.y, h.z), d.copy(h).normalize(), _.push(d.x, d.y, d.z), g.push(S + y, 1 - v), b.push(c++)
			}
			u.push(b)
		}
		for (let m = 0; m < i; m++)
			for (let b = 0; b < t; b++) {
				const v = u[m][b + 1],
					y = u[m][b],
					x = u[m + 1][b],
					S = u[m + 1][b + 1];
				(m !== 0 || o > 0) && f.push(v, y, S), (m !== i - 1 || l < Math.PI) && f.push(y, x, S)
			}
		this.setIndex(f), this.setAttribute("position", new $i(p, 3)), this.setAttribute("normal", new $i(_, 3)), this.setAttribute("uv", new $i(g, 2))
	}
	copy(e) {
		return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
	}
	static fromJSON(e) {
		return new e0(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
	}
}
class rq extends Dn {
	constructor(e) {
		super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
	}
}
class Bd extends Cs {
	constructor(e) {
		super(), this.isMeshStandardMaterial = !0, this.defines = {
			STANDARD: ""
		}, this.type = "MeshStandardMaterial", this.color = new et(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new et(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = SD, this.normalScale = new Oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Er, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.defines = {
			STANDARD: ""
		}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
	}
}
class go extends Bd {
	constructor(e) {
		super(), this.isMeshPhysicalMaterial = !0, this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Oe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
			get: function () {
				return ti(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
			},
			set: function (t) {
				this.ior = (1 + .4 * t) / (1 - .4 * t)
			}
		}), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new et(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new et(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new et(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
	}
	get anisotropy() {
		return this._anisotropy
	}
	set anisotropy(e) {
		this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
	}
	get clearcoat() {
		return this._clearcoat
	}
	set clearcoat(e) {
		this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
	}
	get iridescence() {
		return this._iridescence
	}
	set iridescence(e) {
		this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
	}
	get sheen() {
		return this._sheen
	}
	set sheen(e) {
		this._sheen > 0 != e > 0 && this.version++, this._sheen = e
	}
	get transmission() {
		return this._transmission
	}
	set transmission(e) {
		this._transmission > 0 != e > 0 && this.version++, this._transmission = e
	}
	copy(e) {
		return super.copy(e), this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
	}
}

function $f(n, e, t) {
	return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}

function sq(n) {
	return ArrayBuffer.isView(n) && !(n instanceof DataView)
}

function oq(n) {
	function e(r, s) {
		return n[r] - n[s]
	}
	const t = n.length,
		i = new Array(t);
	for (let r = 0; r !== t; ++r) i[r] = r;
	return i.sort(e), i
}

function UE(n, e, t) {
	const i = n.length,
		r = new n.constructor(i);
	for (let s = 0, o = 0; o !== i; ++s) {
		const a = t[s] * e;
		for (let l = 0; l !== e; ++l) r[o++] = n[a + l]
	}
	return r
}

function YD(n, e, t, i) {
	let r = 1,
		s = n[0];
	for (; s !== void 0 && s[i] === void 0;) s = n[r++];
	if (s === void 0) return;
	let o = s[i];
	if (o !== void 0)
		if (Array.isArray(o))
			do o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++]; while (s !== void 0);
		else if (o.toArray !== void 0)
		do o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++]; while (s !== void 0);
	else
		do o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++]; while (s !== void 0)
}
class zd {
	constructor(e, t, i, r) {
		this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
	}
	evaluate(e) {
		const t = this.parameterPositions;
		let i = this._cachedIndex,
			r = t[i],
			s = t[i - 1];
		n: {
			e: {
				let o;t: {
					i: if (!(e < r)) {
						for (let a = i + 2;;) {
							if (r === void 0) {
								if (e < s) break i;
								return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
							}
							if (i === a) break;
							if (s = r, r = t[++i], e < r) break e
						}
						o = t.length;
						break t
					}if (!(e >= s)) {
						const a = t[1];
						e < a && (i = 2, s = a);
						for (let l = i - 2;;) {
							if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
							if (i === l) break;
							if (r = s, s = t[--i - 1], e >= s) break e
						}
						o = i, i = 0;
						break t
					}
					break n
				}
				for (; i < o;) {
					const a = i + o >>> 1;
					e < t[a] ? o = a : i = a + 1
				}
				if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0,
				this.copySampleValue_(0);
				if (r === void 0) return i = t.length,
				this._cachedIndex = i,
				this.copySampleValue_(i - 1)
			}
			this._cachedIndex = i,
			this.intervalChanged_(i, s, r)
		}
		return this.interpolate_(i, s, e, r)
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			i = this.sampleValues,
			r = this.valueSize,
			s = e * r;
		for (let o = 0; o !== r; ++o) t[o] = i[s + o];
		return t
	}
	interpolate_() {
		throw new Error("call to abstract method")
	}
	intervalChanged_() {}
}
class aq extends zd {
	constructor(e, t, i, r) {
		super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
			endingStart: R2,
			endingEnd: R2
		}
	}
	intervalChanged_(e, t, i) {
		const r = this.parameterPositions;
		let s = e - 2,
			o = e + 1,
			a = r[s],
			l = r[o];
		if (a === void 0) switch (this.getSettings_().endingStart) {
			case L2:
				s = e, a = 2 * t - i;
				break;
			case k2:
				s = r.length - 2, a = t + r[s] - r[s + 1];
				break;
			default:
				s = e, a = i
		}
		if (l === void 0) switch (this.getSettings_().endingEnd) {
			case L2:
				o = e, l = 2 * i - t;
				break;
			case k2:
				o = 1, l = i + r[1] - r[0];
				break;
			default:
				o = e - 1, l = t
		}
		const c = (i - t) * .5,
			u = this.valueSize;
		this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = s * u, this._offsetNext = o * u
	}
	interpolate_(e, t, i, r) {
		const s = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = e * a,
			c = l - a,
			u = this._offsetPrev,
			h = this._offsetNext,
			d = this._weightPrev,
			f = this._weightNext,
			p = (i - t) / (r - t),
			_ = p * p,
			g = _ * p,
			m = -d * g + 2 * d * _ - d * p,
			b = (1 + d) * g + (-1.5 - 2 * d) * _ + (-.5 + d) * p + 1,
			v = (-1 - f) * g + (1.5 + f) * _ + .5 * p,
			y = f * g - f * _;
		for (let x = 0; x !== a; ++x) s[x] = m * o[u + x] + b * o[c + x] + v * o[l + x] + y * o[h + x];
		return s
	}
}
class lq extends zd {
	constructor(e, t, i, r) {
		super(e, t, i, r)
	}
	interpolate_(e, t, i, r) {
		const s = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = e * a,
			c = l - a,
			u = (i - t) / (r - t),
			h = 1 - u;
		for (let d = 0; d !== a; ++d) s[d] = o[c + d] * h + o[l + d] * u;
		return s
	}
}
class cq extends zd {
	constructor(e, t, i, r) {
		super(e, t, i, r)
	}
	interpolate_(e) {
		return this.copySampleValue_(e - 1)
	}
}
class Os {
	constructor(e, t, i, r) {
		if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
		if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
		this.name = e, this.times = $f(t, this.TimeBufferType), this.values = $f(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
	}
	static toJSON(e) {
		const t = e.constructor;
		let i;
		if (t.toJSON !== this.toJSON) i = t.toJSON(e);
		else {
			i = {
				name: e.name,
				times: $f(e.times, Array),
				values: $f(e.values, Array)
			};
			const r = e.getInterpolation();
			r !== e.DefaultInterpolation && (i.interpolation = r)
		}
		return i.type = e.ValueTypeName, i
	}
	InterpolantFactoryMethodDiscrete(e) {
		return new cq(this.times, this.values, this.getValueSize(), e)
	}
	InterpolantFactoryMethodLinear(e) {
		return new lq(this.times, this.values, this.getValueSize(), e)
	}
	InterpolantFactoryMethodSmooth(e) {
		return new aq(this.times, this.values, this.getValueSize(), e)
	}
	setInterpolation(e) {
		let t;
		switch (e) {
			case ud:
				t = this.InterpolantFactoryMethodDiscrete;
				break;
			case cu:
				t = this.InterpolantFactoryMethodLinear;
				break;
			case dg:
				t = this.InterpolantFactoryMethodSmooth;
				break
		}
		if (t === void 0) {
			const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (this.createInterpolant === void 0)
				if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
				else throw new Error(i);
			return console.warn("THREE.KeyframeTrack:", i), this
		}
		return this.createInterpolant = t, this
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return ud;
			case this.InterpolantFactoryMethodLinear:
				return cu;
			case this.InterpolantFactoryMethodSmooth:
				return dg
		}
	}
	getValueSize() {
		return this.values.length / this.times.length
	}
	shift(e) {
		if (e !== 0) {
			const t = this.times;
			for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
		}
		return this
	}
	scale(e) {
		if (e !== 1) {
			const t = this.times;
			for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
		}
		return this
	}
	trim(e, t) {
		const i = this.times,
			r = i.length;
		let s = 0,
			o = r - 1;
		for (; s !== r && i[s] < e;) ++s;
		for (; o !== -1 && i[o] > t;) --o;
		if (++o, s !== 0 || o !== r) {
			s >= o && (o = Math.max(o, 1), s = o - 1);
			const a = this.getValueSize();
			this.times = i.slice(s, o), this.values = this.values.slice(s * a, o * a)
		}
		return this
	}
	validate() {
		let e = !0;
		const t = this.getValueSize();
		t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
		const i = this.times,
			r = this.values,
			s = i.length;
		s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
		let o = null;
		for (let a = 0; a !== s; a++) {
			const l = i[a];
			if (typeof l == "number" && isNaN(l)) {
				console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
				break
			}
			if (o !== null && o > l) {
				console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
				break
			}
			o = l
		}
		if (r !== void 0 && sq(r))
			for (let a = 0, l = r.length; a !== l; ++a) {
				const c = r[a];
				if (isNaN(c)) {
					console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
					break
				}
			}
		return e
	}
	optimize() {
		const e = this.times.slice(),
			t = this.values.slice(),
			i = this.getValueSize(),
			r = this.getInterpolation() === dg,
			s = e.length - 1;
		let o = 1;
		for (let a = 1; a < s; ++a) {
			let l = !1;
			const c = e[a],
				u = e[a + 1];
			if (c !== u && (a !== 1 || c !== e[0]))
				if (r) l = !0;
				else {
					const h = a * i,
						d = h - i,
						f = h + i;
					for (let p = 0; p !== i; ++p) {
						const _ = t[h + p];
						if (_ !== t[d + p] || _ !== t[f + p]) {
							l = !0;
							break
						}
					}
				} if (l) {
				if (a !== o) {
					e[o] = e[a];
					const h = a * i,
						d = o * i;
					for (let f = 0; f !== i; ++f) t[d + f] = t[h + f]
				}++o
			}
		}
		if (s > 0) {
			e[o] = e[s];
			for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
			++o
		}
		return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this
	}
	clone() {
		const e = this.times.slice(),
			t = this.values.slice(),
			i = this.constructor,
			r = new i(this.name, e, t);
		return r.createInterpolant = this.createInterpolant, r
	}
}
Os.prototype.TimeBufferType = Float32Array;
Os.prototype.ValueBufferType = Float32Array;
Os.prototype.DefaultInterpolation = cu;
class Cu extends Os {}
Cu.prototype.ValueTypeName = "bool";
Cu.prototype.ValueBufferType = Array;
Cu.prototype.DefaultInterpolation = ud;
Cu.prototype.InterpolantFactoryMethodLinear = void 0;
Cu.prototype.InterpolantFactoryMethodSmooth = void 0;
class KD extends Os {}
KD.prototype.ValueTypeName = "color";
class du extends Os {}
du.prototype.ValueTypeName = "number";
class uq extends zd {
	constructor(e, t, i, r) {
		super(e, t, i, r)
	}
	interpolate_(e, t, i, r) {
		const s = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = (i - t) / (r - t);
		let c = e * a;
		for (let u = c + a; c !== u; c += 4) qr.slerpFlat(s, 0, o, c - a, o, c, l);
		return s
	}
}
class Dl extends Os {
	InterpolantFactoryMethodLinear(e) {
		return new uq(this.times, this.values, this.getValueSize(), e)
	}
}
Dl.prototype.ValueTypeName = "quaternion";
Dl.prototype.DefaultInterpolation = cu;
Dl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Au extends Os {}
Au.prototype.ValueTypeName = "string";
Au.prototype.ValueBufferType = Array;
Au.prototype.DefaultInterpolation = ud;
Au.prototype.InterpolantFactoryMethodLinear = void 0;
Au.prototype.InterpolantFactoryMethodSmooth = void 0;
class fu extends Os {}
fu.prototype.ValueTypeName = "vector";
class hq {
	constructor(e, t = -1, i, r = fV) {
		this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = rs(), this.duration < 0 && this.resetDuration()
	}
	static parse(e) {
		const t = [],
			i = e.tracks,
			r = 1 / (e.fps || 1);
		for (let o = 0, a = i.length; o !== a; ++o) t.push(fq(i[o]).scale(r));
		const s = new this(e.name, e.duration, t, e.blendMode);
		return s.uuid = e.uuid, s
	}
	static toJSON(e) {
		const t = [],
			i = e.tracks,
			r = {
				name: e.name,
				duration: e.duration,
				tracks: t,
				uuid: e.uuid,
				blendMode: e.blendMode
			};
		for (let s = 0, o = i.length; s !== o; ++s) t.push(Os.toJSON(i[s]));
		return r
	}
	static CreateFromMorphTargetSequence(e, t, i, r) {
		const s = t.length,
			o = [];
		for (let a = 0; a < s; a++) {
			let l = [],
				c = [];
			l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
			const u = oq(l);
			l = UE(l, 1, u), c = UE(c, 1, u), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new du(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i))
		}
		return new this(e, -1, o)
	}
	static findByName(e, t) {
		let i = e;
		if (!Array.isArray(e)) {
			const r = e;
			i = r.geometry && r.geometry.animations || r.animations
		}
		for (let r = 0; r < i.length; r++)
			if (i[r].name === t) return i[r];
		return null
	}
	static CreateClipsFromMorphTargetSequences(e, t, i) {
		const r = {},
			s = /^([\w-]*?)([\d]+)$/;
		for (let a = 0, l = e.length; a < l; a++) {
			const c = e[a],
				u = c.name.match(s);
			if (u && u.length > 1) {
				const h = u[1];
				let d = r[h];
				d || (r[h] = d = []), d.push(c)
			}
		}
		const o = [];
		for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
		return o
	}
	static parseAnimation(e, t) {
		if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
		const i = function (h, d, f, p, _) {
				if (f.length !== 0) {
					const g = [],
						m = [];
					YD(f, g, m, p), g.length !== 0 && _.push(new h(d, g, m))
				}
			},
			r = [],
			s = e.name || "default",
			o = e.fps || 30,
			a = e.blendMode;
		let l = e.length || -1;
		const c = e.hierarchy || [];
		for (let h = 0; h < c.length; h++) {
			const d = c[h].keys;
			if (!(!d || d.length === 0))
				if (d[0].morphTargets) {
					const f = {};
					let p;
					for (p = 0; p < d.length; p++)
						if (d[p].morphTargets)
							for (let _ = 0; _ < d[p].morphTargets.length; _++) f[d[p].morphTargets[_]] = -1;
					for (const _ in f) {
						const g = [],
							m = [];
						for (let b = 0; b !== d[p].morphTargets.length; ++b) {
							const v = d[p];
							g.push(v.time), m.push(v.morphTarget === _ ? 1 : 0)
						}
						r.push(new du(".morphTargetInfluence[" + _ + "]", g, m))
					}
					l = f.length * o
				} else {
					const f = ".bones[" + t[h].name + "]";
					i(fu, f + ".position", d, "pos", r), i(Dl, f + ".quaternion", d, "rot", r), i(fu, f + ".scale", d, "scl", r)
				}
		}
		return r.length === 0 ? null : new this(s, l, r, a)
	}
	resetDuration() {
		const e = this.tracks;
		let t = 0;
		for (let i = 0, r = e.length; i !== r; ++i) {
			const s = this.tracks[i];
			t = Math.max(t, s.times[s.times.length - 1])
		}
		return this.duration = t, this
	}
	trim() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
		return this
	}
	validate() {
		let e = !0;
		for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
		return e
	}
	optimize() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
		return this
	}
	clone() {
		const e = [];
		for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
		return new this.constructor(this.name, this.duration, e, this.blendMode)
	}
	toJSON() {
		return this.constructor.toJSON(this)
	}
}

function dq(n) {
	switch (n.toLowerCase()) {
		case "scalar":
		case "double":
		case "float":
		case "number":
		case "integer":
			return du;
		case "vector":
		case "vector2":
		case "vector3":
		case "vector4":
			return fu;
		case "color":
			return KD;
		case "quaternion":
			return Dl;
		case "bool":
		case "boolean":
			return Cu;
		case "string":
			return Au
	}
	throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}

function fq(n) {
	if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
	const e = dq(n.type);
	if (n.times === void 0) {
		const t = [],
			i = [];
		YD(n.keys, t, i, "value"), n.times = t, n.values = i
	}
	return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const ea = {
	enabled: !1,
	files: {},
	add: function (n, e) {
		this.enabled !== !1 && (this.files[n] = e)
	},
	get: function (n) {
		if (this.enabled !== !1) return this.files[n]
	},
	remove: function (n) {
		delete this.files[n]
	},
	clear: function () {
		this.files = {}
	}
};
class pq {
	constructor(e, t, i) {
		const r = this;
		let s = !1,
			o = 0,
			a = 0,
			l;
		const c = [];
		this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (u) {
			a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), s = !0
		}, this.itemEnd = function (u) {
			o++, r.onProgress !== void 0 && r.onProgress(u, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad())
		}, this.itemError = function (u) {
			r.onError !== void 0 && r.onError(u)
		}, this.resolveURL = function (u) {
			return l ? l(u) : u
		}, this.setURLModifier = function (u) {
			return l = u, this
		}, this.addHandler = function (u, h) {
			return c.push(u, h), this
		}, this.removeHandler = function (u) {
			const h = c.indexOf(u);
			return h !== -1 && c.splice(h, 2), this
		}, this.getHandler = function (u) {
			for (let h = 0, d = c.length; h < d; h += 2) {
				const f = c[h],
					p = c[h + 1];
				if (f.global && (f.lastIndex = 0), f.test(u)) return p
			}
			return null
		}
	}
}
const mq = new pq;
class Fl {
	constructor(e) {
		this.manager = e !== void 0 ? e : mq, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
	}
	load() {}
	loadAsync(e, t) {
		const i = this;
		return new Promise(function (r, s) {
			i.load(e, r, t, s)
		})
	}
	parse() {}
	setCrossOrigin(e) {
		return this.crossOrigin = e, this
	}
	setWithCredentials(e) {
		return this.withCredentials = e, this
	}
	setPath(e) {
		return this.path = e, this
	}
	setResourcePath(e) {
		return this.resourcePath = e, this
	}
	setRequestHeader(e) {
		return this.requestHeader = e, this
	}
}
Fl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ws = {};
class gq extends Error {
	constructor(e, t) {
		super(e), this.response = t
	}
}
class um extends Fl {
	constructor(e) {
		super(e)
	}
	load(e, t, i, r) {
		e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
		const s = ea.get(e);
		if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
			t && t(s), this.manager.itemEnd(e)
		}, 0), s;
		if (Ws[e] !== void 0) {
			Ws[e].push({
				onLoad: t,
				onProgress: i,
				onError: r
			});
			return
		}
		Ws[e] = [], Ws[e].push({
			onLoad: t,
			onProgress: i,
			onError: r
		});
		const o = new Request(e, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? "include" : "same-origin"
			}),
			a = this.mimeType,
			l = this.responseType;
		fetch(o).then(c => {
			if (c.status === 200 || c.status === 0) {
				if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
				const u = Ws[e],
					h = c.body.getReader(),
					d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
					f = d ? parseInt(d) : 0,
					p = f !== 0;
				let _ = 0;
				const g = new ReadableStream({
					start(m) {
						b();

						function b() {
							h.read().then(({
								done: v,
								value: y
							}) => {
								if (v) m.close();
								else {
									_ += y.byteLength;
									const x = new ProgressEvent("progress", {
										lengthComputable: p,
										loaded: _,
										total: f
									});
									for (let S = 0, E = u.length; S < E; S++) {
										const C = u[S];
										C.onProgress && C.onProgress(x)
									}
									m.enqueue(y), b()
								}
							})
						}
					}
				});
				return new Response(g)
			} else throw new gq(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
		}).then(c => {
			switch (l) {
				case "arraybuffer":
					return c.arrayBuffer();
				case "blob":
					return c.blob();
				case "document":
					return c.text().then(u => new DOMParser().parseFromString(u, a));
				case "json":
					return c.json();
				default:
					if (a === void 0) return c.text(); {
						const h = /charset="?([^;"\s]*)"?/i.exec(a),
							d = h && h[1] ? h[1].toLowerCase() : void 0,
							f = new TextDecoder(d);
						return c.arrayBuffer().then(p => f.decode(p))
					}
			}
		}).then(c => {
			ea.add(e, c);
			const u = Ws[e];
			delete Ws[e];
			for (let h = 0, d = u.length; h < d; h++) {
				const f = u[h];
				f.onLoad && f.onLoad(c)
			}
		}).catch(c => {
			const u = Ws[e];
			if (u === void 0) throw this.manager.itemError(e), c;
			delete Ws[e];
			for (let h = 0, d = u.length; h < d; h++) {
				const f = u[h];
				f.onError && f.onError(c)
			}
			this.manager.itemError(e)
		}).finally(() => {
			this.manager.itemEnd(e)
		}), this.manager.itemStart(e)
	}
	setResponseType(e) {
		return this.responseType = e, this
	}
	setMimeType(e) {
		return this.mimeType = e, this
	}
}
class _q extends Fl {
	constructor(e) {
		super(e)
	}
	load(e, t, i, r) {
		this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
		const s = this,
			o = ea.get(e);
		if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () {
			t && t(o), s.manager.itemEnd(e)
		}, 0), o;
		const a = hd("img");

		function l() {
			u(), ea.add(e, this), t && t(this), s.manager.itemEnd(e)
		}

		function c(h) {
			u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e)
		}

		function u() {
			a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
		}
		return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
	}
}
class t0 extends Fl {
	constructor(e) {
		super(e)
	}
	load(e, t, i, r) {
		const s = new Kn,
			o = new _q(this.manager);
		return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) {
			s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
		}, i, r), s
	}
}
class n0 extends ht {
	constructor(e, t = 1) {
		super(), this.isLight = !0, this.type = "Light", this.color = new et(e), this.intensity = t
	}
	dispose() {}
	copy(e, t) {
		return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
	}
}
const Vg = new pt,
	BE = new X,
	zE = new X;
class Vb {
	constructor(e) {
		this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Oe(512, 512), this.map = null, this.mapPass = null, this.matrix = new pt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new kb, this._frameExtents = new Oe(1, 1), this._viewportCount = 1, this._viewports = [new kt(0, 0, 1, 1)]
	}
	getViewportCount() {
		return this._viewportCount
	}
	getFrustum() {
		return this._frustum
	}
	updateMatrices(e) {
		const t = this.camera,
			i = this.matrix;
		BE.setFromMatrixPosition(e.matrixWorld), t.position.copy(BE), zE.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(zE), t.updateMatrixWorld(), Vg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Vg), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(Vg)
	}
	getViewport(e) {
		return this._viewports[e]
	}
	getFrameExtents() {
		return this._frameExtents
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
	}
	copy(e) {
		return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	toJSON() {
		const e = {};
		return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
	}
}
class vq extends Vb {
	constructor() {
		super(new Yn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
	}
	updateMatrices(e) {
		const t = this.camera,
			i = uu * 2 * e.angle * this.focus,
			r = this.mapSize.width / this.mapSize.height,
			s = e.distance || t.far;
		(i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
	}
	copy(e) {
		return super.copy(e), this.focus = e.focus, this
	}
}
class bq extends n0 {
	constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
		super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ht.DEFAULT_UP), this.updateMatrix(), this.target = new ht, this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new vq
	}
	get power() {
		return this.intensity * Math.PI
	}
	set power(e) {
		this.intensity = e / Math.PI
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e, t) {
		return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
	}
}
const VE = new pt,
	ju = new X,
	Hg = new X;
class yq extends Vb {
	constructor() {
		super(new Yn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Oe(4, 2), this._viewportCount = 6, this._viewports = [new kt(2, 1, 1, 1), new kt(0, 1, 1, 1), new kt(3, 1, 1, 1), new kt(1, 1, 1, 1), new kt(3, 0, 1, 1), new kt(1, 0, 1, 1)], this._cubeDirections = [new X(1, 0, 0), new X(-1, 0, 0), new X(0, 0, 1), new X(0, 0, -1), new X(0, 1, 0), new X(0, -1, 0)], this._cubeUps = [new X(0, 1, 0), new X(0, 1, 0), new X(0, 1, 0), new X(0, 1, 0), new X(0, 0, 1), new X(0, 0, -1)]
	}
	updateMatrices(e, t = 0) {
		const i = this.camera,
			r = this.matrix,
			s = e.distance || i.far;
		s !== i.far && (i.far = s, i.updateProjectionMatrix()), ju.setFromMatrixPosition(e.matrixWorld), i.position.copy(ju), Hg.copy(i.position), Hg.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Hg), i.updateMatrixWorld(), r.makeTranslation(-ju.x, -ju.y, -ju.z), VE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(VE)
	}
}
class xq extends n0 {
	constructor(e, t, i = 0, r = 2) {
		super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new yq
	}
	get power() {
		return this.intensity * 4 * Math.PI
	}
	set power(e) {
		this.intensity = e / (4 * Math.PI)
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e, t) {
		return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
	}
}
class wq extends Vb {
	constructor() {
		super(new Jm(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
	}
}
class Eq extends n0 {
	constructor(e, t) {
		super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ht.DEFAULT_UP), this.updateMatrix(), this.target = new ht, this.shadow = new wq
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e) {
		return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
	}
}
class ZD extends n0 {
	constructor(e, t) {
		super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
	}
}
class Oh {
	static decodeText(e) {
		if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
		let t = "";
		for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
		try {
			return decodeURIComponent(escape(t))
		} catch {
			return t
		}
	}
	static extractUrlBase(e) {
		const t = e.lastIndexOf("/");
		return t === -1 ? "./" : e.slice(0, t + 1)
	}
	static resolveURL(e, t) {
		return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
	}
}
class JD extends gi {
	constructor() {
		super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
	}
	copy(e) {
		return super.copy(e), this.instanceCount = e.instanceCount, this
	}
	toJSON() {
		const e = super.toJSON();
		return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
	}
}
class Sq extends Fl {
	constructor(e) {
		super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
			premultiplyAlpha: "none"
		}
	}
	setOptions(e) {
		return this.options = e, this
	}
	load(e, t, i, r) {
		e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
		const s = this,
			o = ea.get(e);
		if (o !== void 0) {
			if (s.manager.itemStart(e), o.then) {
				o.then(c => {
					t && t(c), s.manager.itemEnd(e)
				}).catch(c => {
					r && r(c)
				});
				return
			}
			return setTimeout(function () {
				t && t(o), s.manager.itemEnd(e)
			}, 0), o
		}
		const a = {};
		a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
		const l = fetch(e, a).then(function (c) {
			return c.blob()
		}).then(function (c) {
			return createImageBitmap(c, Object.assign(s.options, {
				colorSpaceConversion: "none"
			}))
		}).then(function (c) {
			return ea.add(e, c), t && t(c), s.manager.itemEnd(e), c
		}).catch(function (c) {
			r && r(c), ea.remove(e), s.manager.itemError(e), s.manager.itemEnd(e)
		});
		ea.add(e, l), s.manager.itemStart(e)
	}
}
const Hb = "\\[\\]\\.:\\/",
	Tq = new RegExp("[" + Hb + "]", "g"),
	Gb = "[^" + Hb + "]",
	Mq = "[^" + Hb.replace("\\.", "") + "]",
	Cq = /((?:WC+[\/:])*)/.source.replace("WC", Gb),
	Aq = /(WCOD+)?/.source.replace("WCOD", Mq),
	Dq = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Gb),
	Pq = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Gb),
	Rq = new RegExp("^" + Cq + Aq + Dq + Pq + "$"),
	Lq = ["material", "materials", "bones", "map"];
class kq {
	constructor(e, t, i) {
		const r = i || zt.parseTrackName(t);
		this._targetGroup = e, this._bindings = e.subscribe_(t, r)
	}
	getValue(e, t) {
		this.bind();
		const i = this._targetGroup.nCachedObjects_,
			r = this._bindings[i];
		r !== void 0 && r.getValue(e, t)
	}
	setValue(e, t) {
		const i = this._bindings;
		for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t)
	}
	bind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
	}
	unbind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
	}
}
class zt {
	constructor(e, t, i) {
		this.path = t, this.parsedPath = i || zt.parseTrackName(t), this.node = zt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
	static create(e, t, i) {
		return e && e.isAnimationObjectGroup ? new zt.Composite(e, t, i) : new zt(e, t, i)
	}
	static sanitizeNodeName(e) {
		return e.replace(/\s/g, "_").replace(Tq, "")
	}
	static parseTrackName(e) {
		const t = Rq.exec(e);
		if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
		const i = {
				nodeName: t[2],
				objectName: t[3],
				objectIndex: t[4],
				propertyName: t[5],
				propertyIndex: t[6]
			},
			r = i.nodeName && i.nodeName.lastIndexOf(".");
		if (r !== void 0 && r !== -1) {
			const s = i.nodeName.substring(r + 1);
			Lq.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s)
		}
		if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
		return i
	}
	static findNode(e, t) {
		if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
		if (e.skeleton) {
			const i = e.skeleton.getBoneByName(t);
			if (i !== void 0) return i
		}
		if (e.children) {
			const i = function (s) {
					for (let o = 0; o < s.length; o++) {
						const a = s[o];
						if (a.name === t || a.uuid === t) return a;
						const l = i(a.children);
						if (l) return l
					}
					return null
				},
				r = i(e.children);
			if (r) return r
		}
		return null
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(e, t) {
		e[t] = this.targetObject[this.propertyName]
	}
	_getValue_array(e, t) {
		const i = this.resolvedProperty;
		for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
	}
	_getValue_arrayElement(e, t) {
		e[t] = this.resolvedProperty[this.propertyIndex]
	}
	_getValue_toArray(e, t) {
		this.resolvedProperty.toArray(e, t)
	}
	_setValue_direct(e, t) {
		this.targetObject[this.propertyName] = e[t]
	}
	_setValue_direct_setNeedsUpdate(e, t) {
		this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
		this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_array(e, t) {
		const i = this.resolvedProperty;
		for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
	}
	_setValue_array_setNeedsUpdate(e, t) {
		const i = this.resolvedProperty;
		for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
		this.targetObject.needsUpdate = !0
	}
	_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
		const i = this.resolvedProperty;
		for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
		this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_arrayElement(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t]
	}
	_setValue_arrayElement_setNeedsUpdate(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_fromArray(e, t) {
		this.resolvedProperty.fromArray(e, t)
	}
	_setValue_fromArray_setNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_getValue_unbound(e, t) {
		this.bind(), this.getValue(e, t)
	}
	_setValue_unbound(e, t) {
		this.bind(), this.setValue(e, t)
	}
	bind() {
		let e = this.node;
		const t = this.parsedPath,
			i = t.objectName,
			r = t.propertyName;
		let s = t.propertyIndex;
		if (e || (e = zt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
			console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
			return
		}
		if (i) {
			let c = t.objectIndex;
			switch (i) {
				case "materials":
					if (!e.material) {
						console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
						return
					}
					if (!e.material.materials) {
						console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
						return
					}
					e = e.material.materials;
					break;
				case "bones":
					if (!e.skeleton) {
						console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
						return
					}
					e = e.skeleton.bones;
					for (let u = 0; u < e.length; u++)
						if (e[u].name === c) {
							c = u;
							break
						} break;
				case "map":
					if ("map" in e) {
						e = e.map;
						break
					}
					if (!e.material) {
						console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
						return
					}
					if (!e.material.map) {
						console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
						return
					}
					e = e.material.map;
					break;
				default:
					if (e[i] === void 0) {
						console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
						return
					}
					e = e[i]
			}
			if (c !== void 0) {
				if (e[c] === void 0) {
					console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
					return
				}
				e = e[c]
			}
		}
		const o = e[r];
		if (o === void 0) {
			const c = t.nodeName;
			console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
			return
		}
		let a = this.Versioning.None;
		this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
		let l = this.BindingType.Direct;
		if (s !== void 0) {
			if (r === "morphTargetInfluences") {
				if (!e.geometry) {
					console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
					return
				}
				if (!e.geometry.morphAttributes) {
					console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
					return
				}
				e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
			}
			l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
		} else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
		this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
	}
	unbind() {
		this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
}
zt.Composite = kq;
zt.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};
zt.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};
zt.prototype.GetterByBindingType = [zt.prototype._getValue_direct, zt.prototype._getValue_array, zt.prototype._getValue_arrayElement, zt.prototype._getValue_toArray];
zt.prototype.SetterByBindingTypeAndVersioning = [
	[zt.prototype._setValue_direct, zt.prototype._setValue_direct_setNeedsUpdate, zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
	[zt.prototype._setValue_array, zt.prototype._setValue_array_setNeedsUpdate, zt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
	[zt.prototype._setValue_arrayElement, zt.prototype._setValue_arrayElement_setNeedsUpdate, zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
	[zt.prototype._setValue_fromArray, zt.prototype._setValue_fromArray_setNeedsUpdate, zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class QD extends WD {
	constructor(e, t, i = 1) {
		super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i
	}
	copy(e) {
		return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
	}
	clone(e) {
		const t = super.clone(e);
		return t.meshPerAttribute = this.meshPerAttribute, t
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
	}
}
const HE = new pt;
class Iq {
	constructor(e, t, i = 0, r = 1 / 0) {
		this.ray = new Su(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Pb, this.params = {
			Mesh: {},
			Line: {
				threshold: 1
			},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		}
	}
	set(e, t) {
		this.ray.set(e, t)
	}
	setFromCamera(e, t) {
		t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
	}
	setFromXRController(e) {
		return HE.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(HE), this
	}
	intersectObject(e, t = !0, i = []) {
		return Fv(e, this, i, t), i.sort(GE), i
	}
	intersectObjects(e, t = !0, i = []) {
		for (let r = 0, s = e.length; r < s; r++) Fv(e[r], this, i, t);
		return i.sort(GE), i
	}
}

function GE(n, e) {
	return n.distance - e.distance
}

function Fv(n, e, t, i) {
	if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) {
		const r = n.children;
		for (let s = 0, o = r.length; s < o; s++) Fv(r[s], e, t, !0)
	}
}
class WE {
	constructor(e = 1, t = 0, i = 0) {
		return this.radius = e, this.phi = t, this.theta = i, this
	}
	set(e, t, i) {
		return this.radius = e, this.phi = t, this.theta = i, this
	}
	copy(e) {
		return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
	}
	makeSafe() {
		return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
	}
	setFromVector3(e) {
		return this.setFromCartesianCoords(e.x, e.y, e.z)
	}
	setFromCartesianCoords(e, t, i) {
		return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(ti(t / this.radius, -1, 1))), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
const qf = new ks;
class Oq extends qD {
	constructor(e, t = 16776960) {
		const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
			r = new Float32Array(8 * 3),
			s = new gi;
		s.setIndex(new Cn(i, 1)), s.setAttribute("position", new Cn(r, 3)), super(s, new Bb({
			color: t,
			toneMapped: !1
		})), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
	}
	update(e) {
		if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && qf.setFromObject(this.object), qf.isEmpty()) return;
		const t = qf.min,
			i = qf.max,
			r = this.geometry.attributes.position,
			s = r.array;
		s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
	}
	setFromObject(e) {
		return this.object = e, this.update(), this
	}
	copy(e, t) {
		return super.copy(e, t), this.object = e.object, this
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose()
	}
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
	detail: {
		revision: Mb
	}
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Mb);
var eP = typeof window < "u" && new class {
	constructor() {
		this.raf = n => {
			requestAnimationFrame(this.raf);
			const e = n - this.now;
			this.now = n;
			for (let t = 0; t < this.callbacks.length; t++) this.callbacks[t].callback(n, e)
		}, this.callbacks = [], this.now = performance.now(), requestAnimationFrame(this.raf)
	}
	add(n, e = 0) {
		return this.callbacks.push({
			callback: n,
			priority: e
		}), this.callbacks.sort((t, i) => t.priority - i.priority), () => this.remove(n)
	}
	remove(n) {
		this.callbacks = this.callbacks.filter(({
			callback: e
		}) => n !== e)
	}
};

function pu(n, e = 0, t = 1) {
	return Math.min(Math.max(n, e), t)
}

function zc(n, e, t, i, r) {
	return i + (r - i) * ((n - e) / (t - e))
}

function Gg(n, e, t, i, r) {
	const s = i + (r - i) * ((n - e) / (t - e));
	return Math.max(i, Math.min(r, s))
}
const Fq = Nl;

function Nl(n, e, t) {
	return n * (1 - t) + e * t
}

function Ur(n, e, t, i) {
	return Nl(n, e, 1 - Math.exp(-t * .05 * i))
}

function Wg(n = 6) {
	const e = new Float64Array(n),
		t = {
			value: 0,
			push: o,
			reset: a
		};
	let i, r, s;
	return i = r = s = 0, t;

	function o(l) {
		i < n && i++, s = (s + 1) % n;
		const c = e[s];
		return e[s] = l, r += l - c, t.value = r / i
	}

	function a() {
		i = r = s = 0;
		for (let l = 0; l < n; l++) e[l] = 0
	}
}

function jE(n) {
	function e(r) {
		(n = (r | 0) % 2147483647) <= 0 && (n += 2147483646)
	}

	function t() {
		return n = n * 48271 % 2147483647
	}

	function i() {
		return (t() - 1) / 2147483646
	}
	return e(n), {
		seed: e,
		nextInt: t,
		nextFloat: i
	}
}

function Nq(n = 0) {
	let e = jE(n);
	return e.nextFloat(), e.nextFloat(), {
		setSeed: t,
		random: i,
		randomFloat: r,
		randomInt: s,
		hash2d: l,
		hash2dInt: c
	};

	function t(u) {
		n = u, e = jE(n)
	}

	function i() {
		return e.nextFloat()
	}

	function r(u = 0, h = 1) {
		return e.nextFloat() * (h - u) + u
	}

	function s(u, h) {
		return Math.floor(e.nextFloat() * (h - u + 1)) + u
	}

	function o(u) {
		return u - Math.floor(u)
	}

	function a(u, h, d, f) {
		return u * f - d * h
	}

	function l(u, h) {
		return o(Math.sin(a(u, h, 12.9898, 78.233)) * 43758.5453)
	}

	function c(u, h, d, f) {
		return Math.floor(l(u, h) * (f - d + 1)) + d
	}
}
const Rt = Nq(Date.now()),
	Uq = un({
		name: "touch",
		parallel: !0,
		dependsOn: ["viewport"],
		async setup(n) {
			new Oe;
			let e = !1,
				t = !1;
			const {
				setIsTouch: i
			} = Ct();
			i("ontouchstart" in document.documentElement);
			const {
				$viewport: r,
				callHook: s
			} = Ke(), o = Ii({
				pressed: !1,
				pos: new Oe(0, 0),
				delta: new Oe,
				normalizePos: new Oe,
				dragDelta: new Oe
			}), a = {
				pressed: !1,
				pos: new Oe,
				delta: new Oe,
				normalizePos: new Oe,
				firstPos: new Oe,
				prevPos: new Oe
			};
			async function l() {
				window.addEventListener("mousemove", p), window.addEventListener("mousedown", c), window.addEventListener("mouseup", f), window.addEventListener("touchstart", u), window.addEventListener("touchmove", h), window.addEventListener("touchend", d), eP.add(_)
			}

			function c(m) {
				a.delta.set(0, 0), a.firstPos.set(m.clientX, m.clientY), a.prevPos.copy(a.firstPos), a.pos.copy(a.firstPos), a.pressed = !0, s("MOUSE:DOWN"), e = !0
			}

			function u(m) {
				a.delta.set(0, 0), a.firstPos.set(m.changedTouches[0].clientX || 0, m.changedTouches[0].clientY || 0), a.prevPos.copy(a.firstPos), a.pos.copy(a.firstPos), a.pressed = !0, e = !0
			}

			function h(m) {
				t = !0, a.pos.set(m.changedTouches[0].clientX || 0, m.changedTouches[0].clientY || 0)
			}

			function d(m) {
				a.pos.set(m.changedTouches[0].clientX || 0, m.changedTouches[0].clientY || 0), a.pressed = !1, e = !0
			}

			function f(m) {
				a.pos.set(m.clientX, m.clientY), a.pressed = !1, e = !0
			}

			function p(m) {
				t = !0, a.pos.set(m.clientX, m.clientY)
			}

			function _() {
				a.delta.copy(a.pos).sub(a.prevPos), a.prevPos.copy(a.pos);
				const m = o.delta;
				e || (e = !a.delta.equals(m) || a.delta !== 0), e && g(), e = !1
			}

			function g() {
				o.pressed = a.pressed, o.pos.copy(a.pos), o.delta.copy(a.delta);
				const m = {
					x: r.width,
					y: r.height
				};
				o.normalizePos.set(zc(a.pos.x, 0, m.x, -1, 1), zc(a.pos.y, 0, m.y, 1, -1)), t || o.normalizePos.set(0, 0)
			}
			return l(), {
				provide: {
					touch: o
				}
			}
		}
	}),
	Xf = document.documentElement;
let Rr;

function Bq() {
	Rr = document.createElement("div"), Object.assign(Rr.style, {
		position: "fixed",
		top: 0,
		left: 0,
		width: "200px",
		height: "10px",
		overflowY: "scroll",
		pointerEvents: "none",
		userSelect: "none",
		zIndex: -1,
		opacity: 0
	});

	function n() {
		const t = document.createElement("div"),
			i = {
				width: "1px",
				height: "100lvh",
				overflowY: "hidden"
			};
		Object.assign(Rr.style, {
			width: "200px",
			height: "10px",
			overflowY: "scroll"
		}), Object.assign(t.style, {
			width: "100%",
			height: "150%"
		}), Rr.appendChild(t), document.body.appendChild(Rr);
		const r = parseFloat(getComputedStyle(Xf).zoom),
			s = isNaN(r) ? 1 : r,
			o = Math.round((200 - Rr.clientWidth) * s);
		return Xf.style.setProperty("--scrollbar-width", o + "px"), document.body.removeChild(Rr), Rr.removeChild(t), Object.assign(Rr.style, i), o
	}

	function e() {
		document.body.appendChild(Rr);
		const i = Rr.getBoundingClientRect().height;
		return document.body.removeChild(Rr), Xf.style.setProperty("--inner-height", window.innerHeight + "px"), Xf.style.setProperty("--vp-height", i + "px"), i
	}
	return {
		measureScrollbarWidth: n,
		measureViewportHeight: e
	}
}
const zq = un({
	name: "viewport",
	parallel: !0,
	async setup(n) {
		const {
			setWindowSize: e
		} = Ct(), {
			scrollMode: t
		} = $t(Ct());
		let i = null;
		const r = xz(l, 200, {
				trail: !1
			}),
			s = Ii({
				width: 10,
				height: 10,
				domHeight: 10,
				viewportRatio: 1,
				pixelRatio: 1,
				visible: !0,
				scrollBar: 0,
				started: !1
			});

		function o() {
			i = Bq(), s.scrollBar = i.measureScrollbarWidth(), a(), document.addEventListener("visibilitychange", h, !1), window.addEventListener("resize", () => {
				r()
			}, !1), window.addEventListener("orientationchange", () => {
				c()
			}, !1), l()
		}

		function a() {
			return window.matchMedia("(orientation: landscape)").matches
		}

		function l(d = !0) {
			u(), a(), t.value === "desktop" && window.innerWidth < 768 && B_({
				force: !0
			}), t.value === "mobile" && window.innerWidth > 768 && B_({
				force: !0
			}), s.width = window.innerWidth, s.height = window.innerHeight, s.domHeight = i.measureViewportHeight(), s.viewportRatio = s.width / s.height, s.started = !0, at.update(), e({
				width: s.width,
				height: s.height
			}), n.callHook("WINDOW:RESIZE")
		}

		function c() {
			n.callHook("WINDOW:ORIENTATION")
		}

		function u() {
			s.pixelRatio = Math.min(2, window.devicePixelRatio || 1)
		}

		function h() {
			s.visible = !document.hidden, l()
		}
		return o(), {
			provide: {
				viewport: s
			}
		}
	}
});

function Vq(n) {
	return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}

function mte(n) {
	if (n.__esModule) return n;
	var e = n.default;
	if (typeof e == "function") {
		var t = function i() {
			return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
		};
		t.prototype = e.prototype
	} else t = {};
	return Object.defineProperty(t, "__esModule", {
		value: !0
	}), Object.keys(n).forEach(function (i) {
		var r = Object.getOwnPropertyDescriptor(n, i);
		Object.defineProperty(t, i, r.get ? r : {
			enumerable: !0,
			get: function () {
				return n[i]
			}
		})
	}), t
}
var tP = {
	exports: {}
};
(function (n) {
	(function () {
		function e(M, W, le) {
			return M.call.apply(M.bind, arguments)
		}

		function t(M, W, le) {
			if (!M) throw Error();
			if (2 < arguments.length) {
				var J = Array.prototype.slice.call(arguments, 2);
				return function () {
					var oe = Array.prototype.slice.call(arguments);
					return Array.prototype.unshift.apply(oe, J), M.apply(W, oe)
				}
			}
			return function () {
				return M.apply(W, arguments)
			}
		}

		function i(M, W, le) {
			return i = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? e : t, i.apply(null, arguments)
		}
		var r = Date.now || function () {
			return +new Date
		};

		function s(M, W) {
			this.a = M, this.o = W || M, this.c = this.o.document
		}
		var o = !!window.FontFace;

		function a(M, W, le, J) {
			if (W = M.c.createElement(W), le)
				for (var oe in le) le.hasOwnProperty(oe) && (oe == "style" ? W.style.cssText = le[oe] : W.setAttribute(oe, le[oe]));
			return J && W.appendChild(M.c.createTextNode(J)), W
		}

		function l(M, W, le) {
			M = M.c.getElementsByTagName(W)[0], M || (M = document.documentElement), M.insertBefore(le, M.lastChild)
		}

		function c(M) {
			M.parentNode && M.parentNode.removeChild(M)
		}

		function u(M, W, le) {
			W = W || [], le = le || [];
			for (var J = M.className.split(/\s+/), oe = 0; oe < W.length; oe += 1) {
				for (var _e = !1, I = 0; I < J.length; I += 1)
					if (W[oe] === J[I]) {
						_e = !0;
						break
					} _e || J.push(W[oe])
			}
			for (W = [], oe = 0; oe < J.length; oe += 1) {
				for (_e = !1, I = 0; I < le.length; I += 1)
					if (J[oe] === le[I]) {
						_e = !0;
						break
					} _e || W.push(J[oe])
			}
			M.className = W.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
		}

		function h(M, W) {
			for (var le = M.className.split(/\s+/), J = 0, oe = le.length; J < oe; J++)
				if (le[J] == W) return !0;
			return !1
		}

		function d(M) {
			return M.o.location.hostname || M.a.location.hostname
		}

		function f(M, W, le) {
			function J() {
				ee && oe && _e && (ee(I), ee = null)
			}
			W = a(M, "link", {
				rel: "stylesheet",
				href: W,
				media: "all"
			});
			var oe = !1,
				_e = !0,
				I = null,
				ee = le || null;
			o ? (W.onload = function () {
				oe = !0, J()
			}, W.onerror = function () {
				oe = !0, I = Error("Stylesheet failed to load"), J()
			}) : setTimeout(function () {
				oe = !0, J()
			}, 0), l(M, "head", W)
		}

		function p(M, W, le, J) {
			var oe = M.c.getElementsByTagName("head")[0];
			if (oe) {
				var _e = a(M, "script", {
						src: W
					}),
					I = !1;
				return _e.onload = _e.onreadystatechange = function () {
					I || this.readyState && this.readyState != "loaded" && this.readyState != "complete" || (I = !0, le && le(null), _e.onload = _e.onreadystatechange = null, _e.parentNode.tagName == "HEAD" && oe.removeChild(_e))
				}, oe.appendChild(_e), setTimeout(function () {
					I || (I = !0, le && le(Error("Script load timeout")))
				}, J || 5e3), _e
			}
			return null
		}

		function _() {
			this.a = 0, this.c = null
		}

		function g(M) {
			return M.a++,
				function () {
					M.a--, b(M)
				}
		}

		function m(M, W) {
			M.c = W, b(M)
		}

		function b(M) {
			M.a == 0 && M.c && (M.c(), M.c = null)
		}

		function v(M) {
			this.a = M || "-"
		}
		v.prototype.c = function (M) {
			for (var W = [], le = 0; le < arguments.length; le++) W.push(arguments[le].replace(/[\W_]+/g, "").toLowerCase());
			return W.join(this.a)
		};

		function y(M, W) {
			this.c = M, this.f = 4, this.a = "n";
			var le = (W || "n4").match(/^([nio])([1-9])$/i);
			le && (this.a = le[1], this.f = parseInt(le[2], 10))
		}

		function x(M) {
			return C(M) + " " + (M.f + "00") + " 300px " + S(M.c)
		}

		function S(M) {
			var W = [];
			M = M.split(/,\s*/);
			for (var le = 0; le < M.length; le++) {
				var J = M[le].replace(/['"]/g, "");
				J.indexOf(" ") != -1 || /^\d/.test(J) ? W.push("'" + J + "'") : W.push(J)
			}
			return W.join(",")
		}

		function E(M) {
			return M.a + M.f
		}

		function C(M) {
			var W = "normal";
			return M.a === "o" ? W = "oblique" : M.a === "i" && (W = "italic"), W
		}

		function P(M) {
			var W = 4,
				le = "n",
				J = null;
			return M && ((J = M.match(/(normal|oblique|italic)/i)) && J[1] && (le = J[1].substr(0, 1).toLowerCase()), (J = M.match(/([1-9]00|normal|bold)/i)) && J[1] && (/bold/i.test(J[1]) ? W = 7 : /[1-9]00/.test(J[1]) && (W = parseInt(J[1].substr(0, 1), 10)))), le + W
		}

		function w(M, W) {
			this.c = M, this.f = M.o.document.documentElement, this.h = W, this.a = new v("-"), this.j = W.events !== !1, this.g = W.classes !== !1
		}

		function D(M) {
			M.g && u(M.f, [M.a.c("wf", "loading")]), j(M, "loading")
		}

		function U(M) {
			if (M.g) {
				var W = h(M.f, M.a.c("wf", "active")),
					le = [],
					J = [M.a.c("wf", "loading")];
				W || le.push(M.a.c("wf", "inactive")), u(M.f, le, J)
			}
			j(M, "inactive")
		}

		function j(M, W, le) {
			M.j && M.h[W] && (le ? M.h[W](le.c, E(le)) : M.h[W]())
		}

		function z() {
			this.c = {}
		}

		function H(M, W, le) {
			var J = [],
				oe;
			for (oe in W)
				if (W.hasOwnProperty(oe)) {
					var _e = M.c[oe];
					_e && J.push(_e(W[oe], le))
				} return J
		}

		function F(M, W) {
			this.c = M, this.f = W, this.a = a(this.c, "span", {
				"aria-hidden": "true"
			}, this.f)
		}

		function G(M) {
			l(M.c, "body", M.a)
		}

		function R(M) {
			return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + S(M.c) + ";" + ("font-style:" + C(M) + ";font-weight:" + (M.f + "00") + ";")
		}

		function Q(M, W, le, J, oe, _e) {
			this.g = M, this.j = W, this.a = J, this.c = le, this.f = oe || 3e3, this.h = _e || void 0
		}
		Q.prototype.start = function () {
			var M = this.c.o.document,
				W = this,
				le = r(),
				J = new Promise(function (I, ee) {
					function De() {
						r() - le >= W.f ? ee() : M.fonts.load(x(W.a), W.h).then(function (V) {
							1 <= V.length ? I() : setTimeout(De, 25)
						}, function () {
							ee()
						})
					}
					De()
				}),
				oe = null,
				_e = new Promise(function (I, ee) {
					oe = setTimeout(ee, W.f)
				});
			Promise.race([_e, J]).then(function () {
				oe && (clearTimeout(oe), oe = null), W.g(W.a)
			}, function () {
				W.j(W.a)
			})
		};

		function B(M, W, le, J, oe, _e, I) {
			this.v = M, this.B = W, this.c = le, this.a = J, this.s = I || "BESbswy", this.f = {}, this.w = oe || 3e3, this.u = _e || null, this.m = this.j = this.h = this.g = null, this.g = new F(this.c, this.s), this.h = new F(this.c, this.s), this.j = new F(this.c, this.s), this.m = new F(this.c, this.s), M = new y(this.a.c + ",serif", E(this.a)), M = R(M), this.g.a.style.cssText = M, M = new y(this.a.c + ",sans-serif", E(this.a)), M = R(M), this.h.a.style.cssText = M, M = new y("serif", E(this.a)), M = R(M), this.j.a.style.cssText = M, M = new y("sans-serif", E(this.a)), M = R(M), this.m.a.style.cssText = M, G(this.g), G(this.h), G(this.j), G(this.m)
		}
		var ge = {
				D: "serif",
				C: "sans-serif"
			},
			Ae = null;

		function ze() {
			if (Ae === null) {
				var M = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
				Ae = !!M && (536 > parseInt(M[1], 10) || parseInt(M[1], 10) === 536 && 11 >= parseInt(M[2], 10))
			}
			return Ae
		}
		B.prototype.start = function () {
			this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = r(), ye(this)
		};

		function K(M, W, le) {
			for (var J in ge)
				if (ge.hasOwnProperty(J) && W === M.f[ge[J]] && le === M.f[ge[J]]) return !0;
			return !1
		}

		function ye(M) {
			var W = M.g.a.offsetWidth,
				le = M.h.a.offsetWidth,
				J;
			(J = W === M.f.serif && le === M.f["sans-serif"]) || (J = ze() && K(M, W, le)), J ? r() - M.A >= M.w ? ze() && K(M, W, le) && (M.u === null || M.u.hasOwnProperty(M.a.c)) ? Z(M, M.v) : Z(M, M.B) : Se(M) : Z(M, M.v)
		}

		function Se(M) {
			setTimeout(i(function () {
				ye(this)
			}, M), 50)
		}

		function Z(M, W) {
			setTimeout(i(function () {
				c(this.g.a), c(this.h.a), c(this.j.a), c(this.m.a), W(this.a)
			}, M), 0)
		}

		function pe(M, W, le) {
			this.c = M, this.a = W, this.f = 0, this.m = this.j = !1, this.s = le
		}
		var ce = null;
		pe.prototype.g = function (M) {
			var W = this.a;
			W.g && u(W.f, [W.a.c("wf", M.c, E(M).toString(), "active")], [W.a.c("wf", M.c, E(M).toString(), "loading"), W.a.c("wf", M.c, E(M).toString(), "inactive")]), j(W, "fontactive", M), this.m = !0, Ce(this)
		}, pe.prototype.h = function (M) {
			var W = this.a;
			if (W.g) {
				var le = h(W.f, W.a.c("wf", M.c, E(M).toString(), "active")),
					J = [],
					oe = [W.a.c("wf", M.c, E(M).toString(), "loading")];
				le || J.push(W.a.c("wf", M.c, E(M).toString(), "inactive")), u(W.f, J, oe)
			}
			j(W, "fontinactive", M), Ce(this)
		};

		function Ce(M) {
			--M.f == 0 && M.j && (M.m ? (M = M.a, M.g && u(M.f, [M.a.c("wf", "active")], [M.a.c("wf", "loading"), M.a.c("wf", "inactive")]), j(M, "active")) : U(M.a))
		}

		function Re(M) {
			this.j = M, this.a = new z, this.h = 0, this.f = this.g = !0
		}
		Re.prototype.load = function (M) {
			this.c = new s(this.j, M.context || this.j), this.g = M.events !== !1, this.f = M.classes !== !1, k(this, new w(this.c, M), M)
		};

		function Y(M, W, le, J, oe) {
			var _e = --M.h == 0;
			(M.f || M.g) && setTimeout(function () {
				var I = oe || null,
					ee = J || null || {};
				if (le.length === 0 && _e) U(W.a);
				else {
					W.f += le.length, _e && (W.j = _e);
					var De, V = [];
					for (De = 0; De < le.length; De++) {
						var be = le[De],
							te = ee[be.c],
							Ee = W.a,
							Ie = be;
						if (Ee.g && u(Ee.f, [Ee.a.c("wf", Ie.c, E(Ie).toString(), "loading")]), j(Ee, "fontloading", Ie), Ee = null, ce === null)
							if (window.FontFace) {
								var Ie = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
									st = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
								ce = Ie ? 42 < parseInt(Ie[1], 10) : !st
							} else ce = !1;
						ce ? Ee = new Q(i(W.g, W), i(W.h, W), W.c, be, W.s, te) : Ee = new B(i(W.g, W), i(W.h, W), W.c, be, W.s, I, te), V.push(Ee)
					}
					for (De = 0; De < V.length; De++) V[De].start()
				}
			}, 0)
		}

		function k(M, W, le) {
			var oe = [],
				J = le.timeout;
			D(W);
			var oe = H(M.a, le, M.c),
				_e = new pe(M.c, W, J);
			for (M.h = oe.length, W = 0, le = oe.length; W < le; W++) oe[W].load(function (I, ee, De) {
				Y(M, _e, I, ee, De)
			})
		}

		function O(M, W) {
			this.c = M, this.a = W
		}
		O.prototype.load = function (M) {
			function W() {
				if (_e["__mti_fntLst" + J]) {
					var I = _e["__mti_fntLst" + J](),
						ee = [],
						De;
					if (I)
						for (var V = 0; V < I.length; V++) {
							var be = I[V].fontfamily;
							I[V].fontStyle != null && I[V].fontWeight != null ? (De = I[V].fontStyle + I[V].fontWeight, ee.push(new y(be, De))) : ee.push(new y(be))
						}
					M(ee)
				} else setTimeout(function () {
					W()
				}, 50)
			}
			var le = this,
				J = le.a.projectId,
				oe = le.a.version;
			if (J) {
				var _e = le.c.o;
				p(this.c, (le.a.api || "https://fast.fonts.net/jsapi") + "/" + J + ".js" + (oe ? "?v=" + oe : ""), function (I) {
					I ? M([]) : (_e["__MonotypeConfiguration__" + J] = function () {
						return le.a
					}, W())
				}).id = "__MonotypeAPIScript__" + J
			} else M([])
		};

		function q(M, W) {
			this.c = M, this.a = W
		}
		q.prototype.load = function (M) {
			var W, le, J = this.a.urls || [],
				oe = this.a.families || [],
				_e = this.a.testStrings || {},
				I = new _;
			for (W = 0, le = J.length; W < le; W++) f(this.c, J[W], g(I));
			var ee = [];
			for (W = 0, le = oe.length; W < le; W++)
				if (J = oe[W].split(":"), J[1])
					for (var De = J[1].split(","), V = 0; V < De.length; V += 1) ee.push(new y(J[0], De[V]));
				else ee.push(new y(J[0]));
			m(I, function () {
				M(ee, _e)
			})
		};

		function ie(M, W) {
			M ? this.c = M : this.c = N, this.a = [], this.f = [], this.g = W || ""
		}
		var N = "https://fonts.googleapis.com/css";

		function me(M, W) {
			for (var le = W.length, J = 0; J < le; J++) {
				var oe = W[J].split(":");
				oe.length == 3 && M.f.push(oe.pop());
				var _e = "";
				oe.length == 2 && oe[1] != "" && (_e = ":"), M.a.push(oe.join(_e))
			}
		}

		function ve(M) {
			if (M.a.length == 0) throw Error("No fonts to load!");
			if (M.c.indexOf("kit=") != -1) return M.c;
			for (var W = M.a.length, le = [], J = 0; J < W; J++) le.push(M.a[J].replace(/ /g, "+"));
			return W = M.c + "?family=" + le.join("%7C"), 0 < M.f.length && (W += "&subset=" + M.f.join(",")), 0 < M.g.length && (W += "&text=" + encodeURIComponent(M.g)), W
		}

		function xe(M) {
			this.f = M, this.a = [], this.c = {}
		}
		var A = {
				latin: "BESbswy",
				"latin-ext": "çöüğş",
				cyrillic: "йяЖ",
				greek: "αβΣ",
				khmer: "កខគ",
				Hanuman: "កខគ"
			},
			T = {
				thin: "1",
				extralight: "2",
				"extra-light": "2",
				ultralight: "2",
				"ultra-light": "2",
				light: "3",
				regular: "4",
				book: "4",
				medium: "5",
				"semi-bold": "6",
				semibold: "6",
				"demi-bold": "6",
				demibold: "6",
				bold: "7",
				"extra-bold": "8",
				extrabold: "8",
				"ultra-bold": "8",
				ultrabold: "8",
				black: "9",
				heavy: "9",
				l: "3",
				r: "4",
				b: "7"
			},
			$ = {
				i: "i",
				italic: "i",
				n: "n",
				normal: "n"
			},
			re = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

		function se(M) {
			for (var W = M.f.length, le = 0; le < W; le++) {
				var J = M.f[le].split(":"),
					oe = J[0].replace(/\+/g, " "),
					_e = ["n4"];
				if (2 <= J.length) {
					var I, ee = J[1];
					if (I = [], ee)
						for (var ee = ee.split(","), De = ee.length, V = 0; V < De; V++) {
							var be;
							if (be = ee[V], be.match(/^[\w-]+$/)) {
								var te = re.exec(be.toLowerCase());
								if (te == null) be = "";
								else {
									if (be = te[2], be = be == null || be == "" ? "n" : $[be], te = te[1], te == null || te == "") te = "4";
									else var Ee = T[te],
										te = Ee || (isNaN(te) ? "4" : te.substr(0, 1));
									be = [be, te].join("")
								}
							} else be = "";
							be && I.push(be)
						}
					0 < I.length && (_e = I), J.length == 3 && (J = J[2], I = [], J = J ? J.split(",") : I, 0 < J.length && (J = A[J[0]]) && (M.c[oe] = J))
				}
				for (M.c[oe] || (J = A[oe]) && (M.c[oe] = J), J = 0; J < _e.length; J += 1) M.a.push(new y(oe, _e[J]))
			}
		}

		function ue(M, W) {
			this.c = M, this.a = W
		}
		var Me = {
			Arimo: !0,
			Cousine: !0,
			Tinos: !0
		};
		ue.prototype.load = function (M) {
			var W = new _,
				le = this.c,
				J = new ie(this.a.api, this.a.text),
				oe = this.a.families;
			me(J, oe);
			var _e = new xe(oe);
			se(_e), f(le, ve(J), g(W)), m(W, function () {
				M(_e.a, _e.c, Me)
			})
		};

		function Le(M, W) {
			this.c = M, this.a = W
		}
		Le.prototype.load = function (M) {
			var W = this.a.id,
				le = this.c.o;
			W ? p(this.c, (this.a.api || "https://use.typekit.net") + "/" + W + ".js", function (J) {
				if (J) M([]);
				else if (le.Typekit && le.Typekit.config && le.Typekit.config.fn) {
					J = le.Typekit.config.fn;
					for (var oe = [], _e = 0; _e < J.length; _e += 2)
						for (var I = J[_e], ee = J[_e + 1], De = 0; De < ee.length; De++) oe.push(new y(I, ee[De]));
					try {
						le.Typekit.load({
							events: !1,
							classes: !1,
							async: !0
						})
					} catch {}
					M(oe)
				}
			}, 2e3) : M([])
		};

		function we(M, W) {
			this.c = M, this.f = W, this.a = []
		}
		we.prototype.load = function (M) {
			var W = this.f.id,
				le = this.c.o,
				J = this;
			W ? (le.__webfontfontdeckmodule__ || (le.__webfontfontdeckmodule__ = {}), le.__webfontfontdeckmodule__[W] = function (oe, _e) {
				for (var I = 0, ee = _e.fonts.length; I < ee; ++I) {
					var De = _e.fonts[I];
					J.a.push(new y(De.name, P("font-weight:" + De.weight + ";font-style:" + De.style)))
				}
				M(J.a)
			}, p(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + d(this.c) + "/" + W + ".js", function (oe) {
				oe && M([])
			})) : M([])
		};
		var Te = new Re(window);
		Te.a.c.custom = function (M, W) {
			return new q(W, M)
		}, Te.a.c.fontdeck = function (M, W) {
			return new we(W, M)
		}, Te.a.c.monotype = function (M, W) {
			return new O(W, M)
		}, Te.a.c.typekit = function (M, W) {
			return new Le(W, M)
		}, Te.a.c.google = function (M, W) {
			return new ue(W, M)
		};
		var je = {
			load: i(Te.load, Te)
		};
		n.exports ? n.exports = je : (window.WebFont = je, window.WebFontConfig && Te.load(window.WebFontConfig))
	})()
})(tP);
var Hq = tP.exports;
const Gq = Vq(Hq),
	Wq = un({
		name: "webfontloader",
		parallel: !0,
		async setup(n) {
			const {
				setIsFontLoaded: e
			} = Ct();
			Gq.load({
				custom: {
					families: ["LayWeb:n5", "ApercuWeb:n5", "ApercuWeb:n4"]
				},
				active: () => {
					e(), n.callHook("FONTS:LOADED")
				}
			})
		}
	}),
	jq = Number.MAX_SAFE_INTEGER,
	$E = [30, 60, 120, 144, 240].map(n => (n = 1e3 / n, [n + .75, n, n - .75]));

function $q(n) {
	const e = Wg(20),
		t = Wg(6);
	let i = !1,
		r = performance.now();
	const s = Wg(20);
	let o = 0,
		a = 0,
		l = 0;
	n.hooks.afterFrame.watchOnce(() => {
		i = !0
	});
	const c = n.time = {
		dt: 0,
		clampedDt: 0,
		averageDt: 16.6667,
		stableDt: 16.6667,
		elapsed: 0,
		pausedElapsed: 0,
		frameNum: 0,
		isPaused: !0,
		isStarted: !0,
		clampFps: 60,
		set clampTo60Fps(g) {
			c.clampFps = g ? 60 : 0
		},
		init: u,
		start: f,
		stop: p,
		resume: h,
		pause: d,
		customLoop: null
	};

	function u() {
		c.customLoop ? c.customLoop(_) : eP.add(_), c.isStarted = !0, c.isPaused = !1
	}

	function h() {
		c.isPaused = !1
	}

	function d() {
		c.isPaused = !0
	}

	function f() {
		c.isStarted = !0
	}

	function p() {
		c.isStarted = !1
	}

	function _(g) {
		const m = r;
		if (r = performance.now(), g = r - m, g === 0 && (g = 16.6667), i && (i = !1, g = 16.6667, e.reset(), t.reset(), a = o = l = 0, s.reset()), c.clampFps > 0) {
			const v = s.push(g),
				y = 1e3 / c.clampFps,
				x = Math.max(0, y - v);
			if (a += x, a >= y) {
				o = 0, a = Math.max(0, a - y), l += g;
				return
			}
			o >= 10 ? a = o = 0 : o += 1, g += l, l = 0
		}
		c.clampedDt = pu(g === void 0 ? 16.6667 : g, 1, 130), c.averageDt = e.push(g);
		let b = c.averageDt;
		for (let v = 0, y = $E.length; v < y; v++) {
			const x = $E[v];
			if (b >= x[2]) {
				b <= x[0] && (b = x[1]);
				break
			}
		}
		c.stableDt = t.push(b), c.dt = g, c.frameNum = (c.frameNum + 1) % jq, c.elapsed += g, c.isStarted && (c.isPaused || (c.pausedElapsed += g), n.frame())
	}
}
const qq = {
	"720p": 1280 * 720,
	"1080p": 1920 * 1080,
	"1440p": 2560 * 1440,
	"2k": 2560 * 1440,
	"3k": 2880 * 1620,
	"4k": 3840 * 2160,
	"5k": 5120 * 2880,
	"8k": 7680 * 4320
};

function Xq(n) {
	let e;
	const t = new et("#7A7C79");
	let i = 1,
		r = 2,
		s = qq["3k"];
	const o = tt(new Oe),
		a = tt(1),
		l = {
			antialias: !0,
			alpha: !1,
			depth: !0,
			stencil: !1,
			preserveDrawingBuffer: !1,
			powerPreference: "high-performance",
			premultipliedAlpha: !1
		},
		c = {
			init: u,
			options: l,
			clearColor: t,
			resize: h,
			drawingBufferSize: o,
			pixelRatio: a
		};
	n.hooks.beforeFrame.watch(() => {
		e.info.reset()
	});

	function u() {
		l.canvas = n.canvas, e = new Fb(l), e.autoClear = !1, e.info.autoReset = !1, e.setClearColor(t, 1), n.threeRenderer = e, Vt(n.$viewport, h, {
			immediate: !0
		})
	}

	function h() {
		const {
			width: f,
			height: p,
			domHeight: _
		} = n.$viewport;
		let g = pu(n.$viewport.pixelRatio, i, r);
		const m = new Oe,
			b = new Oe(f, p);
		e.getSize(m);
		let v = g * f * p;
		v > s && (g /= v / s), e.getPixelRatio() !== g && e.setPixelRatio(g), m.equals(b) || e.setSize(b.x, b.y), d()
	}

	function d() {
		const f = new Oe;
		e.getDrawingBufferSize(f), o.value.copy(f), a.value = e.getPixelRatio()
	}
	n.renderer = c
}

function Yq(n) {
	if (!n.$gui) return;
	const t = n.$gui.addFolder({
			title: "Stats",
			index: 0,
			expanded: !0
		}),
		i = {
			fps: 60,
			programs: 0,
			geometries: 0,
			textureMemory: 0,
			geometryMemory: 0,
			textures: 0,
			drawcalls: 0,
			triangles: 0,
			matrixUpdates: 0
		};
	for (const u in i) {
		const h = {
			interval: 30,
			readonly: !0
		};
		u !== "fps" && (h.format = d => Math.floor(d)), (u === "textureMemory" || u === "geometryMemory") && (h.format = d => ~~d + "mb"), i["_" + u] = t.addBinding(i, u, h)
	}
	let r = 0,
		s = performance.now();

	function o() {
		const u = performance.now(),
			h = u - s;
		if (h > 1e3) {
			const d = r * 1e3 / h;
			r = 0, s = u, i.fps !== d && (i.fps = d, i._fps.refresh())
		}
		r++
	}
	let a = performance.now();

	function l() {
		const u = performance.now();
		if (u - a < 200) return;
		a = u;
		const d = n.threeRenderer.info,
			f = d.programs.length;
		f !== i.programs && (i.programs = f, i._programs.refresh());
		const p = d.memory.geometries;
		p !== i.geometries && (i.geometries = p, i._geometries.refresh());
		const _ = d.memory.textures;
		_ !== i.textures && (i.textures = _, i._textures.refresh());
		const g = d.render.calls;
		g !== i.drawcalls && (i.drawcalls = g, i._drawcalls.refresh());
		const m = d.render.triangles;
		m !== i.triangles && (i.triangles = m, i._triangles.refresh());
		const b = d.memory.geometries;
		b !== i.geometryMemory && (i.geometryMemory = b, i._geometryMemory.refresh());
		const v = d.memory.textures;
		v !== i.textureMemory && (i.textureMemory = v, i._textureMemory.refresh())
	}

	function c() {
		l(), o()
	}
	n.hooks.afterFrame.watch(c)
}

function Kq(n) {
	n.store = {
		isRunning: !0,
		backgroundColor: new et("#7A7C79"),
		isMobile: !(n.$viewport.width > 738),
		mobileFactor: 0,
		rocksProgress: 0,
		dollyProgress: 0,
		rocksActive: !1,
		backgroundProgress: 0,
		maskProgress: 0,
		maskRotation: 0,
		noisePropagation: 0,
		noiseDissolve: 0,
		opacity: 0,
		labDollyProgress: 0,
		labProgress: 2.5,
		labActive: !1,
		labOpacity: 1,
		labScaleFactor: 0,
		labProcessing: 0,
		labSmoothProgress: 0,
		textProgress: 0,
		pPosition: new X,
		lab: {
			x: 0,
			y: 0
		}
	};
	const e = () => {
		n.isMobile = !(n.$viewport.width > 738)
	};
	Vt(n.$viewport, e, {
		immediate: !0
	}), n.store.update = () => {
		const t = n.time.stableDt;
		n.store.labSmoothProgress = Ur(n.store.labSmoothProgress, n.store.labDollyProgress, .1, t)
	}
}

function qE(n, e) {
	if (e === pV) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n;
	if (e === Rv || e === ED) {
		let t = n.getIndex();
		if (t === null) {
			const o = [],
				a = n.getAttribute("position");
			if (a !== void 0) {
				for (let l = 0; l < a.count; l++) o.push(l);
				n.setIndex(o), t = n.getIndex()
			} else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n
		}
		const i = t.count - 2,
			r = [];
		if (e === Rv)
			for (let o = 1; o <= i; o++) r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
		else
			for (let o = 0; o < i; o++) o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
		r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
		const s = n.clone();
		return s.setIndex(r), s.clearGroups(), s
	} else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n
}
class Zq extends Fl {
	constructor(e) {
		super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) {
			return new nX(t)
		}), this.register(function (t) {
			return new hX(t)
		}), this.register(function (t) {
			return new dX(t)
		}), this.register(function (t) {
			return new fX(t)
		}), this.register(function (t) {
			return new rX(t)
		}), this.register(function (t) {
			return new sX(t)
		}), this.register(function (t) {
			return new oX(t)
		}), this.register(function (t) {
			return new aX(t)
		}), this.register(function (t) {
			return new tX(t)
		}), this.register(function (t) {
			return new lX(t)
		}), this.register(function (t) {
			return new iX(t)
		}), this.register(function (t) {
			return new uX(t)
		}), this.register(function (t) {
			return new cX(t)
		}), this.register(function (t) {
			return new Qq(t)
		}), this.register(function (t) {
			return new pX(t)
		}), this.register(function (t) {
			return new mX(t)
		})
	}
	load(e, t, i, r) {
		const s = this;
		let o;
		if (this.resourcePath !== "") o = this.resourcePath;
		else if (this.path !== "") {
			const c = Oh.extractUrlBase(e);
			o = Oh.resolveURL(c, this.path)
		} else o = Oh.extractUrlBase(e);
		this.manager.itemStart(e);
		const a = function (c) {
				r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e)
			},
			l = new um(this.manager);
		l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) {
			try {
				s.parse(c, o, function (u) {
					t(u), s.manager.itemEnd(e)
				}, a)
			} catch (u) {
				a(u)
			}
		}, i, a)
	}
	setDRACOLoader(e) {
		return this.dracoLoader = e, this
	}
	setDDSLoader() {
		throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
	}
	setKTX2Loader(e) {
		return this.ktx2Loader = e, this
	}
	setMeshoptDecoder(e) {
		return this.meshoptDecoder = e, this
	}
	register(e) {
		return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
	}
	unregister(e) {
		return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
	}
	parse(e, t, i, r) {
		let s;
		const o = {},
			a = {},
			l = new TextDecoder;
		if (typeof e == "string") s = JSON.parse(e);
		else if (e instanceof ArrayBuffer)
			if (l.decode(new Uint8Array(e, 0, 4)) === nP) {
				try {
					o[wt.KHR_BINARY_GLTF] = new gX(e)
				} catch (h) {
					r && r(h);
					return
				}
				s = JSON.parse(o[wt.KHR_BINARY_GLTF].content)
			} else s = JSON.parse(l.decode(e));
		else s = e;
		if (s.asset === void 0 || s.asset.version[0] < 2) {
			r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
			return
		}
		const c = new DX(s, {
			path: t || this.resourcePath || "",
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder
		});
		c.fileLoader.setRequestHeader(this.requestHeader);
		for (let u = 0; u < this.pluginCallbacks.length; u++) {
			const h = this.pluginCallbacks[u](c);
			h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[h.name] = h, o[h.name] = !0
		}
		if (s.extensionsUsed)
			for (let u = 0; u < s.extensionsUsed.length; ++u) {
				const h = s.extensionsUsed[u],
					d = s.extensionsRequired || [];
				switch (h) {
					case wt.KHR_MATERIALS_UNLIT:
						o[h] = new eX;
						break;
					case wt.KHR_DRACO_MESH_COMPRESSION:
						o[h] = new _X(s, this.dracoLoader);
						break;
					case wt.KHR_TEXTURE_TRANSFORM:
						o[h] = new vX;
						break;
					case wt.KHR_MESH_QUANTIZATION:
						o[h] = new bX;
						break;
					default:
						d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
				}
			}
		c.setExtensions(o), c.setPlugins(a), c.parse(i, r)
	}
	parseAsync(e, t) {
		const i = this;
		return new Promise(function (r, s) {
			i.parse(e, t, r, s)
		})
	}
}

function Jq() {
	let n = {};
	return {
		get: function (e) {
			return n[e]
		},
		add: function (e, t) {
			n[e] = t
		},
		remove: function (e) {
			delete n[e]
		},
		removeAll: function () {
			n = {}
		}
	}
}
const wt = {
	KHR_BINARY_GLTF: "KHR_binary_glTF",
	KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
	KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
	KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
	KHR_MATERIALS_IOR: "KHR_materials_ior",
	KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
	KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
	KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
	KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
	KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
	KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
	KHR_MATERIALS_VOLUME: "KHR_materials_volume",
	KHR_TEXTURE_BASISU: "KHR_texture_basisu",
	KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
	KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
	KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
	EXT_MATERIALS_BUMP: "EXT_materials_bump",
	EXT_TEXTURE_WEBP: "EXT_texture_webp",
	EXT_TEXTURE_AVIF: "EXT_texture_avif",
	EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
	EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Qq {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_LIGHTS_PUNCTUAL, this.cache = {
			refs: {},
			uses: {}
		}
	}
	_markDefs() {
		const e = this.parser,
			t = this.parser.json.nodes || [];
		for (let i = 0, r = t.length; i < r; i++) {
			const s = t[i];
			s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
		}
	}
	_loadLight(e) {
		const t = this.parser,
			i = "light:" + e;
		let r = t.cache.get(i);
		if (r) return r;
		const s = t.json,
			l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
		let c;
		const u = new et(16777215);
		l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Jn);
		const h = l.range !== void 0 ? l.range : 0;
		switch (l.type) {
			case "directional":
				c = new Eq(u), c.target.position.set(0, 0, -1), c.add(c.target);
				break;
			case "point":
				c = new xq(u), c.distance = h;
				break;
			case "spot":
				c = new bq(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
				break;
			default:
				throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
		}
		return c.position.set(0, 0, 0), c.decay = 2, Go(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), r = Promise.resolve(c), t.cache.add(i, r), r
	}
	getDependency(e, t) {
		if (e === "light") return this._loadLight(t)
	}
	createNodeAttachment(e) {
		const t = this,
			i = this.parser,
			s = i.json.nodes[e],
			a = (s.extensions && s.extensions[this.name] || {}).light;
		return a === void 0 ? null : this._loadLight(a).then(function (l) {
			return i._getNodeRef(t.cache, a, l)
		})
	}
}
class eX {
	constructor() {
		this.name = wt.KHR_MATERIALS_UNLIT
	}
	getMaterialType() {
		return yr
	}
	extendParams(e, t, i) {
		const r = [];
		e.color = new et(1, 1, 1), e.opacity = 1;
		const s = t.pbrMetallicRoughness;
		if (s) {
			if (Array.isArray(s.baseColorFactor)) {
				const o = s.baseColorFactor;
				e.color.setRGB(o[0], o[1], o[2], Jn), e.opacity = o[3]
			}
			s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, qn))
		}
		return Promise.all(r)
	}
}
class tX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_EMISSIVE_STRENGTH
	}
	extendMaterialParams(e, t) {
		const r = this.parser.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = r.extensions[this.name].emissiveStrength;
		return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve()
	}
}
class nX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_CLEARCOAT
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
			const a = o.clearcoatNormalTexture.scale;
			t.clearcoatNormalScale = new Oe(a, a)
		}
		return Promise.all(s)
	}
}
class iX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_IRIDESCENCE
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
	}
}
class rX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_SHEEN
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [];
		t.sheenColor = new et(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
		const o = r.extensions[this.name];
		if (o.sheenColorFactor !== void 0) {
			const a = o.sheenColorFactor;
			t.sheenColor.setRGB(a[0], a[1], a[2], Jn)
		}
		return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, qn)), o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
	}
}
class sX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_TRANSMISSION
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s)
	}
}
class oX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_VOLUME
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
		const a = o.attenuationColor || [1, 1, 1];
		return t.attenuationColor = new et().setRGB(a[0], a[1], a[2], Jn), Promise.all(s)
	}
}
class aX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_IOR
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const r = this.parser.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = r.extensions[this.name];
		return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
	}
}
class lX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_SPECULAR
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
		const a = o.specularColorFactor || [1, 1, 1];
		return t.specularColor = new et().setRGB(a[0], a[1], a[2], Jn), o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, qn)), Promise.all(s)
	}
}
class cX {
	constructor(e) {
		this.parser = e, this.name = wt.EXT_MATERIALS_BUMP
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && s.push(i.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(s)
	}
}
class uX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_MATERIALS_ANISOTROPY
	}
	getMaterialType(e) {
		const i = this.parser.json.materials[e];
		return !i.extensions || !i.extensions[this.name] ? null : go
	}
	extendMaterialParams(e, t) {
		const i = this.parser,
			r = i.json.materials[e];
		if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
		const s = [],
			o = r.extensions[this.name];
		return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s)
	}
}
class hX {
	constructor(e) {
		this.parser = e, this.name = wt.KHR_TEXTURE_BASISU
	}
	loadTexture(e) {
		const t = this.parser,
			i = t.json,
			r = i.textures[e];
		if (!r.extensions || !r.extensions[this.name]) return null;
		const s = r.extensions[this.name],
			o = t.options.ktx2Loader;
		if (!o) {
			if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
			return null
		}
		return t.loadTextureImage(e, s.source, o)
	}
}
class dX {
	constructor(e) {
		this.parser = e, this.name = wt.EXT_TEXTURE_WEBP, this.isSupported = null
	}
	loadTexture(e) {
		const t = this.name,
			i = this.parser,
			r = i.json,
			s = r.textures[e];
		if (!s.extensions || !s.extensions[t]) return null;
		const o = s.extensions[t],
			a = r.images[o.source];
		let l = i.textureLoader;
		if (a.uri) {
			const c = i.options.manager.getHandler(a.uri);
			c !== null && (l = c)
		}
		return this.detectSupport().then(function (c) {
			if (c) return i.loadTextureImage(e, o.source, l);
			if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
			return i.loadTexture(e)
		})
	}
	detectSupport() {
		return this.isSupported || (this.isSupported = new Promise(function (e) {
			const t = new Image;
			t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
				e(t.height === 1)
			}
		})), this.isSupported
	}
}
class fX {
	constructor(e) {
		this.parser = e, this.name = wt.EXT_TEXTURE_AVIF, this.isSupported = null
	}
	loadTexture(e) {
		const t = this.name,
			i = this.parser,
			r = i.json,
			s = r.textures[e];
		if (!s.extensions || !s.extensions[t]) return null;
		const o = s.extensions[t],
			a = r.images[o.source];
		let l = i.textureLoader;
		if (a.uri) {
			const c = i.options.manager.getHandler(a.uri);
			c !== null && (l = c)
		}
		return this.detectSupport().then(function (c) {
			if (c) return i.loadTextureImage(e, o.source, l);
			if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
			return i.loadTexture(e)
		})
	}
	detectSupport() {
		return this.isSupported || (this.isSupported = new Promise(function (e) {
			const t = new Image;
			t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () {
				e(t.height === 1)
			}
		})), this.isSupported
	}
}
class pX {
	constructor(e) {
		this.name = wt.EXT_MESHOPT_COMPRESSION, this.parser = e
	}
	loadBufferView(e) {
		const t = this.parser.json,
			i = t.bufferViews[e];
		if (i.extensions && i.extensions[this.name]) {
			const r = i.extensions[this.name],
				s = this.parser.getDependency("buffer", r.buffer),
				o = this.parser.options.meshoptDecoder;
			if (!o || !o.supported) {
				if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
				return null
			}
			return s.then(function (a) {
				const l = r.byteOffset || 0,
					c = r.byteLength || 0,
					u = r.count,
					h = r.byteStride,
					d = new Uint8Array(a, l, c);
				return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, r.mode, r.filter).then(function (f) {
					return f.buffer
				}) : o.ready.then(function () {
					const f = new ArrayBuffer(u * h);
					return o.decodeGltfBuffer(new Uint8Array(f), u, h, d, r.mode, r.filter), f
				})
			})
		} else return null
	}
}
class mX {
	constructor(e) {
		this.name = wt.EXT_MESH_GPU_INSTANCING, this.parser = e
	}
	createNodeMesh(e) {
		const t = this.parser.json,
			i = t.nodes[e];
		if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
		const r = t.meshes[i.mesh];
		for (const c of r.primitives)
			if (c.mode !== kr.TRIANGLES && c.mode !== kr.TRIANGLE_STRIP && c.mode !== kr.TRIANGLE_FAN && c.mode !== void 0) return null;
		const o = i.extensions[this.name].attributes,
			a = [],
			l = {};
		for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then(u => (l[c] = u, l[c])));
		return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(c => {
			const u = c.pop(),
				h = u.isGroup ? u.children : [u],
				d = c[0].count,
				f = [];
			for (const p of h) {
				const _ = new pt,
					g = new X,
					m = new qr,
					b = new X(1, 1, 1),
					v = new tq(p.geometry, p.material, d);
				for (let y = 0; y < d; y++) l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, y), l.ROTATION && m.fromBufferAttribute(l.ROTATION, y), l.SCALE && b.fromBufferAttribute(l.SCALE, y), v.setMatrixAt(y, _.compose(g, m, b));
				for (const y in l)
					if (y === "_COLOR_0") {
						const x = l[y];
						v.instanceColor = new cm(x.array, x.itemSize, x.normalized)
					} else y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && p.geometry.setAttribute(y, l[y]);
				ht.prototype.copy.call(v, p), this.parser.assignFinalMaterial(v), f.push(v)
			}
			return u.isGroup ? (u.clear(), u.add(...f), u) : f[0]
		}))
	}
}
const nP = "glTF",
	$u = 12,
	XE = {
		JSON: 1313821514,
		BIN: 5130562
	};
class gX {
	constructor(e) {
		this.name = wt.KHR_BINARY_GLTF, this.content = null, this.body = null;
		const t = new DataView(e, 0, $u),
			i = new TextDecoder;
		if (this.header = {
				magic: i.decode(new Uint8Array(e.slice(0, 4))),
				version: t.getUint32(4, !0),
				length: t.getUint32(8, !0)
			}, this.header.magic !== nP) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
		if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
		const r = this.header.length - $u,
			s = new DataView(e, $u);
		let o = 0;
		for (; o < r;) {
			const a = s.getUint32(o, !0);
			o += 4;
			const l = s.getUint32(o, !0);
			if (o += 4, l === XE.JSON) {
				const c = new Uint8Array(e, $u + o, a);
				this.content = i.decode(c)
			} else if (l === XE.BIN) {
				const c = $u + o;
				this.body = e.slice(c, c + a)
			}
			o += a
		}
		if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
	}
}
class _X {
	constructor(e, t) {
		if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
		this.name = wt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
	}
	decodePrimitive(e, t) {
		const i = this.json,
			r = this.dracoLoader,
			s = e.extensions[this.name].bufferView,
			o = e.extensions[this.name].attributes,
			a = {},
			l = {},
			c = {};
		for (const u in o) {
			const h = Nv[u] || u.toLowerCase();
			a[h] = o[u]
		}
		for (const u in e.attributes) {
			const h = Nv[u] || u.toLowerCase();
			if (o[u] !== void 0) {
				const d = i.accessors[e.attributes[u]],
					f = Vc[d.componentType];
				c[h] = f.name, l[h] = d.normalized === !0
			}
		}
		return t.getDependency("bufferView", s).then(function (u) {
			return new Promise(function (h, d) {
				r.decodeDracoFile(u, function (f) {
					for (const p in f.attributes) {
						const _ = f.attributes[p],
							g = l[p];
						g !== void 0 && (_.normalized = g)
					}
					h(f)
				}, a, c, Jn, d)
			})
		})
	}
}
class vX {
	constructor() {
		this.name = wt.KHR_TEXTURE_TRANSFORM
	}
	extendTexture(e, t) {
		return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
	}
}
class bX {
	constructor() {
		this.name = wt.KHR_MESH_QUANTIZATION
	}
}
class iP extends zd {
	constructor(e, t, i, r) {
		super(e, t, i, r)
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			i = this.sampleValues,
			r = this.valueSize,
			s = e * r * 3 + r;
		for (let o = 0; o !== r; o++) t[o] = i[s + o];
		return t
	}
	interpolate_(e, t, i, r) {
		const s = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = a * 2,
			c = a * 3,
			u = r - t,
			h = (i - t) / u,
			d = h * h,
			f = d * h,
			p = e * c,
			_ = p - c,
			g = -2 * f + 3 * d,
			m = f - d,
			b = 1 - g,
			v = m - d + h;
		for (let y = 0; y !== a; y++) {
			const x = o[_ + y + a],
				S = o[_ + y + l] * u,
				E = o[p + y + a],
				C = o[p + y] * u;
			s[y] = b * x + v * S + g * E + m * C
		}
		return s
	}
}
const yX = new qr;
class xX extends iP {
	interpolate_(e, t, i, r) {
		const s = super.interpolate_(e, t, i, r);
		return yX.fromArray(s).normalize().toArray(s), s
	}
}
const kr = {
		FLOAT: 5126,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	},
	Vc = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	},
	YE = {
		9728: $n,
		9729: jn,
		9984: Pv,
		9985: vp,
		9986: mc,
		9987: Qs
	},
	KE = {
		33071: Nr,
		33648: nm,
		10497: ya
	},
	jg = {
		SCALAR: 1,
		VEC2: 2,
		VEC3: 3,
		VEC4: 4,
		MAT2: 4,
		MAT3: 9,
		MAT4: 16
	},
	Nv = {
		POSITION: "position",
		NORMAL: "normal",
		TANGENT: "tangent",
		TEXCOORD_0: "uv",
		TEXCOORD_1: "uv1",
		TEXCOORD_2: "uv2",
		TEXCOORD_3: "uv3",
		COLOR_0: "color",
		WEIGHTS_0: "skinWeight",
		JOINTS_0: "skinIndex"
	},
	Ro = {
		scale: "scale",
		translation: "position",
		rotation: "quaternion",
		weights: "morphTargetInfluences"
	},
	wX = {
		CUBICSPLINE: void 0,
		LINEAR: cu,
		STEP: ud
	},
	$g = {
		OPAQUE: "OPAQUE",
		MASK: "MASK",
		BLEND: "BLEND"
	};

function EX(n) {
	return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Bd({
		color: 16777215,
		emissive: 0,
		metalness: 1,
		roughness: 1,
		transparent: !1,
		depthTest: !0,
		side: fo
	})), n.DefaultMaterial
}

function Wa(n, e, t) {
	for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i])
}

function Go(n, e) {
	e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function SX(n, e, t) {
	let i = !1,
		r = !1,
		s = !1;
	for (let c = 0, u = e.length; c < u; c++) {
		const h = e[c];
		if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (r = !0), h.COLOR_0 !== void 0 && (s = !0), i && r && s) break
	}
	if (!i && !r && !s) return Promise.resolve(n);
	const o = [],
		a = [],
		l = [];
	for (let c = 0, u = e.length; c < u; c++) {
		const h = e[c];
		if (i) {
			const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
			o.push(d)
		}
		if (r) {
			const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
			a.push(d)
		}
		if (s) {
			const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
			l.push(d)
		}
	}
	return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
		const u = c[0],
			h = c[1],
			d = c[2];
		return i && (n.morphAttributes.position = u), r && (n.morphAttributes.normal = h), s && (n.morphAttributes.color = d), n.morphTargetsRelative = !0, n
	})
}

function TX(n, e) {
	if (n.updateMorphTargets(), e.weights !== void 0)
		for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t];
	if (e.extras && Array.isArray(e.extras.targetNames)) {
		const t = e.extras.targetNames;
		if (n.morphTargetInfluences.length === t.length) {
			n.morphTargetDictionary = {};
			for (let i = 0, r = t.length; i < r; i++) n.morphTargetDictionary[t[i]] = i
		} else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
	}
}

function MX(n) {
	let e;
	const t = n.extensions && n.extensions[wt.KHR_DRACO_MESH_COMPRESSION];
	if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + qg(t.attributes) : e = n.indices + ":" + qg(n.attributes) + ":" + n.mode, n.targets !== void 0)
		for (let i = 0, r = n.targets.length; i < r; i++) e += ":" + qg(n.targets[i]);
	return e
}

function qg(n) {
	let e = "";
	const t = Object.keys(n).sort();
	for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
	return e
}

function Uv(n) {
	switch (n) {
		case Int8Array:
			return 1 / 127;
		case Uint8Array:
			return 1 / 255;
		case Int16Array:
			return 1 / 32767;
		case Uint16Array:
			return 1 / 65535;
		default:
			throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
	}
}

function CX(n) {
	return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const AX = new pt;
class DX {
	constructor(e = {}, t = {}) {
		this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Jq, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
			refs: {},
			uses: {}
		}, this.cameraCache = {
			refs: {},
			uses: {}
		}, this.lightCache = {
			refs: {},
			uses: {}
		}, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
		let i = !1,
			r = !1,
			s = -1;
		typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || r && s < 98 ? this.textureLoader = new t0(this.options.manager) : this.textureLoader = new Sq(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new um(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
	}
	setExtensions(e) {
		this.extensions = e
	}
	setPlugins(e) {
		this.plugins = e
	}
	parse(e, t) {
		const i = this,
			r = this.json,
			s = this.extensions;
		this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (o) {
			return o._markDefs && o._markDefs()
		}), Promise.all(this._invokeAll(function (o) {
			return o.beforeRoot && o.beforeRoot()
		})).then(function () {
			return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
		}).then(function (o) {
			const a = {
				scene: o[0][r.scene || 0],
				scenes: o[0],
				animations: o[1],
				cameras: o[2],
				asset: r.asset,
				parser: i,
				userData: {}
			};
			return Wa(s, a, r), Go(a, r), Promise.all(i._invokeAll(function (l) {
				return l.afterRoot && l.afterRoot(a)
			})).then(function () {
				e(a)
			})
		}).catch(t)
	}
	_markDefs() {
		const e = this.json.nodes || [],
			t = this.json.skins || [],
			i = this.json.meshes || [];
		for (let r = 0, s = t.length; r < s; r++) {
			const o = t[r].joints;
			for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
		}
		for (let r = 0, s = e.length; r < s; r++) {
			const o = e[r];
			o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
		}
	}
	_addNodeRef(e, t) {
		t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
	}
	_getNodeRef(e, t, i) {
		if (e.refs[t] <= 1) return i;
		const r = i.clone(),
			s = (o, a) => {
				const l = this.associations.get(o);
				l != null && this.associations.set(a, l);
				for (const [c, u] of o.children.entries()) s(u, a.children[c])
			};
		return s(i, r), r.name += "_instance_" + e.uses[t]++, r
	}
	_invokeOne(e) {
		const t = Object.values(this.plugins);
		t.push(this);
		for (let i = 0; i < t.length; i++) {
			const r = e(t[i]);
			if (r) return r
		}
		return null
	}
	_invokeAll(e) {
		const t = Object.values(this.plugins);
		t.unshift(this);
		const i = [];
		for (let r = 0; r < t.length; r++) {
			const s = e(t[r]);
			s && i.push(s)
		}
		return i
	}
	getDependency(e, t) {
		const i = e + ":" + t;
		let r = this.cache.get(i);
		if (!r) {
			switch (e) {
				case "scene":
					r = this.loadScene(t);
					break;
				case "node":
					r = this._invokeOne(function (s) {
						return s.loadNode && s.loadNode(t)
					});
					break;
				case "mesh":
					r = this._invokeOne(function (s) {
						return s.loadMesh && s.loadMesh(t)
					});
					break;
				case "accessor":
					r = this.loadAccessor(t);
					break;
				case "bufferView":
					r = this._invokeOne(function (s) {
						return s.loadBufferView && s.loadBufferView(t)
					});
					break;
				case "buffer":
					r = this.loadBuffer(t);
					break;
				case "material":
					r = this._invokeOne(function (s) {
						return s.loadMaterial && s.loadMaterial(t)
					});
					break;
				case "texture":
					r = this._invokeOne(function (s) {
						return s.loadTexture && s.loadTexture(t)
					});
					break;
				case "skin":
					r = this.loadSkin(t);
					break;
				case "animation":
					r = this._invokeOne(function (s) {
						return s.loadAnimation && s.loadAnimation(t)
					});
					break;
				case "camera":
					r = this.loadCamera(t);
					break;
				default:
					if (r = this._invokeOne(function (s) {
							return s != this && s.getDependency && s.getDependency(e, t)
						}), !r) throw new Error("Unknown type: " + e);
					break
			}
			this.cache.add(i, r)
		}
		return r
	}
	getDependencies(e) {
		let t = this.cache.get(e);
		if (!t) {
			const i = this,
				r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
			t = Promise.all(r.map(function (s, o) {
				return i.getDependency(e, o)
			})), this.cache.add(e, t)
		}
		return t
	}
	loadBuffer(e) {
		const t = this.json.buffers[e],
			i = this.fileLoader;
		if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
		if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[wt.KHR_BINARY_GLTF].body);
		const r = this.options;
		return new Promise(function (s, o) {
			i.load(Oh.resolveURL(t.uri, r.path), s, void 0, function () {
				o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
			})
		})
	}
	loadBufferView(e) {
		const t = this.json.bufferViews[e];
		return this.getDependency("buffer", t.buffer).then(function (i) {
			const r = t.byteLength || 0,
				s = t.byteOffset || 0;
			return i.slice(s, s + r)
		})
	}
	loadAccessor(e) {
		const t = this,
			i = this.json,
			r = this.json.accessors[e];
		if (r.bufferView === void 0 && r.sparse === void 0) {
			const o = jg[r.type],
				a = Vc[r.componentType],
				l = r.normalized === !0,
				c = new a(r.count * o);
			return Promise.resolve(new Cn(c, o, l))
		}
		const s = [];
		return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (o) {
			const a = o[0],
				l = jg[r.type],
				c = Vc[r.componentType],
				u = c.BYTES_PER_ELEMENT,
				h = u * l,
				d = r.byteOffset || 0,
				f = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0,
				p = r.normalized === !0;
			let _, g;
			if (f && f !== h) {
				const m = Math.floor(d / f),
					b = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + m + ":" + r.count;
				let v = t.cache.get(b);
				v || (_ = new c(a, m * f, r.count * f / u), v = new WD(_, f / u), t.cache.add(b, v)), g = new pr(v, l, d % f / u, p)
			} else a === null ? _ = new c(r.count * l) : _ = new c(a, d, r.count * l), g = new Cn(_, l, p);
			if (r.sparse !== void 0) {
				const m = jg.SCALAR,
					b = Vc[r.sparse.indices.componentType],
					v = r.sparse.indices.byteOffset || 0,
					y = r.sparse.values.byteOffset || 0,
					x = new b(o[1], v, r.sparse.count * m),
					S = new c(o[2], y, r.sparse.count * l);
				a !== null && (g = new Cn(g.array.slice(), g.itemSize, g.normalized));
				for (let E = 0, C = x.length; E < C; E++) {
					const P = x[E];
					if (g.setX(P, S[E * l]), l >= 2 && g.setY(P, S[E * l + 1]), l >= 3 && g.setZ(P, S[E * l + 2]), l >= 4 && g.setW(P, S[E * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
				}
			}
			return g
		})
	}
	loadTexture(e) {
		const t = this.json,
			i = this.options,
			s = t.textures[e].source,
			o = t.images[s];
		let a = this.textureLoader;
		if (o.uri) {
			const l = i.manager.getHandler(o.uri);
			l !== null && (a = l)
		}
		return this.loadTextureImage(e, s, a)
	}
	loadTextureImage(e, t, i) {
		const r = this,
			s = this.json,
			o = s.textures[e],
			a = s.images[t],
			l = (a.uri || a.bufferView) + ":" + o.sampler;
		if (this.textureCache[l]) return this.textureCache[l];
		const c = this.loadImageSource(t, i).then(function (u) {
			u.flipY = !1, u.name = o.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
			const d = (s.samplers || {})[o.sampler] || {};
			return u.magFilter = YE[d.magFilter] || jn, u.minFilter = YE[d.minFilter] || Qs, u.wrapS = KE[d.wrapS] || ya, u.wrapT = KE[d.wrapT] || ya, r.associations.set(u, {
				textures: e
			}), u
		}).catch(function () {
			return null
		});
		return this.textureCache[l] = c, c
	}
	loadImageSource(e, t) {
		const i = this,
			r = this.json,
			s = this.options;
		if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone());
		const o = r.images[e],
			a = self.URL || self.webkitURL;
		let l = o.uri || "",
			c = !1;
		if (o.bufferView !== void 0) l = i.getDependency("bufferView", o.bufferView).then(function (h) {
			c = !0;
			const d = new Blob([h], {
				type: o.mimeType
			});
			return l = a.createObjectURL(d), l
		});
		else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
		const u = Promise.resolve(l).then(function (h) {
			return new Promise(function (d, f) {
				let p = d;
				t.isImageBitmapLoader === !0 && (p = function (_) {
					const g = new Kn(_);
					g.needsUpdate = !0, d(g)
				}), t.load(Oh.resolveURL(h, s.path), p, void 0, f)
			})
		}).then(function (h) {
			return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = o.mimeType || CX(o.uri), h
		}).catch(function (h) {
			throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h
		});
		return this.sourceCache[e] = u, u
	}
	assignTexture(e, t, i, r) {
		const s = this;
		return this.getDependency("texture", i.index).then(function (o) {
			if (!o) return null;
			if (i.texCoord !== void 0 && i.texCoord > 0 && (o = o.clone(), o.channel = i.texCoord), s.extensions[wt.KHR_TEXTURE_TRANSFORM]) {
				const a = i.extensions !== void 0 ? i.extensions[wt.KHR_TEXTURE_TRANSFORM] : void 0;
				if (a) {
					const l = s.associations.get(o);
					o = s.extensions[wt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l)
				}
			}
			return r !== void 0 && (o.colorSpace = r), e[t] = o, o
		})
	}
	assignFinalMaterial(e) {
		const t = e.geometry;
		let i = e.material;
		const r = t.attributes.tangent === void 0,
			s = t.attributes.color !== void 0,
			o = t.attributes.normal === void 0;
		if (e.isPoints) {
			const a = "PointsMaterial:" + i.uuid;
			let l = this.cache.get(a);
			l || (l = new XD, Cs.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l
		} else if (e.isLine) {
			const a = "LineBasicMaterial:" + i.uuid;
			let l = this.cache.get(a);
			l || (l = new Bb, Cs.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(a, l)), i = l
		}
		if (r || s || o) {
			let a = "ClonedMaterial:" + i.uuid + ":";
			r && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:");
			let l = this.cache.get(a);
			l || (l = i.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l
		}
		e.material = i
	}
	getMaterialType() {
		return Bd
	}
	loadMaterial(e) {
		const t = this,
			i = this.json,
			r = this.extensions,
			s = i.materials[e];
		let o;
		const a = {},
			l = s.extensions || {},
			c = [];
		if (l[wt.KHR_MATERIALS_UNLIT]) {
			const h = r[wt.KHR_MATERIALS_UNLIT];
			o = h.getMaterialType(), c.push(h.extendParams(a, s, t))
		} else {
			const h = s.pbrMetallicRoughness || {};
			if (a.color = new et(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
				const d = h.baseColorFactor;
				a.color.setRGB(d[0], d[1], d[2], Jn), a.opacity = d[3]
			}
			h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, qn)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function (d) {
				return d.getMaterialType && d.getMaterialType(e)
			}), c.push(Promise.all(this._invokeAll(function (d) {
				return d.extendMaterialParams && d.extendMaterialParams(e, a)
			})))
		}
		s.doubleSided === !0 && (a.side = _r);
		const u = s.alphaMode || $g.OPAQUE;
		if (u === $g.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === $g.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== yr && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new Oe(1, 1), s.normalTexture.scale !== void 0)) {
			const h = s.normalTexture.scale;
			a.normalScale.set(h, h)
		}
		if (s.occlusionTexture !== void 0 && o !== yr && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== yr) {
			const h = s.emissiveFactor;
			a.emissive = new et().setRGB(h[0], h[1], h[2], Jn)
		}
		return s.emissiveTexture !== void 0 && o !== yr && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, qn)), Promise.all(c).then(function () {
			const h = new o(a);
			return s.name && (h.name = s.name), Go(h, s), t.associations.set(h, {
				materials: e
			}), s.extensions && Wa(r, h, s), h
		})
	}
	createUniqueName(e) {
		const t = zt.sanitizeNodeName(e || "");
		return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
	}
	loadGeometries(e) {
		const t = this,
			i = this.extensions,
			r = this.primitiveCache;

		function s(a) {
			return i[wt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) {
				return ZE(l, a, t)
			})
		}
		const o = [];
		for (let a = 0, l = e.length; a < l; a++) {
			const c = e[a],
				u = MX(c),
				h = r[u];
			if (h) o.push(h.promise);
			else {
				let d;
				c.extensions && c.extensions[wt.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = ZE(new gi, c, t), r[u] = {
					primitive: c,
					promise: d
				}, o.push(d)
			}
		}
		return Promise.all(o)
	}
	loadMesh(e) {
		const t = this,
			i = this.json,
			r = this.extensions,
			s = i.meshes[e],
			o = s.primitives,
			a = [];
		for (let l = 0, c = o.length; l < c; l++) {
			const u = o[l].material === void 0 ? EX(this.cache) : this.getDependency("material", o[l].material);
			a.push(u)
		}
		return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) {
			const c = l.slice(0, l.length - 1),
				u = l[l.length - 1],
				h = [];
			for (let f = 0, p = u.length; f < p; f++) {
				const _ = u[f],
					g = o[f];
				let m;
				const b = c[f];
				if (g.mode === kr.TRIANGLES || g.mode === kr.TRIANGLE_STRIP || g.mode === kr.TRIANGLE_FAN || g.mode === void 0) m = s.isSkinnedMesh === !0 ? new J$(_, b) : new an(_, b), m.isSkinnedMesh === !0 && m.normalizeSkinWeights(), g.mode === kr.TRIANGLE_STRIP ? m.geometry = qE(m.geometry, ED) : g.mode === kr.TRIANGLE_FAN && (m.geometry = qE(m.geometry, Rv));
				else if (g.mode === kr.LINES) m = new qD(_, b);
				else if (g.mode === kr.LINE_STRIP) m = new zb(_, b);
				else if (g.mode === kr.LINE_LOOP) m = new nq(_, b);
				else if (g.mode === kr.POINTS) m = new iq(_, b);
				else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
				Object.keys(m.geometry.morphAttributes).length > 0 && TX(m, s), m.name = t.createUniqueName(s.name || "mesh_" + e), Go(m, s), g.extensions && Wa(r, m, g), t.assignFinalMaterial(m), h.push(m)
			}
			for (let f = 0, p = h.length; f < p; f++) t.associations.set(h[f], {
				meshes: e,
				primitives: f
			});
			if (h.length === 1) return s.extensions && Wa(r, h[0], s), h[0];
			const d = new il;
			s.extensions && Wa(r, d, s), t.associations.set(d, {
				meshes: e
			});
			for (let f = 0, p = h.length; f < p; f++) d.add(h[f]);
			return d
		})
	}
	loadCamera(e) {
		let t;
		const i = this.json.cameras[e],
			r = i[i.type];
		if (!r) {
			console.warn("THREE.GLTFLoader: Missing camera parameters.");
			return
		}
		return i.type === "perspective" ? t = new Yn(MD.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new Jm(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Go(t, i), Promise.resolve(t)
	}
	loadSkin(e) {
		const t = this.json.skins[e],
			i = [];
		for (let r = 0, s = t.joints.length; r < s; r++) i.push(this._loadNodeShallow(t.joints[r]));
		return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function (r) {
			const s = r.pop(),
				o = r,
				a = [],
				l = [];
			for (let c = 0, u = o.length; c < u; c++) {
				const h = o[c];
				if (h) {
					a.push(h);
					const d = new pt;
					s !== null && d.fromArray(s.array, c * 16), l.push(d)
				} else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
			}
			return new Ub(a, l)
		})
	}
	loadAnimation(e) {
		const t = this.json,
			i = this,
			r = t.animations[e],
			s = r.name ? r.name : "animation_" + e,
			o = [],
			a = [],
			l = [],
			c = [],
			u = [];
		for (let h = 0, d = r.channels.length; h < d; h++) {
			const f = r.channels[h],
				p = r.samplers[f.sampler],
				_ = f.target,
				g = _.node,
				m = r.parameters !== void 0 ? r.parameters[p.input] : p.input,
				b = r.parameters !== void 0 ? r.parameters[p.output] : p.output;
			_.node !== void 0 && (o.push(this.getDependency("node", g)), a.push(this.getDependency("accessor", m)), l.push(this.getDependency("accessor", b)), c.push(p), u.push(_))
		}
		return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(u)]).then(function (h) {
			const d = h[0],
				f = h[1],
				p = h[2],
				_ = h[3],
				g = h[4],
				m = [];
			for (let b = 0, v = d.length; b < v; b++) {
				const y = d[b],
					x = f[b],
					S = p[b],
					E = _[b],
					C = g[b];
				if (y === void 0) continue;
				y.updateMatrix && y.updateMatrix();
				const P = i._createAnimationTracks(y, x, S, E, C);
				if (P)
					for (let w = 0; w < P.length; w++) m.push(P[w])
			}
			return new hq(s, void 0, m)
		})
	}
	createNodeMesh(e) {
		const t = this.json,
			i = this,
			r = t.nodes[e];
		return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function (s) {
			const o = i._getNodeRef(i.meshCache, r.mesh, s);
			return r.weights !== void 0 && o.traverse(function (a) {
				if (a.isMesh)
					for (let l = 0, c = r.weights.length; l < c; l++) a.morphTargetInfluences[l] = r.weights[l]
			}), o
		})
	}
	loadNode(e) {
		const t = this.json,
			i = this,
			r = t.nodes[e],
			s = i._loadNodeShallow(e),
			o = [],
			a = r.children || [];
		for (let c = 0, u = a.length; c < u; c++) o.push(i.getDependency("node", a[c]));
		const l = r.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", r.skin);
		return Promise.all([s, Promise.all(o), l]).then(function (c) {
			const u = c[0],
				h = c[1],
				d = c[2];
			d !== null && u.traverse(function (f) {
				f.isSkinnedMesh && f.bind(d, AX)
			});
			for (let f = 0, p = h.length; f < p; f++) u.add(h[f]);
			return u
		})
	}
	_loadNodeShallow(e) {
		const t = this.json,
			i = this.extensions,
			r = this;
		if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
		const s = t.nodes[e],
			o = s.name ? r.createUniqueName(s.name) : "",
			a = [],
			l = r._invokeOne(function (c) {
				return c.createNodeMesh && c.createNodeMesh(e)
			});
		return l && a.push(l), s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function (c) {
			return r._getNodeRef(r.cameraCache, s.camera, c)
		})), r._invokeAll(function (c) {
			return c.createNodeAttachment && c.createNodeAttachment(e)
		}).forEach(function (c) {
			a.push(c)
		}), this.nodeCache[e] = Promise.all(a).then(function (c) {
			let u;
			if (s.isBone === !0 ? u = new jD : c.length > 1 ? u = new il : c.length === 1 ? u = c[0] : u = new ht, u !== c[0])
				for (let h = 0, d = c.length; h < d; h++) u.add(c[h]);
			if (s.name && (u.userData.name = s.name, u.name = o), Go(u, s), s.extensions && Wa(i, u, s), s.matrix !== void 0) {
				const h = new pt;
				h.fromArray(s.matrix), u.applyMatrix4(h)
			} else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
			return r.associations.has(u) || r.associations.set(u, {}), r.associations.get(u).nodes = e, u
		}), this.nodeCache[e]
	}
	loadScene(e) {
		const t = this.extensions,
			i = this.json.scenes[e],
			r = this,
			s = new il;
		i.name && (s.name = r.createUniqueName(i.name)), Go(s, i), i.extensions && Wa(t, s, i);
		const o = i.nodes || [],
			a = [];
		for (let l = 0, c = o.length; l < c; l++) a.push(r.getDependency("node", o[l]));
		return Promise.all(a).then(function (l) {
			for (let u = 0, h = l.length; u < h; u++) s.add(l[u]);
			const c = u => {
				const h = new Map;
				for (const [d, f] of r.associations)(d instanceof Cs || d instanceof Kn) && h.set(d, f);
				return u.traverse(d => {
					const f = r.associations.get(d);
					f != null && h.set(d, f)
				}), h
			};
			return r.associations = c(s), s
		})
	}
	_createAnimationTracks(e, t, i, r, s) {
		const o = [],
			a = e.name ? e.name : e.uuid,
			l = [];
		Ro[s.path] === Ro.weights ? e.traverse(function (d) {
			d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid)
		}) : l.push(a);
		let c;
		switch (Ro[s.path]) {
			case Ro.weights:
				c = du;
				break;
			case Ro.rotation:
				c = Dl;
				break;
			case Ro.position:
			case Ro.scale:
				c = fu;
				break;
			default:
				switch (i.itemSize) {
					case 1:
						c = du;
						break;
					case 2:
					case 3:
					default:
						c = fu;
						break
				}
				break
		}
		const u = r.interpolation !== void 0 ? wX[r.interpolation] : cu,
			h = this._getArrayFromAccessor(i);
		for (let d = 0, f = l.length; d < f; d++) {
			const p = new c(l[d] + "." + Ro[s.path], t.array, h, u);
			r.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), o.push(p)
		}
		return o
	}
	_getArrayFromAccessor(e) {
		let t = e.array;
		if (e.normalized) {
			const i = Uv(t.constructor),
				r = new Float32Array(t.length);
			for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i;
			t = r
		}
		return t
	}
	_createCubicSplineTrackInterpolant(e) {
		e.createInterpolant = function (i) {
			const r = this instanceof Dl ? xX : iP;
			return new r(this.times, this.values, this.getValueSize() / 3, i)
		}, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
	}
}

function PX(n, e, t) {
	const i = e.attributes,
		r = new ks;
	if (i.POSITION !== void 0) {
		const a = t.json.accessors[i.POSITION],
			l = a.min,
			c = a.max;
		if (l !== void 0 && c !== void 0) {
			if (r.set(new X(l[0], l[1], l[2]), new X(c[0], c[1], c[2])), a.normalized) {
				const u = Uv(Vc[a.componentType]);
				r.min.multiplyScalar(u), r.max.multiplyScalar(u)
			}
		} else {
			console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
			return
		}
	} else return;
	const s = e.targets;
	if (s !== void 0) {
		const a = new X,
			l = new X;
		for (let c = 0, u = s.length; c < u; c++) {
			const h = s[c];
			if (h.POSITION !== void 0) {
				const d = t.json.accessors[h.POSITION],
					f = d.min,
					p = d.max;
				if (f !== void 0 && p !== void 0) {
					if (l.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), d.normalized) {
						const _ = Uv(Vc[d.componentType]);
						l.multiplyScalar(_)
					}
					a.max(l)
				} else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
			}
		}
		r.expandByVector(a)
	}
	n.boundingBox = r;
	const o = new Is;
	r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, n.boundingSphere = o
}

function ZE(n, e, t) {
	const i = e.attributes,
		r = [];

	function s(o, a) {
		return t.getDependency("accessor", o).then(function (l) {
			n.setAttribute(a, l)
		})
	}
	for (const o in i) {
		const a = Nv[o] || o.toLowerCase();
		a in n.attributes || r.push(s(i[o], a))
	}
	if (e.indices !== void 0 && !n.index) {
		const o = t.getDependency("accessor", e.indices).then(function (a) {
			n.setIndex(a)
		});
		r.push(o)
	}
	return Lt.workingColorSpace !== Jn && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Lt.workingColorSpace}" not supported.`), Go(n, e), PX(n, e, t), Promise.all(r).then(function () {
		return e.targets !== void 0 ? SX(n, e.targets, t) : n
	})
}
const Xg = new WeakMap;
class RX extends Fl {
	constructor(e) {
		super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
			position: "POSITION",
			normal: "NORMAL",
			color: "COLOR",
			uv: "TEX_COORD"
		}, this.defaultAttributeTypes = {
			position: "Float32Array",
			normal: "Float32Array",
			color: "Float32Array",
			uv: "Float32Array"
		}
	}
	setDecoderPath(e) {
		return this.decoderPath = e, this
	}
	setDecoderConfig(e) {
		return this.decoderConfig = e, this
	}
	setWorkerLimit(e) {
		return this.workerLimit = e, this
	}
	load(e, t, i, r) {
		const s = new um(this.manager);
		s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
			this.parse(o, t, r)
		}, i, r)
	}
	parse(e, t, i = () => {}) {
		this.decodeDracoFile(e, t, null, null, qn).catch(i)
	}
	decodeDracoFile(e, t, i, r, s = Jn, o = () => {}) {
		const a = {
			attributeIDs: i || this.defaultAttributeIDs,
			attributeTypes: r || this.defaultAttributeTypes,
			useUniqueIDs: !!i,
			vertexColorSpace: s
		};
		return this.decodeGeometry(e, a).then(t).catch(o)
	}
	decodeGeometry(e, t) {
		const i = JSON.stringify(t);
		if (Xg.has(e)) {
			const l = Xg.get(e);
			if (l.key === i) return l.promise;
			if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
		}
		let r;
		const s = this.workerNextTaskID++,
			o = e.byteLength,
			a = this._getWorker(s, o).then(l => (r = l, new Promise((c, u) => {
				r._callbacks[s] = {
					resolve: c,
					reject: u
				}, r.postMessage({
					type: "decode",
					id: s,
					taskConfig: t,
					buffer: e
				}, [e])
			}))).then(l => this._createGeometry(l.geometry));
		return a.catch(() => !0).then(() => {
			r && s && this._releaseTask(r, s)
		}), Xg.set(e, {
			key: i,
			promise: a
		}), a
	}
	_createGeometry(e) {
		const t = new gi;
		e.index && t.setIndex(new Cn(e.index.array, 1));
		for (let i = 0; i < e.attributes.length; i++) {
			const r = e.attributes[i],
				s = r.name,
				o = r.array,
				a = r.itemSize,
				l = new Cn(o, a);
			s === "color" && (this._assignVertexColorSpace(l, r.vertexColorSpace), l.normalized = !(o instanceof Float32Array)), t.setAttribute(s, l)
		}
		return t
	}
	_assignVertexColorSpace(e, t) {
		if (t !== qn) return;
		const i = new et;
		for (let r = 0, s = e.count; r < s; r++) i.fromBufferAttribute(e, r).convertSRGBToLinear(), e.setXYZ(r, i.r, i.g, i.b)
	}
	_loadLibrary(e, t) {
		const i = new um(this.manager);
		return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((r, s) => {
			i.load(e, r, void 0, s)
		})
	}
	preload() {
		return this._initDecoder(), this
	}
	_initDecoder() {
		if (this.decoderPending) return this.decoderPending;
		const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
			t = [];
		return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(i => {
			const r = i[0];
			e || (this.decoderConfig.wasmBinary = i[1]);
			const s = LX.toString(),
				o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
			this.workerSourceURL = URL.createObjectURL(new Blob([o]))
		}), this.decoderPending
	}
	_getWorker(e, t) {
		return this._initDecoder().then(() => {
			if (this.workerPool.length < this.workerLimit) {
				const r = new Worker(this.workerSourceURL);
				r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({
					type: "init",
					decoderConfig: this.decoderConfig
				}), r.onmessage = function (s) {
					const o = s.data;
					switch (o.type) {
						case "decode":
							r._callbacks[o.id].resolve(o);
							break;
						case "error":
							r._callbacks[o.id].reject(o);
							break;
						default:
							console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
					}
				}, this.workerPool.push(r)
			} else this.workerPool.sort(function (r, s) {
				return r._taskLoad > s._taskLoad ? -1 : 1
			});
			const i = this.workerPool[this.workerPool.length - 1];
			return i._taskCosts[e] = t, i._taskLoad += t, i
		})
	}
	_releaseTask(e, t) {
		e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
	}
	debug() {
		console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
	}
	dispose() {
		for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
		return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this
	}
}

function LX() {
	let n, e;
	onmessage = function (o) {
		const a = o.data;
		switch (a.type) {
			case "init":
				n = a.decoderConfig, e = new Promise(function (u) {
					n.onModuleLoaded = function (h) {
						u({
							draco: h
						})
					}, DracoDecoderModule(n)
				});
				break;
			case "decode":
				const l = a.buffer,
					c = a.taskConfig;
				e.then(u => {
					const h = u.draco,
						d = new h.Decoder;
					try {
						const f = t(h, d, new Int8Array(l), c),
							p = f.attributes.map(_ => _.array.buffer);
						f.index && p.push(f.index.array.buffer), self.postMessage({
							type: "decode",
							id: a.id,
							geometry: f
						}, p)
					} catch (f) {
						console.error(f), self.postMessage({
							type: "error",
							id: a.id,
							error: f.message
						})
					} finally {
						h.destroy(d)
					}
				});
				break
		}
	};

	function t(o, a, l, c) {
		const u = c.attributeIDs,
			h = c.attributeTypes;
		let d, f;
		const p = a.GetEncodedGeometryType(l);
		if (p === o.TRIANGULAR_MESH) d = new o.Mesh, f = a.DecodeArrayToMesh(l, l.byteLength, d);
		else if (p === o.POINT_CLOUD) d = new o.PointCloud, f = a.DecodeArrayToPointCloud(l, l.byteLength, d);
		else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
		if (!f.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
		const _ = {
			index: null,
			attributes: []
		};
		for (const g in u) {
			const m = self[h[g]];
			let b, v;
			if (c.useUniqueIDs) v = u[g], b = a.GetAttributeByUniqueId(d, v);
			else {
				if (v = a.GetAttributeId(d, o[u[g]]), v === -1) continue;
				b = a.GetAttribute(d, v)
			}
			const y = r(o, a, d, g, m, b);
			g === "color" && (y.vertexColorSpace = c.vertexColorSpace), _.attributes.push(y)
		}
		return p === o.TRIANGULAR_MESH && (_.index = i(o, a, d)), o.destroy(d), _
	}

	function i(o, a, l) {
		const u = l.num_faces() * 3,
			h = u * 4,
			d = o._malloc(h);
		a.GetTrianglesUInt32Array(l, h, d);
		const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
		return o._free(d), {
			array: f,
			itemSize: 1
		}
	}

	function r(o, a, l, c, u, h) {
		const d = h.num_components(),
			p = l.num_points() * d,
			_ = p * u.BYTES_PER_ELEMENT,
			g = s(o, u),
			m = o._malloc(_);
		a.GetAttributeDataArrayForAllPoints(l, h, g, _, m);
		const b = new u(o.HEAPF32.buffer, m, p).slice();
		return o._free(m), {
			name: c,
			array: b,
			itemSize: d
		}
	}

	function s(o, a) {
		switch (a) {
			case Float32Array:
				return o.DT_FLOAT32;
			case Int8Array:
				return o.DT_INT8;
			case Int16Array:
				return o.DT_INT16;
			case Int32Array:
				return o.DT_INT32;
			case Uint8Array:
				return o.DT_UINT8;
			case Uint16Array:
				return o.DT_UINT16;
			case Uint32Array:
				return o.DT_UINT32
		}
	}
}
async function kX(n, e = {}) {
	const i = await (await fetch(n)).json();
	return e.onLoad && e.onLoad(i), i
}

function JE(n, e, t, i = 0) {
	const r = e.size,
		s = e.scale / Math.max(r.w, r.h),
		o = {},
		a = n.anchor || n.pivot || {
			x: .5,
			y: .5
		};
	t.split("_")[0] === "hint" && (a.x = 0, a.y = 0);
	const u = n.frame,
		h = n.sourceSize,
		d = n.spriteSourceSize;
	o.id = t;
	const f = t.split("/");
	o.sequence = f.pop(), o.group = f.join("/"), o.frameIndex = i, o.texCoords = new Float32Array([u.x / r.w, (r.h - u.y - u.h) / r.h, u.w / r.w, u.h / r.h]), o.meshCoords = new Float32Array([d.w * .5 + d.x - h.w * a.x, -(d.h * .5 + d.y - h.h * a.y), d.w, d.h]);
	for (let p = 0, _ = o.meshCoords.length; p < _; p++) o.meshCoords[p] *= s;
	return o.anchor = a, o.sourceSize = n.sourceSize, o.spriteSourceSize = n.spriteSourceSize, o.vertices = n.vertices, o.verticesUV = n.verticesUV, o.triangles = n.triangles, o
}

function IX(n) {
	const e = {
			sprites: {},
			meta: n.meta
		},
		t = n.frames;
	n.animations || (n.animations = {});
	for (const i in n.animations) {
		const r = n.animations[i],
			s = e.sprites[i] = [];
		for (let o = 0, a = r.length; o < a; o++) {
			const l = t[r[o]];
			delete t[r[o]], s.push(JE(l, n.meta, i, o))
		}
	}
	for (const i in t) {
		const r = t[i],
			o = (r.filename ? r.filename.toString() : i).replace(/[^a-zA-Z0-9-_-]/g, "").replace("png", ""),
			a = e.sprites[o] = [];
		delete t[i], a.push(JE(r, n.meta, o))
	}
	return e
}
const OX = "" + globalThis.__publicAssetsURL("textures/utils/bluenoise.png"),
	FX = "" + globalThis.__publicAssetsURL("textures/utils/noise.png"),
	NX = "" + globalThis.__publicAssetsURL("textures/utils/cloud.webp"),
	UX = "" + globalThis.__publicAssetsURL("textures/utils/cloud_blur.webp"),
	BX = "" + globalThis.__publicAssetsURL("textures/utils/cloudPattern.webp"),
	zX = "" + globalThis.__publicAssetsURL("textures/utils/dirt.jpg"),
	VX = "" + globalThis.__publicAssetsURL("textures/smoke_left.webp"),
	HX = "" + globalThis.__publicAssetsURL("textures/smoke_right.webp"),
	GX = "" + globalThis.__publicAssetsURL("textures/text.png"),
	WX = "" + globalThis.__publicAssetsURL("textures/cross.png"),
	jX = "" + globalThis.__publicAssetsURL("sprites/texture.png"),
	$X = "" + globalThis.__publicAssetsURL("sprites/texture.json"),
	yn = {};
yn.bluenoise = OX;
yn.noise = FX;
yn.cloud = NX;
yn.cloudBlur = UX;
yn.cloudPattern = BX;
yn.dirt = zX;
yn.smokeLeft = VX;
yn.smokeRight = HX;
yn.text = GX;
yn.cross = WX;
yn.atlas = $X;
yn.sprites = jX;

function qX(n) {
	const e = {
			textures: null,
			geometries: null,
			atlases: null,
			init: s,
			preload: o
		},
		t = new t0,
		i = new Zq,
		r = new RX;
	r.setDecoderPath("/draco/"), r.setDecoderConfig({
		type: "js"
	}), i.setDRACOLoader(r);
	async function s() {}
	async function o() {
		const c = n.$preloader,
			{
				isMobile: u
			} = n.store,
			h = u ? "mobile" : "desktop",
			d = [];
		[
			[yn.noise, "noise"],
			[yn.cloud, "cloud"],
			[yn.cloudBlur, "cloudBlur"],
			[yn.cloudPattern, "cloudPattern"]
		].forEach(p => {
			d.push(c.task(a(p[0], {
				repeat: !0,
				flipY: !1,
				onLoad: _ => {
					e.textures[p[1]] = _
				}
			})))
		}), d.push(c.task(kX(yn.atlas, {
			onLoad: p => {
				e.atlases.sprites = IX(p)
			}
		}))), d.push(c.task(a(yn.sprites, {
			repeat: !1,
			flipY: !1,
			onLoad: p => {
				e.textures.sprites = p
			}
		}))), d.push(c.task(l("/models/scene.glb", {
			onLoad: p => {
				const g = p.scene.children;
				e.geometries.camera = p.cameras[0], g.forEach(m => {
					m.type !== "PerspectiveCamera" && (e.geometries[m.name.toLowerCase()] = m)
				})
			}
		}))), d.push(c.task(l("/models/logo.glb", {
			onLoad: p => {
				p.scene.children.forEach(m => {
					e.geometries.logo = m
				})
			}
		}))), d.push(c.task(l("/models/curved.glb", {
			onLoad: p => {
				p.scene.children.forEach(m => {
					e.geometries.curved = m
				})
			}
		}))), d.push(c.task(a("/textures/env.webp", {
			onLoad: p => {
				e.textures.env = p
			},
			flipY: !1
		}))), d.push(c.task(a(`/textures/${h}/albedo.webp`, {
			onLoad: p => {
				e.textures.albedo = p
			},
			flipY: !1
		}))), d.push(c.task(a(`/textures/${h}/albedo_close.webp`, {
			onLoad: p => {
				e.textures.close = p
			},
			flipY: !1
		}))), d.push(c.task(a(`/textures/${h}/normal.webp`, {
			onLoad: p => {
				e.textures.normal = p
			},
			flipY: !1
		}))), d.push(c.task(a("/textures/logo_normal_light.webp", {
			onLoad: p => {
				e.textures.logo = p
			},
			flipY: !1
		}))), d.push(c.task(a("/textures/bake.webp", {
			onLoad: p => {
				e.textures.bake = p
			},
			flipY: !1
		}))), d.push(c.task(a(yn.cross, {
			onLoad: p => {
				e.textures.cross = p
			},
			flipY: !1
		}))), d.push(c.task(a(n.homeData.url, {
			onLoad: p => {
				e.textures.text = p
			},
			flipY: !1
		}))), d.push(c.task(a(yn.smokeRight, {
			onLoad: p => {
				e.textures.smokeRight = p
			},
			flipY: !1
		}))), d.push(c.task(a(yn.smokeLeft, {
			onLoad: p => {
				e.textures.smokeLeft = p
			},
			flipY: !1
		}))), await Promise.all(d)
	}
	async function a(c, u) {
		const h = await new Promise((d, f) => {
			t.load(c, p => {
				u.onLoad && u.onLoad(p), d(p)
			})
		});
		u.flipY !== void 0 && (h.flipY = u.flipY), u.magFilter && (h.magFilter = u.magFilter), u.minFilter && (h.minFilter = u.minFilter), u.repeat ? (h.wrapS = ya, h.wrapT = ya) : (u.wrapS && (h.wrapS = u.wrapS), u.wrapT && (h.wrapT = u.wrapT))
	}
	async function l(c, u) {
		return new Promise((h, d) => {
			i.load(c, f => {
				u.onLoad(f), h(f)
			})
		})
	}
	n.loader = e, n.textures = e.textures = {}, n.geometries = e.geometries = {}, n.atlases = e.atlases = {}
}

function XX(n) {
	const e = {
			time: {
				type: "f",
				value: 0
			},
			isMobile: {
				type: "bool",
				value: !1
			},
			resolution: {
				type: "v4",
				value: new kt
			},
			bufferSize: {
				type: "v2",
				value: new Oe
			},
			pixelRatio: {
				type: "f",
				value: 1
			},
			rocksProgress: {
				type: "f",
				value: 0
			},
			backgroundProgress: {
				type: "f",
				value: 0
			},
			labProgress: {
				type: "f",
				value: 0
			}
		},
		t = {
			PI: Math.PI,
			PI2: Math.PI * 2,
			PI_HALF: Math.PI * .5
		};

	function i() {
		Vt(n.$viewport, () => {
			const {
				resolution: s,
				bufferSize: o
			} = e, {
				width: a,
				height: l,
				pixelRatio: c,
				viewportRatio: u
			} = n.$viewport;
			s.value.set(a, l, c, u);
			const h = n.renderer.drawingBufferSize;
			n.renderer.pixelRatio, e.pixelRatio.value = n.$viewport.pixelRatio, o.value.copy(h.value)
		}, {
			immediate: !0
		})
	}

	function r() {
		const {
			rocksProgress: s,
			backgroundProgress: o,
			isMobile: a,
			labDollyProgress: l
		} = n.store, {
			elapsed: c,
			stableDt: u
		} = n.time, {
			width: h,
			height: d,
			pixelRatio: f,
			viewportRatio: p
		} = n.$viewport;
		e.isMobile.value = h < 768, e.rocksProgress.value = s, e.backgroundProgress.value = o, e.time.value = c * .001, e.labProgress.value = l
	}
	Object.assign(n, {
		uniforms: e,
		defines: t,
		shaders: {
			init: i,
			update: r
		}
	})
}
const YX = new Float32Array([-2, 0, 0, -2, 2, 2]),
	rP = new gi;
rP.setAttribute("position", new Cn(YX, 2));
const i0 = ["precision highp float;", "attribute vec2 position;", "varying vec2 vUv;", "void main() {", "vUv = position;", "gl_Position =  vec4(2.0 * position - 1.0, 0.,  1);", "}"].join(""),
	Yg = new Lb,
	KX = "precision highp float;varying vec2 vUv;void main(){gl_FragColor=vec4(vUv,0.,1.);}";
let Lo;
new os(1, 1);

function Ai({
	renderer: n,
	useRawShader: e = !0,
	vertexShader: t,
	fragmentShader: i,
	customScreen: r,
	...s
} = {}) {
	if (!n) throw new Error("WebGL Renderer is required");
	const o = e ? rq : Dn,
		a = new o(Object.assign({}, {
			vertexShader: i0,
			fragmentShader: KX,
			depthTest: !1,
			depthWrite: !1,
			transparent: !0
		}, s));
	return t && (t.use ? t.use(a) : a.vertexShader = t), i && (i.use ? i.use(a) : a.fragmentShader = i), Lo || (Lo = new an(rP, a), Lo.frustumCulled = !1, Lo.matrixAutoUpdate = !1, Lo.matrixWorldAutoUpdate = !1), {
		cam: Yg,
		screen: Lo,
		material: a,
		uniforms: a.uniforms,
		u: a.uniforms,
		render() {
			const c = n.sortObjects,
				u = n.shadowMap.enabled,
				h = n.autoclear;
			n.sortObjects = !1, n.shadowMap.enabled = !1, n.autoclear = !1, r ? (r.material = a, n.render(r, Yg)) : (Lo.material = a, n.render(Lo, Yg)), n.sortObjects = c, n.shadowMap.enabled = u, n.autoclear = h
		}
	}
}

function ZX({
	renderer: n,
	alpha: e,
	depth: t,
	stencil: i,
	width: r,
	height: s,
	scale: o = 1,
	depthTexture: a,
	name: l,
	format: c
}) {
	const u = new Oe;
	r && s ? u.set(r, s) : n.getDrawingBufferSize(u), u.multiplyScalar(o);
	const h = new xa(u.x, u.y, {
		minFilter: jn,
		magFilter: jn,
		format: c || vr,
		colorSpace: qn,
		type: au,
		depthBuffer: !!t,
		stencilBuffer: !!i,
		depthTexture: a,
		alpha: e
	});
	return h.texture.generateMipmaps = !1, h
}
const JX = ["precision highp float;", "uniform sampler2D frame;", "varying vec2 vUv;", "void main() {", "vec2 uv = vUv;", "vec3 color = texture2D(frame, vUv ).rgb;", "gl_FragColor = vec4(color, 1.);", "}"].join("");

function QX(n) {
	let e, t, i;
	const r = {
			createBuffer: p,
			registerBuffer: f,
			unregisterBuffer: _,
			update: g,
			init: u
		},
		s = {
			previewPosition: new Oe,
			previewScale: .3
		},
		o = {
			name: ""
		},
		a = new Map([
			[!1, "None"]
		]),
		l = new Map([
			["None", !1]
		]),
		c = new kt;

	function u(m) {
		m.$gui && (e = Ai({
			renderer: m.threeRenderer,
			fragmentShader: JX,
			uniforms: {
				frame: {
					type: "t"
				}
			},
			transparent: !1
		}), t = m.$gui.addFolder({
			title: "Framebuffers",
			index: 4,
			expanded: !0
		}), t.addBinding(s, "previewPosition", {
			x: {
				step: 10
			},
			y: {
				step: 10
			}
		}), t.addBinding(s, "previewScale", {
			min: .05,
			max: 2
		}), h(), m.hooks.afterFrame.watch(g))
	}

	function h() {
		i && i.dispose();
		const m = [...a.values()].reverse().reduce((v, y) => (v[y] = y, v), {});
		i = t.addBinding(o, "name", {
			index: 0,
			label: "Preview",
			options: m
		});
		const b = sessionStorage.getItem("fbo_current");
		b != null && Object.values(m).includes(b) && (o.name = b, i.refresh()), i.on("change", v => d(v.value))
	}

	function d(m) {
		sessionStorage.setItem("fbo_current", m)
	}

	function f(m, b) {
		a.has(b) || l.has(m) || (a.set(b, m), l.set(m, b), n.$gui && h())
	}

	function p(m) {
		const b = ZX(m);
		return m.name && f(m.name, b), b
	}

	function _(m) {
		!m || m === "None" || (l.has(m) ? (a.delete(l.get(m)), l.delete(m)) : a.has(m) && (l.delete(a.get(m)), a.delete(m)), n.debug && h())
	}

	function g() {
		const m = l.get(o.name);
		if (!m) return;
		const b = n.$viewport,
			v = m.texture || m,
			y = v.image.width / v.image.height,
			x = b.width * s.previewScale,
			S = x / y,
			E = s.previewPosition.x,
			C = b.height - S - s.previewPosition.y,
			P = n.threeRenderer.autoclear,
			w = n.threeRenderer.getViewport(c),
			D = n.threeRenderer.getRenderTarget();
		n.threeRenderer.autoclear = !1, n.threeRenderer.setRenderTarget(null), n.threeRenderer.setViewport(E, C, x, S), e.uniforms.frame.value = v, e.render(), n.threeRenderer.setViewport(w), n.threeRenderer.setRenderTarget(D), n.threeRenderer.autoclear = P
	}
	n.fbo = r
}

function Fi(n, e, t) {
	return {
		vs: n,
		fs: e,
		use: r => {
			r.fragmentShader = e, r.vertexShader = n
		},
		unuse: () => {}
	}
}
var eY = `precision highp float;

uniform highp sampler2D inputBuffer;
uniform mediump float blurStrength;

uniform vec4 resolution;

const float PI2 = 6.28318530718;
const float BLUR_SAMPLES = 10.0;

vec4 blur( sampler2D image, vec2 uv){
	vec4 color = texture2D(image, uv);
	for (float d = 0.0; d < PI2; d += PI2 / BLUR_SAMPLES) {
		color += texture2D(image, uv + vec2(cos(d), sin(d)) * blurStrength);
	}
	color /= BLUR_SAMPLES * 1.095;
	return color;
}

vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * direction;
  color += texture2D(image, uv) * 0.29411764705882354;
  color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
  color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
  return color;
}

varying vec2 vUv;

void main() {
	vec4 sum = blur(inputBuffer, vUv); 

	gl_FragColor = sum;
  
  

}`;

function tY(n, e) {
	const t = n.threeRenderer,
		i = {
			strength: 18,
			strengthTarget: 50
		};
	n.$gui && e.addBinding(i, "strengthTarget", {
		label: "DOF Strength",
		min: 0,
		max: 100
	});
	const r = n.fbo.createBuffer({
			name: "PP - BlurTexture A",
			renderer: n.threeRenderer,
			scale: .15,
			alpha: !1
		}),
		s = n.fbo.createBuffer({
			name: "PP - BlurTexture B",
			renderer: n.threeRenderer,
			scale: .07,
			alpha: !1
		}),
		o = n.fbo.createBuffer({
			name: "PP - BlurTexture C",
			renderer: n.threeRenderer,
			scale: .3,
			alpha: !1
		}),
		a = Ai({
			renderer: n.threeRenderer,
			fragmentShader: eY,
			uniforms: {
				blurStrength: {
					value: .0028
				},
				blurAlpha: {
					value: 1
				},
				inputBuffer: {
					value: null,
					type: "t"
				}
			}
		});

	function l(u) {
		const {
			inputBuffer: h,
			blurStrength: d
		} = a.uniforms, f = t.getRenderTarget();
		u = (u == null ? void 0 : u.texture) || u || (f == null ? void 0 : f.texture), h.value = u, i.strength += (i.strengthTarget - i.strength) / 6;
		const p = Gg(i.strength, 30, 100, 0, .01),
			_ = Gg(i.strength, 50, 100, 0, .01),
			g = Gg(i.strength, 0, 100, 0, .015);
		return p > 0 && (d.value = p, t.setRenderTarget(r), t.clearColor(), a.render(), h.value = r.texture), _ > 0 && (d.value = _, t.setRenderTarget(s), t.clearColor(), a.render(), h.value = s.texture), d.value = g, t.setRenderTarget(o), t.clearColor(), a.render(), t.setRenderTarget(f), c.outputTexture
	}
	const c = {
		render: l,
		get outputTexture() {
			return o.texture
		}
	};
	return c
}
var nY = `precision highp float;

uniform sampler2D scene;

uniform sampler2D backgroundScene;
uniform sampler2D rockScene;
uniform sampler2D labScene;

uniform float rocksProgress;
uniform float rocksActive;

uniform float backgroundProgress;
uniform float time;

uniform float blurAmount;
uniform bool mobile;

uniform vec4 resolution;
uniform vec2 res;
uniform float dpi;
uniform float opacity;

uniform float labProgress;
uniform float maskProgress;
uniform float maskRotation;

varying vec2 vUv;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <colorspace_pars_fragment>

float hash12(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * .1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.x + p3.y) * p3.z);
}

float blendSoftLight(float base, float blend) {
	return (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));
}

vec3 blendSoftLight(vec3 base, vec3 blend) {
	return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));
}

vec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {
	return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));
}

float roundBox( vec2 p, vec2 b, float r ) {
  return length(max(abs(p)-b+r,0.0))-r;
}

vec2 rotateUV(vec2 uv, float rotation) {
  float cosAngle = cos(rotation);
  float sinAngle = sin(rotation);
  vec2 p = uv - vec2(0.5);
  return vec2(
      cosAngle * p.x + sinAngle * p.y + 0.5,
      cosAngle * p.y - sinAngle * p.x + 0.5
  );
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

const int iterations = 7;
const float bendAmount = -0.8;
const float maxDistort = 0.2;

float sat( float t ) {
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

vec3 blendOverlay(vec3 base, vec3 blend) {
	return mix(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, step(base, vec3(0.5)));
}

float blendScreen(float base, float blend) {
	return 1.0-((1.0-base)*(1.0-blend));
}

vec3 blendAdd(vec3 base, vec3 blend) {
	return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t, 0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo, 1.0, hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);
	return pow( ret, vec4(1.0/2.2) );
}

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

void main() {
  vec2 px = gl_FragCoord.xy - 0.5 * res.xy;
	vec2 uv = vUv;

  
  vec2 boxScale = maskProgress * resolution.xy * 0.5 * dpi;
  vec2 boxUv = rotateUV(px, maskRotation);

  float radius = mix(20., 0., maskProgress);
  float box = roundBox(boxUv, boxScale, radius);

  vec3 rockDiffuse = texture2D( rockScene, uv ).rgb;
  vec3 backgroundDiffuse = texture2D(backgroundScene, uv).rgb;

  
  vec3 diffuse = mix(backgroundDiffuse, rockDiffuse, step(backgroundProgress, uv.y));
  diffuse = mix(diffuse, backgroundDiffuse, smoothstep(0.0,1.0,box));

	gl_FragColor.rgb = diffuse;
  gl_FragColor.a = opacity;

  
  gl_FragColor = sRGBTransferOETF( gl_FragColor );
}`;
const Kg = Fi(i0, nY);
var iY = `precision highp float;

uniform sampler2D inputTexture;
uniform sampler2D blurredTexture;
varying vec2 vUv;

const int iterations = 7;
const float bend = -0.5;
const float distort = 0.25;

float sat( float t ) {
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t, 0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo, 1.0, hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);
	return pow( ret, vec4(1.0/2.2) );
}

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

void main() {

  vec4 diffuse;
  vec2 uv = vUv;

  
	vec2 uv2 = vUv;
	uv2 *= 1.0 - vUv.yx;
	float vig = uv2.x * uv2.y * 20.0; 
	vig = pow(vig, 0.5); 

  
  vec3 sharp = texture2D(inputTexture, uv).rgb;
  vec3 blurred = texture2D(blurredTexture, uv).rgb;

  
  vec4 screenFx;
  vec4 sumcol = vec4(0.0);
  vec4 sumw = vec4(0.0);
  float reci_num_iter_f = 1. / float(iterations);
  for (int i = 0; i < iterations; i++) {
    float t = float(i) * reci_num_iter_f;
    vec4 w = spectrum_offset( t );
    sumw += w;
    sumcol += w * texture2D( inputTexture, barrelDistortion(uv, bend * distort * t ) );
  }
  screenFx = sumcol / sumw;
  sharp = screenFx.rgb;

  diffuse.rgb = mix(blurred, sharp, clamp(vig, 0., 1.));

  gl_FragColor.rgb = diffuse.rgb;
  gl_FragColor.a = 1.;

  
}`;
const rY = Fi(i0, iY);

function sY(n, e) {
	const t = Ai({
		renderer: n.threeRenderer,
		fragmentShader: rY.fs,
		uniforms: {
			...n.uniforms,
			inputTexture: {
				value: null,
				type: "t"
			},
			blurredTexture: {
				value: null,
				type: "t"
			}
		},
		defines: Object.assign({
			MOBILE: n.store.isMobile
		})
	});
	return function (r, s) {
		t.u.blurredTexture.value = s, t.u.inputTexture.value = r.texture, t.render()
	}
}
var oY = `precision highp float;

uniform sampler2D rockTexture;
uniform sampler2D textTexture;

const int iterations = 7;

float sat( float t ) {
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t, 0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo, 1.0, hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);
	return pow( ret, vec4(1.0/2.2) );
}

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

varying vec2 vUv;

void main() {

  float bend = -0.3;
  float distort = 2.;

  vec4 textDiffuse;

  #ifdef MOBILE
    bend = 0.2;
    distort = 2.;
  #endif

  
  vec4 screenFx;
  vec4 sumcol = vec4(0.0);
  vec4 sumw = vec4(0.0);
  float reci_num_iter_f = 1. / float(iterations);
  for (int i = 0; i < iterations; i++) {
    float t = float(i) * reci_num_iter_f;
    vec4 w = spectrum_offset( t );
    sumw += w;
    sumcol += w * texture2D( textTexture, barrelDistortion(vUv, bend * distort * t ) );
  }
  screenFx = sumcol / sumw;

  textDiffuse = screenFx;
	vec4 rocks = texture2D(rockTexture, vUv);

	gl_FragColor = rocks;

  
  gl_FragColor = mix(rocks, textDiffuse, textDiffuse.a);
}`;
const aY = Fi(i0, oY);

function lY(n, e) {
	const t = Ai({
		renderer: n.threeRenderer,
		fragmentShader: aY.fs,
		uniforms: {
			...n.uniforms,
			rockTexture: {
				value: null,
				type: "t"
			},
			textTexture: {
				value: null,
				type: "t"
			}
		},
		defines: Object.assign({
			MOBILE: n.store.isMobile
		})
	});

	function i(r, s) {
		t.u.rockTexture.value = r.texture, t.u.textTexture.value = s.texture, t.render()
	}
	return {
		render: i
	}
}
var cY = `precision highp float;

uniform sampler2D inputTexture;
varying vec2 vUv;

void main() {
  vec4 diffuse = texture2D(inputTexture, vUv);
	gl_FragColor = diffuse;
}`;

function uY(n, e) {
	const t = Ai({
		renderer: n.threeRenderer,
		fragmentShader: cY,
		uniforms: {
			...n.uniforms,
			inputTexture: {
				value: null,
				type: "t"
			}
		}
	});
	return function (r) {
		t.u.inputTexture.value = r.texture, t.render()
	}
}
var hY = `precision highp float;

uniform sampler2D inputTexture;
varying vec2 vUv;
uniform float labProgress;

const int iterations = 7;
const float bend = -0.8;
const float distort = 0.2;

float sat( float t ) {
	return clamp( t, 0.0, 1.0 );
}

float linterp( float t ) {
	return sat( 1.0 - abs( 2.0*t - 1.0 ) );
}

float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

vec4 spectrum_offset( float t ) {
	vec4 ret;
	float lo = step(t, 0.5);
	float hi = 1.0-lo;
	float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );
	ret = vec4(lo, 1.0, hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);
	return pow( ret, vec4(1.0/2.2) );
}

vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	return coord + cc * dist * amt;
}

void main() {

    vec2 uv = vUv;

  
	vec2 uv2 = vUv;
	uv2 *= 1.0 - vUv.yx;
	float vig = uv2.x * uv2.y * 20.0; 
	vig = pow(vig, 0.55); 

	vec4 diffuse;
  vec4 screenFx;
  vec4 sumcol = vec4(0.0);
  vec4 sumw = vec4(0.0);
  float reci_num_iter_f = 1. / float(iterations);
  for (int i = 0; i < iterations; i++) {
    float t = float(i) * reci_num_iter_f;
    vec4 w = spectrum_offset( t );
    sumw += w;
    sumcol += w * texture2D( inputTexture, barrelDistortion(uv, bend * distort * t ) );
  }
  screenFx = sumcol / sumw;
  diffuse = vec4(screenFx.rgb, 1.);

  gl_FragColor = diffuse;
}`;

function dY(n, e) {
	const t = Ai({
		renderer: n.threeRenderer,
		fragmentShader: hY,
		uniforms: {
			...n.uniforms,
			inputTexture: {
				value: null,
				type: "t"
			}
		}
	});
	return function (r) {
		t.u.inputTexture.value = r.texture, t.render()
	}
}
const Wb = new gi,
	fY = new Float32Array([-1, -1, 3, -1, -1, 3]),
	pY = new Float32Array([0, 0, 2, 0, 0, 2]);
Wb.setAttribute("position", new $i(fY, 2));
Wb.setAttribute("uv", new $i(pY, 2));

function mY(n) {
	const e = {},
		u = {
			value: new Oe(.0078125, .0078125)
		},
		h = `
  precision highp float;
  attribute vec2 position;
  attribute vec2 uv;
  varying vec2 vUv;
  varying vec2 vL;
  varying vec2 vR;
  varying vec2 vT;
  varying vec2 vB;
  uniform vec2 texelSize;
  void main () {
      vUv = uv;
      vL = vUv - vec2(texelSize.x, 0.0);
      vR = vUv + vec2(texelSize.x, 0.0);
      vT = vUv + vec2(0.0, texelSize.y);
      vB = vUv - vec2(0.0, texelSize.y);
      gl_Position = vec4(position, 0, 1);
  }
  `,
		d = `
  precision mediump float;
  precision mediump sampler2D;
  varying highp vec2 vUv;
  uniform sampler2D uTexture;
  uniform float value;
  void main () {
      gl_FragColor = value * texture2D(uTexture, vUv);
  }
  `,
		f = `
  precision highp float;
  precision highp sampler2D;
  varying vec2 vUv;
  uniform sampler2D uTarget;
  uniform float aspectRatio;
  uniform vec3 color;
  uniform vec2 point;
  uniform float radius;
  void main () {
      vec2 p = vUv - point.xy;
      p.x *= aspectRatio;
      vec3 splat = exp(-dot(p, p) / radius) * color;
      vec3 base = texture2D(uTarget, vUv).xyz;
      gl_FragColor = vec4(base + splat, 1.0);
  }
  `,
		p = `
  precision highp float;
  precision highp sampler2D;
  varying vec2 vUv;
  uniform sampler2D uVelocity;
  uniform sampler2D uSource;
  uniform vec2 texelSize;
  uniform float dt;
  uniform float dissipation;
  void main () {
      vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
      gl_FragColor = dissipation * texture2D(uSource, coord);
      gl_FragColor.a = 1.0;
  }
  `,
		_ = `
  precision mediump float;
  precision mediump sampler2D;
  varying highp vec2 vUv;
  varying highp vec2 vL;
  varying highp vec2 vR;
  varying highp vec2 vT;
  varying highp vec2 vB;
  uniform sampler2D uVelocity;
  void main () {
      float L = texture2D(uVelocity, vL).x;
      float R = texture2D(uVelocity, vR).x;
      float T = texture2D(uVelocity, vT).y;
      float B = texture2D(uVelocity, vB).y;
      vec2 C = texture2D(uVelocity, vUv).xy;
      if (vL.x < 0.0) { L = -C.x; }
      if (vR.x > 1.0) { R = -C.x; }
      if (vT.y > 1.0) { T = -C.y; }
      if (vB.y < 0.0) { B = -C.y; }
      float div = 0.5 * (R - L + T - B);
      gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
  }
  `,
		g = `
  precision mediump float;
  precision mediump sampler2D;
  varying highp vec2 vUv;
  varying highp vec2 vL;
  varying highp vec2 vR;
  varying highp vec2 vT;
  varying highp vec2 vB;
  uniform sampler2D uVelocity;
  void main () {
      float L = texture2D(uVelocity, vL).y;
      float R = texture2D(uVelocity, vR).y;
      float T = texture2D(uVelocity, vT).x;
      float B = texture2D(uVelocity, vB).x;
      float vorticity = R - L - T + B;
      gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
  }
  `,
		m = `
  precision highp float;
  precision highp sampler2D;
  varying vec2 vUv;
  varying vec2 vL;
  varying vec2 vR;
  varying vec2 vT;
  varying vec2 vB;
  uniform sampler2D uVelocity;
  uniform sampler2D uCurl;
  uniform float curl;
  uniform float dt;
  void main () {
      float L = texture2D(uCurl, vL).x;
      float R = texture2D(uCurl, vR).x;
      float T = texture2D(uCurl, vT).x;
      float B = texture2D(uCurl, vB).x;
      float C = texture2D(uCurl, vUv).x;
      vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
      force /= length(force) + 0.0001;
      force *= curl * C;
      force.y *= -1.0;
      vec2 vel = texture2D(uVelocity, vUv).xy;
      gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);
  }
  `,
		b = `
  precision mediump float;
  precision mediump sampler2D;
  varying highp vec2 vUv;
  varying highp vec2 vL;
  varying highp vec2 vR;
  varying highp vec2 vT;
  varying highp vec2 vB;
  uniform sampler2D uPressure;
  uniform sampler2D uDivergence;
  void main () {
      float L = texture2D(uPressure, vL).x;
      float R = texture2D(uPressure, vR).x;
      float T = texture2D(uPressure, vT).x;
      float B = texture2D(uPressure, vB).x;
      float C = texture2D(uPressure, vUv).x;
      float divergence = texture2D(uDivergence, vUv).x;
      float pressure = (L + R + B + T - divergence) * 0.25;
      gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
  }
  `,
		v = `
  precision mediump float;
  precision mediump sampler2D;
  varying highp vec2 vUv;
  varying highp vec2 vL;
  varying highp vec2 vR;
  varying highp vec2 vT;
  varying highp vec2 vB;
  uniform sampler2D uPressure;
  uniform sampler2D uVelocity;
  void main () {
      float L = texture2D(uPressure, vL).x;
      float R = texture2D(uPressure, vR).x;
      float T = texture2D(uPressure, vT).x;
      float B = texture2D(uPressure, vB).x;
      vec2 velocity = texture2D(uVelocity, vUv).xy;
      velocity.xy -= vec2(R - L, T - B);
      gl_FragColor = vec4(velocity, 0.0, 1.0);
  }
  `;

	function y(H, F, G) {
		return n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Liquid - " + H,
			width: F,
			height: F,
			format: G,
			depth: !1
		})
	}

	function x(H, F, G) {
		const R = {
			read: n.fbo.createBuffer({
				renderer: n.threeRenderer,
				name: "Liquid - Read " + H,
				width: F,
				height: F,
				format: G,
				depth: !1
			}),
			write: n.fbo.createBuffer({
				renderer: n.threeRenderer,
				name: "Liquid - Write " + H,
				width: F,
				height: F,
				format: G,
				depth: !1
			}),
			swap: () => {
				let Q = R.read;
				R.read = R.write, R.write = Q
			}
		};
		return R
	}
	const S = x("Density", 512),
		E = x("Velocity", 128, bD),
		C = x("Pressure", 128, Lh),
		P = y("Divergence", 128, Lh),
		w = y("Curl", 128, Lh),
		D = new yr,
		U = new an(Wb, D);
	U.frustumCulled = !1, U.matrixAutoUpdate = !1, U.matrixWorldAutoUpdate = !1, e.clear = Ai({
		renderer: n.threeRenderer,
		fragmentShader: d,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uTexture: {
				value: null
			},
			value: {
				value: .8
			}
		})
	}), e.splat = Ai({
		renderer: n.threeRenderer,
		fragmentShader: f,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uTarget: {
				value: null
			},
			aspectRatio: {
				value: 1
			},
			color: {
				value: new et
			},
			point: {
				value: new Oe
			},
			radius: {
				value: .3 / 100
			}
		})
	}), e.advection = Ai({
		renderer: n.threeRenderer,
		fragmentShader: p,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			dyeTexelSize: {
				value: new Oe(1 / 512, 1 / 512)
			},
			uVelocity: {
				value: null
			},
			uSource: {
				value: null
			},
			dt: {
				value: .016
			},
			dissipation: {
				value: 1
			}
		})
	}), e.divergence = Ai({
		renderer: n.threeRenderer,
		fragmentShader: _,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uVelocity: {
				value: null
			}
		})
	}), e.curl = Ai({
		renderer: n.threeRenderer,
		fragmentShader: g,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uVelocity: {
				value: null
			}
		})
	}), e.vorticity = Ai({
		renderer: n.threeRenderer,
		fragmentShader: m,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uVelocity: {
				value: null
			},
			uCurl: {
				value: null
			},
			curl: {
				value: 20
			},
			dt: {
				value: .016
			}
		})
	}), e.pressure = Ai({
		renderer: n.threeRenderer,
		fragmentShader: b,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uPressure: {
				value: null
			},
			uDivergence: {
				value: null
			}
		})
	}), e.gradient = Ai({
		renderer: n.threeRenderer,
		fragmentShader: v,
		vertexShader: h,
		customScreen: U,
		uniforms: Object.assign({
			texelSize: u,
			uPressure: {
				value: null
			},
			uVelocity: {
				value: null
			}
		})
	});

	function j() {
		const H = n.threeRenderer,
			{
				pos: F,
				delta: G
			} = n.$touch,
			{
				width: R,
				height: Q,
				viewportRatio: B
			} = n.$viewport;
		e.splat.u.uTarget.value = E.read.texture, e.splat.u.aspectRatio.value = B, e.splat.u.point.value.set(F.x / R, 1 - F.y / Q), e.splat.u.color.value.set(G.x * 5, G.y * -5, 1);
		const ge = H.getRenderTarget();
		H.setRenderTarget(E.write), e.splat.render(), E.swap(), e.splat.u.uTarget.value = S.read.texture, H.setRenderTarget(S.write), e.splat.render(), S.swap(), H.setRenderTarget(ge)
	}

	function z() {
		const H = n.threeRenderer;
		H.setClearAlpha(1), j();
		const F = H.getRenderTarget();
		e.curl.u.uVelocity.value = E.read.texture, H.setRenderTarget(w), e.curl.render(), e.vorticity.u.uVelocity.value = E.read.texture, e.vorticity.u.uCurl.value = w.texture, H.setRenderTarget(E.write), e.vorticity.render(), E.swap(), e.divergence.u.uVelocity.value = E.read.texture, H.setRenderTarget(P), e.divergence.render(), e.clear.u.uTexture.value = C.read.texture, H.setRenderTarget(C.write), e.clear.render(), C.swap(), e.pressure.u.uDivergence.value = P.texture;
		for (let G = 0; G < 3; G++) e.pressure.u.uPressure.value = C.read.texture, H.setRenderTarget(C.write), e.pressure.render(), C.swap();
		e.gradient.u.uPressure.value = C.read.texture, e.gradient.u.uVelocity.value = E.read.texture, H.setRenderTarget(E.write), e.gradient.render(), E.swap(), e.advection.u.dyeTexelSize.value.set(1 / 128, 1 / 128), e.advection.u.uVelocity.value = E.read.texture, e.advection.u.uSource.value = E.read.texture, e.advection.u.dissipation.value = .94, H.setRenderTarget(E.write), e.advection.render(), E.swap(), e.advection.u.dyeTexelSize.value.set(1 / 512, 1 / 512), e.advection.u.uVelocity.value = E.read.texture, e.advection.u.uSource.value = S.read.texture, e.advection.u.dissipation.value = .94, H.setRenderTarget(S.write), e.advection.render(), S.swap(), H.setRenderTarget(F), H.setClearAlpha(0)
	}
	return {
		render: z,
		splat: j,
		texture: S.read.texture
	}
}

function gY(n) {
	const e = {},
		t = {};
	let i = new GD,
		r = new Ob(512, 512);
	const s = {
		enabled: !0,
		init: o,
		update: c,
		render: u,
		pingpong: a,
		buffers: e,
		depthMaterial: i,
		depthTexture: r
	};
	n.postprocess = s;

	function o() {
		var d;
		const {
			isMobile: h
		} = n.store;
		n.$gui, h || (s.liquid = mY(n)), s.blurPass = tY(n, n.$gui), s.rockComposer = sY(n, n.$gui), s.textComposer = lY(n, n.$gui), s.labComposer = dY(n, n.$gui), s.renderToScreen = uY(n), e.main = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Main",
			depth: !0
		}), e.rock = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Rocks",
			depth: !0
		}), e.rockPost = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Rocks Post",
			depth: !1
		}), e.text = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Text",
			alpha: !0
		}), e.lab = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Lab",
			depth: !0
		}), e.labPost = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Lab Post"
		}), e.background = n.fbo.createBuffer({
			renderer: n.threeRenderer,
			name: "Scene - Background"
		}), t.main = Ai({
			renderer: n.threeRenderer,
			vertexShader: Kg.vs,
			fragmentShader: Kg.fs,
			uniforms: Object.assign({
				...n.uniforms,
				mobile: {
					value: h
				},
				res: {
					value: new Oe
				},
				dpi: {
					value: 0
				},
				rockScene: {
					value: e.rockPost.texture
				},
				labScene: {
					value: e.lab.texture
				},
				backgroundScene: {
					value: (d = e == null ? void 0 : e.background) == null ? void 0 : d.texture
				},
				maskProgress: {
					value: null
				},
				maskRotation: {
					value: null
				},
				labProgress: {
					value: null
				},
				rocksActive: {
					value: null
				},
				blurAmount: {
					value: 0
				},
				opacity: {
					value: null
				}
			}),
			defines: Object.assign({
				MOBILE: h
			})
		}), t.main.material.transparent = !1, Kg.use(t.main.material), Vt(n.$viewport, l, {
			immediate: !0
		})
	}

	function a() {
		const h = e.ping,
			d = e.pong,
			f = e.main === h ? h : d,
			p = f === d ? h : d;
		e.main = p, n.previousFrame.value = f.texture, n.currentFrame.value = p.texture
	}

	function l() {
		t.main.uniforms.res.value.copy(n.renderer.drawingBufferSize.value), t.main.uniforms.dpi.value = n.renderer.pixelRatio.value;
		const h = n.renderer.drawingBufferSize.value;
		e.rock.setSize(h.x, h.y), e.rockPost.setSize(h.x, h.y), e.text.setSize(h.x, h.y), e.background.setSize(h.x, h.y), e.lab.setSize(h.x, h.y), e.labPost.setSize(h.x, h.y), e.main.setSize(h.x, h.y)
	}

	function c() {
		const h = t.main.uniforms;
		h.rocksActive.value = n.store.rocksActive, h.opacity.value = n.store.opacity, h.maskProgress.value = n.store.maskProgress, h.labProgress.value = n.store.labProgress, h.maskRotation.value = n.store.maskRotation, h.blurAmount.value = n.store.labProcessing, h.labProgress.value = n.store.labProcessing
	}

	function u() {
		var h;
		n.threeRenderer, (h = s.liquid) == null || h.render(), t.main.render()
	}
}
const _Y = "string";
class _i {
	constructor(e = {}) {
		this.isComponent = !0, this.props = e, this.webgl = Qn(), this.scene = null, this.parent = null, this.base = null, this.children = []
	}
	triggerInit() {
		this.isInit || (this.beforeInit && this.beforeInit(), this.init && this.init(), this.webgl.$gui && this.debug && this.debug(), this.isInit = !0, this.afterInit && this.afterInit())
	}
	addObject3D(e) {
		return this.base && this.base.add(e), e
	}
	removeObject3D(e) {
		return this.base && this.base.remove(e), null
	}
	add(e, t = {}, i) {
		if (typeof e === _Y && (e = this.webgl.components[e]), !e) return;
		if (~this.children.indexOf(e)) return e;
		e.isComponent || (e = new e(t));
		const r = e.parent;
		return r && r.remove(e), e.parent = this, this.scene ? e.scene = this.scene : this.isScene && (e.scene = this), e.isInit || e.triggerInit(t), this.children.push(e), e.base && (i ? i.add(e.base) : this.base && this.base.add(e.base)), e.destroyed ? (this.remove(e), e) : (this.isAttached && triggerAttached(this.scene, e), e)
	}
	triggerUpdate() {
		if (!this.isInit) return;
		this.beforeUpdate && this.beforeUpdate(), this.update && this.update();
		const e = this.children;
		for (let t = 0, i = e.length; t < i; t++) {
			const r = e[t];
			r && r.triggerUpdate()
		}
		this.afterUpdate && this.afterUpdate()
	}
}

function vY() {
	const n = window.innerWidth / window.innerHeight;
	return new Yn(55, n, .1, 100)
}
class Vd extends _i {
	constructor(e = {}) {
		super(e), this.isCamera = !0, this.isUsed = !1
	}
	afterInit() {
		this.cam && !this.base ? this.base = this.cam : this.cam || (this.cam = vY()), this.base || (this.base = this.cam), Vt(this.webgl.$viewport, this.resize.bind(this), {
			immediate: !0
		})
	}
	resize() {
		this.cam.aspect = this.webgl.$viewport.width / this.webgl.$viewport.height, this.cam.updateProjectionMatrix()
	}
	used() {}
	unused() {}
}

function QE(n, e) {
	!n || n.isUsed == e || (n.isUsed = !!e, n.isUsed ? n.used() : n.unused())
}
class r0 extends _i {
	constructor(e = {}) {
		super(e, !0), this.isScene = !0, this._cam = {
			current: !1,
			forced: !1
		}
	}
	triggerInit() {
		this.isInit || (this.base = new K$, super.triggerInit())
	}
	render(e) {
		if (!e) return;
		const t = this.getCurrentCamera();
		t && e.render(this.base, t.cam)
	}
	get camera() {
		return this._cam.current
	}
	set camera(e) {
		(!e || !e.isCamera) && (e = !1);
		const t = this._cam;
		t.current !== e && (QE(t.current, !1), t.current = e, QE(t.current, !0))
	}
	getCurrentCamera() {
		return this._cam.forced || this._cam.current
	}
	triggerRender(e) {
		this.beforeRender && this.beforeRender(e), this.render(e), this.afterRender && this.afterRender(e)
	}
}
var bY = `precision highp float;

uniform vec3 uGreen;
uniform vec3 uGrey;

uniform sampler2D uNoise;
uniform sampler2D uLeft;
uniform sampler2D uRight;
uniform sampler2D uSmoke;
uniform sampler2D uLiquid;

uniform vec4 resolution;
uniform float time;
uniform float uProgress;
uniform float uDissolve;
uniform float uLine;
uniform bool isMobile;

varying vec2 vUv;

float LIMIT = 0.25;

float blendScreen(float base, float blend) {
	return 1.0-((1.0-base)*(1.0-blend));
}

vec3 blendScreen(vec3 base, vec3 blend) {
	return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));
}

vec3 blendScreen(vec3 base, vec3 blend, float opacity) {
	return (blendScreen(base, blend) * opacity + base * (1.0 - opacity));
}

void main() {
  float uvMask = smoothstep(0., 1., vUv.y);
  float yGradient = 1.;

  vec3 fluid = texture2D(uLiquid, vUv).rgb;
  float realFluid = 0.;

  float mobileFactor = isMobile ? 1. : 2.;

  vec2 uvLeft = vec2(vUv.x * 2. + uLine * 1.5, vUv.y - 0.25);
  
  vec2 uvRight = vec2(vUv.x * 2. - uLine * 2., vUv.y - 0.15);
  

  
  if (vUv.x < uLine) {
    uvMask *= smoothstep(0., uLine, vUv.x);
  } else {
    uvMask *= smoothstep(uLine, uLine + 0.2, vUv.x) + 0.5;
  }

  vec2 uvHardLine = vec2(vUv.x, vUv.y);
  vec2 uv = vUv;

  float left = texture2D(uLeft, vec2(uvLeft.x * (2. * mobileFactor), uvLeft.y)).r;
  float right = texture2D(uRight, vec2(uvRight.x * (2. * mobileFactor), uvRight.y)).r;
  float smoke = 0.;

  
  vec3 noise = texture2D(uNoise, vUv + time * 0.01).rgb;
  noise.r = smoothstep(0.1, 0.99, noise.r);

  
  float dist;
  float strokeRadius;
  float innerEdge;
  float outerEdge;
  float innerCircle;
  float strokeInnerEdge;
  float strokeOuterEdge;
  float stroke;

  if (vUv.x > uLine) {
    
    yGradient = smoothstep(0.25, 1., vUv.y);
    uvHardLine = uvRight;
    smoke = right;

    realFluid = fluid.b;

  } else {
    
    yGradient = smoothstep(0., 1., vUv.y);
    uvHardLine = uvLeft;
    smoke = left;

    realFluid = fluid.b - fluid.r;
  }

  dist = distance(uvHardLine, vec2(0., 1.));
  strokeRadius = sqrt(2.0) * smoothstep(0., 2., uProgress);
  strokeRadius *= 1. + noise.g * 2.;

  innerEdge = strokeRadius - 0.3;
  outerEdge = strokeRadius;
  innerCircle = smoothstep(innerEdge, outerEdge, dist);

  strokeInnerEdge = strokeRadius;
  strokeOuterEdge = strokeRadius + 0.1;
  stroke = innerCircle - smoothstep(strokeInnerEdge, strokeOuterEdge, dist);

  stroke *= 1. - uProgress;
  stroke *= uvMask;

  
  float gradientNoise = texture2D(uNoise, vUv * 1. + time * 0.01).r;
  smoke *= 0.6;
  smoke *= 1. - gradientNoise * 0.5;
  smoke *= uvMask;

  vec3 diffuse = mix(uGrey, uGreen, clamp(yGradient * (0.2 + smoke * innerEdge * 0.9), 0., 1.));
  diffuse = mix(diffuse, uGreen, clamp(smoothstep(0., 0.3, stroke) * 0.5, 0., 1.));
  diffuse = mix(uGrey, diffuse, clamp(1. - uDissolve - clamp(realFluid, 0., 0.6), 0., 1.));
  gl_FragColor = vec4(diffuse, 1.);
  

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	yY = `varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
const xY = Fi(yY, bY);
class hm extends Dn {
	constructor(e = {}) {
		var r;
		super();
		const t = Qn(),
			i = t.postprocess;
		this.uniforms = {
			...t.uniforms,
			uNoise: {
				value: t.textures.noise
			},
			uGreen: {
				value: new et("#EAFFB0")
			},
			uGrey: {
				value: new et("#EEEDEA")
			},
			uSmoke: {
				value: t.textures.smokeLeft
			},
			uLeft: {
				value: t.textures.smokeLeft
			},
			uRight: {
				value: t.textures.smokeRight
			},
			uProgress: {
				value: t.store.noisePropagation
			},
			uDissolve: {
				value: t.store.noiseDissolve
			},
			uLine: {
				value: .255
			},
			uLiquid: {
				value: (r = i.liquid) == null ? void 0 : r.texture
			}
		}, Vt(t.$viewport, () => {
			const s = t.$viewport.width;
			s < 1024 && (this.uniforms.uLine.value = .1825), s > 1024 && (this.uniforms.uLine.value = .255)
		}, {
			immediate: !0
		}), xY.use(this), this.depthTest = !1, this.depthWrite = !1, this.transparent = !0, t.hooks.afterUpdate.watch(() => {
			this.uniforms.uProgress.value = t.store.noisePropagation, this.uniforms.uDissolve.value = t.store.noiseDissolve
		})
	}
}
let eS = null;
hm.use = () => eS = eS ?? new hm;
hm.unuse = () => {};
class wY extends _i {
	init() {
		const e = new os(1, 1);
		this.base = new an(e, hm.use()), this.base.frustumCulled = !1, this.base.renderOrder = 2
	}
	resize(e) {
		this.base.scale.set(this.webgl.$viewport.width, this.webgl.$viewport.height)
	}
}
class EY extends Vd {
	init() {
		this.base = new ht, this.cam = new Jm(-1, 1, 1, -1, 0, 1), Vt(this.webgl.$viewport, this.resize.bind(this), {
			immediate: !0
		}), this.base.add(this.cam)
	}
	resize(e) {
		const t = this.cam;
		t.left = this.webgl.$viewport.width / -2, t.right = this.webgl.$viewport.width / 2, t.top = this.webgl.$viewport.height / 2, t.bottom = this.webgl.$viewport.height / -2, t.updateProjectionMatrix()
	}
}
var SY = `precision highp float;
uniform vec4 resolution;
uniform float dpi;
uniform float opacity;
uniform float radiusFactor;
uniform sampler2D map;
varying vec2 vUv;

float calcDistance(vec2 uv, float radius) {
  vec2 center = abs(vUv * 2. - 1.);
  vec2 res = resolution.xy / 2.;
  vec2 coords = center * (res + radius);
  vec2 delta = max(coords - res, 0.);
  return length(delta);
}

void main() {

  vec3 diffuse = texture2D(map, vUv).rgb;
  gl_FragColor = vec4(diffuse, opacity);

  float radius = 4. * radiusFactor;

  float dist = calcDistance(vUv, radius);
  if (dist > radius) {
    gl_FragColor.a = 0.;
  }

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
	TY = `varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
const MY = Fi(TY, SY);
class dm extends Dn {
	constructor(e = {}) {
		super();
		const t = Qn();
		this.uniforms = {
			...t.uniforms,
			map: {
				value: t.postprocess.buffers.labPost.texture
			},
			opacity: {
				value: t.store.labOpacity
			},
			radiusFactor: {
				value: t.store.labScaleFactor
			}
		}, MY.use(this), this.depthTest = !1, this.depthWrite = !1, this.transparent = !0, t.hooks.afterUpdate.watch(() => {
			this.uniforms.opacity.value = t.store.labOpacity, this.uniforms.radiusFactor.value = t.store.labScaleFactor
		})
	}
}
let tS = null;
dm.use = () => tS = tS ?? new dm;
dm.unuse = () => {};
class CY extends _i {
	init() {
		const e = new os(1, 1);
		this.base = new an(e, new dm), this.scaleFactor = 1, this.mobileLerp = 1, this.base.frustumCulled = !1, this.base.renderOrder = 10
	}
	update() {
		const e = this.webgl.time.dt,
			t = this.webgl.store.labProgress - 1,
			i = this.webgl.store.labActive ? 0 : 1,
			{
				width: r,
				height: s,
				domHeight: o,
				scrollBar: a,
				pixelRatio: l
			} = this.webgl.$viewport;
		this.scaleFactor = Ur(this.scaleFactor, i, .25, e), this.webgl.store.labScaleFactor = this.scaleFactor;
		const c = o - s,
			u = r < 764 ? 0 : 1;
		this.base.scale.set(r - (this.px * 2 + a) * this.scaleFactor * u, s), this.base.position.x = -(a / 2) * this.scaleFactor, this.base.position.y = this.webgl.$viewport.height * t - c / 2 * this.scaleFactor
	}
	resize(e) {
		const {
			width: t,
			height: i,
			domHeight: r,
			scrollBar: s,
			pixelRatio: o
		} = this.webgl.$viewport;
		this.px = t * .2 * 100 / 1440, this.mobileLerp = t < 764 ? .99 : 1, this.base.scale.set(t - (this.px * o + s * o), i)
	}
}
class AY extends r0 {
	init() {
		this.isUsed = !0, this.camera = this.add(EY), this.plane = this.add(CY), this.gradient = this.add(wY), Vt(this.webgl.$viewport, this.resize.bind(this), {
			immediate: !0
		})
	}
	resize(e) {
		this.plane.resize(e), this.gradient.resize(e)
	}
}
const nS = {
		type: "change"
	},
	Zg = {
		type: "start"
	},
	iS = {
		type: "end"
	},
	Yf = new Su,
	rS = new Ho,
	DY = Math.cos(70 * MD.DEG2RAD);
class PY extends Ol {
	constructor(e, t) {
		super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new X, this.cursor = new X, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
			LEFT: "ArrowLeft",
			UP: "ArrowUp",
			RIGHT: "ArrowRight",
			BOTTOM: "ArrowDown"
		}, this.mouseButtons = {
			LEFT: jl.ROTATE,
			MIDDLE: jl.DOLLY,
			RIGHT: jl.PAN
		}, this.touches = {
			ONE: $l.ROTATE,
			TWO: $l.DOLLY_PAN
		}, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
			return a.phi
		}, this.getAzimuthalAngle = function () {
			return a.theta
		}, this.getDistance = function () {
			return this.object.position.distanceTo(this.target)
		}, this.listenToKeyEvents = function (I) {
			I.addEventListener("keydown", Le), this._domElementKeyEvents = I
		}, this.stopListenToKeyEvents = function () {
			this._domElementKeyEvents.removeEventListener("keydown", Le), this._domElementKeyEvents = null
		}, this.saveState = function () {
			i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom
		}, this.reset = function () {
			i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(nS), i.update(), s = r.NONE
		}, this.update = function () {
			const I = new X,
				ee = new qr().setFromUnitVectors(e.up, new X(0, 1, 0)),
				De = ee.clone().invert(),
				V = new X,
				be = new qr,
				te = new X,
				Ee = 2 * Math.PI;
			return function (st = null) {
				const Et = i.object.position;
				I.copy(Et).sub(i.target), I.applyQuaternion(ee), a.setFromVector3(I), i.autoRotate && s === r.NONE && U(w(st)), i.enableDamping ? (a.theta += l.theta * i.dampingFactor, a.phi += l.phi * i.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
				let He = i.minAzimuthAngle,
					Ve = i.maxAzimuthAngle;
				isFinite(He) && isFinite(Ve) && (He < -Math.PI ? He += Ee : He > Math.PI && (He -= Ee), Ve < -Math.PI ? Ve += Ee : Ve > Math.PI && (Ve -= Ee), He <= Ve ? a.theta = Math.max(He, Math.min(Ve, a.theta)) : a.theta = a.theta > (He + Ve) / 2 ? Math.max(He, a.theta) : Math.min(Ve, a.theta)), a.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, a.phi)), a.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u), i.target.sub(i.cursor), i.target.clampLength(i.minTargetRadius, i.maxTargetRadius), i.target.add(i.cursor);
				let $e = !1;
				if (i.zoomToCursor && S || i.object.isOrthographicCamera) a.radius = B(a.radius);
				else {
					const Pe = a.radius;
					a.radius = B(a.radius * c), $e = Pe != a.radius
				}
				if (I.setFromSpherical(a), I.applyQuaternion(De), Et.copy(i.target).add(I), i.object.lookAt(i.target), i.enableDamping === !0 ? (l.theta *= 1 - i.dampingFactor, l.phi *= 1 - i.dampingFactor, u.multiplyScalar(1 - i.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0)), i.zoomToCursor && S) {
					let Pe = null;
					if (i.object.isPerspectiveCamera) {
						const Ze = I.length();
						Pe = B(Ze * c);
						const Je = Ze - Pe;
						i.object.position.addScaledVector(y, Je), i.object.updateMatrixWorld(), $e = !!Je
					} else if (i.object.isOrthographicCamera) {
						const Ze = new X(x.x, x.y, 0);
						Ze.unproject(i.object);
						const Je = i.object.zoom;
						i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), i.object.updateProjectionMatrix(), $e = Je !== i.object.zoom;
						const ot = new X(x.x, x.y, 0);
						ot.unproject(i.object), i.object.position.sub(ot).add(Ze), i.object.updateMatrixWorld(), Pe = I.length()
					} else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1;
					Pe !== null && (this.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(Pe).add(i.object.position) : (Yf.origin.copy(i.object.position), Yf.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(Yf.direction)) < DY ? e.lookAt(i.target) : (rS.setFromNormalAndCoplanarPoint(i.object.up, i.target), Yf.intersectPlane(rS, i.target))))
				} else if (i.object.isOrthographicCamera) {
					const Pe = i.object.zoom;
					i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / c)), Pe !== i.object.zoom && (i.object.updateProjectionMatrix(), $e = !0)
				}
				return c = 1, S = !1, $e || V.distanceToSquared(i.object.position) > o || 8 * (1 - be.dot(i.object.quaternion)) > o || te.distanceToSquared(i.target) > o ? (i.dispatchEvent(nS), V.copy(i.object.position), be.copy(i.object.quaternion), te.copy(i.target), !0) : !1
			}
		}(), this.dispose = function () {
			i.domElement.removeEventListener("contextmenu", je), i.domElement.removeEventListener("pointerdown", ve), i.domElement.removeEventListener("pointercancel", A), i.domElement.removeEventListener("wheel", re), i.domElement.removeEventListener("pointermove", xe), i.domElement.removeEventListener("pointerup", A), i.domElement.getRootNode().removeEventListener("keydown", ue, {
				capture: !0
			}), i._domElementKeyEvents !== null && (i._domElementKeyEvents.removeEventListener("keydown", Le), i._domElementKeyEvents = null)
		};
		const i = this,
			r = {
				NONE: -1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_PAN: 4,
				TOUCH_DOLLY_PAN: 5,
				TOUCH_DOLLY_ROTATE: 6
			};
		let s = r.NONE;
		const o = 1e-6,
			a = new WE,
			l = new WE;
		let c = 1;
		const u = new X,
			h = new Oe,
			d = new Oe,
			f = new Oe,
			p = new Oe,
			_ = new Oe,
			g = new Oe,
			m = new Oe,
			b = new Oe,
			v = new Oe,
			y = new X,
			x = new Oe;
		let S = !1;
		const E = [],
			C = {};
		let P = !1;

		function w(I) {
			return I !== null ? 2 * Math.PI / 60 * i.autoRotateSpeed * I : 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
		}

		function D(I) {
			const ee = Math.abs(I * .01);
			return Math.pow(.95, i.zoomSpeed * ee)
		}

		function U(I) {
			l.theta -= I
		}

		function j(I) {
			l.phi -= I
		}
		const z = function () {
				const I = new X;
				return function (De, V) {
					I.setFromMatrixColumn(V, 0), I.multiplyScalar(-De), u.add(I)
				}
			}(),
			H = function () {
				const I = new X;
				return function (De, V) {
					i.screenSpacePanning === !0 ? I.setFromMatrixColumn(V, 1) : (I.setFromMatrixColumn(V, 0), I.crossVectors(i.object.up, I)), I.multiplyScalar(De), u.add(I)
				}
			}(),
			F = function () {
				const I = new X;
				return function (De, V) {
					const be = i.domElement;
					if (i.object.isPerspectiveCamera) {
						const te = i.object.position;
						I.copy(te).sub(i.target);
						let Ee = I.length();
						Ee *= Math.tan(i.object.fov / 2 * Math.PI / 180), z(2 * De * Ee / be.clientHeight, i.object.matrix), H(2 * V * Ee / be.clientHeight, i.object.matrix)
					} else i.object.isOrthographicCamera ? (z(De * (i.object.right - i.object.left) / i.object.zoom / be.clientWidth, i.object.matrix), H(V * (i.object.top - i.object.bottom) / i.object.zoom / be.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1)
				}
			}();

		function G(I) {
			i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c /= I : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
		}

		function R(I) {
			i.object.isPerspectiveCamera || i.object.isOrthographicCamera ? c *= I : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
		}

		function Q(I, ee) {
			if (!i.zoomToCursor) return;
			S = !0;
			const De = i.domElement.getBoundingClientRect(),
				V = I - De.left,
				be = ee - De.top,
				te = De.width,
				Ee = De.height;
			x.x = V / te * 2 - 1, x.y = -(be / Ee) * 2 + 1, y.set(x.x, x.y, 1).unproject(i.object).sub(i.object.position).normalize()
		}

		function B(I) {
			return Math.max(i.minDistance, Math.min(i.maxDistance, I))
		}

		function ge(I) {
			h.set(I.clientX, I.clientY)
		}

		function Ae(I) {
			Q(I.clientX, I.clientX), m.set(I.clientX, I.clientY)
		}

		function ze(I) {
			p.set(I.clientX, I.clientY)
		}

		function K(I) {
			d.set(I.clientX, I.clientY), f.subVectors(d, h).multiplyScalar(i.rotateSpeed);
			const ee = i.domElement;
			U(2 * Math.PI * f.x / ee.clientHeight), j(2 * Math.PI * f.y / ee.clientHeight), h.copy(d), i.update()
		}

		function ye(I) {
			b.set(I.clientX, I.clientY), v.subVectors(b, m), v.y > 0 ? G(D(v.y)) : v.y < 0 && R(D(v.y)), m.copy(b), i.update()
		}

		function Se(I) {
			_.set(I.clientX, I.clientY), g.subVectors(_, p).multiplyScalar(i.panSpeed), F(g.x, g.y), p.copy(_), i.update()
		}

		function Z(I) {
			Q(I.clientX, I.clientY), I.deltaY < 0 ? R(D(I.deltaY)) : I.deltaY > 0 && G(D(I.deltaY)), i.update()
		}

		function pe(I) {
			let ee = !1;
			switch (I.code) {
				case i.keys.UP:
					I.ctrlKey || I.metaKey || I.shiftKey ? j(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : F(0, i.keyPanSpeed), ee = !0;
					break;
				case i.keys.BOTTOM:
					I.ctrlKey || I.metaKey || I.shiftKey ? j(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : F(0, -i.keyPanSpeed), ee = !0;
					break;
				case i.keys.LEFT:
					I.ctrlKey || I.metaKey || I.shiftKey ? U(2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : F(i.keyPanSpeed, 0), ee = !0;
					break;
				case i.keys.RIGHT:
					I.ctrlKey || I.metaKey || I.shiftKey ? U(-2 * Math.PI * i.rotateSpeed / i.domElement.clientHeight) : F(-i.keyPanSpeed, 0), ee = !0;
					break
			}
			ee && (I.preventDefault(), i.update())
		}

		function ce(I) {
			if (E.length === 1) h.set(I.pageX, I.pageY);
			else {
				const ee = oe(I),
					De = .5 * (I.pageX + ee.x),
					V = .5 * (I.pageY + ee.y);
				h.set(De, V)
			}
		}

		function Ce(I) {
			if (E.length === 1) p.set(I.pageX, I.pageY);
			else {
				const ee = oe(I),
					De = .5 * (I.pageX + ee.x),
					V = .5 * (I.pageY + ee.y);
				p.set(De, V)
			}
		}

		function Re(I) {
			const ee = oe(I),
				De = I.pageX - ee.x,
				V = I.pageY - ee.y,
				be = Math.sqrt(De * De + V * V);
			m.set(0, be)
		}

		function Y(I) {
			i.enableZoom && Re(I), i.enablePan && Ce(I)
		}

		function k(I) {
			i.enableZoom && Re(I), i.enableRotate && ce(I)
		}

		function O(I) {
			if (E.length == 1) d.set(I.pageX, I.pageY);
			else {
				const De = oe(I),
					V = .5 * (I.pageX + De.x),
					be = .5 * (I.pageY + De.y);
				d.set(V, be)
			}
			f.subVectors(d, h).multiplyScalar(i.rotateSpeed);
			const ee = i.domElement;
			U(2 * Math.PI * f.x / ee.clientHeight), j(2 * Math.PI * f.y / ee.clientHeight), h.copy(d)
		}

		function q(I) {
			if (E.length === 1) _.set(I.pageX, I.pageY);
			else {
				const ee = oe(I),
					De = .5 * (I.pageX + ee.x),
					V = .5 * (I.pageY + ee.y);
				_.set(De, V)
			}
			g.subVectors(_, p).multiplyScalar(i.panSpeed), F(g.x, g.y), p.copy(_)
		}

		function ie(I) {
			const ee = oe(I),
				De = I.pageX - ee.x,
				V = I.pageY - ee.y,
				be = Math.sqrt(De * De + V * V);
			b.set(0, be), v.set(0, Math.pow(b.y / m.y, i.zoomSpeed)), G(v.y), m.copy(b);
			const te = (I.pageX + ee.x) * .5,
				Ee = (I.pageY + ee.y) * .5;
			Q(te, Ee)
		}

		function N(I) {
			i.enableZoom && ie(I), i.enablePan && q(I)
		}

		function me(I) {
			i.enableZoom && ie(I), i.enableRotate && O(I)
		}

		function ve(I) {
			i.enabled !== !1 && (E.length === 0 && (i.domElement.setPointerCapture(I.pointerId), i.domElement.addEventListener("pointermove", xe), i.domElement.addEventListener("pointerup", A)), !le(I) && (M(I), I.pointerType === "touch" ? we(I) : T(I)))
		}

		function xe(I) {
			i.enabled !== !1 && (I.pointerType === "touch" ? Te(I) : $(I))
		}

		function A(I) {
			switch (W(I), E.length) {
				case 0:
					i.domElement.releasePointerCapture(I.pointerId), i.domElement.removeEventListener("pointermove", xe), i.domElement.removeEventListener("pointerup", A), i.dispatchEvent(iS), s = r.NONE;
					break;
				case 1:
					const ee = E[0],
						De = C[ee];
					we({
						pointerId: ee,
						pageX: De.x,
						pageY: De.y
					});
					break
			}
		}

		function T(I) {
			let ee;
			switch (I.button) {
				case 0:
					ee = i.mouseButtons.LEFT;
					break;
				case 1:
					ee = i.mouseButtons.MIDDLE;
					break;
				case 2:
					ee = i.mouseButtons.RIGHT;
					break;
				default:
					ee = -1
			}
			switch (ee) {
				case jl.DOLLY:
					if (i.enableZoom === !1) return;
					Ae(I), s = r.DOLLY;
					break;
				case jl.ROTATE:
					if (I.ctrlKey || I.metaKey || I.shiftKey) {
						if (i.enablePan === !1) return;
						ze(I), s = r.PAN
					} else {
						if (i.enableRotate === !1) return;
						ge(I), s = r.ROTATE
					}
					break;
				case jl.PAN:
					if (I.ctrlKey || I.metaKey || I.shiftKey) {
						if (i.enableRotate === !1) return;
						ge(I), s = r.ROTATE
					} else {
						if (i.enablePan === !1) return;
						ze(I), s = r.PAN
					}
					break;
				default:
					s = r.NONE
			}
			s !== r.NONE && i.dispatchEvent(Zg)
		}

		function $(I) {
			switch (s) {
				case r.ROTATE:
					if (i.enableRotate === !1) return;
					K(I);
					break;
				case r.DOLLY:
					if (i.enableZoom === !1) return;
					ye(I);
					break;
				case r.PAN:
					if (i.enablePan === !1) return;
					Se(I);
					break
			}
		}

		function re(I) {
			i.enabled === !1 || i.enableZoom === !1 || s !== r.NONE || (I.preventDefault(), i.dispatchEvent(Zg), Z(se(I)), i.dispatchEvent(iS))
		}

		function se(I) {
			const ee = I.deltaMode,
				De = {
					clientX: I.clientX,
					clientY: I.clientY,
					deltaY: I.deltaY
				};
			switch (ee) {
				case 1:
					De.deltaY *= 16;
					break;
				case 2:
					De.deltaY *= 100;
					break
			}
			return I.ctrlKey && !P && (De.deltaY *= 10), De
		}

		function ue(I) {
			I.key === "Control" && (P = !0, i.domElement.getRootNode().addEventListener("keyup", Me, {
				passive: !0,
				capture: !0
			}))
		}

		function Me(I) {
			I.key === "Control" && (P = !1, i.domElement.getRootNode().removeEventListener("keyup", Me, {
				passive: !0,
				capture: !0
			}))
		}

		function Le(I) {
			i.enabled === !1 || i.enablePan === !1 || pe(I)
		}

		function we(I) {
			switch (J(I), E.length) {
				case 1:
					switch (i.touches.ONE) {
						case $l.ROTATE:
							if (i.enableRotate === !1) return;
							ce(I), s = r.TOUCH_ROTATE;
							break;
						case $l.PAN:
							if (i.enablePan === !1) return;
							Ce(I), s = r.TOUCH_PAN;
							break;
						default:
							s = r.NONE
					}
					break;
				case 2:
					switch (i.touches.TWO) {
						case $l.DOLLY_PAN:
							if (i.enableZoom === !1 && i.enablePan === !1) return;
							Y(I), s = r.TOUCH_DOLLY_PAN;
							break;
						case $l.DOLLY_ROTATE:
							if (i.enableZoom === !1 && i.enableRotate === !1) return;
							k(I), s = r.TOUCH_DOLLY_ROTATE;
							break;
						default:
							s = r.NONE
					}
					break;
				default:
					s = r.NONE
			}
			s !== r.NONE && i.dispatchEvent(Zg)
		}

		function Te(I) {
			switch (J(I), s) {
				case r.TOUCH_ROTATE:
					if (i.enableRotate === !1) return;
					O(I), i.update();
					break;
				case r.TOUCH_PAN:
					if (i.enablePan === !1) return;
					q(I), i.update();
					break;
				case r.TOUCH_DOLLY_PAN:
					if (i.enableZoom === !1 && i.enablePan === !1) return;
					N(I), i.update();
					break;
				case r.TOUCH_DOLLY_ROTATE:
					if (i.enableZoom === !1 && i.enableRotate === !1) return;
					me(I), i.update();
					break;
				default:
					s = r.NONE
			}
		}

		function je(I) {
			i.enabled !== !1 && I.preventDefault()
		}

		function M(I) {
			E.push(I.pointerId)
		}

		function W(I) {
			delete C[I.pointerId];
			for (let ee = 0; ee < E.length; ee++)
				if (E[ee] == I.pointerId) {
					E.splice(ee, 1);
					return
				}
		}

		function le(I) {
			for (let ee = 0; ee < E.length; ee++)
				if (E[ee] == I.pointerId) return !0;
			return !1
		}

		function J(I) {
			let ee = C[I.pointerId];
			ee === void 0 && (ee = new Oe, C[I.pointerId] = ee), ee.set(I.pageX, I.pageY)
		}

		function oe(I) {
			const ee = I.pointerId === E[0] ? E[1] : E[0];
			return C[ee]
		}
		i.domElement.addEventListener("contextmenu", je), i.domElement.addEventListener("pointerdown", ve), i.domElement.addEventListener("pointercancel", A), i.domElement.addEventListener("wheel", re, {
			passive: !1
		}), i.domElement.getRootNode().addEventListener("keydown", ue, {
			passive: !0,
			capture: !0
		}), this.update()
	}
}
const sS = {
	from: {
		position: [-.2288, 10.42245, -8.93748],
		quaternion: [.054192, .945681, .23448, -.218561]
	}
};
for (let n in sS) {
	const e = sS[n];
	e.position = new X(...e.position), e.quaternion = new qr(...e.quaternion)
}
let oS, aS;
class RY extends Vd {
	init() {
		this.base = new ht, this.cam = new Yn(45, this.webgl.$viewport.viewportRatio, 1, 1e3), this.cam.position.set(1, 1, 1).multiplyScalar(3), this.controls = new PY(this.cam, this.webgl.canvas), this.controls.enabled = !1, this.controls.enableDamping = !0, this.controls.dampingFactor = .1, this.base.add(this.cam)
	}
	update() {
		this.isUsed && this.controls.update()
	}
	used() {
		const {
			$lenis: e
		} = Ke();
		this.controls.enabled = !0, e.stop(), this.scene.base.fog && (oS = this.scene.base.fog.far, aS = this.scene.base.fog.near, this.scene.base.fog.near = 200, this.scene.base.fog.far = 300)
	}
	unused() {
		const {
			$lenis: e
		} = Ke();
		this.controls.enabled = !1, e.start(), this.scene.base.fog && (this.scene.base.fog.near = aS, this.scene.base.fog.far = oS)
	}
}
var LY = `precision highp float;

uniform sampler2D atlas;
uniform float uOpacity;
varying vec2 vUv;
varying vec4 vColor;

void main() {
	vec2 uv = vUv;
	vec4 color = texture2D(atlas, uv);

	
	float shape = color.r;
	float alpha = color.a;

	vec3 col = vColor.rgb;

	gl_FragColor = vec4(col, alpha * vColor.a);
	
	gl_FragColor.rgb = vec3(vUv, 1.);
}`,
	kY = `precision highp float;

attribute vec4 texCoords;
attribute vec4 meshCoords;

attribute vec3 instancePos;
attribute vec4 instanceQt;
attribute vec2 decorators;

varying vec2 vUv;
varying vec4 vColor;

mat4 getInstanceMatrix( vec3 p, vec4 q, vec3 s ) {

    mat4 m;

    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;

    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;

    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;

    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;

    float sx = s.x;
    float sy = s.y;
    float sz = s.z;

    m[ 0 ][ 0 ] = ( 1. - ( yy + zz ) ) * sx;
    m[ 0 ][ 1 ] = ( xy + wz ) * sx;
    m[ 0 ][ 2 ] = ( xz - wy ) * sx;
    m[ 0 ][ 3 ] = 0.;

    m[ 1 ][ 0 ] = ( xy - wz ) * sy;
    m[ 1 ][ 1 ] = ( 1. - ( xx + zz ) ) * sy;
    m[ 1 ][ 2 ] = ( yz + wx ) * sy;
    m[ 1 ][ 3 ] = 0.;

    m[ 2 ][ 0 ] = ( xz + wy ) * sz;
    m[ 2 ][ 1 ] = ( yz - wx ) * sz;
    m[ 2 ][ 2 ] = ( 1. - ( xx + yy ) ) * sz;
    m[ 2 ][ 3 ] = 0.;

    m[ 3 ][ 0 ] = p.x;
    m[ 3 ][ 1 ] = p.y;
    m[ 3 ][ 2 ] = p.z;
    m[ 3 ][ 3 ] = 1.;

    return m;

}

void main() {
  vUv = uv;
	mat4 instanceMatrix = getInstanceMatrix(instancePos, instanceQt, vec3(1.) );
	vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position, 1.);

	gl_Position = projectionMatrix * mvPosition;
}`;
const IY = Fi(kY, LY);
class Bv extends Dn {
	constructor(e = {}) {
		super(e);
		const t = Qn();
		t.textures, this.uniforms = {
			...t.uniforms,
			uOpacity: {
				value: .4
			}
		}, this.blending = ha, this.transparent = !0, this.depthWrite = !1, this.depthTest = !0, this.side = _r, IY.use(this)
	}
}
let lS = null;
Bv.use = () => lS = lS ?? new Bv;
Bv.unuse = () => {};
var OY = `#define PI 3.141592653589793

precision highp float;

uniform float time;
uniform sampler2D uMap;
uniform sampler2D uBayer;
uniform float uGranularity;
uniform float uOpacity;
uniform float uHover;
uniform float uAlpha;
uniform vec2 res;
varying vec2 vUv;

varying float vDepth;

#include <fog_pars_fragment>

highp float rand( const in vec2 uv ) {
  const highp float a = 12.9898, b = 78.233, c = 43758.5453;
  highp float dt = dot( vUv.xy, vec2( a, b ) ), sn = mod( dt, PI );
  return fract( sin( sn ) * c );
}

vec3 greyscale(vec3 color, float str) {
  float g = dot(color, vec3(0.299, 0.587, 0.114));
  return mix(color, vec3(g), str);
}

float luma(vec3 color) {
  return dot(color, vec3(0.299, 0.587, 0.114));
}
void main() {

  vec2 uv = vec2(1. - vUv.x, vUv.y);
  vec3 diffuse = texture2D(uMap, uv).rgb;

  float luminance = luma(diffuse);
  float inverse = smoothstep(1., 0., luminance);

  vec3 mixDiffuse = mix(vec3(inverse), diffuse, uHover);
  float mixAlpha = mix(luminance, inverse, uHover);

  mixDiffuse *= vDepth;

  gl_FragColor.rgb = mixDiffuse;
  gl_FragColor.a = luminance * vDepth * uAlpha;

  
  

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	FY = `precision highp float;

varying vec2 vUv;
varying float vDepth;
#include <fog_pars_vertex>

void main() {
  vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
  vec4 mvPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.);
  vDepth = smoothstep(10., 3., gl_Position.z);
  #include <fog_vertex>
}`;
const NY = Fi(FY, OY);
class fm extends Dn {
	constructor(e = {}) {
		super();
		const t = this.webgl = Qn();
		this.uniforms = {
			...ni.standard.uniforms,
			...t.uniforms,
			res: {
				value: new Oe
			},
			uMap: {
				value: e.image
			},
			uBayer: {
				value: t.textures.bayer
			},
			uGranularity: {
				value: 1
			},
			uOpacity: {
				value: .7
			},
			uHover: {
				value: 1
			},
			uAlpha: {
				value: 0
			}
		}, NY.use(this), this.transparent = !0, this.side = _r, this.fog = !0, this.isShaderMaterial = !0, Vt(t.$viewport, () => {
			const i = t.renderer.drawingBufferSize.value;
			this.uniforms.res.value.copy(i)
		}, {
			immediate: !0
		})
	}
	update() {}
}
let cS = null;
fm.use = () => cS = cS ?? new fm;
fm.unuse = () => {};
new ht;
new t0;
class uS extends _i {
	init() {
		const t = this.props.data.width / this.props.data.height,
			i = pu(this.props.data.width, 0, 1800),
			r = i / t,
			{
				hook: s,
				callHook: o
			} = Ke();
		this.geo = new os(i * .001 * .75, r * .001 * .75, 15, 15), this.webgl.geometries.curved.clone(), this.base = new an(this.geo, new fm({
			image: this.props.data
		})), this.tVecA = new Oe, this.angle = 0, this.smoothOpacity = .4, this.tweenOpacity = 0, this.active = !1, this.curve(), this.setPosition(), this.id = this.props.data._id, this.base.show = this.show.bind(this), this.base.hide = this.hide.bind(this), this.base.enter = this.enter.bind(this), s("LAB:CLICK", this.click.bind(this))
	}
	click() {
		const {
			callHook: e
		} = Ke();
		this.active && e("LAB:OPEN", {
			id: this.id
		})
	}
	show() {
		const e = Ct();
		this.active = !0, e.setCursorPointer(!0)
	}
	hide() {
		const e = Ct();
		this.active = !1, e.setCursorPointer(!1)
	}
	enter() {
		lt.fromTo(this, {
			tweenOpacity: 0
		}, {
			tweenOpacity: 1,
			duration: 3,
			ease: "expo.out",
			delay: .5 + .5 * Math.random()
		})
	}
	curve() {
		const e = this.props.radius * .07,
			t = new Oe,
			i = this.geo.attributes.uv,
			r = this.geo.attributes.position,
			s = this.geo.parameters.width * .5,
			o = new Oe(-s, 0),
			a = new Oe(0, e),
			l = new Oe(s, 0),
			c = new Oe().subVectors(o, a),
			u = new Oe().subVectors(a, l),
			h = new Oe().subVectors(o, l),
			d = c.length() * u.length() * h.length() / (2 * Math.abs(c.cross(h))),
			f = new Oe(0, e - d),
			g = (new Oe().subVectors(o, f).angle() - Math.PI * .5) * 2;
		for (let m = 0; m < i.count; m++) {
			let b = 1 - i.getX(m),
				v = r.getY(m);
			t.copy(l).rotateAround(f, g * b), r.setXYZ(m, t.x, v, -t.y)
		}
		r.needsUpdate = !0
	}
	setPosition() {
		this.radius = this.props.radius, this.angle = this.props.angle;
		const e = this.base.geometry.parameters.width;
		this.y = this.props.y - e / 2;
		const t = this.radius * Math.cos(this.angle),
			i = this.y,
			r = this.radius * Math.sin(this.angle);
		this.base.position.set(t, i, r)
	}
	update() {
		const e = this.webgl.time.stableDt,
			{
				width: t
			} = this.webgl.$viewport,
			i = 25e-5 + this.props.speed * .0025;
		this.angle += i;
		const r = this.radius * Math.cos(this.angle),
			s = this.radius * Math.sin(this.angle);
		this.base.position.x = r, this.base.position.z = s;
		const o = this.parent.base.position.y;
		this.base.lookAt(0, this.y + o, 0);
		const a = this.webgl.store.labScaleFactor,
			l = t < 768,
			c = this.active && !l ? 1 : 0;
		this.active;
		let u = 0;
		this.props.front && (u = a), this.smoothOpacity = Ur(this.smoothOpacity, c, .1, e), this.base.material.uniforms.uOpacity.value = this.smoothOpacity * this.tweenOpacity, this.base.material.uniforms.uAlpha.value = this.tweenOpacity - u, this.base.material.uniforms.uHover.value = this.smoothOpacity, this.base.material.uniforms.uAlpha.value < .1 ? this.base.visible = !1 : this.base.visible = !0
	}
}
var UY = `precision highp float;

uniform float time;
uniform float uOpacity;
varying vec2 vUv;
varying vec4 vColor;
varying float vDepth;

#include <fog_pars_fragment>

float thickness = 1.2;

void main() {

  vec3 afwidth = fwidth( vColor.xyz );
  vec3 edge3 = smoothstep( ( thickness - 1.0 ) * afwidth, thickness * afwidth, vColor.xyz );
  float edge = 1.0 - min( min( edge3.x, edge3.y ), edge3.z );

  gl_FragColor.rgb = gl_FrontFacing ? vec3(0.15) : vec3(0.05);
  gl_FragColor.a = edge * uOpacity * 0.2;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	BY = `attribute vec3 center;
attribute vec4 color;

varying vec3 vCenter;
varying vec2 vUv;
varying vec4 vColor;

void main() {

  vCenter = center;
  vUv = uv;
  vColor = color;

  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
const zY = Fi(BY, UY);
class pm extends Dn {
	constructor(e = {}) {
		super();
		const t = this.webgl = Qn();
		this.uniforms = {
			...ni.standard.uniforms,
			...t.uniforms,
			uOpacity: {
				value: 1
			}
		}, zY.use(this), this.transparent = !0, this.side = _r, this.fog = !0, this.isShaderMaterial = !0, this.depthTest = !1
	}
	update() {}
}
let hS = null;
pm.use = () => hS = hS ?? new pm;
pm.unuse = () => {};
new ht;
class VY extends _i {
	init() {
		const e = this.webgl.geometries.curved.geometry;
		this.base = new an(e, new pm), this.tVecA = new Oe, this.angle = 0, this.setPosition()
	}
	enter() {
		lt.fromTo(this, {
			tweenOpacity: 0
		}, {
			tweenOpacity: 1,
			duration: 3,
			ease: "expo.out",
			delay: .5 + .5 * Math.random()
		})
	}
	setPosition() {
		this.radius = this.props.radius, this.angle = this.props.angle, this.y = this.props.y;
		const e = this.radius * Math.cos(this.angle),
			t = this.y,
			i = this.radius * Math.sin(this.angle);
		this.base.position.set(e, t, i)
	}
	update() {
		this.webgl.time.stableDt;
		const e = 25e-5 + this.props.speed * .0025;
		this.angle += e;
		const t = this.radius * Math.cos(this.angle),
			i = this.radius * Math.sin(this.angle);
		this.base.position.x = t, this.base.position.z = i;
		const r = this.parent.base.position.y;
		this.base.lookAt(0, this.y + r, 0);
		const s = this.webgl.store.labScaleFactor;
		this.base.material.uniforms.uOpacity.value = 1 - s, this.base.material.uniforms.uOpacity.value < .1 ? this.base.visible = !1 : this.base.visible = !0
	}
}
const ko = n => {
		var l, c;
		const {
			videoUrl: e = null,
			videoWidth: t = null,
			videoHeight: i = null,
			mobileVideoUrl: r = null,
			mobileVideoWidth: s = null,
			mobileVideoHeight: o = null,
			image: a
		} = n;
		return e != null && e.url || a != null && a.url ? {
			src: e ? e == null ? void 0 : e.url : a ? a == null ? void 0 : a.url : null,
			width: t ? t || 1600 : (l = a == null ? void 0 : a.dimensions) == null ? void 0 : l.width,
			height: i ? i || 900 : (c = a == null ? void 0 : a.dimensions) == null ? void 0 : c.height,
			alt: (a == null ? void 0 : a.alt) || (a == null ? void 0 : a.copyright) || "Ashfall Studio",
			srcMobile: r != null && r.url ? {
				src: r == null ? void 0 : r.url,
				width: s || t || 1600,
				height: o || i || 900
			} : null
		} : null
	},
	HY = `
  metaDescription
  metaImage
  metaTitle
`,
	qs = `
  ...on asset {
    videoUrl
    videoWidth
    videoHeight
    mobileVideoUrl
    mobileVideoWidth
    mobileVideoHeight
    image
  }
`,
	GY = `
{
  case_study {
    ${HY}
    
    slug
    title
    date
    excerpt
    services {
      service {
        ...on service {
          label
        }
      }
    }
    featuredAsset {
      ${qs}
    }
    featuredAssetLandscape {
      ${qs}
    }
    hoverAsset {
      ${qs}
    }
    hoverAssetLandscape {
      ${qs}
    }
    heroAsset {
      ${qs}
    }
    heroIntro
    heroCopy
    heroLinkLabel
    heroLinkUrl
    credits {
      title
      lists
    }
    slices4 {
      ...on quote {
        variation {
          ...on default {
            primary {
              name
              quote
            }
          }
        }
      }
      ...on title_copy {
        variation {
          ...on default {
            primary {
              title
              copy
            }
          }
        }
      }
      ...on fullbleed_asset {
        variation {
          ...on default {
            primary {
              asset {
                ${qs}
              }
              isInset
            }
          }
        }
      }
      ...on copy_asset {
        variation {
          ...on default {
            primary {
              copy
              asset {
                ${qs}
              }
              isFlipped
            }
          }
        }
      }
    }
    recircTitle
    recircProjects {
      project {
        ...on case_study {
          slug
        }
      }
    }
  }
}
`,
	WY = `
{
  service {
    uid
    label
    title
    asset {
      ${qs}
    }
    featuredWork {
      work {
        ...on case_study {
          slug
        }
      }
    }
    approachTitle
    approachCopy
    servicesTitle
    accordions {
      title
      copy
      asset {
        ${qs}
      }
    }
  }
}
`,
	Ji = V3("data", {
		state: () => ({
			globalData: null,
			navData: null,
			footerData: null,
			workData: null,
			servicesData: null,
			serviceModalData: null,
			labModalData: null
		}),
		getters: {},
		actions: {
			async fetchData() {
				const {
					client: n,
					asHTML: e
				} = Ls(), [{
					data: t
				}, {
					data: i
				}, {
					data: r
				}, {
					data: s
				}, {
					data: o
				}] = await Promise.all([Za("global", () => n.getSingle("global")), Za("nav", () => n.getSingle("nav")), Za("footer", () => n.getSingle("footer")), Za("caseStudies", () => n.getAllByType("case_study", {
					graphQuery: GY
				})), Za("services", () => n.getAllByType("service", {
					graphQuery: WY
				}))]), a = {
					loaderTitle: t.value.data.loaderTitle,
					termsPdf: t.value.data.termsPdf,
					seo: {
						title: t.value.data.seoTitle,
						description: t.value.data.seoDescription,
						image: t.value.data.seoImage || null
					}
				};
				this.setGlobalData(a);
				const l = {
					items: i.value.data.navigation.map(({
						label: d,
						linkedPage: f
					}) => ({
						label: d,
						type: f == null ? void 0 : f.type
					})),
					contactCtaLabel: i.value.data.contactCtaLabel
				};
				this.setNavData(l);
				const c = {
					socials: r.value.data.footerSocialItems.map(({
						socialLabel: d,
						socialUrl: f
					}) => ({
						label: d,
						url: f == null ? void 0 : f.url
					})),
					copyright: r.value.data.footerCopyright,
					contact: {
						subtitle: r.value.data.contactSubtitle,
						title: r.value.data.contactTitle,
						link: r.value.data.contactLink,
						ctaLabel: r.value.data.contactCtaLabel,
						email: r.value.data.contactEmail,
						modalTitle: r.value.data.contactModalTitle
					}
				};
				this.setFooterData(c);
				const u = s.value.map(({
					data: d
				}) => {
					const {
						metaDescription: f,
						metaImage: p,
						metaTitle: _,
						title: g,
						slug: m,
						services: b,
						featuredAsset: v,
						featuredAssetLandscape: y,
						hoverAsset: x,
						hoverAssetLandscape: S,
						excerpt: E,
						date: C,
						heroAsset: P,
						heroIntro: w,
						heroCopy: D,
						heroLinkLabel: U,
						heroLinkUrl: j,
						credits: z,
						recircTitle: H,
						recircProjects: F,
						slices4: G
					} = d;
					return {
						metaTitle: _,
						metaDescription: f,
						metaImage: p,
						slug: m,
						title: g,
						date: C,
						tags: (b == null ? void 0 : b.map(({
							service: R
						}) => {
							var Q;
							return {
								slug: R.uid,
								label: (Q = R == null ? void 0 : R.data) == null ? void 0 : Q.label
							}
						})) || null,
						excerpt: e(E),
						featuredAsset: (v == null ? void 0 : v.data) && ko(v.data) || null,
						featuredAssetLandscape: (y == null ? void 0 : y.data) && ko(y.data) || null,
						hoverAsset: (x == null ? void 0 : x.data) && ko(x.data) || null,
						hoverAssetLandscape: (S == null ? void 0 : S.data) && ko(S.data) || null,
						hero: {
							asset: (P == null ? void 0 : P.data) && ko(P.data) || (v == null ? void 0 : v.data) && ko(v.data) || null,
							intro: e(w),
							copy: e(D),
							cta: {
								label: U,
								url: j == null ? void 0 : j.url
							}
						},
						slices: G == null ? void 0 : G.map(({
							primary: R,
							slice_type: Q
						}) => ({
							data: {
								...R
							},
							type: Q
						})),
						credits: z == null ? void 0 : z.map(({
							title: R,
							lists: Q
						}) => ({
							title: R,
							lists: e(Q)
						})),
						recirc: {
							title: H,
							items: F == null ? void 0 : F.map(({
								project: R
							}) => {
								var Q;
								return (Q = R == null ? void 0 : R.data) == null ? void 0 : Q.slug
							})
						}
					}
				});
				this.setWorkData(u);
				const h = o.value.map(({
					uid: d,
					data: f
				}) => {
					const {
						label: p,
						title: _,
						asset: g,
						featuredWork: m,
						approachTitle: b,
						approachCopy: v,
						servicesTitle: y,
						accordions: x
					} = f;
					return {
						slug: d,
						label: p,
						title: _,
						asset: ko(g.data),
						featuredWork: m.map(({
							work: S
						}) => {
							var E;
							return {
								slug: (E = S == null ? void 0 : S.data) == null ? void 0 : E.slug
							}
						}),
						approachTitle: b,
						approachCopy: e(v),
						servicesTitle: y,
						accordions: x.map(({
							title: S,
							copy: E,
							asset: C
						}) => ({
							title: S,
							copy: e(E),
							asset: C.data && ko(C.data) || null
						}))
					}
				});
				this.setServicesData(h)
			},
			setGlobalData(n) {
				this.globalData = n
			},
			setNavData(n) {
				this.navData = n
			},
			setFooterData(n) {
				this.footerData = n
			},
			setWorkData(n) {
				this.workData = n
			},
			setServicesData(n) {
				this.servicesData = n
			},
			setServiceModalData(n = null) {
				this.serviceModalData = n
			},
			setLabModalData(n = null) {
				this.labModalData = n
			},
			clear() {
				this.$reset()
			}
		}
	});
new os;
new ht;
const jY = new t0;
class $Y extends _i {
	init() {
		this.base = new ht, this.bottom = new ht, this.count = this.webgl.labData.length, this.radius = 2.15, this.raycaster = new Iq, this.instances = [], this.textures = [], this.currentCount = 0, this.hoveredPlane = null, this.canHover = !1;
		const {
			labModalData: e
		} = $t(Ji());
		this.modalData = e, this.loadTextures(), this.createInstances(), this.createWireframes(), this.createTop()
	}
	createInstances() {
		this.rings = [];
		const t = 6,
			i = this.count * 3;
		for (let r = 0; r < Math.ceil(i); r++) this.rings[r] = new ht, this.rings[r].speed = Rt.randomFloat(-1, 1);
		for (let r = 0; r < i; r++) {
			const s = Math.floor(r / t),
				o = Rt.randomFloat(0, this.count),
				a = this.textures[Math.floor(o)],
				l = r % t + Rt.randomFloat(-.1, .1),
				c = this.radius + Rt.randomFloat(-this.radius * .1, this.radius * .1),
				u = s * -1.6,
				h = new uS({
					angle: l,
					radius: c,
					speed: this.rings[s].speed,
					y: u,
					data: a,
					addTo: this.rings[s]
				});
			this.add(h), this.instances.push(h.base)
		}
	}
	loadTextures() {
		this.webgl.labData.forEach(e => {
			const t = jY.load(e.src);
			t.width = e.width, t.height = e.height, t._id = e.id, this.textures.push(t)
		})
	}
	createTop() {
		this.rings = [];
		const t = 6,
			i = this.count * 2;
		for (let r = 0; r < Math.ceil(i); r++) this.rings[r] = new ht, this.rings[r].speed = Rt.randomFloat(-1, 1);
		for (let r = 0; r < i; r++) {
			const s = Math.floor(r / t),
				o = Rt.randomFloat(0, this.count),
				a = this.textures[Math.floor(o)],
				l = r % t + Rt.randomFloat(-.1, .1),
				c = this.radius + Rt.randomFloat(-this.radius * .1, this.radius * .1),
				u = 1.6 + s * 1.6,
				h = new uS({
					angle: l,
					radius: c,
					speed: this.rings[s].speed,
					y: u,
					data: a,
					addTo: this.rings[s],
					front: !0
				});
			this.add(h), this.instances.push(h.base)
		}
	}
	createWireframes() {
		const t = [];
		this.webgl.geometries.curved.geometry;
		for (let s = 0; s < Math.ceil(6); s++) t[s] = new ht, t[s].speed = Rt.randomFloat(-1, 1);
		for (let s = 0; s < 6; s++) {
			const o = Math.floor(s / 1),
				a = Rt.randomFloat(0, this.count),
				l = this.textures[Math.floor(a)],
				c = Math.random() * Math.PI + Rt.randomFloat(-.1, .1),
				u = this.radius - .5 + Rt.randomFloat(-this.radius * .1, this.radius * .1),
				h = 2 + o * -2,
				d = new VY({
					angle: c,
					radius: u,
					speed: this.rings[o].speed,
					y: h,
					data: l,
					addTo: this.rings[o]
				});
			this.add(d)
		}
	}
	onEnter() {
		this.canHover = !1, lt.from(this.base.position, {
			y: -8,
			duration: 3,
			ease: "expo.out"
		}), lt.from(this.base.rotation, {
			y: 6,
			duration: 3,
			ease: "expo.out"
		}), lt.delayedCall(2, () => this.canHover = !0), this.instances.forEach(e => e.enter())
	}
	getHoveredPlane() {
		const e = this.webgl.$touch.normalizePos,
			t = this.scene.getCurrentCamera();
		this.raycaster.setFromCamera(e, t.cam);
		const r = this.raycaster.intersectObjects(this.instances)[0];
		return r ? r.object : null
	}
	update() {
		if (!this.webgl.store.labActive || this.modalData.value || !this.canHover) return;
		const e = this.getHoveredPlane();
		e !== this.hoveredPlane && this.hoveredPlane && (this.hoveredPlane.hide(), this.hoveredPlane.hovered = !1), this.hoveredPlane = e, this.hoveredPlane && !this.hoveredPlane.hovered && (this.hoveredPlane.show(), this.hoveredPlane.hovered = !0)
	}
}
var qY = `#define STANDARD

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

uniform sampler2D noise;
uniform sampler2D bake;

uniform vec3 currentColor;
uniform vec3 nextColor;
uniform float yProgress;
uniform vec4 resolution;

varying vec2 projectionUv;
varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>

#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <normalmap_pars_fragment>

varying vec2 vUv;

float falloffsmooth(float _input, float start, float end, float margin, float progress) {
  float p = mix(start-margin, end, progress);
  return smoothstep(p+margin, p, _input);
}

void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

  

  
  

  

  

	#include <map_fragment>
  
	#include <color_fragment>

	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	vec3 outgoingLight = totalDiffuse * 1.2 + totalSpecular + totalEmissiveRadiance;

	#include <opaque_fragment>

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

	#include <fog_fragment>

}`,
	XY = `#define STANDARD
varying vec3 vViewPosition;

attribute vec2 uv1;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

varying vec2 vUv;
varying vec2 projectionUv;

void main() {
  projectionUv = uv1;
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`;
const YY = Fi(XY, qY);
class dd extends Bd {
	constructor(e = {}) {
		super(e);
		const t = Qn(),
			i = t.textures.env;
		i.mapping = cd, this.uniforms = {
			noise: {
				value: t.textures.noise
			},
			bake: {
				value: t.textures.bake
			},
			yProgress: {
				value: 0
			},
			currentColor: {
				value: new et("#8E8E8E")
			},
			nextColor: {
				value: new et("#EEECEA")
			},
			...t.uniforms,
			...ni.standard.uniforms
		}, YY.use(this), this.map = t.textures.bake, this.color = new et("#EEECEA"), this.normalMap = t.textures.logo, this.normalScale = new Oe(1, 1), this.envMap = i, this.envMapIntensity = 1.2, this.envMapRotation = new Er(0, Math.PI / 2, 0), this.lights = !0, this.type = "LogoMaterial", this.handleColor()
	}
	handleColor() {
		const {
			hook: e
		} = Ke();
		e("WEBGL:CHANGECOLOR", t => {
			const i = new et(t);
			lt.to(this.color, {
				r: i.r,
				g: i.g,
				b: i.b,
				duration: .3,
				ease: "expo.out"
			})
		})
	}
}
let dS = null;
dd.use = () => dS = dS ?? new dd;
dd.unuse = () => {};
let KY = .002,
	fS = 0;
class ZY extends _i {
	init() {
		this.base = new ht, this.globalRotation = 0, this.scrollValue = 0, this.currentValue = 0, this.closestRotation = 0, this.target = 0, this.rotA = 0, this.rotB = 0, this.state = null, this.clampedRot = 0, this.mouseRot = new Er, this.mouseInfluence = 0, this.mouseFactor = 0, this.velocity = 0, this.webgl.geometries.logo.children.forEach(s => {
			s.name.toLowerCase() === "top" && (this.top = s.clone()), s.name.toLowerCase() === "bottom" && (this.bottom = s.clone())
		}), this.bottom.material = dd.use(), this.top.material = dd.use(), this.base.rotation.x = .233, this.base.add(this.top), this.base.add(this.bottom), this.base.scale.set(0, 0, 0);
		const {
			hook: t,
			callHook: i,
			$lenis: r
		} = Ke();
		this.scroller = r, t("SCROLL:UPDATE", this.scroll.bind(this))
	}
	onEnter() {
		lt.to(this.base.scale, {
			x: 1,
			y: 1,
			duration: 1.25,
			ease: "expo.out"
		})
	}
	onLeave() {
		lt.to(this.base.scale, {
			x: 0,
			y: 0,
			duration: 1.25,
			ease: "expo.out"
		})
	}
	nextRotation() {
		this.globalRotation / Math.PI
	}
	scroll(e) {
		this.velocity = e.velocity, this.webgl.$viewport.width < 768 && (this.velocity = Math.abs(fS - e.progress) * .5, fS = e.progress, e.progress === 0 && (this.velocity = 0))
	}
	set2D() {
		if (this.state === "2D") return;
		const {
			callHook: e
		} = Ke();
		e("WEBGL:CHANGECOLOR", "#8E8E8E"), this.mouseFactor = 0, lt.to(this, {
			mouseInfluence: 0,
			duration: 1,
			ease: "expo.out"
		}), lt.to(this.base.scale, {
			z: .01,
			duration: .75,
			ease: "expo.out"
		}), this.state = "2D"
	}
	set3D() {
		if (this.state === "3D") return;
		const {
			callHook: e
		} = Ke();
		e("WEBGL:CHANGECOLOR", "#EEECEA"), this.mouseFactor = 1, lt.to(this, {
			mouseInfluence: 1,
			duration: 1,
			ease: "expo.out"
		}), lt.to(this.base.scale, {
			z: 1,
			duration: 1,
			ease: "elastic.out(2, 0.7)"
		}), this.state = "3D"
	}
	handleRotation(e) {
		this.scrollValue += this.velocity * KY * this.mouseFactor, this.scrollValue / Math.PI;
		const i = this.scroller.direction === 1 ? this.mouseFactor ? Math.ceil(this.scrollValue / Math.PI) * Math.PI : Math.round(this.scrollValue / Math.PI) * Math.PI : Math.floor(this.scrollValue / Math.PI) * Math.PI;
		this.scroller.isScrolling && this.state === "3D" ? this.target = this.scrollValue : (this.target = Ur(this.target, i, .1, e), this.scrollValue = Ur(this.scrollValue, i, .1, e)), this.rotA = Ur(this.rotA, this.target, .1, e), this.rotB = Ur(this.rotB, this.target, .4, e), this.top.rotation.y = this.rotA, this.bottom.rotation.y = this.rotB
	}
	update() {
		this.webgl.time.elapsed;
		const e = this.webgl.time.stableDt;
		this.webgl.time.frameNum, this.handleRotation(e), this.webgl.store.backgroundProgress > .15 ? this.set3D() : this.set2D();
		const i = this.webgl.$touch.normalizePos,
			r = .25;
		this.mouseRot.y = i.x * r, this.mouseRot.x = (-i.y + 1) * r, this.base.rotation.y = Ur(this.base.rotation.y, this.mouseRot.y, .15, e) * this.mouseInfluence
	}
}
const JY = new e0(1, 32, 32).scale(-1, 1, 1);
class QY extends _i {
	init() {
		this.base = new ht;
		const e = new yr({
			color: this.webgl.store.backgroundColor,
			fog: !1
		});
		this.sky = new an(JY, e), this.sky.scale.setScalar(10), this.base.add(this.sky)
	}
}
class eK extends Vd {
	init() {
		this.base = new ht, this.radius = 6, this.cam = new Yn(55, this.webgl.$viewport.viewportRatio, .1, 100), this.base.add(this.cam)
	}
	zoom() {}
	dezoom() {}
}
var tK = `precision highp float;

uniform sampler2D uTexture;

varying vec2 vUv;
varying float vFade;
varying float vDepth;
varying float vScale;
varying float vAlpha;
varying float vNoise;

const vec3 WHITE = vec3(1.0);
const vec3 GRAY = vec3(0.5);

void main() {

  vec4 diffuse = texture2D(uTexture, vUv);

	
	float fade = 1.0 - smoothstep(0., 1.0, vFade);
	

	
	float shape = 1.0 - distance(vUv, vec2(0.5)) * 2.0;

	float alpha = mix(0.3, 1.0, 0.) * fade;
	
	
	
	

	
  gl_FragColor = diffuse;

}`,
	nK = `precision highp float;

attribute vec3 instancePos;
attribute float aOffset;
attribute float aScale;
attribute float aAlpha;

uniform float time;

varying vec2 vUv;
varying float vFade;
varying float vDepth;
varying float vAlpha;
varying float vNoise;

const float DURATION = 2.0;
const float SPEED = 2.15;
const vec3 CENTER = vec3(0.0, -0.5, 0.0);

mat4 getInstanceMatrix( vec3 p, vec4 q, vec3 s ) {

    mat4 m;

    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;

    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;

    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;

    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;

    float sx = s.x;
    float sy = s.y;
    float sz = s.z;

    m[ 0 ][ 0 ] = ( 1. - ( yy + zz ) ) * sx;
    m[ 0 ][ 1 ] = ( xy + wz ) * sx;
    m[ 0 ][ 2 ] = ( xz - wy ) * sx;
    m[ 0 ][ 3 ] = 0.;

    m[ 1 ][ 0 ] = ( xy - wz ) * sy;
    m[ 1 ][ 1 ] = ( 1. - ( xx + zz ) ) * sy;
    m[ 1 ][ 2 ] = ( yz + wx ) * sy;
    m[ 1 ][ 3 ] = 0.;

    m[ 2 ][ 0 ] = ( xz + wy ) * sz;
    m[ 2 ][ 1 ] = ( yz - wx ) * sz;
    m[ 2 ][ 2 ] = ( 1. - ( xx + yy ) ) * sz;
    m[ 2 ][ 3 ] = 0.;

    m[ 3 ][ 0 ] = p.x;
    m[ 3 ][ 1 ] = p.y;
    m[ 3 ][ 2 ] = p.z;
    m[ 3 ][ 3 ] = 1.;

    return m;

}

float whenLower( float x, float y ){
  return max(sign(y - x), 0.0);
}

vec3 random3(vec3 c) {
	float j = 4096.0 * sin(dot(c, vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0 * j);
	j *= .125;
	r.x = fract(512.0 * j);
	j *= .125;
	r.y = fract(512.0 * j);
	return r - 0.5;
}

/* skew constants for 3d simplex functions */
const float F3 = 0.3333333;
const float G3 = 0.1666667;

/* 3d simplex noise */
float simplex3d(vec3 p) {
	 /* 1. find current tetrahedron T and it's four vertices */
	 /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
	 /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/

	 /* calculate s and x */
	vec3 s = floor(p + dot(p, vec3(F3)));
	vec3 x = p - s + dot(s, vec3(G3));

	 /* calculate i1 and i2 */
	vec3 e = step(vec3(0.0), x - x.yzx);
	vec3 i1 = e * (1.0 - e.zxy);
	vec3 i2 = 1.0 - e.zxy * (1.0 - e);

	 /* x1, x2, x3 */
	vec3 x1 = x - i1 + G3;
	vec3 x2 = x - i2 + 2.0 * G3;
	vec3 x3 = x - 1.0 + 3.0 * G3;

	 /* 2. find four surflets and store them in d */
	vec4 w, d;

	 /* calculate surflet weights */
	w.x = dot(x, x);
	w.y = dot(x1, x1);
	w.z = dot(x2, x2);
	w.w = dot(x3, x3);

	 /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
	w = max(0.6 - w, 0.0);

	 /* calculate surflet components */
	d.x = dot(random3(s), x);
	d.y = dot(random3(s + i1), x1);
	d.z = dot(random3(s + i2), x2);
	d.w = dot(random3(s + 1.0), x3);

	 /* multiply d by w^4 */
	w *= w;
	w *= w;
	d *= w;

	 /* 3. return the sum of the four surflets */
	return dot(d, vec4(52.0));
}
vec3 snoiseVec3(vec3 x) {
	float s = simplex3d(vec3(x));
	float s1 = simplex3d(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));
	float s2 = simplex3d(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));
	vec3 c = vec3(s, s1, s2);

	return c;
}

vec3 curlNoise(vec3 p) {
	const float e = .1;
	vec3 dx = vec3(e, 0.0, 0.0);
	vec3 dy = vec3(0.0, e, 0.0);
	vec3 dz = vec3(0.0, 0.0, e);

	vec3 p_x0 = snoiseVec3(p - dx);
	vec3 p_x1 = snoiseVec3(p + dx);
	vec3 p_y0 = snoiseVec3(p - dy);
	vec3 p_y1 = snoiseVec3(p + dy);
	vec3 p_z0 = snoiseVec3(p - dz);
	vec3 p_z1 = snoiseVec3(p + dz);

	float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
	float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
	float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

	const float divisor = 1.0 / (2.0 * e);

	return normalize(vec3(x, y, z) * divisor);
}

void main() {

	vec3 transformed = position;

	float realTime = time * 0.1;
	float velocity = realTime * SPEED;
	float offset = aOffset * aScale * SPEED;
	float loop = mod(realTime + offset, DURATION) / DURATION;

	float noise = simplex3d(transformed * 0.001 + vec3(velocity * 0.1, offset, aScale));

	
	
	
	
	

	vec3 pos = transformed + instancePos;

	
	mat4 instanceMatrix = getInstanceMatrix(instancePos, vec4(1.0), vec3(1.0));
	vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0) + vec4(transformed, 1.0);

	gl_Position = projectionMatrix * mvPosition;

	vNoise = noise;
	vUv = uv;
	vFade = loop;
	vDepth = 1.;
	vAlpha = aAlpha;
}`;
const iK = Fi(nK, tK);
class mm extends Dn {
	constructor(e = {}) {
		super();
		const t = Qn();
		this.uniforms = {
			...t.uniforms,
			uTexture: {
				value: t.textures.cross
			}
		}, iK.use(this), this.depthTest = !1, this.depthWrite = !1, this.transparent = !0, this.isShaderMaterial = !0
	}
}
let pS = null;
mm.use = () => pS = pS ?? new mm;
mm.unuse = () => {};
const Jg = new os,
	rh = 5,
	Kf = rh * .5,
	sP = 20,
	mS = sP * .5,
	Zf = {
		count: 30,
		transparent: !0,
		depthTest: !1,
		depthWrite: !1,
		scale: .07
	},
	uc = Rt.randomFloat,
	rK = Rt.random;
class sK extends _i {
	init() {
		this.base = new ht;
		const e = mm.use(),
			t = this.initAttributes();
		this.particles = new an(t, e), this.particles.frustumCulled = !1, this.particles.position.y = -5, this.base.add(this.particles)
	}
	initAttributes() {
		this.geo && this.geo.dispose();
		const e = new JD;
		e.index = Jg.index, e.attributes.position = Jg.attributes.position, e.attributes.uv = Jg.attributes.uv, e.scale(Zf.scale, Zf.scale, Zf.scale);
		const t = Zf.count,
			i = this.stride = 6,
			r = this.buffer = new Float32Array(t * i),
			s = new QD(r, i);
		e.setAttribute("instancePos", new pr(s, 3, 0, !1)), e.setAttribute("aOffset", new pr(s, 1, 3, !1)), e.setAttribute("aScale", new pr(s, 1, 4, !0)), e.setAttribute("aAlpha", new pr(s, 1, 5, !0));
		for (let o = 0; o < t * i; o += i) {
			let a = 0;
			r[o + a++] = uc(-Kf, Kf), r[o + a++] = uc(-mS, mS), r[o + a++] = uc(-Kf, Kf), r[o + a++] = rK() > .5 ? uc(.25, rh) : uc(-rh, -.25), r[o + a++] = uc(.5, 1.8), r[o + a++] = 1
		}
		return this.particles && (this.particles.geometry = e, this.base.needsUpdate = !0), e
	}
	update() {
		const e = this.webgl.store.labScaleFactor < .9;
		this.base.visible = e
	}
	debug() {
		const e = new Tu(rh, sP, rh),
			t = new yr,
			i = new an(e, t),
			r = new Oq(i, 16776960);
		r.position.y = this.particles.position.y
	}
}
let Qg = 0,
	e_ = 0,
	Jf = 0,
	Qf = 0,
	gS = 0,
	_S = 0;
new ht;
class oK extends r0 {
	init() {
		this.isUsed = !0, this.smoothProgress = 0, this.radius = 5.25, this.rotAmount = 6, this.baseCam = new ht, this.camera = this.add(eK), this.zoomFactor = 0;
		const {
			hook: e,
			callHook: t
		} = Ke();
		e("LAB:OPEN", this.zoom.bind(this)), e("LAB:CLOSE", this.dezoom.bind(this)), this.tVecA = new Oe(0, 0), this.tVecB = new X, this.camera.base.position.set(0, 3, 4).multiplyScalar(2), this.sky = new an(new e0(1, 32, 32).scale(-1, 1, 1), new yr({
			color: "#212121",
			fog: !1
		})), this.sky.scale.setScalar(20), this.logo = new ht, this.webgl.geometries.logo.children.forEach(r => {
			r.name.toLowerCase() === "top" && (this.top = r.clone()), r.name.toLowerCase() === "bottom" && (this.bottom = r.clone())
		}), this.logo.add(this.top), this.logo.add(this.bottom), this.top.material = new yr({
			color: "#616161",
			wireframe: !0,
			transparent: !0,
			opacity: .3
		}), this.bottom.material = new yr({
			color: "#616161",
			wireframe: !0,
			transparent: !0,
			opacity: .3
		}), this.logo.rotation.y = Math.PI / 2, this.logo.scale.setScalar(.5), this.addObject3D(this.logo), this.grid = this.add($Y), this.particles = this.add(sK), this.addObject3D(this.sky), this.computeBounding(), this.onEnter()
	}
	computeBounding() {
		this.grid.children.forEach(t => {
			Qg = Math.min(Qg, t.base.position.y), e_ = Math.max(e_, t.base.position.y)
		}), this.bounds = new Oe(Qg, e_)
	}
	zoom() {
		lt.to(this, {
			zoomFactor: 1,
			duration: 3,
			ease: "expo.out"
		})
	}
	dezoom() {
		lt.to(this, {
			zoomFactor: 0,
			duration: 3,
			ease: "expo.out"
		})
	}
	onEnter() {
		this.grid.onEnter(), lt.fromTo(this.logo.rotation, {
			x: 0,
			y: -Math.PI,
			z: 0
		}, {
			x: 0,
			y: Math.PI / 2,
			z: 0,
			duration: 3,
			ease: "expo.out"
		})
	}
	update() {
		if (!this.bounds) return;
		this.webgl.time.stableDt, this.webgl.store.labDollyProgress, this.smoothProgress = this.webgl.store.labSmoothProgress, this.tVecA.y = 1 * this.webgl.store.labScaleFactor;
		const {
			width: e,
			height: t
		} = this.webgl.$viewport;
		this.radius = zc(e, 375, 1600, 6.5, 5), this.camera.base.position.y = Fq(this.tVecA.y, this.bounds.x + 3.5, this.smoothProgress), _S = gS - this.camera.base.position.y, gS = this.camera.base.position.y, this.radius += Math.abs(_S * 10), this.camera.base.position.x = this.radius * Math.cos(-this.smoothProgress * Math.PI * this.rotAmount), this.camera.base.position.z = this.radius * Math.sin(-this.smoothProgress * Math.PI * this.rotAmount), this.logo.position.y = this.camera.base.position.y - .2, this.logo.scale.setScalar(.45 * (1 - this.webgl.store.labScaleFactor)), this.camera.base.lookAt(0, this.camera.base.position.y - .25, 0), this.updateAbsolute()
	}
	updateAbsolute() {
		const e = this.webgl.time.stableDt,
			t = this.webgl.$touch.normalizePos.x * .4,
			i = this.webgl.$touch.normalizePos.y * .2;
		this.camera.cam.rotation.x = -Math.PI, this.camera.cam.rotation.z = Math.PI, Jf = Ur(Jf, t, .075, e), Qf = Ur(Qf, i, .075, e), this.camera.cam.position.x = Jf * 2.5, this.camera.cam.rotation.y = Jf * .5, this.camera.cam.rotation.x -= Qf * .5, this.camera.cam.position.y = -Qf * 2.5
	}
}
var aK = `#define STANDARD

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

varying vec3 vViewPosition;

uniform sampler2D uTransition;
uniform sampler2D uMoss;
uniform float uProgress;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>

#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <normalmap_pars_fragment>

varying vec2 vUv;

float falloffsmooth(float _input, float start, float end, float margin, float progress) {
  float p = mix(start-margin, end, progress);
  return smoothstep(p+margin, p, _input);
}

void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <map_fragment>
	#include <color_fragment>

  float transition = texture2D(uTransition, vUv).r;
  float elapsed = 1. - (vUv.x - vUv.y * 0.5 + 1.5 - 2.5 * uProgress);
  float mask = falloffsmooth(transition, 0., 1.0, 0.001, uProgress);

	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

  

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
  

}`,
	lK = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

varying vec2 vUv;

void main() {
	#include <uv_vertex>
  vUv = uv;
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`;
const cK = Fi(lK, aK);
class Hc extends Bd {
	constructor(e = {}) {
		super();
		const t = Qn(),
			i = t.textures.env;
		i.mapping = cd, this.map = e.map, this.normalMap = t.textures.normal, this.envMap = i, this.envMapIntensity = 0, this.uniforms = {
			...t.uniforms,
			...ni.standard.uniforms,
			uProgress: {
				value: t.store.rocksProgress
			}
		}, cK.use(this), this.type = "RockMaterial", t.hooks.afterUpdate.watch(() => {
			this.uniforms.uProgress.value = t.store.rocksProgress
		})
	}
}
let vS = null;
Hc.use = () => vS = vS ?? new Hc;
Hc.unuse = () => {};
class uK extends _i {
	init() {
		this.base = new ht, this.progress = 0;
		const e = this.close = this.webgl.geometries.close,
			t = this.far = this.webgl.geometries.far,
			i = this.middle = this.webgl.geometries.middle;
		e.material.dispose(), e.material = new Hc({
			map: this.webgl.textures.close
		}), t.material.dispose(), t.material = new Hc({
			map: this.webgl.textures.albedo
		}), i.material = new Hc({
			map: this.webgl.textures.albedo
		}), this.base.add(i), this.base.add(e), this.base.add(t)
	}
	update() {
		this.progress = Nl(this.progress, this.webgl.store.sceneProgress, .1)
	}
}
let qu = 0,
	ep = 0;
class hK extends Vd {
	init() {
		this.base = new ht;
		const {
			$viewport: e
		} = this.webgl, t = this.webgl.geometries.camera;
		this.cam = new Yn(22, e.viewportRatio, .1, 1e3), this.cam.rotation.y = Math.PI / 2, this.cam.position.copy(t.position), this.base.add(this.cam), this.progress = 0
	}
	update() {
		const {
			isMobile: e
		} = this.webgl.store, t = .92, i = e ? .75 : 0;
		this.progress = Nl(this.progress, this.webgl.store.rocksProgress, .8), this.cam.position.y = zc(this.progress, 0, 1, t, i), this.cam.position.x = zc(this.progress, 0, 1, 2.4, 2.9), this.base.position.x = zc(this.webgl.store.dollyProgress, 0, 1, 0, 1.5), this.updateAbsolute()
	}
	updateAbsolute() {
		const e = this.webgl.time.stableDt,
			t = this.webgl.time.elapsed;
		let i = this.webgl.$touch.normalizePos.x * .1 * (1 - this.webgl.store.dollyProgress),
			r = this.webgl.$touch.normalizePos.y * .03 * (1 - this.webgl.store.dollyProgress);
		qu = Ur(qu, i * .3, .1, e), ep = Ur(ep, r * .3, .1, e);
		const s = .05,
			o = 1.5;
		this.base.position.y = ep, this.base.rotation.z = ep * 4, this.base.position.z = -qu, this.base.rotation.y = qu * 4, this.base.rotation.x = qu * .75, this.base.rotation.y += Math.sin(t * .01 * s) * .01 * o, this.base.rotation.z += Math.cos(t * .01 * s) * .01 * o
	}
	debug() {}
}
var dK = `precision highp float;

uniform sampler2D uCloud;
uniform sampler2D uBlurred;
uniform sampler2D uCloudPattern;
uniform sampler2D uFlow;
uniform vec2 bufferSize;
uniform float time;

varying vec2 vUv;

#include <fog_pars_fragment>

void main() {

  vec2 px = (gl_FragCoord.xy / bufferSize.xy);
  vec3 flow = texture2D(uFlow, px).rgb;

	float pattern = texture2D(uCloudPattern, vUv * 1. + time * 0.015).r;
	vec4 diffuse = texture2D(uCloud, vUv + pattern * 0.25 - vec2(0.03));

	float uvMask = (smoothstep(0.23, 0.37, vUv.y) * smoothstep(0., 0.15, vUv.x)) * smoothstep(1., 0.85, vUv.x);

	gl_FragColor = diffuse;
	gl_FragColor.rgb = vec3(0.5) * 1.25 + clamp( (flow.b) * 0.35, 0., 1.);
	gl_FragColor.a *= uvMask * 0.05;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	fK = `precision highp float;

attribute float opacity;

varying vec2 vUv;
varying float vOpacity;
varying float vDepth;

#include <common>
#include <fog_pars_vertex>

void main() {
	vOpacity = opacity;
	vUv = uv;

	gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);
	vDepth = gl_Position.z;
	vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position, 1.0);

	#include <fog_vertex>
}`;
const pK = Fi(fK, dK);
class gm extends Dn {
	constructor(e = {}) {
		var r;
		super();
		const t = this.webgl = Qn(),
			i = t.textures;
		this.uniforms = {
			...Rb.clone(ni.standard.uniforms),
			...t.uniforms,
			uCloud: {
				value: i.cloud
			},
			uBlurred: {
				value: i.cloudBlur
			},
			uCloudPattern: {
				value: i.cloudPattern
			},
			uFlow: {
				value: (r = t.postprocess.liquid) == null ? void 0 : r.texture
			}
		}, pK.use(this), this.depthTest = !0, this.depthWrite = !1, this.transparent = !0, this.fog = !0, this.isShaderMaterial = !0
	}
	update() {}
}
let bS = null;
gm.use = () => bS = bS ?? new gm;
gm.unuse = () => {};
class mK extends _i {
	init() {
		this.base = new ht;
		const e = this.webgl.geometries.smoke;
		e.material = gm.use(), this.base.add(e)
	}
}
var gK = `precision highp float;

uniform sampler2D uCloud;
uniform sampler2D uBlurred;
uniform sampler2D uCloudPattern;
uniform sampler2D uFlow;
uniform vec2 bufferSize;
uniform float time;

varying float vOffset;
varying vec2 vUv;

#include <fog_pars_fragment>

void main() {

  vec2 px = (gl_FragCoord.xy / bufferSize.xy);
  vec3 flow = texture2D(uFlow, px).rgb;

	float pattern = texture2D(uCloudPattern, vec2(vUv.x * 1., vUv.y * 5. + time * 0.1)).r;

	float uvMask = (smoothstep(0.4, 0.6, vUv.y) * smoothstep(0., 0.2, vUv.x)) * smoothstep(1., 0.7, vUv.x);

	gl_FragColor.rgb = vec3(0.5) + clamp( (flow.b) * 0.1, 0., 1.);
	gl_FragColor.a = uvMask * 1.;
  gl_FragColor.a *= 1. - pattern * 0.6 * uvMask;
  gl_FragColor.a *= 0.05 + cos(time + vOffset) * 0.033;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	_K = `precision highp float;

attribute float opacity;
attribute float offset;

varying vec2 vUv;
varying float vOpacity;
varying float vOffset;
varying float vDepth;

#include <common>
#include <fog_pars_vertex>

void main() {
	vOpacity = opacity;
	vUv = uv;
  vOffset = offset;

	gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);
	vDepth = gl_Position.z;
	vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position, 1.0);

	#include <fog_vertex>
}`;
const vK = Fi(_K, gK);
class _m extends Dn {
	constructor(e = {}) {
		var r;
		super();
		const t = this.webgl = Qn(),
			i = t.textures;
		this.uniforms = {
			...Rb.clone(ni.standard.uniforms),
			...t.uniforms,
			uCloud: {
				value: i.cloud
			},
			uBlurred: {
				value: i.cloudBlur
			},
			uCloudPattern: {
				value: i.cloudPattern
			},
			uFlow: {
				value: (r = t.postprocess.liquid) == null ? void 0 : r.texture
			}
		}, vK.use(this), this.depthTest = !0, this.depthWrite = !1, this.transparent = !0, this.fog = !0, this.isShaderMaterial = !0
	}
	update() {}
}
let yS = null;
_m.use = () => yS = yS ?? new _m;
_m.unuse = () => {};
class bK extends _i {
	init() {
		this.base = new ht;
		const e = this.webgl.geometries.ray,
			t = e.count,
			i = new Float32Array(t);
		for (let s = 0; s < t; s++) i[s] = Rt.randomFloat(0, 3);
		const r = new cm(i, 1);
		e.geometry.setAttribute("offset", r), e.material.dispose(), e.material = _m.use(), this.base.add(e)
	}
}
var yK = `precision highp float;
uniform float time;
uniform float uProgress;
uniform float uScroll;

uniform vec2 bufferSize;
uniform vec4 resolution;
uniform float pixelRatio;
uniform sampler2D uNoise;
uniform sampler2D uMap;
uniform sampler2D uScene;

varying vec2 vUv;

#include <fog_pars_fragment>

void main() {
  vec4 diffuse = texture2D(uMap, vUv);

  vec2 uv = vUv;
  vec2 px = (gl_FragCoord.xy / bufferSize.xy);

  uv.y *= 0.25;

  vec3 noise = texture2D(uNoise, uv * 2.5 + time * 0.01).rgb;

  float dist = distance(vUv, vec2(0., 1.));
  float strokeRadius = sqrt(2.0) * smoothstep(0., 1., uProgress - smoothstep(0.2, 1., uScroll));

  strokeRadius *= 1. + noise.r * 1.;

  float circle = smoothstep(strokeRadius - 0.2, strokeRadius, dist);

  vec3 rockDiffuse = texture2D(uScene, px).rgb;
  vec3 diff = abs(rockDiffuse.rgb * 0.5 - vec3(0.125)) * 2.;

  gl_FragColor = diffuse;
  gl_FragColor.rgb = diff;
  gl_FragColor.a *= 1. - circle;

  

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
	xK = `precision highp float;

varying vec2 vUv;
varying float vDepth;
#include <fog_pars_vertex>

void main() {
  vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
  vec4 mvPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.);
  vDepth = smoothstep(10., 3., gl_Position.z);
  #include <fog_vertex>
}`;
const wK = Fi(xK, yK);
class vm extends Dn {
	constructor(e = {}) {
		super();
		const t = this.webgl = Qn(),
			i = t.postprocess;
		this.uniforms = {
			...ni.standard.uniforms,
			...t.uniforms,
			uMap: {
				value: t.textures.text
			},
			uNoise: {
				value: t.textures.noise
			},
			uProgress: {
				value: 0
			},
			uScroll: {
				value: 0
			},
			uScene: {
				value: i.buffers.rock.texture
			}
		}, wK.use(this), this.transparent = !0, this.fog = !0, this.isShaderMaterial = !0, this.depthWrite = !1, t.hooks.afterUpdate.watch(() => {
			this.uniforms.uProgress.value = t.store.textProgress, this.uniforms.uScroll.value = t.store.rocksProgress
		})
	}
}
let xS = null;
vm.use = () => xS = xS ?? new vm;
vm.unuse = () => {};
class EK extends _i {
	init() {
		this.base = new ht;
		const e = this.text = this.webgl.geometries.text;
		e.material = vm.use(), this.base.add(e), e.rotation.z = -.05, Vt(this.webgl.$viewport, this.resize.bind(this), {
			immediate: !0
		})
	}
	resize() {
		const {
			width: e,
			height: t
		} = this.webgl.homeData.dimensions, i = e / t;
		let r = this.webgl.$viewport.width * .6 / 1440 * 1.485;
		this.webgl.$viewport.width < 768 && (r = .6), this.text.scale.set(r, r / i, r)
	}
	update() {
		const e = this.webgl.store.isMobile ? 4 : .75,
			t = this.scene.camera.cam;
		this.base.position.y = Nl(this.base.position.y, (t.position.y - .92) * e, this.webgl.store.isMobile ? .2 : .5)
	}
}
let wS;
new X;
new X;
class SK extends r0 {
	init() {
		this.mainCamera = this.add(hK), this.debugCamera = this.add(RY), this.camera = this.mainCamera, this.isUsed = !0, this.rock = this.add(uK), this.background = this.add(QY), this.smoke = this.add(mK), this.rays = this.add(bK), this.text = this.add(EK);
		const e = new ZD(16777215, .15);
		this.addObject3D(e), this.particles = this.webgl.particles.addTo(this), this.webgl.particles.emit("Dust", {
			amount: 8,
			spriteId: "Point",
			position: this.base.position,
			scale: 1
		}), this.base.fog = new Nb(this.webgl.store.backgroundColor, 4.5, 5)
	}
	enter() {
		lt.fromTo(this.mainCamera.base.position, {
			x: 1
		}, {
			x: 0,
			duration: 3,
			ease: "expo.out"
		})
	}
	debug() {
		const t = this.webgl.$gui.addFolder({
			title: "Rock Scene",
			expanded: !0
		});
		t.addBlade({
			view: "list",
			label: "Cameras",
			options: [{
				text: "Debug",
				value: this.debugCamera
			}, {
				text: "Main",
				value: this.mainCamera
			}],
			value: this.camera
		}).on("change", r => {
			this.camera = r.value
		});
		const i = t.addButton({
			title: "Copy & Log Coords"
		});
		i.on("click", () => {
			clearTimeout(wS);
			const r = this.webgl.scene.getCurrentCamera(),
				s = r.cam.position.toArray().map(l => l.toFixed(5)).join(", "),
				o = r.cam.quaternion.toArray().map(l => l.toFixed(6)).join(", "),
				a = ["{", "	position: [ " + s + " ],", "	quaternion: [ " + o + " ],", "}"].join(`
`);
			navigator.clipboard.writeText(a).then(() => (i.title = "Copied!", new Promise(l => wS = setTimeout(l, 700)))).then(() => i.title = "Copy Coords")
		})
	}
	update() {
		const e = this.webgl.time.frameNum;
		e % 20 === 1 && this.webgl.particles.emit("Dust", {
			amount: 4,
			spriteId: "Point",
			position: this.base.position,
			scale: 1
		}), e % 600 === 1 && this.webgl.particles.emit("Ash", {
			amount: 4,
			spriteId: "Ash",
			position: this.base.position,
			scale: 1
		})
	}
}

function TK(n) {
	const e = {},
		t = {},
		{
			isMobile: i
		} = n.store,
		r = {
			scenes: e,
			buffers: t,
			init: s,
			update: c,
			render: f
		};
	e.rock = new SK, e.background = new AY, e.lab = new oK;

	function s() {
		n.scene = e.background, e.lab.triggerInit(), e.background.triggerInit(), e.rock.triggerInit(), d(t.lab, n.threeRenderer)
	}

	function o(_) {
		e.rock.background.base.visible = _, e.rock.rock.far.visible = _, e.rock.rock.middle.visible = _, e.rock.smoke.base.visible = _
	}

	function a(_) {
		e.rock.rock.close.visible = _, e.rock.rays.base.visible = _, e.rock.particles.base.visible = _
	}

	function l(_) {
		e.rock.text.base.visible = _
	}

	function c() {
		n.store.opacity !== 0 && n.store.isRunning && (n.store.labProgress > 0 && n.store.labProgress <= 2 && e.lab.triggerUpdate(), e.background.triggerUpdate(), n.store.backgroundProgress !== 1 && e.rock.triggerUpdate())
	}

	function u(_, g) {
		const m = n.postprocess,
			b = n.postprocess.buffers,
			v = n.store.backgroundProgress;
		if (v === 1) return;
		if (!i) {
			const x = n.renderer.drawingBufferSize.value.x,
				S = n.renderer.drawingBufferSize.value.y * v,
				E = n.renderer.drawingBufferSize.value.y;
			b.main.scissorTest = !0, b.text.scissorTest = !0, b.rockPost.scissorTest = !0, b.rock.scissorTest = !0, b.main.scissor.set(0, S, x, E), b.text.scissor.set(0, S, x, E), b.rockPost.scissor.set(0, S, x, E), b.rock.scissor.set(0, S, x, E)
		}
		g.setClearAlpha(0), g.setRenderTarget(_), g.clear(), o(!0), a(!1), l(!1), e.rock.triggerRender(g), g.setRenderTarget(b.text), g.clear(), o(!1), a(!1), l(!0), e.rock.triggerRender(g), g.setRenderTarget(b.main), m.textComposer.render(b.rock, b.text), a(!0), l(!1), g.clearDepth(), e.rock.triggerRender(g);
		const y = m.blurPass.render(b.main);
		g.setRenderTarget(b.rockPost), m.rockComposer(b.main, y)
	}

	function h(_, g) {
		g.setRenderTarget(_), g.clear(), e.background.triggerRender(g)
	}

	function d(_, g) {
		const m = n.postprocess,
			b = n.postprocess.buffers;
		n.store.labProgress === 0 || n.store.labProgress >= 2 || n.store.isMobile && !n.store.labProcessing || (g.setRenderTarget(b.lab), g.clear(), e.lab.triggerRender(g), g.setRenderTarget(b.labPost), m.labComposer(b.lab))
	}

	function f() {
		const _ = n.postprocess.buffers;
		n.threeRenderer.getRenderTarget(), n.store.isRunning && (d(_.lab, n.threeRenderer), h(_.background, n.threeRenderer), u(_.rock, n.threeRenderer))
	}

	function p() {
		n.$gui
	}
	n.$gui && p(), n.scenes = r
}

function MK(n, {
	spriteId: e,
	position: t,
	scale: i
}) {
	n.spriteId = e, n.billboard = !1;
	const r = new X(Rt.randomFloat(0, 1), Rt.randomFloat(0, 1), Rt.randomFloat(-1, 1));
	n.duration = Rt.randomFloat(7e3, 9e3), n.position.copy(r), n.temp = new X, n.target = new X;
	const s = Rt.randomFloat(.04, .1) * i;
	n.scale.set(s, s), n.rand = new X(Rt.randomFloat(.8, 1), Rt.randomFloat(-3.14, 3.14), Rt.randomFloat(0, 1)), n.color = new et("#FFFFFF"), n.alpha = 0
}

function CK(n, e) {
	let t = n.progress > .1 && n.progress < .9 ? .4 : 0;
	n.alpha = Nl(n.alpha, t, .07);
	const i = Math.sin(n.progress * Math.PI * n.rand.x) * .1 * .1;
	n.velocity.y = i, n.position.z += Math.cos(n.progress * Math.PI * n.rand.x) * .001, n.position.y += n.velocity.y * .1, n.rotation.x = n.progress * Math.PI * n.rand.y * .3, n.rotation.z = n.progress * Math.PI + n.rand.y * .3, n.rotation.y = n.progress * Math.PI + n.rand.y * .3, n.quaternion.setFromEuler(n.rotation)
}
const AK = {
		onEmit: MK,
		onUpdate: CK
	},
	DK = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: AK
	}, Symbol.toStringTag, {
		value: "Module"
	}));

function PK(n, e) {
	const t = n.z - e.z,
		i = n.y - e.y;
	return Math.sqrt(t * t + i * i)
}

function RK(n, {
	spriteId: e,
	position: t,
	scale: i
}) {
	n.spriteId = e, n.billboard = !0;
	const r = new X(Rt.randomFloat(0, 1), Rt.randomFloat(0, 1.5), Rt.randomFloat(-1, 1));
	n.duration = Rt.randomFloat(5e3, 6e3), n.position.copy(r);
	const s = Rt.randomFloat(.005, .015) * i;
	n.scale.set(s, s), n.rand = new X(Rt.randomFloat(.8, 1), Rt.randomFloat(-3.14, 3.14), Rt.randomFloat(0, 1)), n.color = new et("#FFFFFF"), n.alpha = 0
}

function LK(n, e) {
	let t = n.progress > .1 && n.progress < .75 ? .4 : 0;
	n.alpha = Nl(n.alpha, t, .07);
	const i = Math.sin(n.progress * Math.PI * n.rand.x) * .1 * .1;
	n.velocity.y = i, n.position.x += Math.cos(n.progress * Math.PI * n.rand.x) * .001, n.position.y += n.velocity.y * .1;
	const r = n.store.pPosition;
	PK(r, n.position)
}
const kK = {
		onEmit: RK,
		onUpdate: LK
	},
	IK = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: kK
	}, Symbol.toStringTag, {
		value: "Module"
	}));
class OK {
	constructor() {
		this.atlas = null, this.frames = [], this.frame = 0, this.frameCount = 0, this.currentFrameIndex = 0, this.loop = !1, this.autoplay = !1, this.id = "", this.group = "", this.sequence = ""
	}
	setAtlas(e) {
		this.sprites = e.sprites
	}
	change({
		id: e = "circleA",
		group: t,
		sequence: i,
		frame: r,
		frameDuration: s,
		autoplay: o,
		loop: a
	}) {
		this.sprites[e] && (this.id = e, this.frames = this.sprites[this.id], this.frameCount = this.frames.length, this.currentFrameIndex = Math.min(r || 0, this.frameCount - 1), this.frame = this.frames[this.currentFrameIndex], this.loop = !!a, this.autoplay = !!o)
	}
}
let tp;
const FK = new ht,
	ES = {};
class NK {
	constructor(e) {
		tp || (tp = Qn()), this.dummy = FK, this.position = new X, this.quaternion = new qr, this.scale = new Oe(1, 1), this.color = new et(16777215), this.rotation = new Er, this.angle = 0, this.store = tp.store, this.billboard = !1, this.textured = this.alpha = 1, this.visible = !0, this.parent = null, this.progress = 0, this.duration = 0, this.age = 0, this.velocity = new X, this.alive = !1, this.killable = !1, this.sprite = new OK, this.spriteId = null, this.spriteFrame = 0, this.spriteFrameDuration = 50, this.spriteLoop = !1, this.spriteAutoplay = !1
	}
	reset() {
		this.duration = 1e3, this.progress = 0, this.age = 0, this.position.set(0, 0, 0)
	}
	emit(e, t, i, r) {
		this.reset(), this.batcher = e, this.killable = !1, this.alive = !0, this.index = r, this.preset = t || ES, this.presetOptions = i || ES, this.preset.onEmit && this.preset.onEmit(this, i), this.sprite.setAtlas(this.batcher.atlas), this.sprite.change({
			id: this.spriteId,
			frame: this.spriteFrame,
			frameDuration: this.spriteFrameDuration,
			loop: this.spriteLoop,
			autoplay: this.spriteAutoplay
		}), this.batcher.addInstance(this)
	}
	kill() {
		this.batcher && (this.batcher.removeInstance(this), this.batcher = null), this.reset(), this.progress = 1, this.alive = !1, this.killable = !1
	}
	update() {
		if (!this.alive || this.killable) return;
		if (this.progress >= 1) return this.killable = !0;
		const e = tp.time.stableDt;
		this.age += e, this.progress = pu(this.age / this.duration, 0, 1), this.preset.onUpdate && this.preset.onUpdate(this, this.presetOptions)
	}
}
const UK = 200,
	oP = {};

function BK(n, e) {
	e || (e = {}), oP[n] = e
}
class zK extends _i {
	constructor(e = {}) {
		super(e), this.batcher = e.batcher, this.count = e.count || UK, this.alive = [], this.dead = new Array(this.count).fill(0).map(() => new NK({}))
	}
	emit(e, t = {}) {
		typeof t == "number" && (t = {
			amount: t
		});
		const i = t.amount = t.amount || 4,
			r = oP[e];
		if (!r) return;
		const s = this.alloc(i),
			o = this.batcher;
		for (let a = s.length - 1; a >= 0; a--) s[a].alive, this.alive.push(s[a]), s[a].emit(o, r, t, a)
	}
	update() {
		const e = [];
		for (let t = this.alive.length - 1; t >= 0; t--) {
			const i = this.alive[t];
			i.update(), i.killable && (e.push(i), this.alive.splice(t, 1), this.dead.push(i))
		}
		for (let t = e.length - 1; t >= 0; t--) e[t].kill()
	}
	alloc(e) {
		const t = this.dead,
			i = this.alive;
		let r = [],
			s = e;
		return t.length > 0 && (r = t.splice(0, s)), s -= r.length, s > 0 && (r = r.concat(i.splice(0, s))), r
	}
	killAll() {
		for (let e = this.alive.length - 1; e >= 0; e--) this.alive[e].kill(), this.dead.push(this.alive[e]), this.alive.splice(e, 1)
	}
	registerPreset(e, t) {
		BK(e, t)
	}
}
var VK = `precision highp float;

uniform sampler2D atlas;

varying vec2 vUv;
varying vec4 vColor;

void main() {
	vec2 uv = vUv;
	vec4 color = texture2D(atlas, uv);

	
	float shape = color.r;
	float alpha = color.a;

	vec3 col = vColor.rgb;

	gl_FragColor = vec4(col, alpha * vColor.a);
	
	
	
}`,
	HK = `precision highp float;

attribute vec4 texCoords;
attribute vec4 meshCoords;

attribute vec3 spritePos;
attribute vec4 spriteQt;
attribute vec4 spriteColor;
attribute vec2 decorators;

varying vec2 vUv;
varying vec4 vColor;

mat4 getInstanceMatrix( vec3 p, vec4 q, vec3 s ) {

    mat4 m;

    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;

    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;

    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;

    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;

    float sx = s.x;
    float sy = s.y;
    float sz = s.z;

    m[ 0 ][ 0 ] = ( 1. - ( yy + zz ) ) * sx;
    m[ 0 ][ 1 ] = ( xy + wz ) * sx;
    m[ 0 ][ 2 ] = ( xz - wy ) * sx;
    m[ 0 ][ 3 ] = 0.;

    m[ 1 ][ 0 ] = ( xy - wz ) * sy;
    m[ 1 ][ 1 ] = ( 1. - ( xx + zz ) ) * sy;
    m[ 1 ][ 2 ] = ( yz + wx ) * sy;
    m[ 1 ][ 3 ] = 0.;

    m[ 2 ][ 0 ] = ( xz + wy ) * sz;
    m[ 2 ][ 1 ] = ( yz - wx ) * sz;
    m[ 2 ][ 2 ] = ( 1. - ( xx + yy ) ) * sz;
    m[ 2 ][ 3 ] = 0.;

    m[ 3 ][ 0 ] = p.x;
    m[ 3 ][ 1 ] = p.y;
    m[ 3 ][ 2 ] = p.z;
    m[ 3 ][ 3 ] = 1.;

    return m;

}

void main() {
	vColor = spriteColor;
	vUv = uv * texCoords.zw + texCoords.xy;
	vUv.y = 1. - vUv.y;

	vec3 transformed = position;
	transformed.xy = transformed.xy * meshCoords.zw + (meshCoords.xy * 0.5);
	transformed.xy += meshCoords.xy * 0.5;

	mat4 instanceMatrix = getInstanceMatrix(spritePos, spriteQt, vec3(1.) );
	vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(transformed, 1.);

	
	vec4 bbPosition = modelViewMatrix * instanceMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	bbPosition.x += cos(spriteQt.x) * transformed.x - sin(spriteQt.x) * transformed.y;
	bbPosition.y += sin(spriteQt.x) * transformed.x + cos(spriteQt.x) * transformed.y;
	mvPosition = mix(mvPosition, bbPosition, decorators.x);

	gl_Position = projectionMatrix * mvPosition;
}`;
const GK = Fi(HK, VK);
class bm extends Dn {
	constructor(e = {}) {
		super(e);
		const t = Qn(),
			i = t.textures;
		this.uniforms = {
			...t.uniforms,
			atlas: {
				value: i.sprites,
				type: "t"
			}
		}, this.blending = ha, this.transparent = !0, this.depthWrite = !1, this.depthTest = !0, GK.use(this)
	}
}
let SS = null;
bm.use = () => SS = SS ?? new bm;
bm.unuse = () => {};
const t_ = new os;
new kt;
class WK extends _i {
	init() {
		this.atlas = this.props.atlas, this.count = this.props.count || 200, this.geo = new JD, this.geo.index = t_.index, this.geo.attributes.position = t_.attributes.position, this.geo.attributes.uv = t_.attributes.uv, this.initAttributes(), this.instances = new Set, this.setDynamic(this.props.dynamic);
		const e = new bm;
		this.base = new an(this.geo, e), this.base.frustumCulled = !1, this.currentCount = 0, this.updateAttributes = this.updateAttributes.bind(this)
	}
	setDynamic(e) {
		this.dynamic = e == null ? !0 : !!e, this.interleavedBuffer.setUsage(this.dynamic ? TV : om), this.interleavedBuffer.needsUpdate = !0, this.needsUpdate = !0
	}
	initAttributes() {
		this.stride = 21, this.buffer = new Float32Array(this.count * this.stride);
		const e = this.geo,
			t = this.interleavedBuffer = new QD(this.buffer, this.stride);
		e.setAttribute("texCoords", new pr(t, 4, 0, !1)), e.setAttribute("meshCoords", new pr(t, 4, 4, !1)), e.setAttribute("spritePos", new pr(t, 3, 8, !1)), e.setAttribute("decorators", new pr(t, 2, 11, !1)), e.setAttribute("spriteQt", new pr(t, 4, 13, !1)), e.setAttribute("spriteColor", new pr(t, 4, 17, !1)), t.needsUpdate = !0
	}
	updateAttributes(e) {
		if (!e || !e.visible) return;
		const t = this.currentCount++,
			i = this.buffer,
			r = this.stride,
			s = e.sprite.frame;
		let o = t * r;
		e.useEuler && e.quaternion.setFromEuler(e.rotation);
		let a = e.position,
			l = e.quaternion,
			c = e.scale;
		if (e.parent) {
			const h = e.parent;
			dummy.position.copy(a), dummy.quaternion.copy(e.billboard ? tQt : l), dummy.scale.set(c.x, c.y, 1), dummy.applyMatrix4(h.matrixWorld), dummy.updateMatrixWorld(), a = dummy.position, l = dummy.quaternion, c = dummy.scale
		}
		const u = e.billboard ? e.angle : l.x;
		i[o++] = s.texCoords[0], i[o++] = s.texCoords[1], i[o++] = s.texCoords[2], i[o++] = s.texCoords[3], i[o++] = s.meshCoords[0] * e.scale.x, i[o++] = s.meshCoords[1] * e.scale.y, i[o++] = s.meshCoords[2] * e.scale.x, i[o++] = s.meshCoords[3] * e.scale.y, i[o++] = a.x, i[o++] = a.y, i[o++] = a.z, i[o++] = e.billboard ? 1 : 0, i[o++] = e.textured ? 1 : 0, i[o++] = u, i[o++] = l.y, i[o++] = l.z, i[o++] = l.w, i[o++] = e.color.r, i[o++] = e.color.g, i[o++] = e.color.b, i[o++] = e.alpha
	}
	addInstance(e) {
		this.instances.has(e) || this.instances.add(e)
	}
	removeInstance(e) {
		this.instances.has(e) && this.instances.delete(e)
	}
	update() {
		this.dynamic && (this.currentCount = 0, this.instances.forEach(this.updateAttributes), this.geo.instanceCount = this.currentCount, this.interleavedBuffer.needsUpdate = !0, this.base.visible = this.currentCount !== 0)
	}
	clearInstances() {
		this.instances.clear()
	}
	destroy() {
		this.clearInstances(), this.geo.dispose(), super.destroy()
	}
}
const jK = Object.assign({
		"/webgl/components/Particles/Presets/Ash.js": DK,
		"/webgl/components/Particles/Presets/Dust.js": IK
	}),
	$K = Object.entries(jK).map(([n, e]) => ({
		id: n.split("/").pop().split(".js").shift(),
		module: e.default
	}));

function qK(n) {
	let e = !1,
		t, i;
	const r = {
		init: s,
		emit: o,
		update: l,
		addTo: a
	};

	function s() {
		if (e) return;
		e = !0;
		const c = {
			atlas: n.atlases.sprites,
			transparent: !0,
			depthWrite: !1,
			depthTest: !1
		};
		i = new WK({
			...c,
			count: 200
		}), t = new zK({
			batcher: i
		}), $K.forEach(u => t.registerPreset(u.id, u.module))
	}

	function o(c, u = {}) {
		if (t) return t.emit(c, u)
	}

	function a(c) {
		return c.add(i), i.base.manualMatrixUpdate = !0, i.base.updateMatrixWorld(), i
	}

	function l() {
		e && (i.update(), t.update())
	}
	n.particles = r
}
class XK extends r0 {
	init() {
		this.isUsed = !0, this.scrollValue = 0, this.camera = this.add(Vd), this.camera.base.position.set(0, 0, 3.5).multiplyScalar(1), this.camera.base.lookAt(0, 0, 0), this.mesh = this.add(ZY);
		const e = new ZD(16777215, 1);
		this.addObject3D(e)
	}
	debug() {}
	update() {}
}

function YK(n) {
	let e, t, i = 1,
		r = 2;
	const s = {
		alpha: !0,
		depth: !0,
		antialias: !0,
		powerPreference: "high-performance"
	};
	t = new XK;

	function o() {
		s.canvas = n.frontCanvas, e = new Fb(s), e.setScissorTest(!0), Vt(n.$viewport, u, {
			immediate: !0
		})
	}

	function a() {
		n.frontRenderer = e, t.triggerInit(), h.scene = t
	}

	function l() {
		t.triggerUpdate()
	}

	function c() {
		t.triggerRender(e)
	}

	function u() {
		const d = pu(n.$viewport.pixelRatio, i, r);
		e.getPixelRatio() !== d && e.setPixelRatio(d);
		const f = n.$viewport.viewportRatio,
			p = pu(n.$viewport.width * .05, 20, 80),
			_ = p / f;
		n.$viewport.width / 2 - p / 2, e.setSize(p, _)
	}
	const h = {
		init: a,
		update: l,
		render: c,
		createRenderer: o,
		scene: t
	};
	n.logo = h
}

function KK() {
	const n = Qn(),
		{
			$preloader: e,
			callHook: t
		} = Ke();

	function i() {
		n.store.backgroundProgress = 1, n.store.noisePropagation = 0, n.store.noiseDissolve = 0, n.store.labProgress = 0, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labActive = !1, n.store.labProcessing = 0;
		const s = n.logo.scene.mesh;
		s && s.onEnter(), t("WEBGL:CHANGECOLOR", "#EEECEA"), lt.fromTo(n.store, {
			noisePropagation: 0
		}, {
			noisePropagation: 1,
			duration: 3,
			ease: "linear"
		})
	}

	function r() {
		const s = n.logo.scene.mesh;
		s && s.onLeave()
	}
	return {
		enter: i,
		leave: r
	}
}
const ZK = Object.freeze(Object.defineProperty({
	__proto__: null,
	default: KK
}, Symbol.toStringTag, {
	value: "Module"
}));

function JK() {
	const n = Qn(),
		e = Ct();

	function t() {
		if (n.store.rocksProgress = 0, n.store.maskProgress = 1, n.store.labProgress = 0, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labActive = !1, n.store.labProcessing = 0, n.store.backgroundProgress = 0, n.store.noisePropagation = 1, n.store.noiseDissolve = 0, n.store.rocksActive = !0, e.isLoaderDone) lt.fromTo(n.store, {
			noisePropagation: 0
		}, {
			noisePropagation: 1,
			duration: 1.5,
			delay: .1,
			ease: "linear"
		}), lt.fromTo(n.store, {
			maskProgress: 0
		}, {
			maskProgress: 1,
			duration: 2,
			ease: "expo.inOut"
		}), lt.fromTo(n.store, {
			maskRotation: .3
		}, {
			maskRotation: 0,
			duration: 2,
			ease: "expo.inOut"
		}), lt.delayedCall(1.5, () => {
			const r = n.logo.scene.mesh;
			r && (r.set2D(), r.onEnter())
		}), lt.fromTo(n.store, {
			dollyProgress: 1
		}, {
			dollyProgress: 0,
			duration: 3,
			ease: "expo.out",
			delay: .75
		}), lt.fromTo(n.store, {
			textProgress: 0
		}, {
			textProgress: .65,
			duration: 4,
			ease: "expo.out",
			delay: .75
		});
		else {
			const r = n.logo.scene.mesh;
			r && r.set2D()
		}
	}

	function i() {
		n.store.labProgress = 0, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labScaleFactor = 1, n.store.labProcessing = 0, n.store.rocksActive = !1;
		const r = n.logo.scene.mesh;
		r && r.onLeave()
	}
	return {
		enter: t,
		leave: i
	}
}
const QK = Object.freeze(Object.defineProperty({
	__proto__: null,
	default: JK
}, Symbol.toStringTag, {
	value: "Module"
}));

function eZ() {
	const n = Qn(),
		{
			$preloader: e,
			callHook: t
		} = Ke();

	function i() {
		n.store.backgroundProgress = 1, n.store.labProgress = 1, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labScaleFactor = 0, n.store.labProcessing = 1, n.store.labActive = !0, t("WEBGL:CHANGECOLOR", "#DCDCDC"), n.scenes.scenes.lab.onEnter();
		const o = n.logo.scene.mesh;
		o && o.onLeave()
	}

	function r() {
		n.store.labActive = !1, n.store.labProgress = 0, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labScaleFactor = 1, n.store.labProcessing = 0, Ct().setCursorPointer(!1)
	}
	return {
		enter: i,
		leave: r
	}
}
const tZ = Object.freeze(Object.defineProperty({
	__proto__: null,
	default: eZ
}, Symbol.toStringTag, {
	value: "Module"
}));

function nZ() {
	const n = Qn(),
		{
			$preloader: e,
			callHook: t
		} = Ke();

	function i() {
		n.store.backgroundProgress = 1, n.store.noisePropagation = 0, n.store.noiseDissolve = 0, n.store.labActive = !1, n.store.labProgress = 0, n.store.labDollyProgress = 0, n.store.labSmoothProgress = 0, n.store.labScaleFactor = 1, n.store.labProcessing = 0;
		const s = n.logo.scene.mesh;
		s && s.onEnter(), t("WEBGL:CHANGECOLOR", "#EEECEA"), lt.fromTo(n.store, {
			noisePropagation: 0
		}, {
			noisePropagation: 1,
			duration: 3,
			ease: "linear"
		})
	}

	function r() {
		const s = n.logo.scene.mesh;
		s && s.onLeave()
	}
	return {
		enter: i,
		leave: r
	}
}
const iZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: nZ
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	rZ = Object.assign({
		"./stateCase.js": ZK,
		"./stateHome.js": QK,
		"./stateLab.js": tZ,
		"./stateModel.js": iZ
	});

function sZ(n) {
	const e = {},
		t = tt(null),
		{
			hook: i,
			$preloader: r
		} = Ke(),
		s = Ca();
	i("TRANSITION:BEFORE_ENTER", l), i("TRANSITION:LEAVE", c);
	for (const [h, d] of Object.entries(rZ)) {
		const f = h.slice(7, -3),
			_ = d.default();
		_.isUsed = !1, e[f] = _
	}
	const o = {
		get current() {
			return t.value
		},
		currentState: t,
		set: u
	};

	function a(h) {
		if (h === "/") return "Home";
		if (h === "/lab") return "Lab";
		if (h === "/about") return "Model";
		if (h.match("/work")) return "Case"
	}

	function l() {
		const h = a(s.path);
		h && u(h)
	}

	function c() {}

	function u(h) {
		if (!e[h] || e[h] === t.value) return;
		const d = t.value;
		d && (d.leave(), d.isUsed = !1), t.value = e[h], t.value.isUsed = !0, t.value.enter()
	}
	n.state = o
}

function oZ(n) {
	Object.assign(n, {
		init: e,
		preload: t,
		start: i,
		update: r,
		render: s
	}), n.usePlugins([Kq, $q, YK, Xq, XX, Yq, qX, QX, gY, qK, TK, sZ]);
	async function e() {
		n.renderer.init(), n.shaders.init(), n.loader.init(), n.store.isMobile || n.logo.createRenderer()
	}
	async function t() {
		n.loader.preload()
	}
	async function i() {
		n.time.init(), n.fbo.init(n), n.postprocess.init(), n.particles.init(), n.store.isMobile || n.logo.init(), n.scenes.init()
	}

	function r() {
		n.store.update(), n.scenes.update(), n.shaders.update(), n.postprocess.update(), n.logo && n.logo.update(), n.store.isRunning && n.particles.update()
	}

	function s() {
		const o = n.threeRenderer,
			a = n.postprocess;
		n.postprocess.buffers, n.logo && n.logo.render(), n.store.isRunning && (a.enabled ? (n.scenes.render(), o.setRenderTarget(null), a.render()) : (o.setRenderTarget(null), n.scenes.scenes.lab.triggerRender(o)))
	}
}

function TS(n, e, t, i) {
	this.fn = e, this.ctx = t || null, this.owner = n, this.once = !!i
}

function n_(n) {
	if (!n || !n.owner) return;
	n.prev && (n.prev.next = n.next), n.next && (n.next.prev = n.prev);
	const e = n.owner;
	n.ctx = n.fn = n.owner = null, n === e._first && (e._first = n.next), n === e._last && (e._last = n.prev)
}
class zv {
	constructor() {
		this._first = this._last = null, this._isStoreSignal = !0
	}
	emit(e, t, i) {
		let r = this._first;
		for (; r;) r.fn.call(r.ctx, e, t, i), r.once && this.unwatch(r), r = r.next
	}
	watch(e, t, i) {
		const r = new TS(this, e, t, i);
		return this._first ? (this._last.next = r, r.prev = this._last, this._last = r) : (this._first = r, this._last = r), r
	}
	watchOnce(e, t) {
		return this.watch(e, t, !0)
	}
	unwatch(e, t) {
		if (e instanceof TS) return n_(e);
		t || (t = null);
		let i = this._first;
		for (; i;) i.fn === e && i.ctx === t && n_(i), i = i.next
	}
	unwatchAll() {
		let e = this._first;
		for (this._first = this._last = null; e;) n_(e), e = e.next
	}
}
zv.prototype.destroy = zv.prototype.unwatchAll;

function MS() {
	return new zv
}
const Io = n => n,
	aZ = n => n.charAt(0).toUpperCase() + n.slice(1);
let gc = {},
	CS = !1;

function Qn() {
	return gc
}

function lZ(n = {}) {
	if (CS) return gc;
	CS = !0;
	const e = ["Init", "Preload", "Load", "Start", "Frame", "Update", "Render"].reduce((c, u) => (c["before" + u] = MS(), c["after" + u] = MS(), c), {}),
		t = n,
		i = [];
	let s = {
		init: Io,
		preload: Io,
		start: Io,
		options: t,
		states: {},
		hooks: e,
		plugins: i,
		prerender: () => gc.frame(),
		frame: () => {
			gc.update(), gc.render()
		},
		update: Io,
		render: Io,
		usePlugins: o
	};
	return oZ(s), l("init", !0, !0, () => {
		a(i), ["frame", "update", "render"].forEach(c => l(c, !1)), ["preload", "start"].forEach(c => l(c, !0, !0)), ["load"].forEach(c => l(c, !0))
	}), gc = s, s;

	function o(c) {
		c.forEach(u => i.push(u))
	}

	function a(c) {
		Array.isArray(c) || (c = [c]), c.forEach(u => typeof u == "function" && u(s))
	}

	function l(c, u, h, d, f) {
		const p = s[c] || Io,
			_ = aZ(c),
			g = e["before" + _] || Io,
			m = e["after" + _] || Io;
		s[c] = u ? async function (b) {
			g.emit(), d && d(), await p(b), m.emit(), h && (g.unwatchAll(), m.unwatchAll())
		}: function (b) {
			g.emit(), d && d(), p(b), m.emit(), h && (g.unwatchAll(), m.unwatchAll())
		}
	}
}
const cZ = `
{
  home {
    webglTitle
  }
}
`,
	uZ = `
{
  lab {
    items {
      item {
        ...on labItem {
          image
        }
      }
    }
  }
}
`,
	hZ = un({
		name: "webgl",
		dependsOn: ["preloader", "viewport", "gui", "touch"],
		async setup(n) {
			let e, t, i, r, s;
			const {
				$preloader: o,
				$viewport: a,
				$touch: l,
				$gui: c,
				hook: u,
				hooks: h
			} = Ke(), {
				client: d
			} = Ls();
			r = document.createElement("canvas"), s = document.createElement("canvas"), i = lZ({
				canvas: r
			}), i.$viewport = a, i.$preloader = o, i.$touch = l, i.isReady = Mv(), c && (i.$gui = c), i.canvas = r, i.frontCanvas = s;
			const [{
				data: f
			}, {
				data: p
			}] = ([e, t] = Xc(() => Promise.all([Za("webglHome", () => d.getSingle("home", {
				graphQuery: cZ
			})), Za("webglLab", () => d.getSingle("lab", {
				graphQuery: uZ
			}))])), e = await e, t(), e), _ = a.width < 768 ? 248 : 512, g = Be(() => {
				const {
					items: m
				} = p == null ? void 0 : p.value.data;
				return m.map(({
					item: b
				}) => {
					var y, x;
					const {
						image: v
					} = b == null ? void 0 : b.data;
					return {
						id: b.id,
						src: `${v==null?void 0:v.url}&w=${_}`,
						width: (y = v == null ? void 0 : v.dimensions) == null ? void 0 : y.width,
						height: (x = v == null ? void 0 : v.dimensions) == null ? void 0 : x.height
					}
				})
			});
			return i.labData = g.value, i.homeData = f == null ? void 0 : f.value.data.webglTitle, o.task(async () => {
				await i.init(), await i.preload()
			}), u("PRELOADER:ASSETSLOADED", async () => {
				await i.start(), await i.prerender(), i.isReady.resolve()
			}), {
				provide: {
					webgl: i
				}
			}
		}
	}),
	dZ = [V6, G6, nI, sI, aI, lI, CI, dO, fO, gO, _O, jF, $F, qF, _B, mz, yz, wz, Ez, Sz, Uq, zq, Wq, hZ],
	aP = (n, e) => {
		const t = n.__vccOpts || n;
		for (const [i, r] of e) t[i] = r;
		return t
	},
	fZ = {
		__name: "Preloader",
		setup(n) {
			const {
				setIsLoaderDone: e,
				setCanvasAbsolute: t,
				setCanvasVisible: i
			} = Ct(), {
				$webgl: r,
				$preloader: s,
				hook: o,
				callHook: a
			} = Ke();
			$t(Ji());
			const l = Ca(),
				c = Be(() => l.name === "index"),
				u = Be(() => l.name === "about"),
				h = Be(() => l.name === "lab"),
				d = tt(!1),
				f = tt(!0);
			o("PRELOADER:BEFOREEXIT", () => {
				d.value = !0
			});
			const p = async () => {
				u.value || a("CURSOR:UPDATE", "loader"), await r.isReady, !c.value && !u.value && (r.store.backgroundProgress = 1), h.value && !u.value && (r.store.labOpacity = 0);
				const g = lt.timeline();
				g.set(r.store, {
					opacity: 1
				}, .1), g.add(() => {
					f.value = !1
				}, .1), g.fromTo(r.store, {
					noisePropagation: 0
				}, {
					noisePropagation: 1,
					duration: 3,
					ease: "linear"
				}, .1), g.add(() => {
					s.onEnter.resolve()
				}, .2)
			}, _ = (g, m) => {
				const b = lt.timeline();
				c.value && (t(!0), i(!0), r.store.rocksActive = !0, b.fromTo(r.store, {
					maskProgress: 0
				}, {
					maskProgress: 1,
					duration: 2,
					ease: "expo.inOut"
				}, 1), b.fromTo(r.store, {
					maskRotation: .3
				}, {
					maskRotation: 0,
					duration: 2,
					ease: "expo.inOut"
				}, 1), b.fromTo(r.store, {
					textProgress: 0
				}, {
					textProgress: .65,
					duration: 4,
					ease: "expo.out"
				}, 1.75), b.fromTo(r.store, {
					dollyProgress: 1
				}, {
					dollyProgress: 0,
					duration: 3,
					ease: "expo.out"
				}, 1.75)), h.value ? (i(!0), r.store.labProgress = 1, r.store.labActive = !0, b.add(() => {
					r.store.labProcessing = 1
				}, 1), b.fromTo(r.store, {
					labOpacity: 0
				}, {
					labOpacity: 1,
					duration: 2,
					ease: "expo.inOut"
				}, 1), b.add(() => {
					r.scenes.scenes.lab.onEnter()
				}, 1)) : b.add(() => {
					const v = r.logo.scene.mesh;
					v && v.onEnter()
				}, c.value ? 2.5 : 1), b.add(() => {
					e()
				}, 1.5), b.add(() => {
					m(), s.onLeave.resolve()
				}, 2)
			};
			return Vn(async () => {
				await Xi(), p()
			}), (g, m) => (ke(), It(ma, {
				css: !1,
				onEnter: p,
				onLeave: _
			}, {
				default: En(() => [fe(d) ? Fn("", !0) : (ke(), Ye("div", {
					key: 0,
					class: jt([{
						"preloader--bg": fe(f) && !fe(u)
					}, "preloader ttu mono"])
				}, null, 2))]),
				_: 1
			}))
		}
	},
	lP = aP(fZ, [
		["__scopeId", "data-v-63d11a51"]
	]),
	pZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: lP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	mZ = ["innerHTML"],
	cP = {
		__name: "TextSplitter",
		props: {
			skipLoad: {
				type: Boolean,
				default: !1
			},
			content: {
				type: String,
				required: !0
			},
			type: {
				type: String,
				default: "lines"
			},
			lineClass: {
				type: String,
				default: ""
			},
			wordClass: {
				type: String,
				default: ""
			},
			charClass: {
				type: String,
				default: ""
			},
			baseDelay: {
				type: Number,
				default: 0
			},
			isLazySplit: {
				type: Boolean,
				default: !0
			},
			hasOverflow: {
				type: Boolean,
				default: !1
			},
			shouldRestore: {
				type: Boolean,
				default: !0
			},
			shouldSetDelay: {
				type: Boolean,
				default: !0
			},
			shouldResize: {
				type: Boolean,
				default: !0
			},
			callback: {
				type: Function,
				default: null
			}
		},
		setup(n) {
			const {
				$webgl: e,
				hook: t,
				hooks: i
			} = Ke(), r = n, s = tt(null), {
				isFontLoaded: o
			} = $t(Ct()), a = tt(!1), l = tt(!1);
			let c = null,
				u = null,
				h = null;
			const d = {
				linesClass: r.lineClass || "anim-line",
				wordsClass: r.wordClass || "anim-word",
				charsClass: r.charClass || "anim-char"
			};
			Vt(() => r.content, async x => {
				x && a.value && (a.value = !1, await Xi(), b())
			}), Vn(async () => {
				await Xi(), await e.isReady, (r.skipLoad || o.value) && g(), f()
			}), Sa(() => {
				h == null || h.kill(), p()
			});
			const f = () => {
					t("WINDOW:RESIZE", _), !r.skipLoad && t("FONTS:LOADED", g)
				},
				p = () => {
					i.removeHook("WINDOW:RESIZE", _), !r.skipLoad && i.removeHook("FONTS:LOADED", g)
				},
				_ = () => {
					r.shouldResize && !l.value && s.value && (v(), a.value = !1, b())
				},
				g = () => {
					r.isLazySplit ? m() : b()
				},
				m = () => {
					h = at.create({
						trigger: s.value,
						start: "top bottom+=50%",
						end: "bottom top-=50%",
						once: !0,
						onEnter: b,
						onLeave: () => {
							r.shouldRestore && (v(), l.value = !0)
						}
					})
				},
				b = () => {
					if (a.value) return;
					const x = [...s.value.querySelectorAll("p")];
					r.hasOverflow ? (u = new _l(x.length ? x : s.value, {
						type: "lines",
						linesClass: "oh"
					}), c = new _l(u.lines, {
						type: r.type,
						...d
					})) : c = new _l(x.length ? x : s.value, {
						type: r.type,
						...d
					}), r.shouldSetDelay && y(), a.value = !0, r.callback && r.callback(c)
				},
				v = () => {
					a.value && (c == null || c.revert()), r.hasOverflow && (u == null || u.revert())
				},
				y = () => {
					if (r.type === "lines") {
						let x = 0;
						c.lines.forEach(S => {
							lt.set(S, {
								transitionDelay: `${r.baseDelay+x}s`
							}), x += .1
						})
					} else if (r.type === "chars") {
						let x = 0;
						lt.utils.shuffle(c.chars).forEach(E => {
							lt.set(E, {
								transitionDelay: `${r.baseDelay+x}s`
							}), x += .03
						})
					}
				};
			return (x, S) => (ke(), Ye("span", {
				ref_key: "container",
				ref: s,
				class: jt([{
					"text-splitter--splitted": fe(a),
					"text-splitter--restored": fe(l)
				}, "text-splitter"]),
				innerHTML: n.content
			}, null, 10, mZ))
		}
	},
	gZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: cP
	}, Symbol.toStringTag, {
		value: "Module"
	}));

function _Z() {
	let n, e;
	const t = new Promise((i, r) => {
		n = i, e = r
	});
	return t.resolve = n, t.reject = e, t
}
const Da = {
		__name: "AnimatedLabel",
		props: {
			content: {
				type: String,
				required: !0
			},
			hasVisibleAnimation: {
				type: Boolean,
				default: !1
			},
			visibleDelay: {
				type: Number,
				default: 0
			},
			baseColor: {
				type: String,
				default: "#929292"
			},
			hoverColor: {
				type: String,
				default: "#eaffb0"
			},
			callbackSplitDone: {
				type: Function,
				default: () => {}
			}
		},
		setup(n, {
			expose: e
		}) {
			const t = n,
				{
					windowSize: i
				} = $t(Ct());
			let r = null,
				s = null,
				o = null,
				a = null,
				l = _Z();
			Sa(() => {
				a == null || a.kill(), r == null || r.revert()
			});
			const c = d => {
					r = d, s = lt.utils.random(0, (r == null ? void 0 : r.chars.length) - 1, 1, !0), l.resolve(), t.callbackSplitDone(d)
				},
				u = () => {
					if (i.value.width < 768) return !1;
					o = s();
					const d = (r == null ? void 0 : r.chars.length) <= 3 ? (r == null ? void 0 : r.chars.length) * .12 : (r == null ? void 0 : r.chars.length) * .06;
					a == null || a.kill(), a = lt.timeline().to(r == null ? void 0 : r.chars, {
						color: t.hoverColor,
						duration: .1,
						ease: "none",
						stagger: {
							from: "random",
							each: .04
						}
					}, 0).to(r == null ? void 0 : r.chars, {
						color: t.baseColor,
						duration: .1,
						ease: "none",
						stagger: {
							from: o,
							each: .06
						}
					}, d)
				};
			return e({
				onVisible: async () => {
					await l, lt.to(r == null ? void 0 : r.chars, {
						opacity: 1,
						duration: .2,
						ease: "none",
						delay: t.visibleDelay,
						stagger: {
							from: "random",
							each: .06
						}
					})
				}
			}), (d, f) => {
				const p = cP;
				return ke(), It(p, {
					"aria-hidden": "true",
					class: jt([{
						"animated-label--has-build-on": n.hasVisibleAnimation
					}, "animated-label"]),
					content: n.content,
					type: "chars",
					"char-class": "animated-label__char",
					"should-restore": !1,
					"should-set-delay": !1,
					"should-resize": !1,
					callback: c,
					onMouseenter: u
				}, null, 8, ["class", "content"])
			}
		}
	},
	vZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: Da
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	uP = {
		__name: "HeaderLogo",
		props: {
			isVisible: {
				type: Boolean,
				default: !1
			}
		},
		setup(n) {
			const e = Ct(),
				{
					setIsNavOpen: t
				} = e,
				{
					isNavOpen: i
				} = $t(e),
				r = n,
				s = Ca(),
				o = Be(() => s.name !== "index"),
				a = tt(null);
			Vt(() => r.isVisible, c => {
				var u;
				c && ((u = a == null ? void 0 : a.value) == null || u.onVisible())
			});
			const l = () => {
				i.value && t()
			};
			return (c, u) => {
				const h = Da,
					d = Zc;
				return ke(), It(d, {
					"aria-label": "Hyperlink to home page",
					to: "/",
					class: jt([{
						"header-logo--back": fe(o)
					}, "header-logo mono ttu"]),
					onClick: l
				}, {
					default: En(() => [Ge(h, {
						ref_key: "animatedLabel",
						ref: a,
						content: "Ashfall.studio",
						"has-visible-animation": !0
					}, null, 512)]),
					_: 1
				}, 8, ["class"])
			}
		}
	},
	bZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: uP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	yZ = {
		class: "nav-item"
	},
	xZ = {
		key: 1
	},
	hP = {
		__name: "NavItem",
		props: {
			label: String,
			url: String,
			onClick: Function,
			hasSplit: {
				type: Boolean,
				default: !1
			},
			splitDelay: {
				type: Number,
				default: 0
			},
			isVisible: {
				type: Boolean,
				default: !1
			}
		},
		setup(n) {
			const e = n,
				t = tt(null);
			Vt(() => e.isVisible, s => {
				var o;
				s && ((o = t == null ? void 0 : t.value) == null || o.onVisible())
			});
			const i = Ca(),
				r = Be(() => i.path.includes(`${e.url}/`));
			return (s, o) => {
				const a = Da,
					l = Zc;
				return ke(), Ye("li", yZ, [Ge(l, {
					class: jt([{
						"router-link-active": fe(r)
					}, "nav-item__link mono ttu"]),
					to: e.url,
					onClick: n.onClick,
					"aria-label": n.label
				}, {
					default: En(() => [n.hasSplit ? (ke(), It(a, {
						key: 0,
						ref_key: "animatedLabel",
						ref: t,
						content: n.label,
						"has-visible-animation": !0,
						"visible-delay": n.splitDelay
					}, null, 8, ["content", "visible-delay"])) : (ke(), Ye("span", xZ, to(n.label), 1))]),
					_: 1
				}, 8, ["class", "to", "onClick", "aria-label"])])
			}
		}
	},
	wZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: hP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	EZ = {
		key: 0,
		class: "border__svg"
	},
	SZ = Fe("use", {
		"xlink:href": "#plus"
	}, null, -1),
	TZ = [SZ],
	jb = {
		__name: "Border",
		props: {
			position: {
				type: String,
				default: "left"
			},
			hasSvg: {
				type: Boolean,
				default: !0
			}
		},
		setup(n) {
			return (e, t) => (ke(), Ye("div", {
				class: jt([`border--${n.position}`, "border"])
			}, [n.hasSvg ? (ke(), Ye("svg", EZ, TZ)) : Fn("", !0)], 2))
		}
	},
	MZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: jb
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	CZ = ["aria-label"],
	AZ = {
		class: "nav-contact-btn__label"
	},
	DZ = Fe("span", {
		"aria-hidden": "true",
		class: "nav-contact-btn__svg-wrapper"
	}, [Fe("svg", {
		class: "nav-contact-btn__svg"
	}, [Fe("use", {
		"xlink:href": "#plus"
	})])], -1),
	dP = {
		__name: "NavContactButton",
		props: {
			isVisible: {
				type: Boolean,
				default: !1
			}
		},
		setup(n) {
			const {
				hook: e,
				hooks: t,
				$lenis: i
			} = Ke(), r = Ct(), {
				setIsContactModalOpen: s
			} = r, {
				windowSize: o
			} = $t(r), {
				navData: a
			} = $t(Ji()), l = tt(null), c = n;
			Vt(() => c.isVisible, m => {
				var b;
				m && ((b = l == null ? void 0 : l.value) == null || b.onVisible())
			});
			const u = tt(!1);
			let h = null;
			Vn(() => {
				d(), _()
			}), Yi(() => {
				f(), h == null || h.kill()
			});
			const d = () => {
					e("PAGE:MOUNTED", _), e("PAGE:BEFORE-DESTROY", p)
				},
				f = () => {
					t.removeHook("PAGE:MOUNTED", _), t.removeHook("PAGE:BEFORE-DESTROY", p)
				},
				p = () => {
					h == null || h.disable(), u.value = !1
				},
				_ = () => {
					h ? h == null || h.enable() : h = at.create({
						trigger: i == null ? void 0 : i.rootElement,
						start: "top top",
						end: () => `+=${o.value.height}`,
						onLeave: g,
						onEnterBack: g
					})
				},
				g = () => {
					u.value = !u.value
				};
			return (m, b) => {
				const v = Da;
				return ke(), Ye("button", {
					class: jt([{
						"nav-contact-btn--expanded": fe(u)
					}, "nav-contact-btn mono ttu"]),
					onClick: b[0] || (b[0] = (...y) => fe(s) && fe(s)(...y)),
					"aria-label": fe(a).contactCtaLabel
				}, [Fe("span", AZ, [Ge(v, {
					ref_key: "animatedLabel",
					ref: l,
					content: fe(a).contactCtaLabel,
					"has-visible-animation": !0,
					"visible-delay": .6
				}, null, 8, ["content"])]), DZ], 10, CZ)
			}
		}
	},
	PZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: dP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	RZ = {
		home: "/",
		work: "/work",
		model: "/about",
		lab: "/lab"
	},
	LZ = n => RZ[n] || "#",
	kZ = {
		class: "nav__list-wrapper"
	},
	IZ = {
		class: "nav__list-inner"
	},
	OZ = {
		class: "nav__list nav__list--primary"
	},
	FZ = {
		class: "nav__list nav__list--secondary anim-char"
	},
	fP = {
		__name: "Nav",
		props: {
			isVisible: {
				type: Boolean,
				default: !1
			}
		},
		setup(n) {
			const {
				navData: e
			} = $t(Ji()), {
				isNavOpen: t
			} = $t(Ct()), {
				setIsNavOpen: i
			} = Ct(), r = Be(() => e.value.items.map(({
				label: o,
				type: a
			}) => ({
				label: o,
				url: LZ(a)
			}))), s = () => {
				t.value && i()
			};
			return (o, a) => {
				const l = hP,
					c = jb,
					u = dP;
				return ke(), Ye("nav", {
					class: jt([{
						"nav--open": fe(t)
					}, "nav"])
				}, [Fe("div", kZ, [Fe("div", IZ, [Fe("ul", OZ, [(ke(!0), Ye(gn, null, Dm(fe(r), ({
					label: h,
					url: d
				}, f) => (ke(), It(l, {
					key: f,
					label: h,
					url: d,
					"has-split": !0,
					"split-delay": f * .2,
					"on-click": s,
					"is-visible": n.isVisible
				}, null, 8, ["label", "url", "split-delay", "is-visible"]))), 128))])])]), Ge(c, {
					class: "nav__border"
				}), Fe("div", FZ, [Ge(u, {
					"is-visible": n.isVisible
				}, null, 8, ["is-visible"])])], 2)
			}
		}
	},
	NZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: fP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	UZ = {
		class: "header-contact-btn__label"
	},
	pP = {
		__name: "HeaderContactButton",
		setup(n) {
			const {
				setIsContactModalOpen: e
			} = Ct(), {
				navData: t
			} = $t(Ji());
			return (i, r) => (ke(), Ye("button", {
				class: "header-contact-btn mono ttu",
				onClick: r[0] || (r[0] = (...s) => fe(e) && fe(e)(...s))
			}, [Fe("span", UZ, to(fe(t).contactCtaLabel), 1)]))
		}
	},
	BZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: pP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	zZ = ["aria-label"],
	VZ = GT('<span class="nav-toggle__wrapper"><svg class="nav-toggle__svg nav-toggle__svg--open"><use xlink:href="#burger"></use></svg><svg class="nav-toggle__svg nav-toggle__svg--close"><use xlink:href="#cross"></use></svg></span>', 1),
	HZ = [VZ],
	mP = {
		__name: "NavToggle",
		setup(n) {
			const {
				$lenis: e
			} = Ke(), {
				isNavOpen: t
			} = $t(Ct()), {
				setIsNavOpen: i
			} = Ct(), r = Be(() => t.value ? "Close navigation" : "Open navigation");
			return Vt(() => t.value, s => {
				s ? e == null || e.stop() : e == null || e.start()
			}), (s, o) => (ke(), Ye("button", {
				class: jt([{
					"nav-toggle--open": fe(t)
				}, "nav-toggle"]),
				"aria-label": fe(r),
				onClick: o[0] || (o[0] = (...a) => fe(i) && fe(i)(...a))
			}, HZ, 10, zZ))
		}
	},
	GZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: mP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	gP = {
		__name: "Header",
		setup(n) {
			const {
				isLoaderDone: e,
				isTransitioning: t
			} = $t(Ct()), i = tt(!1), r = Ca();
			return Vt(() => e.value, (s, o) => {
				s && !o && lt.delayedCall(r.name === "index" ? .7 : 0, () => {
					i.value = !0
				})
			}), Vn(() => {
				r.name === "about" && (i.value = !0)
			}), (s, o) => {
				const a = uP,
					l = fP,
					c = pP,
					u = mP;
				return ke(), Ye("header", {
					class: jt([{
						"is-visible": fe(i),
						"header--transitioning": fe(t)
					}, "header"])
				}, [Ge(a, {
					"is-visible": fe(i)
				}, null, 8, ["is-visible"]), Ge(l, {
					"is-visible": fe(i)
				}, null, 8, ["is-visible"]), Ge(c), Ge(u)], 2)
			}
		}
	},
	WZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: gP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	jZ = {
		"aria-hidden": "true",
		class: "btn__svg-wrapper"
	},
	$Z = ["xlink:href"],
	qZ = {
		key: 0,
		class: "btn__label mono ttu"
	},
	_P = {
		__name: "Button",
		props: {
			label: String,
			subtitle: String,
			url: String,
			onClick: Function,
			iconType: {
				type: String,
				default: "open"
			},
			theme: {
				type: String,
				default: "light"
			},
			isInline: Boolean
		},
		setup(n) {
			const e = {
					open: "#plus",
					play: "#play",
					link: "#arrow",
					close: "#cross"
				},
				t = n,
				i = Be(() => t.url ? Zc : "button"),
				r = Be(() => {
					var l;
					return (l = t.url) == null ? void 0 : l.includes("https://")
				}),
				s = Be(() => r.value ? "_blank" : "_self"),
				o = Be(() => t.url ? {
					to: t.url,
					target: s.value
				} : {}),
				a = Be(() => e[t.iconType]);
			return (l, c) => {
				const u = Da;
				return ke(), It(_u(fe(i)), WT({
					class: [
						[`btn--${n.theme}`, {
							"btn--inline": n.isInline
						}], "btn"
					],
					onClick: n.onClick,
					"aria-label": n.label
				}, fe(o)), {
					default: En(() => [Fe("span", jZ, [(ke(), Ye("svg", {
						class: jt([`btn__svg--${n.iconType}`, "btn__svg"])
					}, [Fe("use", {
						"xlink:href": fe(a)
					}, null, 8, $Z)], 2))]), n.label ? (ke(), Ye("span", qZ, [Ge(u, {
						content: n.label
					}, null, 8, ["content"])])) : Fn("", !0)]),
					_: 1
				}, 16, ["class", "onClick", "aria-label"])
			}
		}
	};

function XZ() {
	const {
		callHook: n
	} = Ke(), {
		windowSize: e
	} = $t(Ct()), t = Ii({
		x: 0,
		y: 0
	});
	Vn(() => {
		t.x = e.value.width / 2 - 35, t.y = e.value.height / 2 - 25, window.addEventListener("mousemove", i, !1)
	}), Yi(() => {
		window.removeEventListener("mousemove", i, !1)
	});
	const i = r => {
		t.x = r.clientX, t.y = r.clientY, n("MOUSEMOVE", t)
	};
	return t
}
const YZ = {
		key: 0,
		class: "cursor__wrapper cursor__wrapper--label mono ttu"
	},
	KZ = Fe("svg", {
		class: "cursor__svg"
	}, [Fe("use", {
		"xlink:href": "#plus"
	})], -1),
	ZZ = {
		key: 0,
		class: "cursor__wrapper cursor__wrapper--btn"
	},
	JZ = "Scroll down",
	AS = .1,
	vP = {
		__name: "CursorCustom",
		setup(n) {
			const {
				hook: e,
				hooks: t,
				$preloader: i
			} = Ke(), r = XZ(), {
				windowSize: s
			} = $t(Ct()), o = tt(null);
			tt(!1);
			const a = tt(""),
				l = tt({
					current: 0
				}),
				c = {
					x: 0,
					y: 0
				},
				u = tt(!1);
			let h = lt.matchMedia();
			const d = Be(() => ["scroll", "loader"].includes(a.value)),
				f = Be(() => a.value === "scroll"),
				p = Be(() => a.value === "loader"),
				_ = Be(() => a.value === "open" || a.value === "close");
			l1(() => {
				c.x = r.x, c.y = r.y
			}), Vn(() => {
				g(), m(), b()
			}), Yi(() => {
				v(), u.value = !1, h == null || h.revert()
			});
			const g = () => {
					h.add("(hover: hover)", () => (u.value = !0, () => {
						u.value = !1
					}))
				},
				m = () => {
					c.x = s.value.width / 2 - 35, c.y = s.value.height / 2 - 25, lt.set(o.value, {
						x: c.x,
						y: c.y,
						force3D: !0
					})
				},
				b = () => {
					e("CURSOR:UPDATE", y), lt.ticker.add(x)
				},
				v = () => {
					t.removeHook("CURSOR:UPDATE", y), lt.ticker.remove(x)
				},
				y = (S = null) => {
					a.value = S, p.value && lt.fromTo(l.value, {
						current: 0
					}, {
						current: 100,
						onUpdate: () => l.value.current = l.value.current.toFixed(0),
						onComplete: async () => {
							await Xi(), a.value = null
						},
						duration: 1.5,
						ease: "none"
					})
				},
				x = () => {
					if (!u.value) return !1;
					c.x += (r.x - c.x) * AS, c.y += (r.y - c.y) * AS, lt.set(o.value, {
						x: c.x,
						y: c.y,
						force3D: !0
					})
				};
			return (S, E) => {
				const C = _P;
				return ke(), Ye("div", {
					ref_key: "container",
					ref: o,
					class: jt([fe(a) && `cursor--${fe(a)}`, "cursor"])
				}, [Ge(ma, {
					name: "fade",
					appear: ""
				}, {
					default: En(() => [fe(d) ? (ke(), Ye("div", YZ, [KZ, fe(f) ? (ke(), Ye(gn, {
						key: 0
					}, [Cp(to(JZ))], 64)) : fe(p) ? (ke(), Ye(gn, {
						key: 1
					}, [Cp(to(fe(l).current), 1)], 64)) : Fn("", !0)])) : Fn("", !0)]),
					_: 1
				}), Ge(ma, {
					name: "cursor-btn"
				}, {
					default: En(() => [fe(_) ? (ke(), Ye("div", ZZ, [Ge(C, {
						"icon-type": fe(a)
					}, null, 8, ["icon-type"])])) : Fn("", !0)]),
					_: 1
				})], 2)
			}
		}
	},
	QZ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: vP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	eJ = {},
	tJ = {
		"aria-hidden": "true",
		class: "landscape-orientation ttu mono-h1"
	};

function nJ(n, e) {
	return ke(), Ye("div", tJ, " Please rotate your device ")
}
const bP = aP(eJ, [
		["render", nJ]
	]),
	iJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: bP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	yP = {
		__name: "Curtain",
		setup(n) {
			const {
				callHook: e,
				hook: t,
				hooks: i,
				$webgl: r
			} = Ke(), {
				isCurtainDark: s,
				hasCurtainFadeIn: o
			} = $t(Ct()), {
				setIsTransitioning: a,
				setIsTransitionBlurVisible: l
			} = Ct(), c = Ca(), u = Be(() => c.name === "index"), h = tt(null);
			let d = null;
			Vn(() => {
				f()
			}), Yi(() => {
				p(), d == null || d.kill()
			});
			const f = () => {
					t("TRANSITION:LEAVE", _), t("TRANSITION:ENTER", g)
				},
				p = () => {
					i.removeHook("TRANSITION:LEAVE", _), i.removeHook("TRANSITION:ENTER", g)
				},
				_ = ({
					el: m,
					done: b
				}) => {
					l(), d = lt.timeline(), o.value ? (d.set(h.value, {
						opacity: 0,
						yPercent: 0,
						rotate: 0,
						clipPath: "inset(0% 0% 0% 0% round 0px)"
					}, 0), d.to(h.value, {
						opacity: 1,
						ease: "power4.out",
						duration: .6
					}, .01)) : (d.fromTo(h.value, {
						rotate: 20,
						yPercent: 80
					}, {
						yPercent: 0,
						rotate: 0,
						ease: "power4.out",
						duration: 1
					}, 0), d.fromTo(h.value, {
						clipPath: "inset(20% 20% 20% 20% round 30px"
					}, {
						clipPath: "inset(0% 0% 0% 0% round 0px",
						ease: "power4.out",
						duration: 1
					}, 0)), d.add(() => {
						b()
					}, o.value ? .6 : 1)
				},
				g = ({
					el: m,
					done: b
				}) => {
					d == null || d.kill(), d = lt.timeline({
						onComplete: () => {
							a(), b()
						}
					}), d.add(() => {
						l()
					}, 0), u.value ? d.to(h.value, {
						opacity: 0,
						ease: "power4.inOut",
						duration: 1
					}, 0) : d.to(h.value, {
						opacity: 0,
						ease: "power4.inOut",
						duration: 1.4
					}, 0)
				};
			return (m, b) => (ke(), Ye("div", {
				"aria-hidden": "true",
				ref_key: "container",
				ref: h,
				class: jt([{
					"curtain--dark": fe(s)
				}, "curtain"])
			}, null, 2))
		}
	},
	rJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: yP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	xP = {
		__name: "CursorTrigger",
		props: {
			tagType: {
				type: String,
				default: "div"
			},
			type: {
				type: String,
				default: null
			}
		},
		setup(n) {
			const {
				callHook: e
			} = Ke(), t = n, i = () => {
				e("CURSOR:UPDATE", t.type || null)
			}, r = () => {
				e("CURSOR:UPDATE")
			};
			return (s, o) => (ke(), It(_u(n.tagType), {
				onMouseenter: i,
				onMouseleave: r
			}, {
				default: En(() => [zh(s.$slots, "default")]),
				_: 3
			}, 32))
		}
	},
	sJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: xP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	wP = {
		__name: "ModalOverlay",
		props: {
			isLowerZ: {
				type: Boolean,
				default: !1
			}
		},
		setup(n) {
			const {
				setIsNavOpen: e,
				setIsContactModalOpen: t
			} = Ct(), {
				isNavOpen: i,
				isContactModalOpen: r
			} = $t(Ct()), {
				setServiceModalData: s,
				setLabModalData: o
			} = Ji(), {
				serviceModalData: a,
				labModalData: l
			} = $t(Ji()), {
				callHook: c
			} = Ke(), u = () => {
				r.value && t(), a.value && s(null), l.value && (c("LAB:CLOSE"), o(null)), i.value && e(), c("CURSOR:UPDATE")
			};
			return (h, d) => {
				const f = xP;
				return ke(), It(f, {
					"aria-label": "Close modal",
					"tag-type": "button",
					type: "close",
					class: jt([{
						"modal-overlay--lower-z": n.isLowerZ
					}, "modal-overlay"]),
					onClick: u
				}, null, 8, ["class"])
			}
		}
	},
	oJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: wP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	aJ = Fe("svg", {
		class: "btn-close__svg"
	}, [Fe("use", {
		"xlink:href": "#cross"
	})], -1),
	lJ = {
		class: "btn-close__label"
	},
	s0 = {
		__name: "ButtonClose",
		props: {
			onClick: Function
		},
		setup(n) {
			return (e, t) => {
				const i = Da;
				return ke(), Ye("button", {
					class: "btn-close mono ttu",
					onClick: t[0] || (t[0] = (...r) => n.onClick && n.onClick(...r)),
					"aria-label": "Close"
				}, [aJ, Fe("span", lJ, [Ge(i, {
					content: "Close"
				})])])
			}
		}
	},
	cJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: s0
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	uJ = {
		"data-lenis-prevent": "",
		role: "dialog",
		class: "modal"
	},
	hJ = {
		class: "modal__wrapper"
	},
	o0 = {
		__name: "Modal",
		setup(n) {
			const {
				$lenis: e
			} = Ke();
			let t = null;
			return Vn(() => {
				t = lt.delayedCall(.8, () => {
					e == null || e.stop()
				})
			}), Yi(() => {
				t == null || t.kill(), e == null || e.start()
			}), (i, r) => (ke(), Ye("aside", uJ, [Fe("div", hJ, [zh(i.$slots, "default")]), zh(i.$slots, "addon")]))
		}
	},
	dJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: o0
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	fJ = {
		class: "contact-modal"
	},
	pJ = {
		class: "contact-modal__header"
	},
	mJ = ["innerHTML"],
	gJ = {
		class: "contact-modal__header-cta"
	},
	_J = {
		class: "contact-modal__footer mono ttu"
	},
	vJ = {
		class: "contact-modal__socials"
	},
	bJ = ["href", "aria-label"],
	yJ = ["href", "aria-label"],
	xJ = {
		__name: "Modal",
		setup(n) {
			const {
				asHTML: e
			} = Ls(), {
				footerData: t
			} = $t(Ji()), {
				setIsContactModalOpen: i
			} = Ct(), r = Be(() => {
				const {
					socials: l
				} = t.value;
				return l
			}), s = Be(() => {
				const {
					title: l,
					modalTitle: c,
					link: u,
					ctaLabel: h,
					email: d
				} = t.value.contact;
				return {
					title: e(l),
					modalTitle: e(c),
					cta: {
						url: u.url,
						label: h
					},
					email: d
				}
			}), o = Be(() => `mailto:${s.value.email}`), a = () => {
				i()
			};
			return (l, c) => {
				const u = s0,
					h = _P,
					d = Da,
					f = o0;
				return ke(), It(f, null, {
					default: En(() => [Fe("div", fJ, [Ge(u, {
						"on-click": a
					}), Fe("div", pJ, [Fe("div", {
						class: "h1",
						innerHTML: fe(s).modalTitle || fe(s).title
					}, null, 8, mJ), Fe("div", gJ, [Ge(h, {
						label: fe(s).cta.label,
						url: fe(s).cta.url,
						"is-inline": !0,
						theme: "dark",
						"icon-type": "link"
					}, null, 8, ["label", "url"])])]), Fe("div", _J, [Fe("ul", vJ, [(ke(!0), Ye(gn, null, Dm(fe(r), ({
						label: p,
						url: _
					}, g) => (ke(), Ye("li", {
						key: g,
						class: "footer__socials-item"
					}, [Fe("a", {
						href: _,
						target: "_blank",
						rel: "noopener noreferrer",
						"aria-label": p
					}, [Ge(d, {
						content: p
					}, null, 8, ["content"])], 8, bJ)]))), 128))]), Fe("a", {
						href: fe(o),
						"aria-label": fe(s).email
					}, [Ge(d, {
						content: fe(s).email
					}, null, 8, ["content"])], 8, yJ)])])]),
					_: 1
				})
			}
		}
	},
	wJ = ["width", "height", "muted", "controls", "autoplay", "loop"],
	EP = {
		__name: "Video",
		props: {
			data: {
				type: Object,
				default: () => {}
			},
			dataMobile: {
				type: Object,
				default: () => {}
			},
			lazyType: {
				type: String,
				default: "scroll"
			},
			isMuted: {
				type: Boolean,
				default: !0
			},
			isPlaying: {
				type: Boolean,
				default: !0
			},
			isAutoplaying: {
				type: Boolean,
				default: !0
			},
			isLooping: {
				type: Boolean,
				default: !0
			},
			hasControls: {
				type: Boolean,
				default: !1
			},
			isFit: {
				type: Boolean,
				default: !1
			},
			volume: {
				type: Number,
				default: 1
			},
			speed: {
				type: Number,
				default: 1
			},
			onEnded: {
				type: Function,
				default: () => {}
			},
			onLoaded: {
				type: Function,
				default: () => {}
			},
			lazyThreshold: {
				type: String,
				default: "-200% 100%"
			}
		},
		setup(n) {
			const {
				windowSize: e
			} = $t(Ct()), t = n, i = tt(null), r = tt(null), s = tt(!1);
			let o = null,
				a = null;
			const l = Be(() => e.value.width < 1024),
				c = Be(() => {
					var m, b, v;
					return l.value && ((m = t.dataMobile) != null && m.src) ? (b = t.dataMobile) == null ? void 0 : b.src : ((v = t.data) == null ? void 0 : v.src) || ""
				}),
				u = Be(() => {
					var m, b;
					return l.value ? (m = t.dataMobile) == null ? void 0 : m.width : ((b = t.data) == null ? void 0 : b.width) || ""
				}),
				h = Be(() => {
					var m, b;
					return l.value ? (m = t.dataMobile) == null ? void 0 : m.height : ((b = t.data) == null ? void 0 : b.height) || ""
				}),
				d = Be(() => t.isFit ? null : {
					paddingTop: t.data.height / t.data.width * 100 + "%"
				});
			Vn(() => {
				f()
			}), Yi(() => {
				o == null || o.kill(), a == null || a.kill()
			});
			const f = () => {
					o = at.create({
						trigger: i.value,
						start: t.lazyThreshold,
						once: !0,
						onEnter: p
					}), t.isLooping && t.isAutoplaying && (a = at.create({
						trigger: i.value,
						start: "top bottom",
						end: "bottom top",
						onEnter: _,
						onEnterBack: _,
						onLeave: g,
						onLeaveBack: g
					}))
				},
				p = () => {
					r.value.setAttribute("src", c.value), r.value.load(), new Promise(m => {
						r.value.oncanplay = () => {
							!r.value || s.value || (r.value.playbackRate = t.speed, r.value.volume = t.volume, t.onLoaded && t.onLoaded(), s.value = !0, m())
						}
					})
				},
				_ = () => {
					s.value && r.value.play()
				},
				g = () => {
					s.value && r.value.pause()
				};
			return (m, b) => {
				const v = G3;
				return ke(), Ye("div", {
					ref_key: "container",
					ref: i,
					class: jt([{
						"base-video--fit": n.isFit,
						"base-video--loaded": fe(s)
					}, "base-video"]),
					style: md(fe(d))
				}, [Ge(v, null, {
					default: En(() => [Fe("video", {
						ref_key: "video",
						ref: r,
						width: fe(u),
						height: fe(h),
						playsinline: "",
						muted: n.isMuted,
						controls: n.hasControls,
						autoplay: n.isAutoplaying,
						loop: n.isLooping,
						onEnded: b[0] || (b[0] = (...y) => n.onEnded && n.onEnded(...y))
					}, null, 40, wJ)]),
					_: 1
				})], 6)
			}
		}
	};
async function EJ(n, e) {
	return await SJ(e).catch(i => (console.error("Failed to get image meta for " + e, i + ""), {
		width: 0,
		height: 0,
		ratio: 0
	}))
}
async function SJ(n) {
	if (typeof Image > "u") throw new TypeError("Image not supported");
	return new Promise((e, t) => {
		const i = new Image;
		i.onload = () => {
			const r = {
				width: i.width,
				height: i.height,
				ratio: i.width / i.height
			};
			e(r)
		}, i.onerror = r => t(r), i.src = n
	})
}

function DS(n) {
	return e => e ? n[e] || e : n.missingValue
}

function TJ({
	formatter: n,
	keyMap: e,
	joinWith: t = "/",
	valueMap: i
} = {}) {
	n || (n = (s, o) => `${s}=${o}`), e && typeof e != "function" && (e = DS(e));
	const r = i || {};
	return Object.keys(r).forEach(s => {
		typeof r[s] != "function" && (r[s] = DS(r[s]))
	}), (s = {}) => Object.entries(s).filter(([a, l]) => typeof l < "u").map(([a, l]) => {
		const c = r[a];
		return typeof c == "function" && (l = c(s[a])), a = typeof e == "function" ? e(a) : a, n(a, l)
	}).join(t)
}

function Ss(n = "") {
	if (typeof n == "number") return n;
	if (typeof n == "string" && n.replace("px", "").match(/^\d+$/g)) return Number.parseInt(n, 10)
}

function MJ(n = "") {
	if (n === void 0 || !n.length) return [];
	const e = new Set;
	for (const t of n.split(" ")) {
		const i = Number.parseInt(t.replace("x", ""));
		i && e.add(i)
	}
	return Array.from(e)
}

function CJ(n) {
	if (n.length === 0) throw new Error("`densities` must not be empty, configure to `1` to render regular size only (DPR 1.0)")
}

function AJ(n) {
	const e = {};
	if (typeof n == "string")
		for (const t of n.split(/[\s,]+/).filter(i => i)) {
			const i = t.split(":");
			i.length !== 2 ? e["1px"] = i[0].trim() : e[i[0].trim()] = i[1].trim()
		} else Object.assign(e, n);
	return e
}

function DJ(n) {
	const e = {
			options: n
		},
		t = (r, s = {}) => SP(e, r, s),
		i = (r, s = {}, o = {}) => t(r, {
			...o,
			modifiers: Rm(s, o.modifiers || {})
		}).url;
	for (const r in n.presets) i[r] = (s, o, a) => i(s, o, {
		...n.presets[r],
		...a
	});
	return i.options = n, i.getImage = t, i.getMeta = (r, s) => PJ(e, r, s), i.getSizes = (r, s) => kJ(e, r, s), e.$img = i, i
}
async function PJ(n, e, t) {
	const i = SP(n, e, {
		...t
	});
	return typeof i.getMeta == "function" ? await i.getMeta() : await EJ(n, i.url)
}

function SP(n, e, t) {
	var c, u;
	if (e && typeof e != "string") throw new TypeError(`input must be a string (received ${typeof e}: ${JSON.stringify(e)})`);
	if (!e || e.startsWith("data:")) return {
		url: e
	};
	const {
		provider: i,
		defaults: r
	} = RJ(n, t.provider || n.options.provider), s = LJ(n, t.preset);
	if (e = ao(e) ? e : x_(e), !i.supportsAlias)
		for (const h in n.options.alias) e.startsWith(h) && (e = Ta(n.options.alias[h], e.substr(h.length)));
	if (i.validateDomains && ao(e)) {
		const h = bu(e).host;
		if (!n.options.domains.find(d => d === h)) return {
			url: e
		}
	}
	const o = Rm(t, s, r);
	o.modifiers = {
		...o.modifiers
	};
	const a = o.modifiers.format;
	(c = o.modifiers) != null && c.width && (o.modifiers.width = Ss(o.modifiers.width)), (u = o.modifiers) != null && u.height && (o.modifiers.height = Ss(o.modifiers.height));
	const l = i.getImage(e, o, n);
	return l.format = l.format || a || "", l
}

function RJ(n, e) {
	const t = n.options.providers[e];
	if (!t) throw new Error("Unknown provider: " + e);
	return t
}

function LJ(n, e) {
	if (!e) return {};
	if (!n.options.presets[e]) throw new Error("Unknown preset: " + e);
	return n.options.presets[e]
}

function kJ(n, e, t) {
	var p, _, g, m, b;
	const i = Ss((p = t.modifiers) == null ? void 0 : p.width),
		r = Ss((_ = t.modifiers) == null ? void 0 : _.height),
		s = AJ(t.sizes),
		o = (g = t.densities) != null && g.trim() ? MJ(t.densities.trim()) : n.options.densities;
	CJ(o);
	const a = i && r ? r / i : 0,
		l = [],
		c = [];
	if (Object.keys(s).length >= 1) {
		for (const v in s) {
			const y = PS(v, String(s[v]), r, a, n);
			if (y !== void 0) {
				l.push({
					size: y.size,
					screenMaxWidth: y.screenMaxWidth,
					media: `(max-width: ${y.screenMaxWidth}px)`
				});
				for (const x of o) c.push({
					width: y._cWidth * x,
					src: RS(n, e, t, y, x)
				})
			}
		}
		IJ(l)
	} else
		for (const v of o) {
			const y = Object.keys(s)[0];
			let x = PS(y, String(s[y]), r, a, n);
			x === void 0 && (x = {
				size: "",
				screenMaxWidth: 0,
				_cWidth: (m = t.modifiers) == null ? void 0 : m.width,
				_cHeight: (b = t.modifiers) == null ? void 0 : b.height
			}), c.push({
				width: v,
				src: RS(n, e, t, x, v)
			})
		}
	OJ(c);
	const u = c[c.length - 1],
		h = l.length ? l.map(v => `${v.media?v.media+" ":""}${v.size}`).join(", ") : void 0,
		d = h ? "w" : "x",
		f = c.map(v => `${v.src} ${v.width}${d}`).join(", ");
	return {
		sizes: h,
		srcset: f,
		src: u == null ? void 0 : u.src
	}
}

function PS(n, e, t, i, r) {
	const s = r.options.screens && r.options.screens[n] || Number.parseInt(n),
		o = e.endsWith("vw");
	if (!o && /^\d+$/.test(e) && (e = e + "px"), !o && !e.endsWith("px")) return;
	let a = Number.parseInt(e);
	if (!s || !a) return;
	o && (a = Math.round(a / 100 * s));
	const l = i ? Math.round(a * i) : t;
	return {
		size: e,
		screenMaxWidth: s,
		_cWidth: a,
		_cHeight: l
	}
}

function RS(n, e, t, i, r) {
	return n.$img(e, {
		...t.modifiers,
		width: i._cWidth ? i._cWidth * r : void 0,
		height: i._cHeight ? i._cHeight * r : void 0
	}, t)
}

function IJ(n) {
	var t;
	n.sort((i, r) => i.screenMaxWidth - r.screenMaxWidth);
	let e = null;
	for (let i = n.length - 1; i >= 0; i--) {
		const r = n[i];
		r.media === e && n.splice(i, 1), e = r.media
	}
	for (let i = 0; i < n.length; i++) n[i].media = ((t = n[i + 1]) == null ? void 0 : t.media) || ""
}

function OJ(n) {
	n.sort((t, i) => t.width - i.width);
	let e = null;
	for (let t = n.length - 1; t >= 0; t--) {
		const i = n[t];
		i.width === e && n.splice(t, 1), e = i.width
	}
}
const FJ = TJ({
		keyMap: {
			width: "w",
			height: "h",
			format: "fm",
			quality: "q",
			backgroundColor: "bg",
			rotate: "rot",
			mask: "mask",
			auto: "auto",
			crop: "crop",
			brightness: "bri",
			contrast: "con",
			exposure: "exp",
			gamma: "gam",
			highlight: "high",
			hueShift: "hue",
			invert: "invert",
			saturation: "sat",
			shadow: "shad",
			sharpen: "sharp",
			unsharpMask: "usm",
			unsharpMaskRadius: "usmrad",
			vibrance: "vib",
			blend: "blend",
			blendAlign: "blend-align",
			blendAlpha: "blend-alpha",
			blendColor: "blend-color",
			blendCrop: "blend-crop",
			blendFit: "blend-fit",
			blendHeight: "blend-h",
			blendMode: "blend-mode",
			blendPadding: "blend-pad",
			blendSize: "blend-size",
			blendWidth: "blend-w",
			blendXPosition: "blend-x",
			blendYPosition: "blend-y",
			padding: "pad",
			borderBottom: "border-bottom",
			borderLeft: "border-left",
			innerBorderRadius: "border-radius-inner",
			outerBorderRadius: "border-radius",
			borderRight: "border-right",
			borderTop: "border-top",
			borderSizeColor: "border",
			paddingBottom: "pad-bottom",
			paddingLeft: "pad-left",
			paddingRight: "pad-right",
			paddingTop: "pad-top",
			paletteColorCount: "colors",
			colorPaletteExtraction: "palette",
			cssPrefix: "prefix",
			expirationTimestamp: "expires",
			faceIndex: "faceindex",
			facePadding: "facepad",
			jsonFaceData: "faces",
			fillMode: "fill",
			fillColor: "fill-color",
			gridColors: "grid-colors",
			gridSize: "grid-size",
			transparency: "transparency",
			focalPointDebug: "fp-debug",
			focalPointXPosition: "fp-x",
			focalPointYPosition: "fp-y",
			focalPointZoom: "fp-z",
			clientHints: "ch",
			chromaSubsampling: "chromasub",
			colorQuantization: "colorquant",
			colorSpace: "cs",
			download: "dl",
			dotsPerInch: "dpi",
			losslessCompression: "lossless",
			maskBackgroundColor: "mask-bg",
			maskCornerRadius: "corner-radius",
			noiseReductionSharp: "nrs",
			noiseReductionBound: "nr",
			pdfPageNumber: "page",
			pdfAnnotation: "pdf-annotation",
			pixelDensity: "dpr",
			orientation: "orient",
			flipAxis: "flip",
			aspectRatio: "ar",
			maximumHeight: "max-h",
			maximumWidth: "max-w",
			minimumHeight: "min-h",
			minimumWidth: "min-w",
			sourceRectangleRegion: "rect",
			gaussianBlur: "blur",
			duotoneAlpha: "duotone-alpha",
			duotone: "duotone",
			halftone: "htn",
			monochrome: "monochrome",
			pixellate: "px",
			sepiaTone: "sepia",
			textAlign: "txt-align",
			textClippingMode: "txt-clip",
			textColor: "txt-color",
			textFitMode: "txt-fit",
			textFont: "txt-font",
			textLigatures: "txt-lig",
			textOutlineColor: "txt-line-color",
			textOutline: "txt-line",
			textPadding: "txt-pad",
			textShadow: "txt-shad",
			textFontSize: "txt-size",
			textWidth: "txt-width",
			textString: "txt",
			trimColor: "trim-color",
			trimMeanDifference: "trim-md",
			trimStandardDeviation: "trim-sd",
			trimTolerance: "trim-tol",
			trimImage: "trim",
			textLeading: "txt-lead",
			textTracking: "txt-track",
			typesettingEndpoint: "~text",
			watermarkAlignment: "mark-align",
			watermarkAlpha: "mark-alpha",
			watermarkBaseURL: "mark-base",
			watermarkFitMode: "mark-fit",
			watermarkHeight: "mark-h",
			watermarkPadding: "mark-pad",
			watermarkRotation: "mark-rot",
			watermarkScale: "mark-sclae",
			watermarkTile: "mark-tile",
			watermarkWidth: "mark-w",
			watermarkXPosition: "mark-x",
			watermarkYPosition: "mark-y",
			watermarkImageURL: "mark"
		},
		valueMap: {
			fit: {
				fill: "scale",
				inside: "max",
				outside: "min",
				cover: "crop",
				contain: "fill",
				clamp: "clamp",
				clip: "clip",
				facearea: "facearea",
				fillMax: "fillmax"
			},
			format: {
				gif: "gif",
				jp2: "jp2",
				jpg: "jpg",
				json: "json",
				jxr: "jxr",
				pjpg: "pjpg",
				mp4: "mp4",
				png: "png",
				png8: "png8",
				png32: "png32",
				webm: "webm",
				webp: "webp",
				blurhash: "blurhash"
			}
		},
		joinWith: "&",
		formatter: (n, e) => `${n}=${e}`
	}),
	NJ = "https://images.prismic.io",
	UJ = (n, {
		modifiers: e = {},
		baseURL: t = NJ
	} = {}) => {
		const i = FJ(e),
			r = bu(n);
		return {
			url: Ta(t, r.pathname + "?" + JT(Object.assign(Pp(r.search), Pp(i))))
		}
	},
	BJ = Object.freeze(Object.defineProperty({
		__proto__: null,
		getImage: UJ
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	TP = {
		screens: {
			xs: 375,
			sm: 768,
			md: 1024,
			lg: 2048,
			xl: 2880,
			xxl: 3840,
			"2xl": 1536
		},
		presets: {},
		provider: "prismic",
		domains: [],
		alias: {},
		densities: [1, 2],
		format: ["webp"]
	};
TP.providers = {
	prismic: {
		provider: BJ,
		defaults: {}
	}
};
const MP = () => {
	const n = Ma(),
		e = Ke();
	return e.$img || e._img || (e._img = DJ({
		...TP,
		nuxt: {
			baseURL: n.app.baseURL
		}
	}))
};

function zJ(n) {
	var e;
	(e = performance == null ? void 0 : performance.mark) == null || e.call(performance, "mark_feature_usage", {
		detail: {
			feature: n
		}
	})
}
const VJ = {
		src: {
			type: String,
			default: void 0
		},
		format: {
			type: String,
			default: void 0
		},
		quality: {
			type: [Number, String],
			default: void 0
		},
		background: {
			type: String,
			default: void 0
		},
		fit: {
			type: String,
			default: void 0
		},
		modifiers: {
			type: Object,
			default: void 0
		},
		preset: {
			type: String,
			default: void 0
		},
		provider: {
			type: String,
			default: void 0
		},
		sizes: {
			type: [Object, String],
			default: void 0
		},
		densities: {
			type: String,
			default: void 0
		},
		preload: {
			type: Boolean,
			default: void 0
		},
		width: {
			type: [String, Number],
			default: void 0
		},
		height: {
			type: [String, Number],
			default: void 0
		},
		alt: {
			type: String,
			default: void 0
		},
		referrerpolicy: {
			type: String,
			default: void 0
		},
		usemap: {
			type: String,
			default: void 0
		},
		longdesc: {
			type: String,
			default: void 0
		},
		ismap: {
			type: Boolean,
			default: void 0
		},
		loading: {
			type: String,
			default: void 0,
			validator: n => ["lazy", "eager"].includes(n)
		},
		crossorigin: {
			type: [Boolean, String],
			default: void 0,
			validator: n => ["anonymous", "use-credentials", "", !0, !1].includes(n)
		},
		decoding: {
			type: String,
			default: void 0,
			validator: n => ["async", "auto", "sync"].includes(n)
		},
		nonce: {
			type: [String],
			default: void 0
		}
	},
	HJ = n => {
		const e = Be(() => ({
				provider: n.provider,
				preset: n.preset
			})),
			t = Be(() => ({
				width: Ss(n.width),
				height: Ss(n.height),
				alt: n.alt,
				referrerpolicy: n.referrerpolicy,
				usemap: n.usemap,
				longdesc: n.longdesc,
				ismap: n.ismap,
				crossorigin: n.crossorigin === !0 ? "anonymous" : n.crossorigin || void 0,
				loading: n.loading,
				decoding: n.decoding,
				nonce: n.nonce
			})),
			i = MP(),
			r = Be(() => ({
				...n.modifiers,
				width: Ss(n.width),
				height: Ss(n.height),
				format: n.format,
				quality: n.quality || i.options.quality,
				background: n.background,
				fit: n.fit
			}));
		return {
			options: e,
			attrs: t,
			modifiers: r
		}
	},
	GJ = {
		...VJ,
		placeholder: {
			type: [Boolean, String, Number, Array],
			default: void 0
		},
		placeholderClass: {
			type: String,
			default: void 0
		}
	},
	WJ = Qi({
		name: "NuxtImg",
		props: GJ,
		emits: ["load", "error"],
		setup: (n, e) => {
			const t = MP(),
				i = HJ(n),
				r = tt(!1),
				s = tt(),
				o = Be(() => t.getSizes(n.src, {
					...i.options.value,
					sizes: n.sizes,
					densities: n.densities,
					modifiers: {
						...i.modifiers.value,
						width: Ss(n.width),
						height: Ss(n.height)
					}
				})),
				a = Be(() => {
					const f = {
						...i.attrs.value,
						"data-nuxt-img": ""
					};
					return (!n.placeholder || r.value) && (f.sizes = o.value.sizes, f.srcset = o.value.srcset), f
				}),
				l = Be(() => {
					let f = n.placeholder;
					if (f === "" && (f = !0), !f || r.value) return !1;
					if (typeof f == "string") return f;
					const p = Array.isArray(f) ? f : typeof f == "number" ? [f, f] : [10, 10];
					return t(n.src, {
						...i.modifiers.value,
						width: p[0],
						height: p[1],
						quality: p[2] || 50,
						blur: p[3] || 3
					}, i.options.value)
				}),
				c = Be(() => n.sizes ? o.value.src : t(n.src, i.modifiers.value, i.options.value)),
				u = Be(() => l.value ? l.value : c.value);
			if (n.preload) {
				const f = Object.values(o.value).every(p => p);
				Im({
					link: [{
						rel: "preload",
						as: "image",
						nonce: n.nonce,
						...f ? {
							href: o.value.src,
							imagesizes: o.value.sizes,
							imagesrcset: o.value.srcset
						} : {
							href: u.value
						}
					}]
				})
			}
			const d = Ke().isHydrating;
			return Vn(() => {
				if (l.value) {
					const f = new Image;
					f.src = c.value, n.sizes && (f.sizes = o.value.sizes || "", f.srcset = o.value.srcset), f.onload = p => {
						r.value = !0, e.emit("load", p)
					}, zJ("nuxt-image");
					return
				}
				s.value && (s.value.complete && d && (s.value.getAttribute("data-error") ? e.emit("error", new Event("error")) : e.emit("load", new Event("load"))), s.value.onload = f => {
					e.emit("load", f)
				}, s.value.onerror = f => {
					e.emit("error", f)
				})
			}), () => on("img", {
				ref: s,
				src: u.value,
				...a.value,
				...e.attrs,
				class: n.placeholder && !r.value ? [n.placeholderClass] : void 0
			})
		}
	}),
	jJ = ["src", "alt", "width", "height"],
	$J = ["srcset"],
	qJ = ["srcset"],
	XJ = ["loading", "src", "width", "height", "alt", "sizes"],
	CP = {
		__name: "Image",
		props: {
			data: {
				type: Object,
				default: () => {}
			},
			alt: {
				type: String,
				default: "Ashfall Studio"
			},
			lazyType: {
				type: String,
				default: "lazy"
			},
			imageSizes: {
				type: String,
				default: null
			},
			isFit: {
				type: Boolean,
				default: !1
			},
			onLoaded: {
				type: Function,
				default: () => {}
			},
			lazyThreshold: {
				type: String,
				default: "-200% 100%"
			},
			hasProvider: {
				type: Boolean,
				default: !0
			}
		},
		setup(n) {
			const e = n,
				t = tt(null),
				i = tt(!1),
				r = tt(!1);
			let s = null;
			const o = Be(() => e.imageSizes || "xs:100vw sm:100vw md:100vw lg:100vw xl:100vw xxl:100vw xxxl:100vw"),
				a = Be(() => {
					const {
						width: h,
						height: d
					} = e.data;
					return `data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20${h}%20${d}%22%3E%3Crect%20width=%22${h}%22%20height=%22${d}%22%20style=%22fill:%23000000%22%3E%3C/rect%3E%3C/svg%3E`
				});
			Vn(() => {
				l()
			}), Yi(() => {
				s == null || s.kill()
			});
			const l = () => {
					e.lazyType !== "lazy" ? c() : s = at.create({
						trigger: t.value,
						start: e.lazyThreshold,
						once: !0,
						onEnter: c
					})
				},
				c = () => {
					i.value = !0
				},
				u = () => {
					r.value = !0, e.onLoaded && e.onLoaded()
				};
			return (h, d) => {
				const f = WJ;
				return ke(), Ye("picture", {
					ref_key: "container",
					ref: t,
					class: jt([{
						"base-image--fit": n.isFit
					}, "base-image"])
				}, [fe(i) ? fe(i) && !n.hasProvider ? (ke(), Ye(gn, {
					key: 1
				}, [n.data.webpSrcSet ? (ke(), Ye("source", {
					key: 0,
					type: "image/webp",
					srcset: n.data.webpSrcSet
				}, null, 8, $J)) : Fn("", !0), n.data.srcSet ? (ke(), Ye("source", {
					key: 1,
					type: "image/jpg",
					srcset: n.data.srcSet
				}, null, 8, qJ)) : Fn("", !0), Fe("img", {
					class: jt([{
						"base-image__img--loaded": fe(r)
					}, "base-image__img"]),
					loading: n.lazyType === "scroll" ? "lazy" : "",
					decoding: "async",
					src: n.data.src,
					width: n.data.width,
					height: n.data.height,
					alt: n.alt,
					sizes: n.hasProvider && fe(o),
					onLoad: u
				}, null, 42, XJ)], 64)) : fe(i) && n.hasProvider ? (ke(), It(f, {
					key: 2,
					class: jt([{
						"base-image__img--loaded": fe(r)
					}, "base-image__img"]),
					src: n.data.src,
					width: n.data.width,
					height: n.data.height,
					alt: n.alt,
					sizes: fe(o),
					format: "webp",
					onLoad: u
				}, null, 8, ["class", "src", "width", "height", "alt", "sizes"])) : Fn("", !0) : (ke(), Ye("img", {
					key: 0,
					class: "base-image__placeholder",
					src: fe(a),
					alt: n.alt,
					width: n.data.width,
					height: n.data.height
				}, null, 8, jJ))], 2)
			}
		}
	},
	AP = {
		__name: "Media",
		props: {
			data: Object,
			alt: String,
			lazyType: {
				type: String,
				default: "lazy"
			},
			imageSizes: {
				type: String,
				default: null
			},
			isFit: {
				type: Boolean,
				default: !1
			},
			isAutoplaying: {
				type: Boolean,
				default: !0
			},
			isMuted: {
				type: Boolean,
				default: !0
			},
			isPlaying: {
				type: Boolean,
				default: !0
			},
			isLooping: {
				type: Boolean,
				default: !0
			},
			onLoaded: Function
		},
		setup(n) {
			const e = n,
				t = Be(() => e.data.src.includes(".mp4")),
				i = Be(() => t.value ? EP : CP),
				r = Be(() => t.value ? {
					data: {
						src: e.data.src,
						width: e.data.width,
						height: e.data.height
					},
					dataMobile: e.data.srcMobile ? {
						...e.data.srcMobile
					} : null
				} : {
					data: {
						src: e.data.src,
						width: e.data.width,
						height: e.data.height
					},
					alt: e.data.alt
				}),
				s = Be(() => t.value ? {
					isPlaying: e.isPlaying,
					isFit: e.isFit,
					isAutoplaying: e.isAutoplaying,
					isLooping: e.isLooping,
					isMuted: e.isMuted,
					onLoaded: e.onLoaded
				} : {
					isFit: e.isFit,
					lazyType: e.lazyType,
					onLoaded: e.onLoaded,
					imageSizes: e.imageSizes
				});
			return (o, a) => (ke(), It(_u(fe(i)), $P(HT({
				...fe(r),
				...fe(s)
			})), null, 16))
		}
	},
	YJ = {
		class: "accordion__header"
	},
	KJ = {
		class: "labor-small"
	},
	ZJ = ["aria-label"],
	JJ = {
		key: 0,
		class: "accordion__svg accordion__svg--close"
	},
	QJ = Fe("use", {
		"xlink:href": "#cross"
	}, null, -1),
	eQ = [QJ],
	tQ = {
		key: 1,
		class: "accordion__svg accordion__svg--open"
	},
	nQ = Fe("use", {
		"xlink:href": "#plus"
	}, null, -1),
	iQ = [nQ],
	DP = {
		__name: "Accordion",
		props: {
			title: String
		},
		setup(n) {
			const {
				isFontLoaded: e
			} = $t(Ct()), {
				hook: t,
				hooks: i,
				callHook: r
			} = Ke();
			let s = 0;
			const o = tt(!1);
			let a = lt.timeline();
			const l = tt(null),
				c = tt(null);
			Vn(() => {
				u()
			}), Yi(() => {
				h(), o.value = !1
			});
			const u = () => {
					t("WINDOW:RESIZE", d), e.value ? f() : t("FONTS:LOADED", f)
				},
				h = () => {
					i.removeHook("WINDOW:RESIZE", d)
				},
				d = () => {
					s = c.value.getBoundingClientRect().height
				},
				f = async () => {
					await Xi(), d()
				}, p = () => {
					a.clear().addLabel("start").to(l.value, {
						height: o.value ? 1 : s,
						duration: .6,
						ease: "power2.out"
					}, "start"), o.value = !o.value
				};
			return (_, g) => (ke(), Ye("div", {
				class: jt([{
					"accordion--open": fe(o)
				}, "accordion"])
			}, [Fe("div", YJ, [Fe("span", KJ, to(n.title), 1), Fe("button", {
				class: "accordion__button",
				"aria-label": fe(o) ? "Close accordion" : "Open accordion",
				onClick: p
			}, [fe(o) ? (ke(), Ye("svg", JJ, eQ)) : (ke(), Ye("svg", tQ, iQ))], 8, ZJ)]), Fe("div", {
				ref_key: "content",
				ref: l,
				class: "accordion__content"
			}, [Fe("div", {
				ref_key: "wrapper",
				ref: c,
				class: "accordion__wrapper"
			}, [zh(_.$slots, "default")], 512)], 512)], 2))
		}
	},
	rQ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: DP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	sQ = {
		class: "service-modal-addon"
	},
	oQ = {
		class: "service-modal-addon__list"
	},
	aQ = {
		class: "service-modal-addon__item-fig"
	},
	lQ = {
		__name: "ModalAddOn",
		props: {
			items: Array
		},
		setup(n) {
			const {
				setServiceModalData: e
			} = Ji(), t = () => {
				e(null)
			};
			return (i, r) => {
				const s = AP,
					o = Da,
					a = Zc;
				return ke(), Ye("div", sQ, [Fe("ul", oQ, [(ke(!0), Ye(gn, null, Dm(n.items, ({
					title: l,
					url: c,
					asset: u = null
				}, h) => (ke(), Ye("li", {
					key: h,
					class: "service-modal-addon__item"
				}, [Ge(a, {
					to: c,
					class: "service-modal-addon__item-link mono ttu",
					onClick: t,
					"aria-label": l
				}, {
					default: En(() => [Fe("figure", aQ, [u ? (ke(), It(s, {
						key: 0,
						data: {
							...u
						},
						"is-fit": !0,
						"image-sizes": "xs:20vw sm:20vw md:20vw lg:20vw xl:20vw xxl:20vw xxxl:20vw",
						"lazy-type": "force"
					}, null, 8, ["data"])) : Fn("", !0)]), Ge(o, {
						content: l
					}, null, 8, ["content"])]),
					_: 2
				}, 1032, ["to", "aria-label"])]))), 128))])])
			}
		}
	},
	cQ = {
		class: "service-modal labor-small"
	},
	uQ = {
		class: "service-modal__header"
	},
	hQ = ["innerHTML"],
	dQ = {
		key: 0,
		class: "service-modal__wrapper"
	},
	fQ = {
		key: 0
	},
	pQ = ["innerHTML"],
	mQ = {
		class: "service-modal__wrapper service-modal__accordions"
	},
	gQ = {
		key: 0
	},
	_Q = {
		class: "service-modal__col service-modal__accordions-wrapper"
	},
	vQ = {
		key: 0,
		class: "service-modal__fig"
	},
	bQ = ["innerHTML"],
	yQ = {
		key: 1,
		class: "service-modal__row labor-small"
	},
	xQ = {
		__name: "Modal",
		setup(n) {
			Ls();
			const {
				setServiceModalData: e
			} = Ji(), {
				serviceModalData: t
			} = $t(Ji()), i = Be(() => {
				const {
					title: s,
					approachTitle: o,
					approachCopy: a,
					accordions: l,
					servicesTitle: c,
					featuredWork: u = []
				} = t.value;
				return {
					title: s,
					approachTitle: o,
					approachCopy: a,
					servicesTitle: c,
					accordions: l,
					items: (u == null ? void 0 : u.length) && (u == null ? void 0 : u.map(({
						title: h,
						slug: d,
						featuredAsset: f
					}) => ({
						title: h,
						url: `/work/${d}`,
						asset: f || null
					}))) || null
				}
			}), r = () => {
				e(null)
			};
			return (s, o) => {
				const a = s0,
					l = AP,
					c = DP,
					u = lQ,
					h = o0;
				return ke(), It(h, {
					class: "modal--service"
				}, {
					addon: En(() => [fe(i).items ? (ke(), It(u, {
						key: 0,
						items: fe(i).items
					}, null, 8, ["items"])) : Fn("", !0)]),
					default: En(() => [Fe("div", cQ, [Ge(a, {
						"on-click": r
					}), Fe("div", uQ, [Fe("div", {
						class: "h1",
						innerHTML: fe(i).title
					}, null, 8, hQ)]), fe(i).approachTitle && fe(i).approachCopy ? (ke(), Ye("div", dQ, [fe(i).approachTitle ? (ke(), Ye("div", fQ, to(fe(i).approachTitle), 1)) : Fn("", !0), Fe("div", {
						class: "service-modal__col service-modal__copy",
						innerHTML: fe(i).approachCopy
					}, null, 8, pQ)])) : Fn("", !0), Fe("div", mQ, [fe(i).servicesTitle ? (ke(), Ye("div", gQ, to(fe(i).servicesTitle), 1)) : Fn("", !0), Fe("div", _Q, [(ke(!0), Ye(gn, null, Dm(fe(i).accordions, ({
						title: d,
						copy: f = null,
						asset: p
					}, _) => (ke(), Ye("div", {
						key: _,
						class: "service-modal__accordion"
					}, [d && f ? (ke(), It(c, {
						key: 0,
						title: d
					}, {
						default: En(() => [p ? (ke(), Ye("figure", vQ, [Ge(l, {
							data: {
								...p
							},
							"is-fit": !0,
							"image-sizes": "xs:80vw sm:80vw md:33vw lg:33vw xl:33vw xxl:33vw xxxl:33vw"
						}, null, 8, ["data"])])) : Fn("", !0), Fe("div", {
							class: "service-modal__copy",
							innerHTML: f
						}, null, 8, bQ)]),
						_: 2
					}, 1032, ["title"])) : (ke(), Ye("div", yQ, to(d), 1))]))), 128))])])])]),
					_: 1
				})
			}
		}
	},
	PP = {
		__name: "InViewTracker",
		props: {
			tagType: {
				type: String,
				default: "div"
			},
			threshold: {
				type: String,
				default: ""
			},
			promise: {
				type: Promise,
				required: !1,
				default: null
			},
			callback: Function
		},
		setup(n) {
			const {
				triggerThreshold: e
			} = $t(Ct()), t = n, {
				hook: i,
				hooks: r
			} = Ke(), s = tt(null), o = tt(!1);
			let a = null;
			Vn(() => {
				l(), h()
			}), Yi(() => {
				c(), a == null || a.kill()
			});
			const l = () => {
					i("WINDOW:RESIZE", u)
				},
				c = () => {
					r.removeHook("WINDOW:RESIZE", u)
				},
				u = () => {
					a == null || a.refresh()
				},
				h = () => {
					a = at.create({
						trigger: s.value,
						start: t.threshold || e.value,
						once: !0,
						onEnter: d
					})
				},
				d = async () => {
					await t.promise, o.value = !0, t.callback && t.callback()
				};
			return (f, p) => (ke(), It(_u(n.tagType), {
				ref_key: "container",
				ref: s,
				class: jt({
					"is-visible": fe(o)
				})
			}, {
				default: En(() => [zh(f.$slots, "default")]),
				_: 3
			}, 8, ["class"]))
		}
	},
	wQ = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: PP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	EQ = {
		class: "lab-modal__wrapper labor-small"
	},
	SQ = {
		class: "lab-modal__title"
	},
	TQ = ["innerHTML"],
	MQ = {
		__name: "Modal",
		setup(n) {
			Ls();
			const {
				setLabModalData: e
			} = Ji(), {
				labModalData: t
			} = $t(Ji()), {
				hook: i,
				callHook: r
			} = Ke(), s = tt(!1), o = Be(() => ({
				...t.value
			})), a = Be(() => o.value.video), l = Be(() => o.value.image), c = () => {
				e(null), r("LAB:CLOSE")
			}, u = () => {
				s.value = !0
			};
			return (h, d) => {
				const f = s0,
					p = EP,
					_ = CP,
					g = jb,
					m = PP,
					b = o0;
				return ke(), It(b, null, {
					default: En(() => [Ge(m, {
						class: "lab-modal labor-small"
					}, {
						default: En(() => [Ge(f, {
							"on-click": c
						}), Fe("figure", {
							class: jt([{
								"lab-modal__fig--loaded": fe(s)
							}, "lab-modal__fig"])
						}, [fe(a) ? (ke(), It(p, {
							key: 0,
							data: {
								...fe(a)
							},
							"on-loaded": u
						}, null, 8, ["data"])) : Fn("", !0), Ge(_, {
							class: jt([{
								"lab-modal__thumbnail--abs": fe(a)
							}, "lab-modal__thumbnail"]),
							data: {
								...fe(l)
							},
							"is-fit": !!fe(a),
							"image-sizes": "xs:100vw sm:100vw md:33vw lg:33vw xl:33vw xxl:33vw xxxl:33vw"
						}, null, 8, ["class", "data", "is-fit"])], 2), Ge(g, {
							position: "center"
						}), Fe("div", EQ, [Fe("div", SQ, to(fe(o).title), 1), Fe("div", {
							class: "lab-modal__copy",
							innerHTML: fe(o).copy
						}, null, 8, TQ)])]),
						_: 1
					})]),
					_: 1
				})
			}
		}
	},
	CQ = Qi({
		props: {
			vnode: {
				type: Object,
				required: !0
			},
			route: {
				type: Object,
				required: !0
			},
			vnodeRef: Object,
			renderKey: String,
			trackRootNodes: Boolean
		},
		setup(n) {
			const e = n.renderKey,
				t = n.route,
				i = {};
			for (const r in n.route) Object.defineProperty(i, r, {
				get: () => e === n.renderKey ? n.route[r] : t[r]
			});
			return al(Lm, gd(i)), () => on(n.vnode, {
				ref: n.vnodeRef
			})
		}
	}),
	AQ = Qi({
		name: "NuxtPage",
		inheritAttrs: !1,
		props: {
			name: {
				type: String
			},
			transition: {
				type: [Boolean, Object],
				default: void 0
			},
			keepalive: {
				type: [Boolean, Object],
				default: void 0
			},
			route: {
				type: Object
			},
			pageKey: {
				type: [Function, String],
				default: null
			}
		},
		setup(n, {
			attrs: e,
			expose: t
		}) {
			const i = Ke(),
				r = tt(),
				s = si(Lm, null);
			let o;
			t({
				pageRef: r
			});
			const a = si(L5, null);
			let l;
			const c = i.deferHydration();
			if (i.isHydrating) {
				const u = i.hooks.hookOnce("app:error", c);
				Sr().beforeEach(u)
			}
			return n.pageKey && Vt(() => n.pageKey, (u, h) => {
				u !== h && i.callHook("page:loading:start")
			}), () => on(F3, {
				name: n.name,
				route: n.route,
				...e
			}, {
				default: u => {
					const h = PQ(s, u.route, u.Component),
						d = s && s.matched.length === u.route.matched.length;
					if (!u.Component) {
						if (l && !d) return l;
						c();
						return
					}
					if (l && a && !a.isCurrent(u.route)) return l;
					if (h && s && (!a || a != null && a.isCurrent(s))) return d ? l : null;
					const f = I_(u, n.pageKey);
					!i.isHydrating && !RQ(s, u.route, u.Component) && o === f && i.callHook("page:loading:end"), o = f;
					const p = !!(n.transition ?? u.route.meta.pageTransition ?? P_),
						_ = p && DQ([n.transition, u.route.meta.pageTransition, P_, {
							onAfterLeave: () => {
								i.callHook("page:transition:finish", u.Component)
							}
						}].filter(Boolean)),
						g = n.keepalive ?? u.route.meta.keepalive ?? L6;
					return l = Xk(ma, p && _, qk(g, on(mT, {
						suspensible: !0,
						onPending: () => i.callHook("page:start", u.Component),
						onResolve: () => {
							Xi(() => i.callHook("page:finish", u.Component).then(() => i.callHook("page:loading:end")).finally(c))
						}
					}, {
						default: () => {
							const m = on(CQ, {
								key: f || void 0,
								vnode: u.Component,
								route: u.route,
								renderKey: f || void 0,
								trackRootNodes: p,
								vnodeRef: r
							});
							return g && (m.type.name = u.Component.type.name || u.Component.type.__name || "RouteProvider"), m
						}
					}))).default(), l
				}
			})
		}
	});

function DQ(n) {
	const e = n.map(t => ({
		...t,
		onAfterLeave: t.onAfterLeave ? x1(t.onAfterLeave) : void 0
	}));
	return Rm(...e)
}

function PQ(n, e, t) {
	if (!n) return !1;
	const i = e.matched.findIndex(r => {
		var s;
		return ((s = r.components) == null ? void 0 : s.default) === (t == null ? void 0 : t.type)
	});
	return !i || i === -1 ? !1 : e.matched.slice(0, i).some((r, s) => {
		var o, a, l;
		return ((o = r.components) == null ? void 0 : o.default) !== ((l = (a = n.matched[s]) == null ? void 0 : a.components) == null ? void 0 : l.default)
	}) || t && I_({
		route: e,
		Component: t
	}) !== I_({
		route: n,
		Component: t
	})
}

function RQ(n, e, t) {
	return n ? e.matched.findIndex(r => {
		var s;
		return ((s = r.components) == null ? void 0 : s.default) === (t == null ? void 0 : t.type)
	}) < e.matched.length - 1 : !1
}
const LQ = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		viewBox: "0 0 107 10"
	},
	kQ = Fe("path", {
		d: "M3.048.6h1.356L7.212 9H5.868l-.672-2.1h-2.94L1.584 9H.228zM4.8 5.676 3.72 2.328 2.64 5.676zM11.497 9.096q-1.224 0-2.076-.636-.84-.648-1.08-1.848l1.188-.456q.192.78.672 1.248t1.32.468q.624 0 1.032-.324.42-.336.42-.9a1.02 1.02 0 0 0-.192-.636q-.192-.252-.576-.42a8 8 0 0 0-1.08-.384q-1.056-.3-1.656-.864-.588-.564-.588-1.56 0-.66.312-1.176a2.2 2.2 0 0 1 .912-.804q.588-.3 1.38-.3 1.032 0 1.692.504t.936 1.296l-1.092.552q-.456-1.128-1.536-1.128-.576 0-.936.288t-.36.816q0 .54.408.816.408.264 1.356.504 1.116.288 1.716.816.612.528.612 1.572 0 .828-.372 1.404-.36.576-.996.864a3.34 3.34 0 0 1-1.416.288M16.179.6h1.308v3.324h3.192V.6h1.308V9h-1.308V5.148h-3.192V9h-1.308zM24.136.6h5.244v1.284h-3.936v2.124h3.348v1.224h-3.348V9h-1.308zM33.774.6h1.356L37.938 9h-1.344l-.672-2.1h-2.94L32.31 9h-1.356zm1.752 5.076-1.08-3.348-1.08 3.348zM39.463.6h1.308v7.176h4.032V9h-5.34zM47.145.6h1.307v7.176h4.032V9h-5.34zM57.49 9.072a.88.88 0 0 1-.9-.912.88.88 0 0 1 .9-.912q.396 0 .648.264a.86.86 0 0 1 .264.648.88.88 0 0 1-.264.648.86.86 0 0 1-.648.264M65.267 9.096q-1.224 0-2.076-.636-.84-.648-1.08-1.848l1.188-.456q.192.78.672 1.248t1.32.468q.624 0 1.032-.324.42-.336.42-.9a1.02 1.02 0 0 0-.192-.636q-.192-.252-.576-.42a8 8 0 0 0-1.08-.384q-1.056-.3-1.656-.864-.588-.564-.588-1.56 0-.66.312-1.176a2.2 2.2 0 0 1 .912-.804q.588-.3 1.38-.3 1.032 0 1.692.504t.936 1.296l-1.092.552q-.456-1.128-1.536-1.128-.576 0-.936.288t-.36.816q0 .54.408.816.408.264 1.356.504 1.116.288 1.716.816.612.528.612 1.572 0 .828-.372 1.404-.36.576-.996.864a3.34 3.34 0 0 1-1.416.288M72.205 1.824h-2.496V.6h6.288v1.224h-2.484V9h-1.308zM80.534 9.096q-.864 0-1.536-.36a2.64 2.64 0 0 1-1.068-1.068q-.384-.708-.384-1.728V.6h1.308v5.388q0 .888.432 1.392.432.492 1.248.492.852 0 1.272-.492t.42-1.392V.6h1.308v5.34q0 1.008-.396 1.728a2.55 2.55 0 0 1-1.068 1.068q-.672.36-1.536.36M85.347.6h2.245q1.103 0 1.98.456.887.456 1.391 1.404.517.948.517 2.34t-.517 2.34q-.504.948-1.391 1.404-.877.456-1.98.456h-2.245zm2.125 7.176q1.176 0 1.907-.684.744-.696.745-2.292 0-1.596-.745-2.28-.732-.696-1.907-.696h-.816v5.952zM93.34 7.824h1.909V1.776H93.34V.6h5.112v1.176h-1.896v6.048h1.896V9H93.34zM103.578 9.096q-.936 0-1.68-.48-.732-.492-1.164-1.452-.42-.972-.42-2.364t.42-2.352q.432-.972 1.164-1.452a2.98 2.98 0 0 1 1.68-.492q.936 0 1.668.492.744.48 1.164 1.452.432.96.432 2.352t-.432 2.364q-.42.96-1.164 1.452-.732.48-1.668.48m0-1.224q.876 0 1.404-.744.54-.744.54-2.328 0-1.596-.54-2.328-.528-.744-1.404-.744c-.876 0-1.052.248-1.404.744q-.528.732-.528 2.328t.528 2.34q.528.732 1.404.732"
	}, null, -1),
	IQ = [kQ];

function OQ(n, e) {
	return ke(), Ye("svg", LQ, [...IQ])
}
const FQ = {
		render: OQ
	},
	NQ = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd"
	},
	UQ = Fe("path", {
		d: "M7.052.68c.189.123-.105-.012-.062.09.044.1.14.029.14.029L7.447.76c.329-.07.686-.093 1.062-.07.044.029.086.097.135.12.05.02.054-.08.158.003.16.296-.203.133-.132.381-.147.039-.2.264-.161.466-.627.058-1.203.283-1.886.129-.357.088-.75.034-1.172-.003q-.304.028-.621.025l-.111-.072a7 7 0 0 0-.767.05 3 3 0 0 1-.424.055c-.211-.008-.372-.068-.662-.055-.138.014-.424.057-.551.078l-.05.072c-.01.014-.055-.037-.092-.03s-.032.047-.04.058q-.147.007-.304-.002c-.107.02-.219-.066-.337-.067-.096-.006-.198.067-.298.032l-.133-.087c-.04-.026-.056.01-.089 0C.824 1.787.647 1.6.533 1.66a1.3 1.3 0 0 0-.206-.134.3.3 0 0 1 0-.234c-.047-.108-.142-.17-.143-.238S.437.923.525.876.607.86.725.91C.747.878.725.792.751.766c.19.052.32-.055.515-.058.064 0 .158.062.225.059.066-.004.027-.04.032-.047a2 2 0 0 1 .262.005c.118.004.36.027.533.031.303-.03.458-.083.824-.031.079-.115.535.047.692-.017.279.101.38-.043.586-.049a38 38 0 0 1 2.632.02ZM7.052 3.68c.189.123-.105-.012-.062.09.044.1.14.029.14.029l.316-.038c.329-.07.686-.093 1.062-.07.044.029.086.097.135.12.05.02.054-.08.158.003.16.296-.203.133-.132.381-.147.039-.2.264-.161.466-.627.058-1.203.283-1.886.129-.357.088-.75.034-1.172-.003q-.304.028-.621.025l-.111-.072a7 7 0 0 0-.767.05 3 3 0 0 1-.424.055c-.211-.008-.372-.068-.662-.055-.138.014-.424.057-.551.078l-.05.072c-.01.014-.055-.037-.092-.03s-.032.047-.04.058q-.147.007-.304-.002c-.107.02-.219-.066-.337-.067-.096-.006-.198.067-.298.032l-.133-.087c-.04-.026-.056.01-.089 0C.824 4.787.647 4.6.533 4.66a1.3 1.3 0 0 0-.206-.134.3.3 0 0 1 0-.234c-.047-.108-.142-.17-.143-.238s.253-.132.341-.179.082-.017.2.034c.022-.032 0-.118.026-.144.19.052.32-.055.515-.058.064 0 .158.062.225.059.066-.004.027-.04.032-.047a2 2 0 0 1 .262.005c.118.004.36.027.533.031.303-.03.458-.083.824-.031.079-.115.535.047.692-.017.279.101.38-.043.586-.049a38 38 0 0 1 2.632.02Z"
	}, null, -1),
	BQ = [UQ];

function zQ(n, e) {
	return ke(), Ye("svg", NQ, [...BQ])
}
const VQ = {
		render: zQ
	},
	HQ = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 10 10"
	},
	GQ = Fe("path", {
		d: "M3.203 7.576a.7.7 0 0 0 .201-.175c.024-.043.23-.204.327-.307.067-.058.153-.117.248-.169.074-.036.051-.08.098-.123a8 8 0 0 1 .336-.268c.781-.723 1.565-1.426 2.224-2.134L6.6 4.331c.324-.136.268-.242.444-.415.233-.287.247-.345.506-.626 0 0 .314-.292.306-.308.086-.124.643-.509.588-.592.282-.22.117-.201.16-.373.204-.077.155-.127.206-.184.052-.057.122-.1.155-.147q.327-.37.594-.729c.093-.045.176-.086.183-.117-.185 0-.358.003-.245-.091l-.276.006C9.398.668 9.267.662 9.08.68c-.2.15-.24.076-.689.218-.074.036-.091.265-.17.315-.227.092-.4.3-.608.426s-.446.165-.591.298c.01.13-.235.285-.41.461.135.036-.099.143-.187.218s-.07.133-.137.205c-.066.072-.237.168-.155.214-.101.05-.055.027-.149.093q.04.017.031.06c-.173.222-.518.494-.556.666l-.157.077c-.055.028-.14.175-.187.242-.047.066-.136.094-.19.148s-.079.137-.136.205c-.244.265-.547.575-.76.767-.213.191-.362.394-.572.592s-.245.285-.402.43c-.157.143-.217.161-.304.24s-.113.228-.402.386a.3.3 0 0 1-.022.09A19 19 0 0 1 .954 8.315c-.056.047.144-.036.083.002-.077.12-.282.237-.385.35-.103.115.063-.01.013.026-.05.037-.128.11-.098.146s.177-.016.11.032c-.068.05.02.038-.116.112.178.007.043.082-.02.16-.064.078.038.075-.04.148-.077.074-.111.051-.098.1.014.048-.004.08.077.08.207-.078.473-.178.636-.3.076-.076.187-.037.242-.154.055-.118.174-.094.246-.177s-.01-.022-.016-.031c.185-.024.36-.2.305-.217s-.046.023-.083.041.213-.191.362-.26c.016.03-.194.21-.151.248.156-.093.314-.318.423-.418-.11.011-.133.101-.287.141.087-.078.277-.203.314-.245s.101.017.165-.038c.352-.193.337-.325.567-.485m-.462.398c-.053.054.08-.094 0 0m.386-.388c.091-.002-.065.032-.057.048-.135.03.038-.039.057-.048m-.164.132.1-.077s-.017.08-.1.077m-1.062.913c.078-.007-.053.054-.065.075-.012.022.012-.044.024-.066z"
	}, null, -1),
	WQ = Fe("path", {
		d: "M7.514 6.819c.116.297-.089-.108-.093.034-.005.141.113.158.113.158l.299.25c.323.23.653.533.98.9.027.07.035.177.07.244.034.067.082-.03.139.149.015.443-.239-.053-.283.263-.148-.096-.294.082-.346.32-.586-.514-1.2-.814-1.743-1.593-.359-.239-.687-.652-1.049-1.076a9 9 0 0 1-.566-.541l-.068-.175a10 10 0 0 0-.708-.65 4 4 0 0 1-.403-.332c-.186-.202-.304-.409-.57-.661a16 16 0 0 0-.526-.426l-.075.027c-.015.006-.034-.087-.07-.114-.037-.026-.05.018-.06.022a5 5 0 0 1-.272-.28c-.105-.079-.168-.266-.273-.376-.083-.093-.207-.114-.28-.24l-.082-.21c-.024-.061-.055-.04-.079-.081-.108-.19-.186-.541-.314-.584a3 3 0 0 0-.126-.323c.008-.117.043-.2.1-.237.006-.151-.052-.3-.024-.37s.284.1.383.133c.099.034.08.057.164.217.034-.013.052-.12.086-.121.148.225.31.236.486.411.057.059.115.208.176.265s.04-.015.048-.018q.117.108.233.245c.103.112.31.356.464.52.284.245.446.334.75.721.12-.044.46.537.627.615.206.357.36.305.545.487a62 62 0 0 1 2.347 2.427"
	}, null, -1),
	jQ = [GQ, WQ];

function $Q(n, e) {
	return ke(), Ye("svg", HQ, [...jQ])
}
const qQ = {
		render: $Q
	},
	XQ = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 6 7"
	},
	YQ = Fe("path", {
		d: "M.5 6.898v-6l5 3z"
	}, null, -1),
	KQ = Fe("path", {
		d: "M4.588 3.131c.04.122-.05-.04-.077.024-.027.063.06.06.06.06l.188.085q.317.112.603.315c.01.028-.002.075.013.102.016.027-.612-.508.082.054-.062.196-.174-.003-.26.141-.098-.029-.239.063-.318.174-.365-.178-.785-.258-1.073-.557-.236-.075-.419-.23-.626-.386a4 4 0 0 1-.345-.191L2.81 2.88a4 4 0 0 0-.434-.227 2 2 0 0 1-.255-.113c-.109-.073-.165-.155-.327-.244a8 8 0 0 0-.334-.143l-.062.019c-.012.004-.011-.036-.035-.045-.023-.009-.04.012-.05.015a2 2 0 0 1-.161-.1c-.068-.026-.085-.104-.147-.144-.048-.034-.14-.033-.175-.082L.802 1.73C.794 1.705.768 1.717.756 1.7c-.052-.074-.053-.224-.144-.232a.5.5 0 0 0-.044-.132.23.23 0 0 1 .116-.114c.03-.068.01-.129.043-.163.033-.033.201.02.271.026s.053.018.09.082c.028-.009.06-.057.086-.061.076.087.199.077.305.14.034.021.054.082.09.103.038.02.035-.01.041-.013a1 1 0 0 1 .138.089c.06.04.179.13.27.19.177.084.286.11.456.255.1-.03.263.199.379.219.098.14.224.104.337.169.476.27.92.553 1.398.873"
	}, null, -1),
	ZQ = Fe("path", {
		d: "M1.304 5.88c-.04.126.05-.04.077.024.026.065-.061.063-.061.063l-.188.089q-.316.118-.602.329c-.01.03.001.077-.014.105-.016.028.614-.527-.083.056.06.2.174-.004.257.143.098-.032.237.061.315.174.364-.186.782-.273 1.072-.582.235-.08.419-.24.627-.403a4 4 0 0 0 .345-.2l.024-.074q.213-.133.434-.238.13-.048.255-.118c.109-.076.165-.16.327-.254.08-.04.255-.117.334-.15l.061.019c.012.003.012-.037.035-.046s.04.012.05.014q.082-.046.162-.105c.067-.027.085-.107.147-.148.048-.036.14-.035.175-.087 0 0 .02-.062.03-.088.008-.026.034-.014.046-.03.052-.078.055-.231.146-.24a.6.6 0 0 1 .044-.137.23.23 0 0 0-.114-.115c-.028-.07-.007-.132-.04-.166-.032-.035-.2.021-.27.029-.07.007-.052.02-.09.085-.028-.009-.059-.059-.085-.062-.076.09-.198.082-.304.147-.034.022-.055.085-.092.106s-.034-.01-.04-.012a1 1 0 0 0-.138.092c-.06.043-.179.137-.27.198-.177.089-.286.116-.457.267-.098-.03-.263.206-.378.228-.1.146-.225.11-.338.177-.476.282-.92.577-1.399.91"
	}, null, -1),
	JQ = Fe("path", {
		d: "M1.06 2.09c-.086-.099.01.065-.058.055-.07-.01-.023-.084-.023-.084l.019-.207c.04-.22.048-.452.025-.686-.02-.024-.067-.039-.083-.066s.14.797-.006-.1C.73.951.849 1.154.68 1.15c-.023.1-.174.173-.31.182-.026.408-.166.812-.048 1.22-.051.241-.007.482.027.744a4 4 0 0 0-.004.398l.05.059q.007.25-.017.495-.025.136-.028.279c.01.133.053.224.05.41-.006.09-.029.28-.04.364l-.048.044c-.01.008.026.029.022.054s-.03.028-.038.034a2 2 0 0 0 .008.193c-.011.072.048.128.052.203.006.06-.041.137-.015.195l.061.07c.018.02-.006.037.002.056.04.084.17.165.132.247a.6.6 0 0 1 .095.108.23.23 0 0 0 .157-.039c.074.012.117.061.163.05s.084-.183.113-.246c.03-.064.01-.055-.026-.122.02-.02.08-.02.096-.04-.039-.113.03-.213.029-.337-.002-.04-.046-.09-.045-.133s.026-.024.031-.029a1 1 0 0 0-.009-.165c-.005-.074-.025-.224-.032-.334.014-.197.047-.305.004-.529.076-.069-.043-.331-.003-.442-.074-.16.02-.248.02-.38a22 22 0 0 0-.068-1.668Z"
	}, null, -1),
	QQ = [YQ, KQ, ZQ, JQ];

function eee(n, e) {
	return ke(), Ye("svg", XQ, [...QQ])
}
const tee = {
		render: eee
	},
	nee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 6 11"
	},
	iee = Fe("path", {
		d: "M1.981 3.228c-.143-.361.016.172-.097.054-.113-.119-.037-.239-.037-.239l.03-.483A8.6 8.6 0 0 0 1.919.904C1.885.82 1.808.72 1.782.631s.085-.048-.01-.254c-.332-.398-.14.259-.416.025-.038.215-.285.19-.509.03C.805 1.402.577 2.21.77 3.37c-.084.527-.01 1.18.045 1.87a13 13 0 0 0-.007.975l.084.213q.01.625-.029 1.195a6 6 0 0 0-.046.648c.016.34.088.625.084 1.08-.01.214-.048-3.085-.067-2.893L.756 6.5c-.015.01.042.107.036.162s-.05.028-.062.035a7 7 0 0 0 .012.485c-.017.162.08.38.086.57.01.155-.067.283-.024.458l.1.255c.03.075-.01.083.004.14.065.262.279.636.216.787q.089.19.155.393c.096.094.187.134.258.115.121.127.193.308.268.343s.137-.34.185-.457.017-.122-.044-.334c.035-.02.131.056.158.029-.063-.328.05-.482.047-.791-.003-.102-.074-.283-.073-.387s.043-.024.05-.028a4 4 0 0 0-.014-.42c-.009-.19-.042-.585-.053-.864.023-.467.076 3.045.006 2.437.124-.07-.07-.875-.005-1.093-.122-.493.033-.584.033-.908a89 89 0 0 0-.114-4.2ZM5.674 3.228c-.142-.361.017.172-.096.054-.113-.119-.038-.239-.038-.239l.031-.483a8.6 8.6 0 0 0 .04-1.656C5.579.82 5.502.72 5.476.631c-.025-.09.086-.048-.01-.254-.332-.398-.139.259-.416.025-.037.215-.284.19-.508.03-.043.97-.271 1.777-.077 2.938-.085.527-.011 1.179.044 1.869q-.02.467-.007.975l.084.213q.01.625-.028 1.195a6 6 0 0 0-.047.648c.017.34.088.625.084 1.08-.01.214-.048-3.085-.067-2.893L4.45 6.5c-.016.01.042.107.035.162s-.05.028-.062.035q-.003.233.013.485c-.018.162.08.38.086.57.01.155-.067.283-.025.458l.1.255c.03.075-.009.083.004.14.066.262.28.636.216.787q.09.19.156.393c.095.094.186.134.258.115.12.127.192.308.268.343.075.036.137-.34.185-.457s.016-.122-.044-.334c.034-.02.13.056.157.029-.063-.328.051-.482.047-.791-.002-.102-.074-.283-.072-.387 0-.105.042-.024.05-.028a4 4 0 0 0-.015-.42c-.008-.19-.042-.585-.053-.864.024-.467.077 3.045.006 2.437.124-.07-.07-.875-.005-1.093-.122-.493.034-.584.033-.908a87 87 0 0 0-.114-4.2Z"
	}, null, -1),
	ree = [iee];

function see(n, e) {
	return ke(), Ye("svg", nee, [...ree])
}
const oee = {
		render: see
	},
	aee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 9 9"
	},
	lee = Fe("path", {
		d: "M5.018 6.997a.3.3 0 0 0 .02-.176c-.013-.04.021-.204.018-.304a.5.5 0 0 1 .059-.18c.028-.041-.021-.072-.018-.115q.02-.135.052-.273c.047-.717.11-1.42.077-2.102l-.077-.048c.14-.167.02-.241.024-.411-.04-.271-.071-.32-.086-.59 0 0 .018-.29 0-.3-.028-.116.102-.522 0-.579.047-.226-.06-.181-.155-.326.094-.098.02-.13.017-.184-.004-.055.017-.101.007-.145A6 6 0 0 0 4.86.576c.035-.053.066-.1.049-.126-.137.034-.263.067-.25-.03L4.46.476c.067-.1-.035-.082-.16-.034-.039.156-.124.104-.35.297-.029.043.126.228.105.282-.101.114-.075.312-.137.45-.061.137-.21.21-.218.343.101.101.035.27.035.441.126.005.032.132.022.208s.045.118.05.188c.003.07-.053.176.041.198-.038.058-.02.032-.041.1a.1.1 0 0 1 .066.043c.036.209-.02.488.078.632l-.059.09c-.02.031.025.164.039.225.014.062-.031.1-.031.153s.042.123.05.188a6 6 0 0 1 0 .748c-.017.19.022.38.012.575s.029.272.018.415c-.01.143-.041.168-.048.246s.084.202-.014.38a.4.4 0 0 1 .05.075q.015.616-.072 1.27c-.007.049.08-.053.063-.012.032.11-.034.24-.027.349s.038-.02.028.017c-.01.039-.014.111.035.135.05.023.12-.045.105.006s.042.026-.003.11c.136-.027.091.057.102.13.01.075.084.054.08.126-.003.073-.045.06 0 .097.046.036.057.066.116.05.097-.099.22-.226.251-.353 0-.075.111-.063.066-.166-.046-.104.06-.106.052-.185-.007-.08-.024-.016-.035-.022.12-.053.12-.225.067-.228s-.018.027-.032.048c-.014.02.017-.191.077-.274.035.022.011.204.07.226.048-.102 0-.31.006-.409-.073.029-.024.104-.108.164.007-.078.056-.212.052-.252-.003-.04.088-.004.095-.06.118-.217.01-.32.062-.488Zm-.049.4c0 .052-.01-.09 0 0m0-.379c.067-.018-.024.037-.006.048-.077.05 0-.037.006-.048m-.024.134.018-.078s.045.066-.018.078m-.114.92c.052-.02 0 .052.007.071.007.02-.025-.037-.032-.057z"
	}, null, -1),
	cee = Fe("path", {
		d: "M7.052 3.68c.189.123-.105-.012-.062.09.044.1.14.029.14.029l.316-.038a4 4 0 0 1 1.062-.07c.044.029.086.097.135.119s.054-.079.158.004c.16.296-.203.132-.132.381-.147.039-.2.264-.161.466-.627.058-1.203.283-1.886.129-.357.088-.75.034-1.172-.003q-.304.028-.621.025l-.111-.072a7 7 0 0 0-.767.05 3 3 0 0 1-.424.055c-.211-.008-.372-.068-.662-.055-.138.013-.424.057-.551.078l-.05.071c-.01.015-.055-.036-.092-.029s-.032.047-.04.058q-.147.006-.304-.002c-.107.02-.219-.066-.337-.067-.096-.006-.198.067-.298.031l-.133-.087c-.04-.025-.056.01-.089 0C.824 4.788.647 4.6.533 4.661a1.2 1.2 0 0 0-.206-.134.3.3 0 0 1 0-.234c-.047-.108-.142-.17-.143-.238-.002-.069.253-.132.341-.179s.082-.017.2.034c.022-.032 0-.119.026-.144.19.052.32-.056.515-.058.064 0 .158.062.225.058.066-.003.027-.039.032-.046a2 2 0 0 1 .262.005c.118.004.36.027.533.031.303-.03.458-.083.824-.031.079-.115.535.047.692-.017.279.101.38-.043.586-.049a38 38 0 0 1 2.632.02Z"
	}, null, -1),
	uee = [lee, cee];

function hee(n, e) {
	return ke(), Ye("svg", aee, [...uee])
}
const dee = {
		render: hee
	},
	fee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 10 9"
	},
	pee = Fe("path", {
		d: "M7.737.678a.23.23 0 0 0-.14-.007c-.03.014-.162-.005-.241.004a.4.4 0 0 1-.143-.038c-.034-.021-.058.021-.092.02a2 2 0 0 1-.218-.026C6.332.634 5.773.623 5.23.69c-.013.02-.032.054-.039.066C5.058.651 5 .753 4.864.76c-.216.048-.254.078-.47.105 0 0-.23.003-.239.018-.091.03-.415-.054-.46.033-.18-.025-.144.061-.26.148-.077-.072-.102-.01-.145-.004-.044.006-.081-.008-.116.003a5 5 0 0 0-.547.119c-.042-.026-.08-.049-.1-.033.026.11.053.212-.023.207l.043.16c-.08-.048-.065.035-.026.136.124.022.083.095.237.27.034.021.181-.117.225-.103.09.077.248.044.357.086.11.043.17.16.275.16.08-.089.214-.044.35-.054.004-.105.106-.034.166-.03s.094-.045.15-.052.14.033.157-.046c.047.028.025.015.08.028a.1.1 0 0 1 .034-.057c.166-.041.388-.012.502-.101l.072.044c.025.015.131-.03.18-.046.049-.015.08.02.121.017.042-.003.098-.042.15-.051.203-.027.443-.048.595-.045s.302-.04.458-.043c.155-.003.216-.04.33-.04s.134.025.196.026c.062.002.16-.08.303-.01a.3.3 0 0 1 .06-.046 6 6 0 0 1 1.011-.015c.038.003-.043-.063-.01-.051.087-.032.19.015.278.002.086-.012-.017-.03.014-.024.03.006.088.005.106-.037s-.036-.095.005-.087.02-.036.087-.003c-.02-.111.046-.079.105-.092s.041-.072.1-.074c.057-.001.048.034.076-.005.029-.04.052-.05.04-.099-.08-.073-.18-.167-.282-.186C8.99.893 9 .8 8.916.844 8.834.888 8.832.801 8.77.811c-.063.01-.012.022-.017.03-.043-.094-.18-.084-.182-.04-.002.043.021.012.038.022S8.457.82 8.391.776c.018-.03.162-.02.18-.071-.082-.034-.247.019-.326.019.023.059.083.014.13.08-.061-.002-.168-.034-.2-.029-.03.005-.004-.072-.048-.074-.173-.085-.254.01-.389-.023Zm.319.017c.042-.003-.07.014 0 0m-.301.022c-.015-.054.03.018.038.003.039.06-.03.002-.038-.003m.107.012-.063-.01s.052-.041.063.01m.732.04c-.016-.041.041-.002.057-.01.015-.006-.03.023-.046.03L8.594.77Z"
	}, null, -1),
	mee = Fe("path", {
		d: "M8.084 2.02a.22.22 0 0 0-.039.123c.005.03-.043.144-.054.216a.4.4 0 0 1-.067.121c-.026.027.005.055-.004.086a2 2 0 0 1-.075.19c-.133.508-.275 1.005-.346 1.5l.048.045c-.123.1-.048.17-.073.292-.01.2.006.24-.02.436 0 0-.053.205-.042.216.004.086-.145.361-.08.415-.065.157.018.139.066.256-.081.057-.033.09-.038.13-.005.039-.026.07-.025.103a5 5 0 0 0-.026.507c-.032.033-.062.063-.053.084.103-.006.198-.013.175.054l.15-.012c-.061.063.014.063.111.045.05-.106.103-.058.293-.167.026-.026-.06-.18-.037-.216.088-.069.097-.214.16-.305.063-.09.18-.124.205-.218-.06-.086.011-.198.035-.322-.09-.02-.004-.099.013-.152s-.016-.091-.009-.142.062-.12-.003-.148c.036-.037.02-.02.044-.067a.07.07 0 0 1-.042-.039c.004-.155.082-.348.032-.464l.055-.057c.019-.02.005-.122.003-.168s.036-.067.043-.105c.008-.038-.013-.094-.009-.142.025-.185.064-.403.103-.538s.037-.275.071-.414c.034-.14.017-.2.044-.301.027-.102.054-.115.07-.17.015-.056-.033-.157.061-.272a.3.3 0 0 1-.024-.061 6 6 0 0 1 .227-.904c.011-.033-.066.028-.047.001-.008-.083.058-.168.068-.247.01-.08-.03.01-.018-.017.013-.026.025-.077-.007-.1s-.091.016-.074-.019-.027-.025.017-.079C8.865.995 8.91.941 8.911.887c.003-.055-.053-.05-.04-.101s.041-.038.013-.07C8.857.684 8.853.661 8.808.664c-.083.06-.189.134-.229.221-.01.054-.088.03-.07.111.019.08-.058.068-.063.126-.006.058.015.014.022.02-.093.022-.116.146-.08.155.038.01.017-.016.03-.03s-.039.135-.093.187c-.022-.02.02-.148-.02-.172-.048.067-.041.223-.06.293.056-.01.032-.071.1-.103-.016.055-.07.145-.072.174-.003.029-.064-.008-.076.03-.115.14-.052.229-.113.343Zm.09-.282c.008-.037-.004.066 0 0m-.052.272c-.05.004.023-.023.012-.033.062-.025-.005.027-.012.033m.036-.093-.023.054s-.024-.053.023-.054m.21-.646c-.04.007.007-.037.005-.052-.003-.015.012.03.014.045z"
	}, null, -1),
	gee = Fe("path", {
		d: "M5.819 2.754c.273-.064-.102.079.025.118.126.039.149-.095.149-.095l.243-.289c.226-.323.518-.636.867-.93.064-.015.161.001.223-.023.063-.025-.022-.104.142-.128.4.089.727-.126 1.008 0-.095.151-.732.756-.521.873-.498.562-.805 1.207-1.538 1.656-.236.361-.627.646-1.029.968q-.24.271-.52.532l-.162.039a8 8 0 0 0-.626.67 3.4 3.4 0 0 1-.323.393c-.192.168-.386.256-.628.506-.11.125-.322.394-.415.515l.02.094c.004.018-.08.019-.106.054-.027.036.013.061.016.075q-.124.13-.268.251c-.077.104-.25.132-.355.23-.089.074-.114.213-.232.27l-.194.045c-.056.013-.039.054-.077.072-.177.082-.497.088-.544.228q-.15.021-.298.07C.572 8.91.5 8.85.47 8.775c-.135-.042-.272-.01-.334-.06-.06-.05.106-.308.143-.415s.056-.08.204-.14C.474 8.117.38 8.07.38 8.03c.211-.119.23-.306.399-.47.056-.052.193-.084.249-.142s-.011-.051-.013-.06q.104-.112.233-.214c.107-.094.339-.277.495-.418.238-.273.327-.44.694-.705-.032-.15.51-.408.59-.585.333-.155.296-.346.47-.52a48 48 0 0 1 2.322-2.163Z"
	}, null, -1),
	_ee = [pee, mee, gee];

function vee(n, e) {
	return ke(), Ye("svg", fee, [..._ee])
}
const bee = {
		render: vee
	},
	yee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 13 8"
	},
	xee = Fe("path", {
		d: "M1.524 4.56a.23.23 0 0 0 .095.104c.031.012.11.118.173.168a.4.4 0 0 1 .074.128c.01.038.056.026.08.05q.07.081.135.173c.406.401.793.805 1.225 1.142l.074-.02c.02.168.134.138.234.228.187.119.235.125.407.258 0 0 .164.161.181.157.086.043.256.331.35.301.109.146.144.06.287.08.004.106.066.08.1.105.036.027.052.063.085.08q.231.167.47.303c.012.048.023.091.048.094.06-.097.112-.188.162-.13l.083-.145c.022.091.07.022.114-.076-.071-.104.01-.126.024-.36-.01-.038-.211-.044-.232-.085-.01-.119-.144-.206-.192-.314-.047-.108-.006-.233-.08-.308-.12.007-.183-.119-.287-.209-.076.072-.099-.05-.138-.095-.04-.046-.098-.035-.142-.07-.044-.034-.077-.122-.145-.078-.013-.053-.007-.03-.036-.077a.1.1 0 0 1-.064.017c-.147-.089-.283-.267-.427-.284l-.02-.082c-.007-.029-.114-.071-.16-.095-.044-.024-.041-.07-.073-.098s-.1-.04-.142-.069a5 5 0 0 1-.453-.39c-.105-.109-.242-.185-.354-.293s-.18-.125-.261-.205c-.08-.081-.078-.113-.12-.157-.044-.045-.172-.056-.223-.206a.3.3 0 0 1-.074-.011 6 6 0 0 1-.726-.704c-.025-.03-.014.075-.029.043-.084-.039-.124-.145-.194-.198s-.01.033-.027.007-.06-.066-.102-.05c-.042.017-.042.094-.065.059-.022-.035-.04.01-.064-.06-.063.094-.088.024-.138-.008-.051-.033-.081.021-.123-.018-.042-.04-.01-.059-.058-.05-.049.007-.073-.002-.098.04.004.109.01.247.068.331.045.04-.027.098.062.126.09.027.03.09.081.127s.024-.006.034-.01c-.038.098.067.187.099.158s-.006-.024-.01-.043c-.005-.02.105.11.12.187-.034.01-.13-.1-.177-.076.034.081.188.161.243.217.026-.058-.048-.069-.036-.149.043.045.096.143.122.162.026.018-.048.053-.018.086.062.183.186.173.258.292m-.213-.237c-.032-.028.06.04 0 0m.229.197c-.028.048-.009-.034-.025-.029.015-.07.022.02.025.029m-.067-.084.037.051s-.066-.008-.037-.051m-.49-.547c-.018.041-.03-.027-.047-.033-.015-.006.037.005.053.011l-.005.022Z"
	}, null, -1),
	wee = Fe("path", {
		d: "M2.224 3.368a.22.22 0 0 0 .116-.06c.017-.025.132-.071.19-.114a.4.4 0 0 1 .134-.039c.037 0 .035-.042.062-.058q.09-.044.188-.08c.454-.267.905-.517 1.306-.817l-.003-.066c.159.016.155-.087.26-.154.147-.135.164-.174.322-.294 0 0 .182-.108.182-.123.058-.065.358-.153.35-.238.157-.065.085-.111.134-.227.098.016.086-.04.118-.065s.069-.031.09-.056q.204-.163.378-.34c.047 0 .088-.001.097-.022-.077-.068-.15-.13-.085-.162L5.947.356C6.036.354 5.983.3 5.901.245c-.11.04-.113-.032-.324-.089-.038 0-.086.17-.128.18-.11-.014-.22.082-.328.102-.11.02-.215-.04-.3.01-.019.102-.148.131-.252.202.05.077-.067.073-.117.098s-.053.076-.093.107c-.041.03-.129.04-.103.107-.051 0-.028 0-.079.016q.014.028.003.057c-.112.107-.304.188-.351.306l-.079.001c-.028 0-.09.083-.121.117-.031.033-.074.022-.105.043-.032.022-.058.077-.094.107-.149.114-.33.24-.453.308s-.22.169-.344.243c-.122.074-.153.129-.244.181-.09.053-.119.044-.169.072s-.088.134-.236.148a.3.3 0 0 1-.025.06 6 6 0 0 1-.8.48c-.032.015.066.025.034.032-.053.064-.16.077-.223.126-.063.05.029.015.001.025-.027.009-.073.037-.067.076s.077.053.04.066c-.037.012.001.036-.068.043.072.071.003.078-.037.115-.04.036.002.072-.043.1-.046.028-.056-.003-.059.04-.003.042-.016.06.017.09.1.017.229.039.318.006.046-.031.085.04.128-.03.044-.07.09-.007.134-.043.045-.037 0-.022 0-.03.08.05.184-.021.164-.054s-.023 0-.041 0 .123-.068.197-.066c.001.03-.119.09-.108.136.082-.014.188-.129.25-.165-.047-.032-.072.028-.143.002.05-.028.151-.053.174-.072s.039.051.075.032c.18-.017.198-.124.322-.162m-.262.135c-.032.021.05-.043 0 0m.23-.156c.038.033-.033 0-.033.016-.061-.027.023-.016.032-.016Zm-.092.04.055-.021s-.021.054-.055.022Zm-.605.309c.034.024-.032.022-.04.034-.01.012.012-.03.021-.043z"
	}, null, -1),
	Eee = Fe("path", {
		d: "M4.348 4.448c-.24-.147.127.017.066-.1-.062-.118-.173-.039-.173-.039l-.376.033a5 5 0 0 1-1.271.044c-.056-.035-.113-.115-.174-.141-.062-.027-.058.088-.19-.01-.22-.345-.604-.425-.713-.713.174-.04 1.051-.016.986-.249.749-.045 1.421-.284 2.257-.084.423-.088.9-.013 1.413.044q.362-.023.744-.008c.036.021.106.065.141.087q.475.009.918-.032.24-.042.505-.049c.255.017.454.091.803.086.165-.01.505-.05.656-.07l.053-.081c.01-.016.07.043.114.037.044-.007.034-.053.042-.065q.178-.003.367.012c.127-.018.269.083.412.089.115.01.232-.07.355-.026l.17.104c.049.03.065-.01.106.003.182.068.413.29.545.224q.122.092.26.161c.047.1.055.194.023.268.066.126.186.2.194.278s-.293.143-.394.193-.097.017-.244-.045c-.024.036.01.136-.018.164-.233-.065-.38.053-.614.05-.077-.003-.197-.077-.277-.075-.08.001-.028.044-.034.052q-.15.004-.315-.014c-.143-.01-.436-.044-.646-.055-.36.025-.543.08-.989.008-.084.13-.648-.072-.83-.004-.346-.125-.455.036-.701.036a48 48 0 0 1-3.17-.113Z"
	}, null, -1),
	See = [xee, wee, Eee];

function Tee(n, e) {
	return ke(), Ye("svg", yee, [...See])
}
const Mee = {
		render: Tee
	},
	Cee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 13 12"
	},
	Aee = GT('<path d="M2.578 5.13a.6.6 0 0 0 .031-.236c-.011-.045.033-.273.036-.4.01-.08-.11 1.619-.076 1.529.03-.067-.016-.086-.01-.142a6 6 0 0 1 .068-.377c.09-.95.052-.099.063-.97l-.071-.03c.145-.275.035-.321.049-.543-.02-.334-.049-.384-.046-.728 0 0 .036-.383.02-.39-.02-.136.13-.719.036-.749.06-.313-.048-.21-.13-.357.098-.167.028-.176.028-.245 0-.07.024-.139.016-.191a10 10 0 0 0-.049-.85c.037-.084.07-.16.055-.185-.134.102-.258.198-.238.068L2.163.49c.07-.158-.029-.09-.153.025-.047.218-.126.187-.358.535-.03.066.108.24.085.32-.106.19-.093.436-.161.64-.069.205-.217.364-.234.54.092.087.018.333.007.556.122-.048.022.157.007.26-.014.102.037.134.036.222 0 .089-.061.251.029.24-.041.091-.023.05-.047.148a.054.054 0 0 1 .062.026c.02.256-.05.641.035.786l-.063.141c-.022.05.014.204.023.277.01.073-.036.143-.04.21-.003.068.033.143.036.223-.002.325.127-1.073.099-.819-.03.255-.003.483-.026.741-.022.258.155-1.447.136-1.258s-.05.236-.062.34.068.226-.037.499q.025.03.042.077c-.016.527.079-.7-.005-.11-.01.064.082-.105.062-.044.024.128-.049.325-.049.464 0 .138.039-.044.026.01-.012.055-.02.15.026.16.046.009.118-.11.101-.037-.016.072.04.016-.01.144.134-.093.157-.859.162-.768.006.092.079.033.07.128-.007.096-.047.098-.005.126.041.027.05.06.108.016.1-.17.155.507.193.329.005-.097.112-.13.074-.244-.037-.115.065-.163.063-.262-.002-.1-.023-.01-.033-.014.119-.119.13-.341.079-.323-.05.018-.019.042-.034.075-.014.033-.043.639.02.507.032.014-.002.259.054.262.052-.153-.054.493-.04.361-.074.069.041-.748-.044-.635.012-.104-.005.596-.006.546 0-.05.085-.044.096-.119.128-.332.03-.418.091-.66Zm-.072.54c-.004.068-.005-.11 0 0m.024-.49c.065-.053-.026.058-.01.064-.078.096.002-.048.01-.065Zm-.032.184.021-.11s.04.066-.021.11m-.025-.548c.052-.047-.003.068.002.09.006.022-.021-.038-.027-.06z"></path><path d="M4.353 1.048c.263.12-.126-.013-.04.083.085.097.174.03.174.03l.355-.03a5.4 5.4 0 0 1 1.214-.047c.062.028-.778.104-.713.125s.035-.073.185.007c.289.283-.19.122-.022.359-.158.034-.142.246-.027.438-.711.044-.393.237-1.243.078-.387.077-.864.019-1.37-.024a8 8 0 0 1-.715.013l-.154-.07c-.306-.003 3.964-.04 3.686-.015q-.222.037-.476.045c-.25-.011-.458-.071-.792-.064-.156.01-.475.046-.616.064l-.033.067c-.006.013-.077-.036-.118-.03s-.021.044-.026.054q-.171.004-.356-.007c-.119.016-.278-.066-.417-.07-.113-.007-.208.06-.336.025l-.186-.085c-.054-.025-.061.009-.103-.002-.191-.054-.463-.236-.575-.18a2.4 2.4 0 0 0-.286-.131c-.068-.082-.097-.16-.082-.222-.092-.103-.224-.163-.25-.228-.024-.065.251-.12.338-.163.086-.042.09-.015.245.036.014-.03-.04-.113-.02-.136.24.052.354-.047.58-.046.075.001.207.062.283.06.077-.002.018-.037.021-.044q.146-.005.308.01c.139.006.429.032.633.039.343-.024.505-.071.951-.015.052-.107.64.054.8-.004.361.101.43-.033.667-.035.998-.011-2.576.066-1.484.115M5.692 10.102a.6.6 0 0 0-.237-.03c-.044.01-.273-.034-.4-.036-.08-.01 1.62.11 1.53.075-.067-.03-.086.016-.143.01a6 6 0 0 1-.377-.068c-.95-.09-.098-.052-.97-.063l-.03.072c-.274-.146-.32-.036-.542-.05-.335.021-.384.049-.729.046 0 0-.382-.035-.389-.02-.137.02-.72-.13-.749-.036-.314-.06-.21.048-.357.13-.167-.097-.176-.028-.246-.028-.069 0-.138-.023-.19-.016a9 9 0 0 0-.851.05c-.084-.038-.159-.071-.185-.056.102.134.199.258.069.239l.155.196c-.159-.07-.091.029.025.154.217.047.186.125.534.357.067.03.241-.108.32-.084.191.105.436.092.64.16.206.069.365.217.54.234.088-.092.333-.017.556-.007-.048-.121.158-.022.26-.007s.134-.037.223-.036c.089 0 .251.062.24-.028.09.04.05.022.148.046a.05.05 0 0 1 .025-.061c.256-.021.642.05.786-.036l.142.063c.05.022.203-.013.276-.023s.143.037.211.04.142-.033.223-.036c.325.002-1.074-.127-.819-.098s.483.003.74.025c.258.022-1.447-.155-1.257-.136.19.02.236.051.34.063.103.011.226-.07.498.037a.3.3 0 0 1 .077-.043c.527.016-.7-.078-.11.005.065.01-.105-.081-.044-.062.129-.024.326.049.464.049.139 0-.043-.039.011-.026.054.012.15.02.159-.026s-.109-.118-.037-.101.016-.039.144.01c-.092-.134-.858-.157-.767-.162s.032-.078.128-.07.098.048.125.006c.028-.042.061-.05.017-.11-.17-.099.506-.154.328-.192-.096-.005-.129-.112-.243-.074-.115.038-.163-.065-.263-.063s-.01.023-.013.033c-.119-.119-.342-.13-.323-.079.018.051.041.019.075.034s.639.043.507-.02c.013-.032.258.003.262-.054-.153-.052.492.054.36.041.07.073-.747-.042-.635.043-.104-.012.596.005.546.006-.05 0-.043-.085-.118-.095-.332-.129-.419-.03-.66-.092m.54.073c.067.003-.111.004 0 0m-.491-.024c-.052-.066.058.026.065.01.096.077-.049-.003-.065-.01m.184.032-.11-.022s.067-.04.11.022m-.547.024c-.048-.052.068.004.09-.002s-.039.021-.06.027z"></path><path d="M1.61 8.327c.12-.263-.014.127.083.04.096-.085.03-.173.03-.173l-.03-.355a5.4 5.4 0 0 1-.047-1.215c.028-.062.103.779.125.714.021-.066-.074-.036.007-.186.283-.289.121.19.358.022.034.158.247.142.438.027.044.711.238.393.079 1.243.077.387.018.864-.024 1.37q.021.343.013.715l-.07.155c-.003.305-.04-3.965-.015-3.686q.037.221.045.475c-.012.25-.072.458-.065.792.01.156.047.476.064.617l.067.032c.014.007-.035.077-.03.118.007.04.044.021.055.026q.003.171-.007.356c.016.119-.067.278-.07.417-.008.113.06.208.024.336l-.084.186c-.025.055.008.061-.002.103-.055.192-.236.463-.18.575a2 2 0 0 0-.132.287c-.081.067-.16.096-.221.081-.103.092-.163.224-.228.25s-.12-.25-.163-.337c-.042-.087-.015-.09.035-.245-.03-.015-.112.04-.135.02.052-.24-.048-.354-.046-.581.001-.075.061-.207.06-.283-.003-.077-.038-.018-.044-.021q-.005-.146.009-.308c.006-.139.032-.428.04-.633-.024-.342-.072-.505-.015-.95-.108-.053.054-.641-.004-.802.1-.36-.034-.429-.036-.666-.01-.998.067 2.577.115 1.484ZM7.622 10.102a.6.6 0 0 1 .237-.03c.044.01.272-.034.4-.036.079-.01-1.62.11-1.53.075.067-.03.086.016.142.01q.185-.027.377-.068c.95-.09.099-.052.97-.063l.03.072c.275-.146.321-.036.543-.05.334.021.384.049.728.046 0 0 .383-.035.39-.02.136.02.719-.13.749-.036.313-.06.21.048.357.13.167-.097.176-.028.245-.028.07 0 .139-.023.191-.016q.446.007.85.05c.084-.038.16-.071.185-.056-.102.134-.198.258-.068.239l-.155.196c.158-.07.09.029-.025.154-.218.047-.187.125-.534.357-.067.03-.242-.108-.32-.084-.192.105-.437.092-.641.16-.205.069-.364.217-.54.234-.087-.092-.333-.017-.556-.007.048-.121-.157-.022-.26-.007-.102.015-.134-.037-.222-.036-.089 0-.251.062-.24-.028-.091.04-.05.022-.148.046a.05.05 0 0 0-.026-.061c-.256-.021-.641.05-.786-.036l-.141.063c-.05.022-.204-.013-.277-.023s-.143.037-.21.04c-.068.003-.143-.033-.223-.036-.325.002 1.073-.127.819-.098-.255.028-.483.003-.741.025s1.447-.155 1.258-.136c-.19.02-.236.051-.34.063-.104.011-.226-.07-.498.037a.3.3 0 0 0-.078-.043c-.527.016.7-.078.111.005-.065.01.104-.081.043-.062-.128-.024-.325.049-.464.049-.138 0 .044-.039-.01-.026-.055.012-.15.02-.16-.026-.009-.046.11-.118.037-.101-.072.017-.016-.039-.144.01.093-.134.859-.157.768-.162-.092-.006-.033-.078-.128-.07-.096.008-.098.048-.126.006s-.06-.05-.016-.11c.17-.099-.507-.154-.329-.192.097-.005.13-.112.244-.074.115.038.163-.065.262-.063.1.002.01.023.014.033.119-.119.341-.13.323-.079s-.042.019-.075.034-.639.043-.507-.02c-.014-.032-.259.003-.262-.054.153-.052-.493.054-.361.041-.069.073.748-.042.635.043.104-.012-.596.005-.546.006.05 0 .044-.085.119-.095.332-.129.418-.03.66-.092m-.54.073c-.068.003.11.004 0 0m.49-.024c.053-.066-.057.026-.064.01-.096.077.048-.003.065-.01Zm-.183.032.109-.022s-.066-.04-.11.022Zm.547.024c.047-.052-.068.004-.09-.002s.038.021.06.027z"></path><path d="M11.704 8.327c-.12-.263.013.127-.083.04-.097-.085-.03-.173-.03-.173l.03-.355a5.4 5.4 0 0 0 .047-1.215c-.028-.062-.104.779-.125.714s.074-.036-.007-.186c-.283-.289-.122.19-.358.022-.035.158-.247.142-.439.027-.044.711-.237.393-.078 1.243-.077.387-.019.864.024 1.37a8 8 0 0 0-.013.715l.07.155c.003.305.04-3.965.015-3.686q-.037.221-.045.475c.011.25.071.458.064.792-.01.156-.046.476-.064.617l-.067.032c-.013.007.036.077.03.118s-.044.021-.054.026q-.004.171.007.356c-.016.119.066.278.07.417.007.113-.06.208-.025.336l.085.186c.025.055-.009.061.002.103.055.192.236.463.18.575q.075.138.131.287c.082.067.16.096.222.081.103.092.163.224.228.25s.12-.25.163-.337c.042-.087.015-.09-.036-.245.03-.015.113.04.136.02-.052-.24.047-.354.046-.581-.001-.075-.062-.207-.06-.283.002-.077.037-.018.044-.021q.005-.146-.01-.308c-.005-.139-.031-.428-.039-.633.024-.342.071-.505.015-.95.107-.053-.054-.641.004-.802-.101-.36.033-.429.035-.666.011-.998-.066 2.577-.115 1.484M10.662 5.13a.6.6 0 0 1-.03-.236c.01-.045-.033-.273-.036-.4-.01-.08.11 1.619.076 1.529-.03-.067.016-.086.01-.142a6 6 0 0 0-.068-.377c-.09-.95-.052-.099-.063-.97l.071-.03c-.146-.275-.035-.321-.049-.543.02-.334.049-.384.045-.728 0 0-.035-.383-.019-.39.02-.136-.131-.719-.036-.749-.06-.313.047-.21.13-.357-.098-.167-.029-.176-.029-.245 0-.07-.023-.139-.015-.191q.006-.446.049-.85c-.037-.084-.07-.16-.056-.185.135.102.259.198.24.068l.196.155c-.071-.158.028-.09.153.025.047.218.126.187.358.535.03.066-.109.24-.085.32.105.19.093.436.161.64.069.205.216.364.234.54-.092.087-.018.333-.007.556-.122-.048-.022.157-.008.26.015.102-.036.134-.036.222.001.089.062.251-.028.24.041.091.022.05.047.148a.054.054 0 0 0-.062.026c-.02.256.05.641-.035.786l.063.141c.022.05-.014.204-.024.277s.037.143.04.21c.004.068-.033.143-.035.223.002.325-.127-1.073-.099-.819.029.255.003.483.026.741.022.258-.155-1.447-.136-1.258s.05.236.062.34-.069.226.037.499a.3.3 0 0 0-.043.077c.017.527-.078-.7.005-.11.01.064-.08-.105-.061-.044-.024.128.048.325.048.464 0 .138-.038-.044-.026.01.013.055.02.15-.025.16-.046.009-.118-.11-.101-.037.016.072-.04.016.01.144-.134-.093-.157-.859-.163-.768-.005.092-.078.033-.07.128.008.096.048.098.006.126s-.05.06-.109.016c-.1-.17-.154.507-.192.329-.005-.097-.112-.13-.074-.244.037-.115-.065-.163-.063-.262.002-.1.023-.01.032-.014-.118-.119-.129-.341-.078-.323.05.018.018.042.033.075s.044.639-.019.507c-.032.014.002.259-.054.262-.053-.153.054.493.04.361.074.069-.041-.748.043-.635-.011-.104.005.596.007.546 0-.05-.085-.044-.096-.119-.128-.332-.03-.418-.091-.66Zm.073.54c.004.068.005-.11 0 0m-.024-.49c-.065-.053.026.058.01.064.078.096-.002-.048-.01-.065Zm.032.184-.021-.11s-.04.066.021.11m.025-.548c-.052-.047.003.068-.002.09-.006.022.02-.038.027-.06z"></path><path d="M8.888 1.048c-.263.12.126-.013.04.083-.085.097-.174.03-.174.03l-.355-.03a5.4 5.4 0 0 0-1.214-.047c-.062.028.778.104.713.125s-.036-.073-.186.007c-.288.283.191.122.022.359.159.034.143.246.028.438.71.044.393.237 1.242.078.387.077.865.019 1.37-.024q.343.023.715.013l.155-.07c.306-.003-3.964-.04-3.686-.015q.222.037.476.045c.25-.011.457-.071.792-.064.156.01.475.046.616.064l.033.067c.006.013.077-.036.118-.03s.02.044.026.054q.17.004.356-.007c.118.016.277-.066.417-.07.113-.007.208.06.336.025l.186-.085c.054-.025.06.009.103-.002.191-.054.463-.236.575-.18a2 2 0 0 1 .286-.131c.068-.082.097-.16.082-.222.092-.103.223-.163.249-.228s-.25-.12-.337-.163c-.087-.042-.09-.015-.245.036-.014-.03.04-.113.02-.136-.24.052-.354-.047-.58-.046-.075.001-.207.062-.284.06s-.017-.037-.02-.044q-.146-.005-.308.01c-.139.006-.429.032-.633.039C9.479.963 9.316.916 8.87.972c-.052-.107-.64.054-.801-.004-.36.101-.43-.033-.667-.035-.998-.011 2.577.066 1.485.115Z"></path>', 5),
	Dee = [Aee];

function Pee(n, e) {
	return ke(), Ye("svg", Cee, [...Dee])
}
const Ree = {
		render: Pee
	},
	Lee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 15 12"
	},
	kee = Fe("path", {
		d: "M14.383 3.029c.02.05.031.188.017.23-.015.043.016.267.01.39q.01.119.056.254c.026.065-.022.082-.02.138q.016.18.046.368c.033.925.082 1.839.037 2.686l-.076.026c.134.272.015.314.015.53-.043.324-.075.37-.095.706 0 0 .012.372-.005.379-.03.132.09.703-.01.728.04.307-.064.202-.16.343.091.166.018.172.014.24-.005.067.015.135.004.186q-.036.432-.107.824c.034.083.063.156.046.181-.134-.103-.257-.201-.245-.074l-.195-.157c.064.156-.036.087-.158-.03-.035-.212-.12-.185-.339-.53-.026-.066.13-.231.11-.309-.098-.189-.068-.426-.126-.627s-.202-.36-.209-.532c.102-.082.04-.323.043-.54.124.05.034-.152.025-.252-.008-.1.047-.13.052-.215.005-.087-.048-.246.045-.232-.036-.09-.02-.05-.039-.146a.06.06 0 0 0 .066-.023c.039-.247-.01-.624.089-.762l-.057-.14c-.02-.049.027-.197.042-.267s-.029-.14-.027-.206c0-.066.043-.138.052-.215.018-.316.028-.695.015-.943-.014-.249.028-.47.021-.72-.006-.252.034-.331.026-.516-.007-.185-.038-.23-.043-.332-.005-.101.086-.218-.006-.485a.3.3 0 0 0 .05-.074 14 14 0 0 0-.047-1.634c-.006-.064.078.104.061.044.034-.124-.029-.318-.02-.452.01-.135.038.043.028-.01s-.012-.146.037-.154c.049-.007.116.11.103.04s.042-.015-.001-.14c.134.093.09-.032.102-.12.012-.09.084-.03.082-.123s-.044-.097.002-.122c.045-.025.056-.058.114-.012.093.168.212.384.24.557-.002.095.108.13.061.24-.046.11.057.16.049.257s-.025.008-.035.012c.116.12.112.336.06.316-.051-.02-.016-.04-.03-.074-.013-.032.014.249.07.38.035-.013.016-.252.074-.254.045.15-.007.391-.001.519-.072-.069-.022-.142-.104-.255.006.101.051.292.047.34s.086.046.091.119c.113.326.005.407.053.644m-.04-.527c0-.066-.013.108 0 0m-.008.478c.065.052-.023-.058-.006-.064-.074-.096 0 .047.006.064m-.02-.18.015.107s.046-.063-.016-.107Zm-.096-1.211c.05.048 0-.066.008-.087.007-.022-.025.036-.032.058zM6.198 9.384c-.132.247.015-.118-.09-.037-.104.081-.034.163-.034.163l.028.33c.06.334.073.714.038 1.13-.031.058-.103.126-.127.187s.08.033-.01.173c-.307.272-.128-.176-.385-.016-.035-.147-.264-.13-.471-.021-.04-.662-.252-1.213-.072-2.006-.078-.36-.01-.805.041-1.276a7 7 0 0 1-.006-.666l.078-.145a7 7 0 0 0-.027-.816 3 3 0 0 1-.043-.443c.016-.232.082-.427.078-.738a12 12 0 0 0-.062-.573l-.072-.03c-.014-.006.04-.072.033-.11s-.046-.02-.057-.024a3 3 0 0 1 .011-.331c-.016-.11.075-.26.08-.39.01-.105-.062-.192-.023-.312l.094-.174c.027-.051-.01-.057.003-.096.06-.179.259-.434.2-.537q.082-.13.144-.269c.09-.064.173-.091.24-.078.112-.087.178-.21.248-.234s.127.231.172.312.015.083-.041.228c.032.013.121-.039.146-.02-.059.224.047.33.043.54-.002.07-.068.193-.067.264s.04.017.047.02a2 2 0 0 1-.014.286c-.008.13-.039.4-.05.59.023.319.072.47.007.886.115.047-.066.597-.005.745-.113.337.031.4.03.62.002.93-.04 1.85-.105 2.868M10.332 6.622c-.132-.247.015.117-.09.037s-.035-.163-.035-.163l.03-.33c.06-.334.072-.715.037-1.13-.031-.059-.103-.127-.127-.187-.024-.061.08-.033-.01-.174-.307-.271-.128.177-.385.017-.035.147-.264.13-.472.021-.039.662-.25 1.213-.07 2.006-.08.36-.011.805.04 1.276a7 7 0 0 0-.006.666l.078.145a7 7 0 0 1-.027.816 3 3 0 0 0-.043.443c.015.232.082.427.078.738-.01.145-.045-2.107-.062-1.976l-.072.03c-.014.005.04.072.033.11s-.047.019-.057.023a3 3 0 0 0 .011.332c-.016.11.074.26.08.389.01.106-.062.193-.023.313l.093.174c.028.05-.009.057.004.096.06.179.258.433.2.537q.082.13.144.268c.089.064.173.092.24.079.112.086.178.21.248.234s.127-.232.171-.312.015-.083-.04-.228c.032-.014.121.038.146.02-.059-.224.047-.33.043-.54-.002-.07-.068-.194-.067-.265s.04-.016.046-.019a2 2 0 0 0-.013-.286c-.008-.13-.04-.4-.05-.59.023-.32.072 2.079.006 1.663.115-.047-.065-.597-.005-.746-.112-.336.032-.399.032-.62 0-.93-.042-1.85-.106-2.867M2.129 9.143c-.133.247.015-.117-.09-.037s-.035.163-.035.163l.029.33c.06.334.073.714.038 1.13-.031.059-.103.127-.127.188-.024.06.08.032-.01.172-.307.272-.128-.176-.385-.016-.035-.147-.264-.13-.472-.021-.039-.662-.251-1.213-.07-2.006-.08-.36-.011-.805.04-1.276-.013-.213-.015 1.264-.006 1.033l.078-.145a7 7 0 0 0-.027-.816A3 3 0 0 1 1.05 7.4c.015-.233.082-.427.078-.738-.01-.146-.045 2.106-.062 1.975l-.072-.029c-.014-.006.039-.073.033-.11S.98 8.478.97 8.474a3 3 0 0 1 .01-.331c-.015-.111.075-.26.08-.39.01-.105-.061-.193-.022-.313l.093-.174c.027-.05-.009-.056.003-.096.061-.178.26-.433.201-.537q.082-.13.144-.268c.089-.064.173-.091.24-.078.111-.087.178-.21.248-.235s.127.232.171.312.015.084-.04.229c.032.013.12-.039.146-.02-.059.224.047.33.043.54-.002.07-.068.193-.067.264 0 .072.04.017.046.02a2 2 0 0 1-.013.286c-.008.13-.04.4-.05.59.022.319.071-2.08.006-1.664.115.047-.065.597-.005.746-.112.337.032.4.031.62.001.93-.041.15-.105 1.168Z"
	}, null, -1),
	Iee = [kee];

function Oee(n, e) {
	return ke(), Ye("svg", Lee, [...Iee])
}
const Fee = {
		render: Oee
	},
	Nee = {
		xmlns: "http://www.w3.org/2000/svg",
		fill: "currentColor",
		"fill-rule": "evenodd",
		"clip-rule": "evenodd",
		viewBox: "0 0 15 7"
	},
	Uee = Fe("path", {
		d: "M10.335 2.204c-.133-.247.015.117-.09.037s-.035-.163-.035-.163l.029-.33a4.4 4.4 0 0 0 .038-1.13c-.031-.059-.103-.127-.127-.187-.024-.061.08-.033-.01-.173-.307-.272-.128.176-.385.016-.035.147-.264.13-.472.021-.039.662-.251 1.213-.07 2.006-.08.36-.011.805.04 1.276a7 7 0 0 0-.006.666l.078.145a7 7 0 0 1-.027.816 3 3 0 0 0-.043.442c.015.233.082.428.078.739-.01.145-.045-2.107-.062-1.976l-.072.03c-.014.005.039.072.033.11s-.047.019-.057.023a3 3 0 0 0 .01.332c-.015.11.075.26.08.389.01.106-.061.193-.022.313l.093.174c.027.05-.009.057.003.096.061.179.26.433.201.537q.082.13.144.268c.089.064.173.092.24.079.112.087.178.21.248.234s.127-.232.171-.312.015-.083-.04-.228c.032-.013.12.038.146.02-.059-.224.047-.33.043-.54-.002-.07-.068-.194-.067-.265 0-.071.04-.016.046-.019a2 2 0 0 0-.013-.286c-.008-.13-.04-.4-.05-.59.022-.32.072 2.079.006 1.663.115-.047-.065-.597-.005-.746-.112-.336.032-.399.031-.62.001-.93-.041-1.85-.105-2.867M2.132 4.726c-.133.246.015-.118-.09-.037s-.035.162-.035.162l.029.33c.06.334.073.715.038 1.13-.032.059-.103.127-.127.188-.024.06.079.032-.01.173-.307.271-.128-.177-.385-.017-.035-.147-.264-.13-.472-.02-.039-.664-.25-1.215-.07-2.008-.078-.36-.01-.805.041-1.276-.013-.212-.015 1.265-.006 1.034.02-.037.058-.11.078-.145a7 7 0 0 0-.027-.816 3 3 0 0 1-.043-.443c.015-.232.082-.427.078-.738-.01-.145-.045 2.107-.062 1.976l-.072-.03c-.014-.006.039-.072.033-.11s-.047-.02-.058-.024a3 3 0 0 1 .012-.331c-.017-.11.074-.26.08-.39.009-.105-.062-.192-.023-.312l.093-.174c.027-.051-.009-.057.003-.096.061-.179.26-.434.2-.537a2 2 0 0 0 .145-.268c.089-.064.173-.092.24-.08.111-.086.178-.209.248-.233s.127.231.171.312.015.083-.04.228c.032.013.12-.039.146-.02-.059.224.047.33.043.54-.002.07-.069.193-.067.265 0 .07.04.016.046.019a2 2 0 0 1-.013.286c-.008.13-.04.4-.05.59.022.319.071-2.08.006-1.664.115.048-.065.598-.005.746-.112.337.032.4.031.62.001.93-.041.15-.105 1.169Zm11.816 0c-.132.246.015-.118-.09-.037-.104.08-.035.162-.035.162l.03.33c.06.334.072.715.037 1.13-.031.059-.103.127-.127.188-.024.06.08.032-.01.173-.307.271-.128-.177-.385-.017-.035-.147-.264-.13-.472-.02-.039-.663-.25-1.214-.07-2.007-.079-.36-.011-.805.04-1.276-.013-.212-.015 1.265-.006 1.034.02-.037.058-.11.078-.145a7 7 0 0 0-.027-.816 3 3 0 0 1-.043-.443c.015-.232.082-.427.078-.738-.01-.145-.044 2.107-.062 1.976l-.072-.03c-.014-.006.04-.072.033-.11s-.046-.02-.057-.024a3 3 0 0 1 .011-.331c-.016-.11.075-.26.08-.39.01-.105-.062-.192-.023-.312l.093-.174c.028-.051-.009-.057.004-.096.06-.179.258-.434.2-.537q.082-.13.144-.268c.089-.064.173-.092.24-.08.112-.086.178-.209.248-.233s.127.231.172.312.015.083-.041.228c.032.013.121-.039.146-.02-.059.224.047.33.043.54-.002.07-.068.193-.067.265.001.07.04.016.047.019q.003.135-.014.286c-.008.13-.04.4-.05.59.023.319.072-2.08.006-1.664.115.048-.065.598-.004.746-.113.337.031.4.03.62.002.93-.041.15-.105 1.169M5.98 3.688c-.117-.254.008.119-.092.032-.1-.088-.024-.165-.024-.165l.049-.328c.08-.33.117-.708.107-1.126-.027-.06-.094-.132-.114-.194s.08-.027 0-.173c-.29-.29-.139.168-.385-.007-.044.144-.272.113-.472-.009-.08.658-.326 1.195-.195 1.998-.1.354-.06.803-.038 1.276-.027.211.063-1.263.057-1.032l.069.15a7 7 0 0 1-.077.813 3 3 0 0 0-.07.438c0 .233.055.432.032.742-.019.145.085-2.105.06-1.976l-.073.025c-.015.005.034.075.026.112s-.048.017-.06.02a3 3 0 0 0-.008.332c-.024.11.058.264.055.393.003.106-.074.19-.042.311l.082.18c.024.052-.012.056-.002.096.05.182.231.448.167.548q.073.136.127.277c.084.069.166.102.234.093.106.093.165.22.233.25.068.028.141-.224.19-.302s.02-.082-.026-.23c.033-.011.119.046.145.029-.045-.227.067-.326.077-.537.001-.07-.057-.197-.051-.268.005-.07.04-.013.047-.016q.013-.135.005-.287c0-.13-.015-.4-.013-.592.041-.316-.058 2.08-.097 1.661.117-.04-.029-.6.041-.744-.092-.343.056-.397.07-.618.058-.927-.033-.152-.034-1.172"
	}, null, -1),
	Bee = [Uee];

function zee(n, e) {
	return ke(), Ye("svg", Nee, [...Bee])
}
const Vee = {
		render: zee
	},
	Hee = {
		"aria-hidden": "true",
		class: "svg-sprite"
	},
	Gee = {
		xmlns: "http://www.w3.org/2000/svg",
		"xmlns:xlink": "http://www.w3.org/1999/xlink"
	},
	Wee = {
		id: "logo"
	},
	jee = {
		id: "burger"
	},
	$ee = {
		id: "cross"
	},
	qee = {
		id: "play"
	},
	Xee = {
		id: "pause"
	},
	Yee = {
		id: "plus"
	},
	Kee = {
		id: "arrow"
	},
	Zee = {
		id: "arrow-horizontal"
	},
	Jee = {
		id: "fullscreen"
	},
	Qee = {
		id: "volume"
	},
	ete = {
		id: "volume-muted"
	},
	RP = {
		__name: "SvgSprite",
		setup(n) {
			return (e, t) => (ke(), Ye("div", Hee, [(ke(), Ye("svg", Gee, [Fe("symbol", Wee, [Ge(fe(FQ))]), Fe("symbol", jee, [Ge(fe(VQ))]), Fe("symbol", $ee, [Ge(fe(qQ))]), Fe("symbol", qee, [Ge(fe(tee))]), Fe("symbol", Xee, [Ge(fe(oee))]), Fe("symbol", Yee, [Ge(fe(dee))]), Fe("symbol", Kee, [Ge(fe(bee))]), Fe("symbol", Zee, [Ge(fe(Mee))]), Fe("symbol", Jee, [Ge(fe(Ree))]), Fe("symbol", Qee, [Ge(fe(Fee))]), Fe("symbol", ete, [Ge(fe(Vee))])]))]))
		}
	},
	tte = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: RP
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	nte = {
		__name: "WebGL",
		setup(n) {
			const e = tt(null),
				t = tt(null),
				i = tt(null),
				r = tt(null),
				{
					isCanvasAbsolute: s
				} = $t(Ct()),
				{
					$webgl: o,
					$viewport: a
				} = Ke(),
				l = Be(() => (a == null ? void 0 : a.width) < 768);
			return Vn(() => {
				o.canvas && (i.value = o.canvas, i.value.classList.add("webgl-canvas"), e.value.appendChild(i.value)), o.frontCanvas && (r.value = o.frontCanvas, r.value.classList.add("webgl-front-canvas"), t.value.appendChild(r.value))
			}), (c, u) => (ke(), Ye(gn, null, [Fe("aside", {
				ref_key: "front",
				ref: t,
				class: "webgl-front"
			}, null, 512), Fe("aside", {
				ref_key: "back",
				ref: e,
				class: jt(["webgl-back", {
					"webgl-back--abs": fe(s) && fe(l)
				}])
			}, null, 2)], 64))
		}
	},
	ite = {
		__name: "app",
		setup(n) {
			const {
				isTransitioning: e,
				isContactModalOpen: t,
				isNavOpen: i,
				isTransitionBlurVisible: r,
				isCursorPointer: s
			} = $t(Ct()), {
				setIsModalOpen: o
			} = Ct(), {
				serviceModalData: a,
				labModalData: l
			} = $t(Ji()), c = Be(() => a.value), u = Be(() => l.value), h = Be(() => t.value || i.value || a.value || r.value || u.value);
			return Vt(() => h.value, () => {
				o()
			}), Im({
				bodyAttrs: {
					class: () => s.value && !u.value ? "cursor-pointer" : ""
				}
			}), (d, f) => {
				const p = lP,
					_ = gP,
					g = vP,
					m = bP,
					b = yP,
					v = wP,
					y = xJ,
					x = xQ,
					S = MQ,
					E = AQ,
					C = G3,
					P = RP;
				return ke(), Ye("main", null, [Ge(p), Ge(_), Ge(g), Ge(m), fe(e) ? (ke(), It(b, {
					key: 0
				})) : Fn("", !0), Ge(ma, {
					name: "fade",
					appear: ""
				}, {
					default: En(() => [fe(h) || fe(r) ? (ke(), It(v, {
						key: 0,
						"is-lower-z": fe(r)
					}, null, 8, ["is-lower-z"])) : Fn("", !0)]),
					_: 1
				}), Ge(ma, {
					name: "modal"
				}, {
					default: En(() => [fe(t) ? (ke(), It(y, {
						key: 0
					})) : fe(c) ? (ke(), It(x, {
						key: 1
					})) : fe(u) ? (ke(), It(S, {
						key: 2
					})) : Fn("", !0)]),
					_: 1
				}), Ge(E), Ge(C, null, {
					default: En(() => [Ge(nte)]),
					_: 1
				}), Ge(P)])
			}
		}
	},
	rte = {
		class: "error"
	},
	ste = Fe("div", {
		class: "error__hero"
	}, [Fe("h1", null, "Page wasn't found."), Fe("a", {
		href: "/",
		class: "mono ttu"
	}, "Go back home")], -1),
	ote = [ste],
	ate = {
		__name: "error",
		props: {
			error: {
				type: Object,
				default: () => {}
			}
		},
		setup(n) {
			return (e, t) => (ke(), Ye("main", rte, ote))
		}
	},
	LS = {
		__name: "nuxt-root",
		setup(n) {
			const e = () => null,
				t = Ke(),
				i = t.deferHydration();
			if (t.isHydrating) {
				const a = t.hooks.hookOnce("app:error", i);
				Sr().beforeEach(a)
			}
			const r = !1;
			al(Lm, Ca()), t.hooks.callHookWith(a => a.map(l => l()), "vue:setup");
			const s = km();
			ET((a, l, c) => {
				if (t.hooks.callHook("vue:error", a, l, c).catch(u => console.error("[nuxt] Error in `vue:error` hook", u)), F5(a) && (a.fatal || a.unhandled)) return t.runWithContext(() => vc(a)), !1
			});
			const o = !1;
			return (a, l) => (ke(), It(mT, {
				onResolve: fe(i)
			}, {
				default: En(() => [fe(s) ? (ke(), It(fe(ate), {
					key: 0,
					error: fe(s)
				}, null, 8, ["error"])) : fe(o) ? (ke(), It(fe(e), {
					key: 1,
					context: fe(o)
				}, null, 8, ["context"])) : fe(r) ? (ke(), It(_u(fe(r)), {
					key: 2
				})) : (ke(), It(fe(ite), {
					key: 3
				}))]),
				_: 1
			}, 8, ["onResolve"]))
		}
	};
let kS; {
	let n;
	kS = async function () {
		var o, a;
		if (n) return n;
		const i = !!((o = window.__NUXT__) != null && o.serverRendered || ((a = document.getElementById("__NUXT_DATA__")) == null ? void 0 : a.dataset.ssr) === "true") ? aL(LS) : oL(LS),
			r = h5({
				vueApp: i
			});
		async function s(l) {
			await r.callHook("app:error", l), r.payload.error = r.payload.error || bd(l)
		}
		i.config.errorHandler = s;
		try {
			await f5(r, dZ)
		} catch (l) {
			s(l)
		}
		try {
			await r.hooks.callHook("app:created", i), await r.hooks.callHook("app:beforeMount", i), i.mount(O6), await r.hooks.callHook("app:mounted", i), await Xi()
		} catch (l) {
			s(l)
		}
		return i.config.errorHandler === s && (i.config.errorHandler = void 0), i
	}, n = kS().catch(e => {
		throw console.error("Error while mounting app:", e), e
	})
}
export {
	ute as $, Ls as A, cte as B, Za as C, ko as D, Vt as E, gn as F, Ke as G, xP as H, _P as I, Xi as J, EP as K, G3 as L, dte as M, aP as N, Cp as O, $P as P, HT as Q, _u as R, Ca as S, Im as T, Sa as U, hte as V, Zc as W, Da as X, at as Y, zh as Z, jb as _, Ye as a, mte as a0, Vq as a1, Ge as b, _Z as c, Fe as d, cP as e, PP as f, lt as g, Be as h, Fn as i, It as j, Dm as k, AP as l, Vn as m, jt as n, ke as o, Yi as p, CP as q, tt as r, $t as s, to as t, fe as u, Ct as v, En as w, HY as x, qs as y, Ji as z
};

function __vite__mapDeps(indexes) {
	if (!__vite__mapDeps.viteFileDeps) {
		__vite__mapDeps.viteFileDeps = ["./about.B-aplnQ4.js", "./LogoToggler.BG1pZt59.js", "./LogoToggler.BEtX2zt_.css", "./Reel.B9_2rTtk.js", "./Reel.Eq0axyVP.css", "./List.CGDOyJDT.js", "./SectionTitle.JKfXi8mY.js", "./SectionTitle.wm1irhah.css", "./List.C-HM_m8M.css", "./Marquee.UdWGFVIb.js", "./Marquee.CMoqUowu.css", "./Services.DoNqskIp.js", "./ServiceItem.m6MsAAC-.js", "./filterBySlug.Bor7qi44.js", "./ServiceItem.CeXrOkY2.css", "./Services.BAXpeSuF.css", "./Footer.BzOP24eX.js", "./Contact.Dv1i-ire.js", "./Contact.BBRUt_zJ.css", "./SocialLink.CJVG2S-b.js", "./SocialLink.D8yVspol.css", "./Footer._O-EUep6.css", "./usePageMixin.B-M2lqaA.js", "./about.Blca_Yk5.css", "./index.CJ4KHoTM.js", "./WorkList.BrTaW_iV.js", "./WorkItem.kXh1J7BL.js", "./Tag.IeZyhnI-.js", "./Tag.CCjEAnJ2.css", "./WorkItem.BuVzi8T2.css", "./WorkList.DAKPFzMD.css", "./index.D-bkHgkL.css", "./lab.BusM9PiM.js", "./lab.WkoMswoX.css", "./_slug_.BZ6K_0di.js", "./_slug_.DL2bNPTO.css", "./index.kMqy-Dg0.js", "./index.DruNzOu0.css", "./AnimatedHeadline.CwK2fN5k.js", "./AnimatedHeadline.CraX9VJM.css", "./BackToTop.Ct9BdGRn.js", "./BackToTop.vu14nNz9.css", "./Gridlines.BOfamoPD.js", "./Gridlines.D6vos9Au.css", "./NavBackButton.D5nV_Bw7.js", "./NavBackButton.CWUlXzEa.css"]
	}
	return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}